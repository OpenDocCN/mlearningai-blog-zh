<html>
<head>
<title>Ingesting Clickstream Data with Python, Kinesis, and Terraform</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python、Kinesis和Terraform获取点击流数据</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/ingesting-clickstream-data-with-python-kinesis-and-terraform-446371c6f032?source=collection_archive---------3-----------------------#2022-01-28">https://medium.com/mlearning-ai/ingesting-clickstream-data-with-python-kinesis-and-terraform-446371c6f032?source=collection_archive---------3-----------------------#2022-01-28</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/5f06c26f504060c9aa8163ead857a452.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IFdoo8wNgPODMIn3"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Photo by <a class="ae it" href="https://unsplash.com/@mauromora?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">mauro mora</a> on <a class="ae it" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="edf9" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">介绍和动机。</h1><p id="e2c1" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">我的目标是写几篇文章，每篇文章关注一个在任何公司都可以找到的流行数据源，然后将它们结合在一起，对一个成熟的数据平台有一个全面的了解。本文将是这一系列文章中的第一篇。目前的重点将是点击流数据，而未来的写作将集中在其他熟悉的来源，如OLTP数据库，第三方API，可能还有web服务器日志。</p><h1 id="c95b" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">先决条件。</h1><ul class=""><li id="5c49" class="kq kr hh ju b jv jw jz ka kd ks kh kt kl ku kp kv kw kx ky bi translated">Python3已安装。你应该熟悉编程。</li><li id="089e" class="kq kr hh ju b jv kz jz la kd lb kh lc kl ld kp kv kw kx ky bi translated">已安装Terraform。如果你从未使用过Terraform，你可以跟随我的代码。</li><li id="9fa1" class="kq kr hh ju b jv kz jz la kd lb kh lc kl ld kp kv kw kx ky bi translated">具有凭证(有效访问和密钥)的AWS帐户。如果您在本地机器上配置了AWS CLI，并且在<code class="du le lf lg lh b">~/.aws/</code>目录中有一个凭证文件，这将会有所帮助。</li></ul><h1 id="05cc" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">项目要求。</h1><p id="f84c" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">为了让事情尽可能“真实”，让我们创建一个在数据团队中常见的场景。</p><p id="2609" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">我们是一家虚拟科技公司的数据工程师。用户访问我们公司的应用程序来执行各种活动，从而生成数据点。</p><p id="d3bd" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">我们的任务是获取这些数据，并让公司内的其他成员可以轻松地获得这些数据，以进行进一步分析。此外，在构建解决方案时，我们还应该考虑监控、可伸缩性、可扩展性和可再现性。</p><p id="cc90" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">让我们以一种更加模块化的方式来重新构建这项任务——我们需要将实时点击流数据吸收到数据湖中，供不同的利益相关方(分析工程师、数据分析师、数据科学家等)在下游使用。).</p><p id="a0b7" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">在重申了需求之后，很明显这个任务可以分解成三个有序的子任务。</p><ol class=""><li id="761a" class="kq kr hh ju b jv li jz lj kd ln kh lo kl lp kp lq kw kx ky bi translated">摄取</li><li id="fc68" class="kq kr hh ju b jv kz jz la kd lb kh lc kl ld kp lq kw kx ky bi translated">储存；储备</li><li id="a90a" class="kq kr hh ju b jv kz jz la kd lb kh lc kl ld kp lq kw kx ky bi translated">消费</li></ol><h1 id="0386" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">什么是点击流数据？</h1><p id="8b30" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">想象一下拥有一个网站或者一个网络应用。用户找到他们的方式到您的站点并执行各种操作。访问页面、点击按钮、提交信息和购买产品都是这类活动的例子。但是这些用户数据点是没有帮助的，除非您创建一个过程来记录它们。</p><p id="db6e" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">那么，我们如何捕捉这些未开发的数据流呢？如今，您可以使用许多服务来收集和存储这些数据。这些服务包括谷歌分析、细分、振幅和混合面板。以Segment为例，您的网站被添加为数据源，然后Segment提供所需的JavaScript代码来开始跟踪用户事件并将它们发送给Segment。</p><p id="901d" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">我希望每个人都清楚需要获取这些丰富的数据。例如，为每个用户分析一个按时间排序的事件列表(我们称之为用户之旅)可以让你理解用户的动机和行为。这反过来有助于做出更明智的决策，优化用户体验和转换。</p><figure class="ls lt lu lv fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lr"><img src="../Images/899089c7ee3f3f6a1481e564b67244e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LRrMA5c10UmEK3XRsryZtg.png"/></div></div></figure><h1 id="efe9" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">回到数据工程师的角度</h1><blockquote class="lw lx ly"><p id="d374" class="js jt lz ju b jv li jx jy jz lj kb kc ma lk kf kg mb ll kj kk mc lm kn ko kp ha bi translated"><strong class="ju hi"> <em class="hh">🚨真实世界警报🚨</em> </strong></p><p id="34aa" class="js jt lz ju b jv li jx jy jz lj kb kc ma lk kf kg mb ll kj kk mc lm kn ko kp ha bi translated"><em class="hh">作为一名数据工程师，通常情况下，你不会在设置点击流数据的跟踪和标记方面看到太多动作。相反，这个过程将由前端、产品管理和分析团队的成员共同完成。然而，在一些较小的公司中，数据工程是分析团队中的一个角色(而不是上升到工程)，可能在事件标记过程中有一些输入。</em></p></blockquote><h1 id="5297" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">我们如何获得点击流数据？</h1><p id="d76a" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">如果你一直在关注我以前的文章，你会知道我是一个生成自己的数据的爱好者。这篇文章也不例外。</p><p id="4230" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">这个项目假设我们已经有一个服务，如段，设置，并与标记的用户事件。从Segment导出的数据是半结构化和嵌套的。以下是Segment文档中的一个事件示例。</p><figure class="ls lt lu lv fd ii er es paragraph-image"><div class="er es md"><img src="../Images/dcaa3410fe7e52038763887e576fced9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/1*lLn8lCijLPFB2rKyssn-zw.png"/></div></figure><p id="c7c3" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">这个特定的有效载荷代表一个识别调用，它将一个已知的用户与其特征相匹配。这个调用可以在用户注册、登录或更新他们的信息时生成。注意trait字段本身是一个半结构化的对象，使得事件嵌套。Segment还提供其他呼叫，如track(用户在做什么？)，页面(用户访问的是哪个页面？)，还有更多。</p><p id="a102" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">我们将根据这个识别调用对生成的数据进行建模。然而，让我们不要关心有效载荷的实际内容。相反，更重要的是通过使我们的导出半结构化和嵌套来模仿有效载荷结构。</p><h1 id="f671" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">预览事件。</h1><p id="be02" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">看一下我们稍后将生成的事件的示例。</p><figure class="ls lt lu lv fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es me"><img src="../Images/eadf3f2c317235d3e7cb43df9316b84b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JyZvJfuW3d5qAJHRpfji9w.png"/></div></div></figure><p id="e129" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">在这个有效负载中，我们有一个ID等于90的已知iOS用户，他访问了<code class="du le lf lg lh b">www.fakesite.com/books/</code>路径并点击了一个评论。<code class="du le lf lg lh b">properties</code>字段定义了另一个JSON对象。</p><p id="606a" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">这个示例事件的结构选择是由以下要求驱动的。</p><ul class=""><li id="32db" class="kq kr hh ju b jv li jz lj kd ln kh lo kl lp kp kv kw kx ky bi translated">有效载荷应该是半结构化的。</li><li id="870d" class="kq kr hh ju b jv kz jz la kd lb kh lc kl ld kp kv kw kx ky bi translated">至少应该嵌套一个字段。</li><li id="0d72" class="kq kr hh ju b jv kz jz la kd lb kh lc kl ld kp kv kw kx ky bi translated">为了模拟实际的点击流数据，我们的脚本必须以某种预定义的速率连续产生数据。</li><li id="11b6" class="kq kr hh ju b jv kz jz la kd lb kh lc kl ld kp kv kw kx ky bi translated">我们需要传递参数，让我们1)控制生成事件之间的时间，2)指定我们想要生成的事件总数。</li></ul><h1 id="71c2" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">创建脚本。</h1><p id="1199" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">让我们通过为您的项目创建一个名为<code class="du le lf lg lh b">clickstream-kinesis</code>的目录来开始这个项目。</p><figure class="ls lt lu lv fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mf"><img src="../Images/8e8d6afdc64620e293c7913b7f4c79f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*S5v-uJ_myQwMXmgKxjhm8g.gif"/></div></div></figure><p id="3e51" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">创建一个名为<code class="du le lf lg lh b">clickstream_generator.py</code>的python文件，并粘贴以下代码。</p><figure class="ls lt lu lv fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mg"><img src="../Images/87012bd428f758a72657e71d836b49b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uKgHE1435jn3F5uO5R3Z3Q.png"/></div></div></figure><p id="461a" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">让我们详细介绍一下每个库。</p><ul class=""><li id="581b" class="kq kr hh ju b jv li jz lj kd ln kh lo kl lp kp kv kw kx ky bi translated"><strong class="ju hi"> JSON </strong> —该脚本生成的事件将被构造为Python字典。JSON库有一个dumps方法，允许将python对象转换成等效的JSON对象。</li><li id="83be" class="kq kr hh ju b jv kz jz la kd lb kh lc kl ld kp kv kw kx ky bi translated"><strong class="ju hi">随机</strong> —该库将增加生成事件之间的时间差异。此外，将为每个生成的事件随机选择事件描述、用户Id、页面和操作系统的值。</li><li id="965d" class="kq kr hh ju b jv kz jz la kd lb kh lc kl ld kp kv kw kx ky bi translated"><strong class="ju hi">日期时间</strong>—日期时间库将用于捕获事件创建时的时间戳。</li><li id="7a0a" class="kq kr hh ju b jv kz jz la kd lb kh lc kl ld kp kv kw kx ky bi translated">这个库包含一个允许处理参数的方法。正如在需求部分提到的，您将需要向脚本提供一个时间间隔和记录计数。</li><li id="bdcd" class="kq kr hh ju b jv kz jz la kd lb kh lc kl ld kp kv kw kx ky bi translated"><strong class="ju hi"> Time </strong> —为了使该脚本不可预测，该库将允许在创建事件之间暂停。在随机模块的帮助下，该暂停的长度将被随机化。</li><li id="132e" class="kq kr hh ju b jv kz jz la kd lb kh lc kl ld kp kv kw kx ky bi translated">Hashlib  —每个事件都需要一个唯一的Id。实现这个目标的一个快速方法是散列当前时间戳。我们如何知道事件之间的时间戳是唯一的？事件时间戳被记录到毫秒，而事件之间的暂停至少是一秒。</li></ul><blockquote class="lw lx ly"><p id="0fbc" class="js jt lz ju b jv li jx jy jz lj kb kc ma lk kf kg mb ll kj kk mc lm kn ko kp ha bi translated"><strong class="ju hi">T12】🚨真实世界警报🚨 </strong></p><p id="3a96" class="js jt lz ju b jv li jx jy jz lj kb kc ma lk kf kg mb ll kj kk mc lm kn ko kp ha bi translated"><em class="hh">在流处理中，每个事件通常包含三个时间戳。这个项目不需要这种复杂程度，但还是让我们仔细看看这些时间戳。</em></p><p id="cc99" class="js jt lz ju b jv li jx jy jz lj kb kc ma lk kf kg mb ll kj kk mc lm kn ko kp ha bi translated"><em class="hh"> 1。事件时间——创建事件的时间戳</em></p><p id="a496" class="js jt lz ju b jv li jx jy jz lj kb kc ma lk kf kg mb ll kj kk mc lm kn ko kp ha bi translated"><em class="hh"> 2。摄取时间——流式处理捕获事件的时间戳</em></p><p id="5985" class="js jt lz ju b jv li jx jy jz lj kb kc ma lk kf kg mb ll kj kk mc lm kn ko kp ha bi translated"><em class="hh"> 3。挂钟——流处理器处理事件的时间戳。</em></p></blockquote><p id="5524" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">至于脚本的其余部分，事件中的每个字段都有一个确定其值的函数。python字典被迭代地实例化和填充，然后在每次迭代期间被转换成JSON以构造事件。</p><p id="aa8e" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">让我们测试一下这个脚本。要运行10条记录的脚本，事件之间的最大延迟为2秒，使用命令<code class="du le lf lg lh b">python3 clickstream_generator.py 10 2</code>。</p><figure class="ls lt lu lv fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mf"><img src="../Images/2007f0ab3eb742e0eaeaf0d19af77e7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*hFgERLqlplGAYhDkaLzNrw.gif"/></div></div></figure><p id="74ff" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">下一步是设置kinesis来接收这些事件消息。</p><h1 id="099c" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">基础设施</h1><p id="c153" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">下图展示了支持点击流数据管道的整个基础设施。</p><figure class="ls lt lu lv fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mh"><img src="../Images/1312d7f96c397ef42c5add2d32c3daa6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z0T6Lc8fD5fHUDogatw7jQ.png"/></div></div></figure><p id="499e" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">让我们回到我们虚构的场景，回忆一下我们的项目需求。摄取是要处理的第一个子任务。我们选择Kinesis Firehose是因为我们的目标是简单地将数据从源移动到目标，而不进行任何转换。对于这样一个简单的任务，Firehose是一个显而易见的选择，因为它不会增加任何技术开销。没有什么需要管理的。所有资源(网络、计算、内存等。加载数据所需的)由AWS处理。这提供了我们想要的可伸缩性。</p><p id="f6f4" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">此外，我们可以假设我们的用户不需要实时数据。分析和数据科学团队可能有一些仪表板和分析需要近乎实时地刷新，但考虑到他们的需求，Firehose带来的延迟是合理的(Firehose可以在收到数据后60秒内将数据发送到S3)。</p><p id="7d8f" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">将我们的关注点从接收转移到存储，我们选择将事件发送到数据湖(S3桶的集合)。我们希望避免创建仅限于少数用例的数据系统。相反，将事件数据发送到湖中可以让我们的同事不受任何限制地进行自助服务(记住，出于安全原因，并非所有数据都会传递给我们的利益相关者)。任何人都可以使用数据湖，以他们需要的方式使用，数据工程团队的干预最少。</p><p id="0044" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">最后，请记住，数据是杂乱且不断变化的，我们需要监控。错误可能而且将会发生。我们有责任通过设置适当的日志来避免这些错误。CloudWatch是一个简单的选择，因为它可以接收来自Kinesis Firehose的任何错误日志。</p><h1 id="c4c3" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">地形——作为代码的基础设施</h1><p id="5307" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">到目前为止，我做过的最酷的事情是用几个终端命令在AWS上构建和破坏整个基础设施。所以，如果你是一名从事云计算的数据工程师，请花些时间学习Terraform。</p><p id="1cd6" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">你不需要有任何使用Terraform的经验。我用来构建我们的管道的所有代码都将被解释到您应该能够理解的程度，但是我不会在本文中深入讨论Terraform的细节。</p><p id="e2a2" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">为此，您需要一个有效的AWS帐户和IAM用户的有效访问和密钥。您还需要安装Terraform。</p><blockquote class="lw lx ly"><p id="1676" class="js jt lz ju b jv li jx jy jz lj kb kc ma lk kf kg mb ll kj kk mc lm kn ko kp ha bi translated"><strong class="ju hi"> <em class="hh">🚨真实世界警报🚨</em>T9】</strong></p><p id="9433" class="js jt lz ju b jv li jx jy jz lj kb kc ma lk kf kg mb ll kj kk mc lm kn ko kp ha bi translated"><em class="hh">不同公司的数据工程角色大不相同。并非所有的数据工程师都专注于基础设施。后端团队成员做出数据平台决策的情况并不少见。出于这个原因，你可能不应该太关注Terraform。相反，对云有一个高层次的理解，并更多地关注数据处理和转换的细节可能会更好地利用您的时间。</em></p></blockquote><h1 id="61c1" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">项目结构</h1><p id="f140" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">在您的项目目录中，创建另一个目录并将其命名为<code class="du le lf lg lh b">infrastructure/</code>。在这个目录下，创建五个空的地形配置文件- <code class="du le lf lg lh b">provider.tf</code>、<code class="du le lf lg lh b">cloudwatch.tf</code>、<code class="du le lf lg lh b">iam.tf</code>、<code class="du le lf lg lh b">kinesis.tf</code>和<code class="du le lf lg lh b">s3.tf</code>。</p><p id="3e79" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">项目目录树应该如下所示。</p><pre class="ls lt lu lv fd mi lh mj mk aw ml bi"><span id="70fc" class="mm iv hh lh b fi mn mo l mp mq">|- clickstream-kinesis/<br/>   |- clickstream_generator.py<br/>   |- infrastructure/<br/>      |- provider.tf<br/>      |- s3.tf<br/>      |- kinesis.tf<br/>      |- iam.tf<br/>      |- cloudwatch.tf</span></pre><p id="d9bc" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">让我们仔细看看每个配置文件。</p><h2 id="ec1f" class="mm iv hh bd iw mr ms mt ja mu mv mw je kd mx my ji kh mz na jm kl nb nc jq nd bi translated">provider.tf</h2><p id="1b22" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">我们将假设我们虚构的公司使用AWS来满足其云需求。</p><p id="55e4" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">该配置用于将AWS指定为云提供商。我们还需要传入与IAM用户相关联的地区和凭证。这个动作让Terraform知道哪组资源可用于我们的项目。</p><figure class="ls lt lu lv fd ii er es paragraph-image"><div class="er es ne"><img src="../Images/dc54bf0be148ac0cda835c76b87588f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1396/format:webp/1*udexYT2gp3R2Jd448M2heg.png"/></div></figure><p id="4620" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">我希望将您的凭证以纯文本字符串的形式传递到这个文件中会引起一些关注。也就是说，只要代码不离开您的本地机器，这种配置就很好。</p><p id="6a37" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">向Terraform传递您的AWS凭证有几种方法。我将提供一些有用的Terraform文档的链接，如果你打算公开你的代码(比如把它添加到Github仓库)，你应该遵循这些链接。</p><ul class=""><li id="1ec5" class="kq kr hh ju b jv li jz lj kd ln kh lo kl lp kp kv kw kx ky bi translated"><a class="ae it" href="https://registry.terraform.io/providers/hashicorp/aws/latest/docs" rel="noopener ugc nofollow" target="_blank">环境变量</a></li><li id="e989" class="kq kr hh ju b jv kz jz la kd lb kh lc kl ld kp kv kw kx ky bi translated"><a class="ae it" href="https://registry.terraform.io/providers/hashicorp/aws/latest/docs" rel="noopener ugc nofollow" target="_blank"> AWS凭证文件</a></li></ul><p id="b5d9" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">**如果使用凭证文件进行身份验证，请按照这些<a class="ae it" href="https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-files.html" rel="noopener ugc nofollow" target="_blank">步骤</a>来配置您的AWS CLI。</p><h2 id="fd75" class="mm iv hh bd iw mr ms mt ja mu mv mw je kd mx my ji kh mz na jm kl nb nc jq nd bi translated">s3.tf</h2><p id="53b5" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">对于本文，我们将把数据湖限制在两个S3桶。</p><figure class="ls lt lu lv fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nf"><img src="../Images/0103dd3659af5ff3268e92a426dcad31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6suG6MxdIbG7kVcznDKKtg.png"/></div></div></figure><p id="a1da" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">注意脚本中的两种类型的配置块— <code class="du le lf lg lh b">data</code>和<code class="du le lf lg lh b">resource</code>。</p><p id="508a" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">在这种情况下，我们使用数据块来获取特定于我们帐户的信息。因为在AWS帐户中，存储桶名称需要是唯一的，所以我们调用<code class="du le lf lg lh b">aws_caller_identity</code>数据块来检索我们的帐户ID，我们将它添加到两个存储桶的名称中。两个<code class="du le lf lg lh b">aws_s3_bucket</code>资源块创建私有S3桶，一个用于存储原始数据，另一个用于存储转换后的数据。</p><p id="0fd1" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">请注意我们如何在bucket name参数中引用我们的帐户ID。<code class="du le lf lg lh b">aws_caller_identity</code>数据块包含许多我们可用的属性。我们使用<code class="du le lf lg lh b">DATA.&lt;DATA_RESOURCE_NAME&gt;.&lt;ATTRIBUTE&gt;</code>语法来访问<code class="du le lf lg lh b">account_id</code>属性。</p><h2 id="ad9f" class="mm iv hh bd iw mr ms mt ja mu mv mw je kd mx my ji kh mz na jm kl nb nc jq nd bi translated">kinesis.tf</h2><p id="7d0d" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">Kinesis有相当多的参数需要考虑，但是，大多数参数对于这个项目的最低要求并不重要——将数据流入数据湖。在任何情况下，我都将介绍重要的部分，您应该可以轻松地复制和粘贴其余的部分(并在自己的时间里进一步研究这些高级参数)。</p><figure class="ls lt lu lv fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ng"><img src="../Images/2906f2028620a55dd02af79b166d0397.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L96zmo4JvVqZ_Mk9-M_URQ.png"/></div></div></figure><p id="9b77" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">在分解上述代码之前，我们应该了解一下资源如何引用Terraform中的其他资源。</p><p id="a765" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">回想一下在<code class="du le lf lg lh b">s3.tf</code>配置中我们命名为<code class="du le lf lg lh b">datalake_raw</code>和<code class="du le lf lg lh b">datalake_staging</code>的两个<code class="du le lf lg lh b">aws_s3_bucket</code>资源(注意资源名和存储桶名之间的区别)。我们可以使用下面的语法<code class="du le lf lg lh b">&lt;RESOURCE&gt;.&lt;RESOURCE_NAME&gt;.&lt;PROPERTY&gt;</code>访问一些特定于已创建资源的属性。例如，如果我们想要访问原始bucket的名称<code class="du le lf lg lh b">&lt;ACCOUNT_ID&gt;-datalake-raw</code>，那么正确的语法应该是<code class="du le lf lg lh b">aws_s3_bucket.datalake_raw.bucket</code>。这个值也可以通过封装在模板文字<code class="du le lf lg lh b">"${aws_s3_bucket.datalake_raw.bucket}"</code>中在字符串中使用。</p><p id="6c0b" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">将焦点转移回运动形态。前几个参数命名我们的firehose流并指定一个目的地。S3配置块告诉Kinesis向哪里发送数据，使用哪些权限，以及如何处理错误日志。</p><p id="a4da" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">*有一些对CloudWatch资源的引用将在下一个配置文件中创建。</p><p id="dfb5" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">需要注意的两个重要参数是<code class="du le lf lg lh b">buffer_size</code>和<code class="du le lf lg lh b">buffer_interval</code>。Kinesis Firehose会保持输入的数据流，直到满足这两个参数中的一个。给定我们的值，S3将在我们的流大小达到64MB时或60秒后接收数据，以先到者为准。</p><p id="2f8d" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">此外，Kinesis还对发送到S3的数据进行动态分区。这意味着我们通过从事件中选择一个键/字段来分组数据，从而控制数据在S3的分布。在这个配置中，选择用户id作为分区键，这意味着ID为45的用户将在S3拥有自己的“文件”路径— <code class="du le lf lg lh b">s3://datalake_raw/clickstream/userId=45/...</code>。有了分区，我们避免了扫描大量文件来检索用户id为45的数据，相反，该用户所需的所有数据都存储在一个对象中。这个概念不仅可以扩展到单个用户，还可以扩展到其他分区键。</p><p id="4e77" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">最后，处理配置允许我们在流上做一些光转换。<code class="du le lf lg lh b">MetaDataExtraction</code>帮助解析用于分区的用户ID，而<code class="du le lf lg lh b">RecordDeAggregation</code>区分传入的记录。</p><p id="d901" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">与之前的两个参数相比,<code class="du le lf lg lh b">AppendDelimiterRecord</code>更需要理解。出于某种原因，加入到Kinesis流中的事件被连接成一条连续的数据线。我不认为我必须解释为什么查询一行连续的数据是一个问题。这就是<code class="du le lf lg lh b">AppendDelimiterRecord</code>处理器的用武之地。它在事件有效负载之间添加了一个换行符，使得事件之间的区别更加清晰。</p><h2 id="7076" class="mm iv hh bd iw mr ms mt ja mu mv mw je kd mx my ji kh mz na jm kl nb nc jq nd bi translated">cloudwatch.tf</h2><p id="4323" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">为了捕获错误日志，我们在Cloudwatch中创建一个日志组和日志流。</p><figure class="ls lt lu lv fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nh"><img src="../Images/bbe9f184501417027d03313b16ee109b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Exyz75B4nN7-zr3xzeCIaA.png"/></div></div></figure><p id="68ea" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">如果由于某种原因事件被发送到Kinesis而没有所需的分区键，就会发生错误。设置好一切后，您可以通过注释掉<code class="du le lf lg lh b">clickstream_generator.py</code>脚本中的用户ID字段来模拟这种情况。</p><h2 id="d0a4" class="mm iv hh bd iw mr ms mt ja mu mv mw je kd mx my ji kh mz na jm kl nb nc jq nd bi translated">iam.tf</h2><p id="7beb" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">Kinesis将与S3和Cloudwatch互动。对于S3，Kinesis需要能够列出所需的桶，以及将对象加载到这些桶中。对于Cloudwatch，Kinesis需要访问以将事件添加到上一步中创建的日志组和流中。</p><p id="6418" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">为了实现这一点，我们创建了一个Kinesis可以承担的角色。我们把这个命名为<code class="du le lf lg lh b">datalake_role</code>。</p><figure class="ls lt lu lv fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ni"><img src="../Images/2caeb92b638a194a54b18bdd7906824b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hmm9WL7F1yIZD4HkPWDLIw.png"/></div></div></figure><p id="33bc" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">对于S3，我们需要允许访问数据湖桶和该角色的对象的策略。</p><figure class="ls lt lu lv fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nj"><img src="../Images/da112146a2fd77bc48f8f4e44b5fcaff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7N0kJeuvNM4_-dQ1CIWg5w.png"/></div></div></figure><p id="fefc" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">**在<code class="du le lf lg lh b">aws_iam_policy</code>资源中引用S3存储桶资源告诉Terraform，它需要在创建此策略之前创建S3存储桶。引用资源时总是如此。超级智能地形！</p><p id="57ec" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">对于Cloudwatch，我们创建了向日志组和流添加事件的策略。</p><figure class="ls lt lu lv fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nk"><img src="../Images/4ce384fac3ec81c1e8da6d0fdd1f6775.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5XrhzJL2rLir00-v0HS35Q.png"/></div></div></figure><p id="20e1" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">确保将您的AWS区域添加到策略定义中的资源参数中(第80行)。格式应该类似于<code class="du le lf lg lh b">arn:aws:logs:&lt;REGION&gt;:&lt;ACCOUNT_ID&gt;:log-group:${aws_cloudwatch_log_group.clickstream_firehose.name}:*</code>。</p><p id="14d1" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">最后，我们将所有策略附加到<code class="du le lf lg lh b">datalake_role</code>上，并在Kinesis配置中使用这个角色。</p><figure class="ls lt lu lv fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nl"><img src="../Images/cdda1b7340c3b7a5bba7e45c4dacbf7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MAs1Mr98IPtw72hRoJkWCQ.png"/></div></div></figure><p id="72b0" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">恭喜你！现在，您可以用几个命令创建一个完整的AWS基础设施。但是请耐心等待，在使用Terraform之前，我们必须对我们的脚本进行最后一次修改。</p><h1 id="4ce0" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">将Boto3添加到脚本中。</h1><p id="2295" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">让我们回到我们的脚本，添加几行代码来与Kinesis通信。</p><p id="d44a" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">从导入<code class="du le lf lg lh b">boto3</code>库开始。</p><figure class="ls lt lu lv fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nm"><img src="../Images/521288b176bf3bd6c5a46ea6cf5f9eea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2pObeZK82x9NyQKhM964WQ.png"/></div></div></figure><p id="78fe" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">这个库需要安装，简单的<code class="du le lf lg lh b">pip3 install boto3</code>就可以完成。</p><p id="f3a5" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">现在，对生成事件的循环做一些更改。</p><figure class="ls lt lu lv fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nn"><img src="../Images/cd12cb9b41d1bb443f1d73982ca34fd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*thuIttNrGU5v4vOsnTImwA.png"/></div></div></figure><p id="9bf2" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">实例化<code class="du le lf lg lh b">boto3.Session()</code>对象，并传入认证所需的参数。同样，这些代码对于本地工作来说很好，但是对于任何公共项目来说，请考虑使用环境变量或共享凭证。从会话对象中，我们创建一个客户机来访问我们的Kinesis firehose资源。在向Kinesis发送数据之前，必须首先对数据进行编码，这可以通过JSON转储中可用的encode方法轻松完成。最后，我们创建一个响应对象，将数据发送到<code class="du le lf lg lh b">clickstream</code>交付流并返回一个<code class="du le lf lg lh b">HTTPStatusCode</code>。</p><p id="7793" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">保存文件并返回到包含Terraform文件的目录。</p><h1 id="395c" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">地形命令。</h1><h2 id="5afb" class="mm iv hh bd iw mr ms mt ja mu mv mw je kd mx my ji kh mz na jm kl nb nc jq nd bi translated"><strong class="ak">地形初始化</strong></h2><p id="b887" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">任何Terraform项目的第一步都是在包含配置文件的目录中运行<code class="du le lf lg lh b">terraform init</code>命令。如果你一直遵循前面的步骤，这个目录是<code class="du le lf lg lh b">clickstream-kinesis/infrastructure/</code>。</p><figure class="ls lt lu lv fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es no"><img src="../Images/c6db0c80f7546af8e28f900b98ef435d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*OzOSlxNn2e7okslzJ-AiGw.gif"/></div></div></figure><p id="ad60" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">您可以多次运行这个命令，而不用担心会破坏任何东西。初始化Terraform后会创建一些新文件。您唯一需要担心的是<code class="du le lf lg lh b">terraform.tfstate</code>，它存储了关于您的Terraform基础设施中资源的元数据。这就是Terraform知道管理哪些资源的方式。</p><p id="7c18" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">* * terra form状态文件不应公开。考虑将状态文件添加到您的<code class="du le lf lg lh b">.gitignore</code>或存储在S3，如这里<a class="ae it" href="https://www.terraform.io/language/settings/backends/s3" rel="noopener ugc nofollow" target="_blank">所述</a>。此文件中可能有以纯文本形式存储的不应公开的敏感信息。</p><h2 id="48d1" class="mm iv hh bd iw mr ms mt ja mu mv mw je kd mx my ji kh mz na jm kl nb nc jq nd bi translated">地形图</h2><p id="ffcd" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">使用<code class="du le lf lg lh b">terraform plan</code>输出Terraform计划对您的基础设施进行的更改。</p><figure class="ls lt lu lv fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es np"><img src="../Images/901972492fe3619bf7e8eedd5ec63cb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Y8Nu8MHS__d3tPAYgmk5Ig.gif"/></div></div></figure><p id="c15f" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">检查这个输出，您将会看到一个创建我们在本文中使用的所有资源的计划。</p><h2 id="c11c" class="mm iv hh bd iw mr ms mt ja mu mv mw je kd mx my ji kh mz na jm kl nb nc jq nd bi translated">地形应用</h2><p id="a9a5" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">运行<code class="du le lf lg lh b">terraform apply</code>执行提议的计划。系统将提示您确认资源的创建。输入“yes”并等待几分钟，让Terraform设置好一切。</p><figure class="ls lt lu lv fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es np"><img src="../Images/f093628d310664fea22df16dc612954e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*cj9Iwgwip6qiDd9vP50Tsg.gif"/></div></div></figure><p id="5818" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">导航到AWS控制台以检查资源。</p><p id="cd39" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">两个S3存储桶都是按照预期创建和命名的。</p><figure class="ls lt lu lv fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nq"><img src="../Images/e3757ef27dcc21b13d5609bc870fa19e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lZ6b8uNQnUoPLHf6WWhErw.png"/></div></div></figure><p id="86d6" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">Kinesis流正确地指向原始数据湖目的地。</p><figure class="ls lt lu lv fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nr"><img src="../Images/2536be18282ebcd170f2f498e4880f47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*95CiGaOvSsWExr37fsQ6tg.png"/></div></div></figure><h1 id="8a1f" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">生成事件。</h1><p id="e9ca" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">现在基础设施已经准备好了，是时候测试管道了。让我们生成100个事件，每个事件之间最多间隔1秒。</p><figure class="ls lt lu lv fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ns"><img src="../Images/979b4a2f4bf57865a3c895abdf201c73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*dNvdLxQEsmWl_bCU8zvPJg.gif"/></div></div></figure><p id="9fa4" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">请注意终端输出中的200 HTTP响应代码，它表明记录已成功交付给Kinesis。</p><p id="d51c" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">让我们跳回控制台，看看Kinesis中的交付流指标。</p><figure class="ls lt lu lv fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nt"><img src="../Images/94384c054a61a18c352e90d6da563ca4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iooNroTOsfCrE_60Ok8Bhg.png"/></div></div></figure><p id="636b" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">将鼠标悬停在蓝色数据点上，查看活动情况。分区计数显示了100个事件是如何分布的。在我的例子中，创建了65个分区，这意味着我的100条记录由65个不同的用户组成，并且相应地创建了S3对象。</p><p id="1bd5" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">转到S3，我们可以确认对象是根据用户ID进行分区的。</p><figure class="ls lt lu lv fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nu"><img src="../Images/c4fd324a9bdab06381c06f01ff96b5b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9-r8Nox7CZ5g1-X_oplg-g.png"/></div></div></figure><p id="a150" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">同样，如果我们的任何下游用户需要查询特定(或子集)用户id的数据，以这种方式划分数据将避免扫描大量文件。</p><p id="5162" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">最后，下载这些对象中的一个，验证每条记录是否由换行符分隔。</p><figure class="ls lt lu lv fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nv"><img src="../Images/bee30e8ccb6c6063a24d5cff4845b80c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e3nITL00h6V-tmktaaaOMA.png"/></div></div></figure><p id="3910" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">正如所料，每一行都是一个JSON对象，代表一个不同的记录。这种格式很容易被Spark、Pandas或像雪花这样的现代数据仓库解析。</p><p id="aaf3" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">太好了！我们的流媒体管道已经建立并开始运行。我们可以从脚本中生成尽可能多的事件，并根据需要近乎实时地填充我们的数据湖。</p><h1 id="ca8c" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">产生错误事件。</h1><p id="17be" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">我前面提到过，如果出于某种原因，事件缺少用于分区的用户ID字段，就会发生数据传递错误，这些事件将永远不会到达我们的数据湖。为了解决这个问题，我们设置了CloudWatch日志来捕获这些错误。让我们模拟一个错误事件，并检查我们的系统如何处理它。</p><p id="3a0e" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">回到<code class="du le lf lg lh b">clickstream_generator.py</code>脚本，注释掉事件对象中的<code class="du le lf lg lh b">user_id</code>属性。</p><figure class="ls lt lu lv fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nw"><img src="../Images/64c41d7b49a7255d136074738fc99fcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0UtLp6j9mPPcxKXYCugF8A.png"/></div></div></figure><p id="fb95" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">重新运行脚本，但这次创建单个事件(如果您愿意，也可以创建多个事件)。您仍然应该看到一个200响应，因为向Kinesis的交付将正常工作，但是，一旦数据被发送到S3，就会出现错误。</p><p id="c0de" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">回到AWS控制台，前往CloudWatch。搜索<code class="du le lf lg lh b">aws/kinesisfirehose/clickstream</code>日志组，点击您通过Terraform创建的<code class="du le lf lg lh b">ClickStreamLogStream</code>日志流。大约5分钟后，CloudWatch中应该会记录并显示一个错误。</p><figure class="ls lt lu lv fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nx"><img src="../Images/87a4df4c6fa41e2f040f6d449909d67e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cz8awbeIkx_G2mlKocq-eQ.png"/></div></div></figure><p id="d48d" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">该错误与预期一致—“分区键的值不应为null或空”。</p><p id="8872" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">我们可以检查S3，以确认我们在Terraform中包含的错误日志记录配置正在工作。</p><figure class="ls lt lu lv fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ny"><img src="../Images/8bb79497105a8bd96a2baa7335260449.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X_CO_i824QKXHUbJimliEw.png"/></div></div></figure><p id="ad3b" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">完美！另一个对象——<code class="du le lf lg lh b">clickstream-errors/...</code>——是在我们的原始数据湖中创建的，用来捕获这些错误的记录。</p><h1 id="2868" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">将（行星）地球化（以适合人类居住）...摧毁！</h1><p id="a449" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">这是这个项目中我最喜欢的部分。</p><p id="312f" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">在我们用一个命令摧毁整个基础设施之前，我们必须清空我们的水桶。S3在尝试删除非空桶时会产生一个错误。转到<code class="du le lf lg lh b">&lt;ACCOUNT_ID&gt;-datalake-raw</code>桶，删除<code class="du le lf lg lh b">clickstream/</code>和<code class="du le lf lg lh b">clickstream-errors/</code>对象。抛开其他一切，回到你的终端。</p><figure class="ls lt lu lv fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nz"><img src="../Images/c8b42e638601f1b68262098164023838.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EXgxR38Zjlv9MdWRwoYYcA.png"/></div></div></figure><p id="798b" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">导航到<code class="du le lf lg lh b">infrastructure/</code>目录并输入<code class="du le lf lg lh b">terraform destroy</code>。当要求确认时，输入“是”。</p><figure class="ls lt lu lv fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ns"><img src="../Images/5cfccc8e44858e2be9ad2ed5862a2d09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*nTNnGbVTnG1o1-P4LZDNAA.gif"/></div></div></figure><p id="10db" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">在AWS控制台中，您应该找不到管道的踪迹。没有IAM角色或策略，没有S3桶，没有错误日志，也没有Kinesis。</p><h1 id="b64a" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">包裹</h1><p id="9bfb" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">我们将需求分成三个不同的部分——摄取、存储和消费。这提供了一个超出点击流管道的框架。专注于这些领域的工程师现在有了一种模式，可以遵循每一个需要整合到数据平台中的额外项目。我们越标准化，规模就越大。</p><p id="3af9" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">尽管这篇文章很长，但仍有许多工作要做。</p><p id="43f9" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">如果您已经跟随了，我建议您保存您的代码。在以后的文章中，我们将添加以下内容。</p><ul class=""><li id="e4ba" class="kq kr hh ju b jv li jz lj kd ln kh lo kl lp kp kv kw kx ky bi translated">使用AWS Lake Formation对原始存储桶和暂存存储桶实施访问控制。在现实世界中，原始存储桶将包含并非每个人都可以访问的敏感数据(例如，SSN、银行信息等)。)</li><li id="8046" class="kq kr hh ju b jv kz jz la kd lb kh lc kl ld kp kv kw kx ky bi translated">转换我们的原始事件，并将输出发送到暂存桶。我们可以通过AWS Glue或EMR使用Spark来实现这一点。</li><li id="20d9" class="kq kr hh ju b jv kz jz la kd lb kh lc kl ld kp kv kw kx ky bi translated">为需要实时数据的用例设置Kinesis数据流(不同于Kinesis Firehose)。</li><li id="0f9f" class="kq kr hh ju b jv kz jz la kd lb kh lc kl ld kp kv kw kx ky bi translated">扩展我们的数据湖，以接收来自OLTP和第三方API等不同来源的数据。</li></ul><p id="e15a" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">提醒一下，接下来几篇文章的目标是构建一个完整的数据平台。因此，它们会比通常的阅读时间更长，但希望内容丰富。</p><p id="4941" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">查看这个项目的<a class="ae it" href="https://github.com/jduran9987/data-platform" rel="noopener ugc nofollow" target="_blank"> Github库</a>。请记住，随着我添加更多的来源和管道，这个回购将随着时间的推移而演变。</p><p id="ad81" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">如果任何人对这个项目有任何问题，我的猜测是它与AWS认证有关，我很乐意帮忙。联系我的最好方式是通过<a class="ae it" href="https://twitter.com/jduran9987" rel="noopener ugc nofollow" target="_blank">推特</a>。</p><p id="8c71" class="pw-post-body-paragraph js jt hh ju b jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">感谢阅读并期待下一篇文章。</p><div class="oa ob ez fb oc od"><a rel="noopener follow" target="_blank" href="/mlearning-ai/mlearning-ai-submission-suggestions-b51e2b130bfb"><div class="oe ab dw"><div class="of ab og cl cj oh"><h2 class="bd hi fi z dy oi ea eb oj ed ef hg bi translated">Mlearning.ai提交建议</h2><div class="ok l"><h3 class="bd b fi z dy oi ea eb oj ed ef dx translated">如何成为Mlearning.ai上的作家</h3></div><div class="ol l"><p class="bd b fp z dy oi ea eb oj ed ef dx translated">medium.com</p></div></div><div class="om l"><div class="on l oo op oq om or in od"/></div></div></a></div></div></div>    
</body>
</html>