<html>
<head>
<title>Multiple Object Detection using NVIDIA’s Transfer Learning Toolkit</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用NVIDIA的迁移学习工具包进行多对象检测</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/multiple-object-detection-using-nvidias-transfer-learning-toolkit-e7cfc1b5a381?source=collection_archive---------1-----------------------#2021-03-08">https://medium.com/mlearning-ai/multiple-object-detection-using-nvidias-transfer-learning-toolkit-e7cfc1b5a381?source=collection_archive---------1-----------------------#2021-03-08</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="4b00" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这篇文章并不是对机器或深度学习的深入解释，而是为项目设置对象检测的实用指南。这篇博文将介绍使用<a class="ae jc" href="https://developer.nvidia.com/transfer-learning-toolkit" rel="noopener ugc nofollow" target="_blank"> NVIDIA的转移学习工具包(TLT) </a>构建一个自定义的对象检测系统。<em class="jd">需要注意的是，使用TLT的训练只在x86上使用NVIDIA GPU如V100通过TLT训练的模型可以部署在任何NVIDIA平台上。</em>我写过一些关于如何用Fast构建一个<a class="ae jc" href="https://ronak-k-bhatia.medium.com/building-an-object-detection-model-with-fast-ai-c1694c7a521e" rel="noopener">对象分类模型的博文。AI </a>以及使用<a class="ae jc" href="https://ronak-k-bhatia.medium.com/building-a-multiple-object-detection-model-with-tensorflows-object-detection-api-5a71eaaa5b96" rel="noopener"> TensorFlow的对象检测API进行多对象检测</a>。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/1d5dca51b1c8b6636faee623f8f012fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b6vHBTPQi5A76SyzpU9uIg.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">Example Output of an NVIDIA TLT Objection Detection Model Trained on Nike Shoes</figcaption></figure><p id="7cd7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">NVIDIA的Transfer Learning Toolkit是一个基于Python的人工智能工具包，用于获取预先构建的人工智能模型，并用您自己的数据定制它们。迁移学习包括从现有的神经网络中提取学习到的特征到新的神经网络中；当创建大型训练数据集不可行时，通常会使用它(<a class="ae jc" href="https://developer.nvidia.com/transfer-learning-toolkit" rel="noopener ugc nofollow" target="_blank"> NVIDIA </a>)。该工具声称通过优化的预训练模型和模型修剪来减少人工智能训练和开发时间。你不需要人工智能框架的专业知识来使用它，也不需要编写额外的代码。<em class="jd">但是，请注意，通过TLT进行的培训只能通过NVIDIA GPU进行</em>。</p><p id="5d9f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这篇博文的目的是介绍设置TLT的细微差别，因为对于使用自定义数据的人来说，现有的文档可能不清楚。这篇文章将涵盖(1)获取和修改TLT的数据；(2)用TLT训练模型；以及(3)模型优化和可视化结果。为了我们的培训目的，我们使用了一个<a class="ae jc" href="https://www.nvidia.com/en-us/data-center/dgx-1/" rel="noopener ugc nofollow" target="_blank">英伟达DGX-1 </a>，我们远程访问它。如果使用其他设置，您的训练时间可能会更长。此外，对于数据操作和转换，我使用了一台Macbook Pro，规格如下:<code class="du ju jv jw jx b">macOS Catalina, Version 10.15.7, 16GB RAM, 2.3 GHz, 8-Core Intel i9</code>。</p><h1 id="57ab" class="jy jz hh bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">参考文献和鸣谢</h1><p id="a7a0" class="pw-post-body-paragraph ie if hh ig b ih kw ij ik il kx in io ip ky ir is it kz iv iw ix la iz ja jb ha bi translated">在开始这篇文章之前，我想感谢下面的人和资源，这些人和资源或者是这篇文章的参考，或者是因为它们才成为可能。Joev Valdivia有一个令人难以置信的YouTube频道,通过使用TLT工具，我发现它非常有用，并且是这个演练的基础。此外，我要感谢那些通过<a class="ae jc" href="https://forums.developer.nvidia.com/c/accelerated-computing/intelligent-video-analytics/transfer-learning-toolkit/17" rel="noopener ugc nofollow" target="_blank"> NVIDIA的开发者论坛</a>帮助我们团队的人。这个资源非常适合提问，让我们能够缩小问题的范围。接下来，我要感谢Eddie Weill有用的<a class="ae jc" href="https://github.com/eweill/convert-datasets" rel="noopener ugc nofollow" target="_blank">转换数据集工具</a>将COCO数据集转换为KITTI格式。Mityakov Aleksandr的用于将XML转换成KITTI的工具也非常有用。此外，我想感谢Naveen Malwani的<a class="ae jc" href="https://towardsdatascience.com/how-to-easily-download-googles-open-images-dataset-for-your-ai-apps-db552a82fc6" rel="noopener" target="_blank">有用文章</a>关于下载Google的OpenImages数据集用于人工智能应用。最后，我要感谢Allison Youngdahl，她帮助我校对了这篇文章，并与我一起完成了这个项目。本教程的部分内容摘自她编写的文档和代码。</p><h1 id="37f6" class="jy jz hh bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">获取和修改TLT的数据</h1><p id="c766" class="pw-post-body-paragraph ie if hh ig b ih kw ij ik il kx in io ip ky ir is it kz iv iw ix la iz ja jb ha bi translated">在我看来，使用TLT工具最困难的部分是它要求数据采用KITTI格式。如果您有一个不同格式的数据集(例如COCO)，您需要将其转换为KITTI。此外，根据您使用的型号，您需要调整图像的大小，或者确保图像符合TLT的大小要求。</p><p id="cf2d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">正如NVIDIA所说，“tlt-train工具不支持对多种分辨率的图像进行训练，也不支持在训练过程中调整图像大小。所有图像必须离线调整大小到最终的训练尺寸，并且相应的边界框必须相应地缩放。”更多信息，请参见<a class="ae jc" href="https://docs.nvidia.com/metropolis/TLT/tlt-getting-started-guide/text/supported_model_architectures.html" rel="noopener ugc nofollow" target="_blank">下面的链接</a>。此链接还包含有关各个型号的图像大小要求的信息(例如，YOLOv3的C * W * H[其中C = 1或3，W &gt; = 128，H &gt; = 128，W，H是32的倍数]。我们的团队在两个数据集上使用了TLT工具:(1)我们为运动鞋创建的自定义数据集，以及(2)我们使用来自谷歌<a class="ae jc" href="https://storage.googleapis.com/openimages/web/factsfigures.html" rel="noopener ugc nofollow" target="_blank"> OpenImages </a>的附加图像创建的数据集。本文包括关于获取和修改这两个选项的数据的说明。</p><h2 id="a762" class="lb jz hh bd ka lc ld le ke lf lg lh ki ip li lj km it lk ll kq ix lm ln ku lo bi translated">继续之前的重要步骤</h2><p id="7264" class="pw-post-body-paragraph ie if hh ig b ih kw ij ik il kx in io ip ky ir is it kz iv iw ix la iz ja jb ha bi translated">为了节省时间和后续步骤的麻烦，<strong class="ig hi"> <em class="jd">请确保将任何非PNG格式的照片转换为PNG </em> </strong>。我们注意到，如果使用JPEG格式的照片，TLT工具包就不能正常工作。请在获得要转换为KITTI的数据之后，但在实际转换数据之前执行此步骤。如果你从谷歌的OpenImages(解释如下)下载图像和标签，它有时会把图像放在JPEG格式。将图像转换为PNG的快速方法是在终端中运行以下程序:</p><pre class="jf jg jh ji fd lp jx lq lr aw ls bi"><span id="0b27" class="lb jz hh jx b fi lt lu l lv lw">mkdir pngs; sips -s format png *.* --out pngs</span></pre><p id="06c3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这将创建一个名为<code class="du ju jv jw jx b">pngs</code>的目录，并将转换后的照片放在那里。然后，您可以删除非PNG的照片，并用上面的照片替换它们。例如，假设我有一个名为<code class="du ju jv jw jx b">images</code>的文件夹，里面有JPEG图像。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lx"><img src="../Images/4b0b96cd9d03c075b1730af5b0ee5b74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0U2iR7mMzJAbwTFxEFEpMw.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">Running the Command for Converting JPEGs to PNGs.</figcaption></figure><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ly"><img src="../Images/c102e6131dad7488555fcdf4219c0f20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rWpLpe1Jlj0YfXJopLgZnQ.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">The Completed Output: PNGs are Stored in a Folder Called “pngs.”</figcaption></figure><h2 id="e2f7" class="lb jz hh bd ka lc ld le ke lf lg lh ki ip li lj km it lk ll kq ix lm ln ku lo bi translated">选项1:修改TLT的自定义数据集</h2><p id="0e19" class="pw-post-body-paragraph ie if hh ig b ih kw ij ik il kx in io ip ky ir is it kz iv iw ix la iz ja jb ha bi translated">对于我们的自定义数据集，我们有XML格式的相关注释，例如如下所示。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lz"><img src="../Images/d8639188775115585183d4c5c3af690d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aPcWFXwmMYFNVJDHkYADUg.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">Example of XML Data for Object Detection for a Custom Dataset</figcaption></figure><p id="0720" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">XML文件包含在名为<code class="du ju jv jw jx b">test</code>和<code class="du ju jv jw jx b">train</code>的两个文件夹中。为了快速方便地将这种格式转换成KITTI，我们使用了<a class="ae jc" href="https://github.com/krustnic/xml2kitti" rel="noopener ugc nofollow" target="_blank">跟随工具</a>。Git克隆存储库后，导航到根文件夹并运行以下命令:</p><pre class="jf jg jh ji fd lp jx lq lr aw ls bi"><span id="d733" class="lb jz hh jx b fi lt lu l lv lw">python3 xml2kitti.py {Path}</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ma"><img src="../Images/57c8673c26715ea33459d613d128e72d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hG9xWR-jr2ZN9pS655p3BQ.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">Successful Output for Running the XML2KITTI Script (python3 xml2kitti.py [name of folder]).</figcaption></figure><p id="9e16" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这将把指定文件夹中的所有XML文件转换成KITTI格式(作为文本文件),而不会删除XML文件。请确保标签(如air_force_1)是小写的。例如，如果我回到我的测试文件夹，我会看到以下输出:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es mb"><img src="../Images/1e222c900ffffb0330c67b8e42ebd293.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wd9CzWGoDZc-SUYsH_7lVg.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">Properly Converting the XML Files to the KITTI Format.</figcaption></figure><p id="8101" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">虽然如果这些都是步骤就很理想了，<em class="jd"> TLT要求KITTI格式只包含15个元素</em>。目前，每个文本文件有16个元素；为了减轻这种情况，我们需要删除所有生成的文本文件的最后一个零。对此最方便快捷的解决方案是运行以下CLI命令，然后删除生成的结果文件<code class="du ju jv jw jx b">.bat</code>。该命令将获取现有的<code class="du ju jv jw jx b">.txt</code>文件，并编辑它们以删除最后的0。由于命令一直在运行，我们必须在所有文件被修改后按CTRL+C(假设每个文本文件大约0.5秒)。</p><pre class="jf jg jh ji fd lp jx lq lr aw ls bi"><span id="61af" class="lb jz hh jx b fi lt lu l lv lw">find . -maxdepth 1 -name '*.txt' -exec sed -i.bak 's/[[:space:]]\{1,\}[^[:space:]]\{1,\}$//' {} \;</span><span id="7aca" class="lb jz hh jx b fi mc lu l lv lw">sed 's/[[:space:]]\{1,\}[^[:space:]]\{1,\}$//'</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es md"><img src="../Images/408479073308edb4d1cc2dec6bd47b9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0McuTyYGTTaV2HmJ-AbDDQ.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">The Original Text Files are now in the Correct KITTI Format with Fifteen Elements.</figcaption></figure><p id="b6bc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对于训练和测试数据，请遵循以下步骤。如果您想要一种系统的方法来检查您的标注是否正确完成(例如，有15个元素)，请尝试在一个空的Jupyter笔记本中运行以下Python命令来检查元素的数量。</p><pre class="jf jg jh ji fd lp jx lq lr aw ls bi"><span id="55b0" class="lb jz hh jx b fi lt lu l lv lw"># This code checks if you have 15 Fields for your labels.</span><span id="a947" class="lb jz hh jx b fi mc lu l lv lw">import glob<br/>rootdir = "{your_path}" #e.g., Data/testing/label_2</span><span id="ea39" class="lb jz hh jx b fi mc lu l lv lw">for i in glob.glob(rootdir + "/*.txt"):<br/>    with open(i, 'r') as j:<br/>        for line in j.readlines():<br/>            label = line.strip()<br/>            length = len(label.split(" ")) <br/>            print("This label have {} fields".format(length))<br/>            assert length == 15, 'Ground truth kitti labels should       have only 15 fields. And make sure there is not empty lines. Please check the label in the file %s' % (j)</span></pre><p id="2802" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在继续下一步之前，请确保您的照片是本文开头提到的PNG格式。此外，我们希望确保照片符合YOLO的适当尺寸要求。根据YOLOv3的要求，png的宽度和高度必须是16的倍数。</p><p id="8cd0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在我们的例子中，我们必须调整自定义数据集图像的大小来满足这一要求。以下代码将我们自定义数据集中的原始图像(800x600)修改为800x576，并在此作为如何根据需要调整图像大小的示例。</p><pre class="jf jg jh ji fd lp jx lq lr aw ls bi"><span id="3e5a" class="lb jz hh jx b fi lt lu l lv lw">import glob<br/>from PIL import Image</span><span id="82c0" class="lb jz hh jx b fi mc lu l lv lw">rootdir = "{your_path}/training/image_2" <br/>#e.g., Data/training/image_2</span><span id="35b9" class="lb jz hh jx b fi mc lu l lv lw">for i in glob.glob(rootdir + "/*.png"):<br/>    print(i)<br/>    # Opens a image in RGB mode<br/>    im = Image.open(i)</span><span id="8a75" class="lb jz hh jx b fi mc lu l lv lw"># Size of the image in pixels (size of original image)<br/>    width, height = im.size  #800, 600</span><span id="0f5a" class="lb jz hh jx b fi mc lu l lv lw"># Setting the points for cropped image<br/>    left = 0<br/>    top = 0<br/>    right = width<br/>    bottom = height - 24<br/>    <br/>    # Cropped image of above dimension<br/>    im = im.crop((left, top, right, bottom))<br/>    newsize = (800, 576)<br/>    im = im.resize(newsize)</span><span id="b914" class="lb jz hh jx b fi mc lu l lv lw"># Save resized image<br/>    im.save(i)</span></pre><p id="5d12" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，我们还需要修改标签以匹配新的图像大小。</p><pre class="jf jg jh ji fd lp jx lq lr aw ls bi"><span id="62f4" class="lb jz hh jx b fi lt lu l lv lw">import os, re<br/>import glob</span><span id="a64a" class="lb jz hh jx b fi mc lu l lv lw">rootdir = "{your_path}/training/label_2"<br/>for i in glob.glob(rootdir + "/*.txt"):<br/>    print(i)<br/>    <br/>    data = open(i,'r').read().replace('\n', '')<br/>    data_list = re.split(" ", data) #list of values<br/>    y_max = data_list[7] #extract bounding box</span><span id="56f7" class="lb jz hh jx b fi mc lu l lv lw">#fit inside resized 576x800 image size<br/>    <br/>    if float(y_max) &gt; 576.0 :<br/>        data_list[7] = '576.0'</span><span id="99c3" class="lb jz hh jx b fi mc lu l lv lw">new_data = " ".join(data_list)</span><span id="075d" class="lb jz hh jx b fi mc lu l lv lw">f = open(i, 'w')<br/>    f.write(new_data)<br/>    f.close()</span></pre><h2 id="8795" class="lb jz hh bd ka lc ld le ke lf lg lh ki ip li lj km it lk ll kq ix lm ln ku lo bi translated">选项2:从谷歌的OpenImages为TLT获取数据</h2><p id="5469" class="pw-post-body-paragraph ie if hh ig b ih kw ij ik il kx in io ip ky ir is it kz iv iw ix la iz ja jb ha bi translated"><em class="jd">如果你没有自定义数据集，你可以使用谷歌的OpenImages </em>创建一个。我们使用了<a class="ae jc" href="https://towardsdatascience.com/how-to-easily-download-googles-open-images-dataset-for-your-ai-apps-db552a82fc6" rel="noopener" target="_blank">下面的教程</a>来下载Google的OpenImage数据。首先，通过以下命令安装openimages包:</p><pre class="jf jg jh ji fd lp jx lq lr aw ls bi"><span id="4511" class="lb jz hh jx b fi lt lu l lv lw">pip install openimages</span></pre><p id="96f5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后，选择您感兴趣的项目或类别。您可以在下面的<a class="ae jc" href="https://storage.googleapis.com/openimages/web/visualizer/index.html?set=train&amp;type=segmentation&amp;r=false&amp;c=%2Fm%2F01xs3r" rel="noopener ugc nofollow" target="_blank">链接</a>中观察到各种不同的项目。例如，假设我对获取糕点的标签和照片感兴趣；我将在命令行中输入以下命令(这是假设您将使用DarkNet-19架构和YOLO进行对象分类):</p><pre class="jf jg jh ji fd lp jx lq lr aw ls bi"><span id="ff5d" class="lb jz hh jx b fi lt lu l lv lw">oi_download_dataset --base_dir ~/dir_Pastry --labels Pastry --format darknet --limit 2000 </span></pre><p id="78d0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">或者，如果您希望目录显示在桌面上，请执行以下操作:</p><pre class="jf jg jh ji fd lp jx lq lr aw ls bi"><span id="890f" class="lb jz hh jx b fi lt lu l lv lw">oi_download_dataset --base_dir /Users/[your name]/Desktop/dir_Pastry --labels Pastry --format darknet --limit 2000</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es me"><img src="../Images/270f9593cc35422de5e0a34ec3ed4242.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-LL98FFLqpfXobfkysPqfw.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">The Output from Running the Above Command. It May Take a Few Minutes to Run Completely.</figcaption></figure><p id="b281" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这一行将创建一个<code class="du ju jv jw jx b">dir_Pastry</code>文件夹，其中分别包含全部注释信息和图像/标签。如果您计划检测多个对象，请对不同的类别运行此过程，直到您有了每个项目的目录。如果您查看<code class="du ju jv jw jx b">dir_Pastry</code>，您将看到一个<code class="du ju jv jw jx b">darknet_obj_names.txt</code>文件，其中包含类名(在本例中为pastry)和一个名为pastry的文件夹，其中包含图像和标签(名为darknet)。我们现在需要正确地将darknet文件夹中的文本文件转换成KITTI格式。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es mf"><img src="../Images/68fb96b3f844063835ea751c5c3fbdba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HIvywpFEYRMRCl1pBRRrxQ.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">Directory After Running the Above Commands</figcaption></figure><p id="66c0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了将这种格式转换成KITTI格式，我们将使用下面的<a class="ae jc" href="https://github.com/eweill/convert-datasets" rel="noopener ugc nofollow" target="_blank">工具</a>。克隆存储库，并为您提取图像和标签的每个项目创建两个文件夹(格式为<code class="du ju jv jw jx b">[classname]</code>和<code class="du ju jv jw jx b">[classname]KITTI</code>)。例如，如果我对检测背包、手提箱、手提包和公文包感兴趣，我将在convert-datasets中有以下文件夹:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es mg"><img src="../Images/598497a870935dd6891a7234fa5d817b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*03HW_CapQeVP4DG-Q5Oykw.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">Initial Folder Structure for Convert-Datasets Directory. Renamed <code class="du ju jv jw jx b">darknet_obj_names.txt</code> for Various Classes and Added Them to Repository.</figcaption></figure><p id="2ce9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，对于每个只有类名的文件夹(例如，公文包)，创建一个名为train和val的文件夹。<em class="jd">我们需要这样做，因为这是convert-dataset工具识别的格式</em>。在train文件夹中，复制<code class="du ju jv jw jx b">dir_[classname]B </code>(如<code class="du ju jv jw jx b">dir_Briefcase</code>)的darknet和images文件夹，分别重命名为labels和images。对val文件夹做完全相同的事情，对您感兴趣的所有不同的类重复这些步骤。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es mh"><img src="../Images/b75bea0eebcbd6e9a35c33274e8943c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z-mUnhXpYvW3GVUqXtwpdA.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">Example File Structure for Each Individual Class in Convert-Datasets.</figcaption></figure><p id="6306" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">同样，将<code class="du ju jv jw jx b">dir_[classname]</code>文件夹中的<code class="du ju jv jw jx b">darknet_obj_names.txt</code>文件重命名为<code class="du ju jv jw jx b">darknet_obj_names_[classname].txt</code>(例如<code class="du ju jv jw jx b">darknet_obj_names_briefcase.txt</code>)。然后，将其移动到convert-datasets存储库的根文件夹中。对所有正在使用的类都这样做。</p><p id="bf56" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，返回convert-datasets的根目录并运行以下命令:</p><pre class="jf jg jh ji fd lp jx lq lr aw ls bi"><span id="a9fc" class="lb jz hh jx b fi lt lu l lv lw"># Generic </span><span id="d6ce" class="lb jz hh jx b fi mc lu l lv lw">python3 convert-dataset.py --from yolo --from-path [classname]/ --to kitti --to-path [classname]KITTI/ --label darknet_obj_names_[classname].txt</span><span id="3305" class="lb jz hh jx b fi mc lu l lv lw"># Example with Pastry </span><span id="8455" class="lb jz hh jx b fi mc lu l lv lw">python3 convert-dataset.py --from yolo --from-path pastry/ --to kitti --to-path pastryKITTI/ --label darknet_obj_names_pastry.txt</span></pre><p id="41b5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果运行此命令有问题，请尝试执行以下操作:</p><pre class="jf jg jh ji fd lp jx lq lr aw ls bi"><span id="8812" class="lb jz hh jx b fi lt lu l lv lw"># Installing Pillow (run via command line) <br/>python3 -m pip install --upgrade pillow</span><span id="16e8" class="lb jz hh jx b fi mc lu l lv lw"># Installing LXML (run via command line) <br/>pip3 install lxml </span></pre><p id="304e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后，您应该会收到以下内容；请键入“是”进行覆盖。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es mi"><img src="../Images/89feff58e718f89aa93c49be3e058c90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/format:webp/1*s3f6PFFbXoScPXY0Dr2IDQ.png"/></div><figcaption class="jq jr et er es js jt bd b be z dx">A Successful Conversion to the KITTI Format</figcaption></figure><p id="530a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">有时，您不会收到“转换完成！!"输出，命令将挂起。在这种情况下，它可能实际上已经完成了转换，您只需<code class="du ju jv jw jx b">CTRL + C.</code>检查您的标签，以确保它们已正确转换为KITTI格式。举个例子:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es mj"><img src="../Images/640005e68fd25253f35c9cd31243f3c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*Yb1UQ710USECoYdTSvxuog.png"/></div><figcaption class="jq jr et er es js jt bd b be z dx">Proper Output to KITTI Format Using the Pastry Example</figcaption></figure><p id="c6f3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">但是，如果你数元素，有16个元素。如前所述，<em class="jd"> TLT要求KITTI格式只包含15个元素</em>。对此最方便快捷的解决方案是运行以下CLI命令，然后删除生成的结果文件<code class="du ju jv jw jx b">.bat</code>。该命令将获取现有的<code class="du ju jv jw jx b">.txt</code>文件，并编辑它们以删除最后的0。</p><pre class="jf jg jh ji fd lp jx lq lr aw ls bi"><span id="9554" class="lb jz hh jx b fi lt lu l lv lw">find . -maxdepth 1 -name '*.txt' -exec sed -i.bak 's/[[:space:]]\{1,\}[^[:space:]]\{1,\}$//' {} \;</span><span id="035f" class="lb jz hh jx b fi mc lu l lv lw">sed 's/[[:space:]]\{1,\}[^[:space:]]\{1,\}$//'</span></pre><p id="5957" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">完成这些步骤后，你的<code class="du ju jv jw jx b">[classname]KITTI</code>目录中就会有你的数据。您可以删除val文件夹中的标签目录，因为它不会被使用。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es mk"><img src="../Images/dc3b36a451916f438b37d6f38bb11995.png" data-original-src="https://miro.medium.com/v2/resize:fit:776/format:webp/1*NzIBUU-oD-IzcCGvrFQhGA.png"/></div><figcaption class="jq jr et er es js jt bd b be z dx">Example Output for the Pastry Example.</figcaption></figure><h2 id="06b8" class="lb jz hh bd ka lc ld le ke lf lg lh ki ip li lj km it lk ll kq ix lm ln ku lo bi translated">获取KITTI格式数据后的步骤</h2><p id="e5ff" class="pw-post-body-paragraph ie if hh ig b ih kw ij ik il kx in io ip ky ir is it kz iv iw ix la iz ja jb ha bi translated">在这一点上，你应该有你的照片训练/测试和他们的KITTI标签，尊重。如果您遵循OpenImages方法，您将拥有一个或多个标记为<code class="du ju jv jw jx b">[classname]KITTI</code>的目录，其中包含一个train和val目录。对于您自己的自定义数据集，您将分别拥有一个包含标签的文件夹和一个包含train/val集照片的文件夹。但是，重要的是将所有这些信息(无论使用何种方法)整合成一种适用于TLT的标准格式。因为TLT包含一个示例Jupyter笔记本和检查特定文件标签和格式的预写代码，这个标准格式允许对代码进行最小的修改，并防止在未来的步骤中出现错误。</p><p id="91f7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">首先，我们需要确保图像和标签遵循一个升序的数字顺序，除了大小合适之外，还要从四个零开始。<strong class="ig hi"> <em class="jd">请注意，无论您使用何种方法获取KITTI数据</em> </strong>，您只需重命名验证数据集的图像以及训练数据集的图像和标签数据。如果您只有一个存储库或数据集，这个过程相当简单，因为您可以创建一个空的Jupyter笔记本，并对训练和验证存储库运行以下命令。对于训练数据集中的标签数据:</p><pre class="jf jg jh ji fd lp jx lq lr aw ls bi"><span id="86eb" class="lb jz hh jx b fi lt lu l lv lw">import os</span><span id="002e" class="lb jz hh jx b fi mc lu l lv lw">i=0<br/># Path to labels data (e.g., {your-path}/convert)<br/># datasets/pastryKITTI/train/labels) </span><span id="4789" class="lb jz hh jx b fi mc lu l lv lw">path="{your_path}/test/labels" <br/>dir = os.listdir(path)<br/>dir.sort()</span><span id="b6fc" class="lb jz hh jx b fi mc lu l lv lw">for filename in dir:<br/>  os.rename(path+'/'+filename,path+'/0000'+str(i)+'.txt')<br/>  i = i + 1</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ml"><img src="../Images/572fa428cb7912aba4933bff534004fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AE_xw8hLRzGeOlrrbtn2Sw.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">Example Output of Running the Above Command.</figcaption></figure><p id="d5da" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">此命令按升序重命名文件夹中的所有内容。接下来，对PNG图像执行相同的命令。注意，每个类的文本文件的数量应该与PNG图像的数量相同。对于图像数据:</p><pre class="jf jg jh ji fd lp jx lq lr aw ls bi"><span id="9b8b" class="lb jz hh jx b fi lt lu l lv lw">import os</span><span id="2e10" class="lb jz hh jx b fi mc lu l lv lw">i=0<br/># Path to labels data (e.g., {your-path}/convert <br/># datasets/pastryKITTI/train/images)<br/>path="{your_path}/test/images"<br/>dir = os.listdir(path)<br/>dir.sort()</span><span id="9e12" class="lb jz hh jx b fi mc lu l lv lw">for filename in dir: <br/>    os.rename(path+'/'+filename,path+'/0000'+str(i)+'.png')<br/>    i = i + 1</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es mm"><img src="../Images/633496c1f7b07635a8e2f5adf3e6e160.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hXH0PN8QfJ-jIvWBJGiM4Q.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">Example Output of Running the Above Command.</figcaption></figure><p id="dafc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，您应该有了按数字升序排列的标签和图像，其中<code class="du ju jv jw jx b">00001.txt</code>对应于<code class="du ju jv jw jx b">00001.png</code>等等。如果你使用Google OpenImages的方法，并且不同的类有多个目录，这有助于将你的照片和标签合并到一个目录中，因为TLT假设你的数据存储在一个存储库中。我们发现，当在不同的类上提取信息时，图像和标签可能共享相同的名称。因此，如果您要立即将照片/标签合并到一个文件夹中，您将拥有引用不同信息的副本；这有助于在整合之前分别重命名每个存储库中的文件。</p><p id="04d8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在第一个类的存储库中执行上述步骤，然后对于后续的类，您可以使用相同的代码，但是将<code class="du ju jv jw jx b">i=0</code>替换为<code class="du ju jv jw jx b">i=[1 + last label number of previous repo]</code>。换句话说，如果第一个存储库有100个图像，那么我们将使用<code class="du ju jv jw jx b">i=101</code>对第二个存储库的标签和图像重新运行上面的命令。完成后，将图像和标签合并到一个文件夹中；关于这种特定格式的更多信息如下。</p><p id="e042" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">无论采用何种方法，我们都需要创建或使用一个文件夹(例如<code class="du ju jv jw jx b">tlt-experiments/data</code>)，该文件夹有两个文件夹<code class="du ju jv jw jx b">training</code>和<code class="du ju jv jw jx b">testing</code>，其中测试包含<em class="jd">仅用于验证/测试的图像</em>，训练包含用于训练的<em class="jd">图像和标签</em>。换句话说，数据的格式应该是这样的:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es mn"><img src="../Images/904b72cf9cc5f85c1e0a0a5366c44eec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9KsTgggAPgPdMNUVIvPEFQ.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">Folder Chart for Datasets for TLT. Use Label_2/Image_2 as the Internal Folders Within Training and Testing.</figcaption></figure><p id="7fd0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们使用这种特定格式的原因是，它与英伟达为TLT提供的YOLO Jupyter笔记本样本中的预期格式相匹配。现在将我们的数据转换成这种格式可以为我们以后的工作节省时间。</p><p id="913c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">你可以从你的图片中随机选择一个子集放到<code class="du ju jv jw jx b">image_2</code>下的<code class="du ju jv jw jx b">testing</code>中，或者完全选择新的图片(确保它们遵循前面提到的升序格式)。为了训练，将您的合并图像文件夹放在那里，并将其重命名为<code class="du ju jv jw jx b">image_2</code>。然后，将您的合并标签文件夹放在那里，并将其重命名为<code class="du ju jv jw jx b">label_2</code>。现在，检查标签和调整信息。</p><p id="3a7d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一旦你的数据文件夹设置好了，就把它上传到Github，或者使用其他的存储方法来获取数据。我们将数据上传到Github，然后上传到DGX 1号。</p><h1 id="38ce" class="jy jz hh bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">和TLT一起训练模特</h1><h2 id="cde5" class="lb jz hh bd ka lc ld le ke lf lg lh ki ip li lj km it lk ll kq ix lm ln ku lo bi translated">设置TLT以供使用</h2><p id="d0eb" class="pw-post-body-paragraph ie if hh ig b ih kw ij ik il kx in io ip ky ir is it kz iv iw ix la iz ja jb ha bi translated">接下来，我们需要设置TLT以供使用。NVIDIA对此的说明也在这里<a class="ae jc" href="https://ngc.nvidia.com/catalog/containers/nvidia:tlt-streamanalytics" rel="noopener ugc nofollow" target="_blank">提供</a>。提醒一下，我们在远程访问的DGX 1号上运行TLT，使用的是2.0版。看起来3.0版本对此有不同的处理方式，没有明确地使用docker有关更多信息，请参见之前链接的文档。首先，运行:</p><pre class="jf jg jh ji fd lp jx lq lr aw ls bi"><span id="6ea8" class="lb jz hh jx b fi lt lu l lv lw">docker pull nvcr.io/nvidia/tlt-streamanalytics:v2.0_py3</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es mo"><img src="../Images/3ef3a1806bc2bf159708c4612360a424.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MVkN4MdICLoHT4bdVd78AQ.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">Resulting Output of Running the Above Command</figcaption></figure><p id="8bdc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">接下来，进入下面的<a class="ae jc" href="https://ngc.nvidia.com/signin" rel="noopener ugc nofollow" target="_blank">站点</a>创建一个NGC账户，输入你的电子邮件，选择创建账户，然后输入你的信息，点击下一步。然后，通过<code class="du ju jv jw jx b">ngc config set</code>配置NGC命令行界面。您将被要求提供一个API密钥，您可以从下面的中的<a class="ae jc" href="http://ngc.nvidia.com/setup/api-key" rel="noopener ugc nofollow" target="_blank">获得该密钥(假设您已登录NGC)。复制API密钥，粘贴到终端中；对于其余的设置，使用默认选项。在这一部分之后，您将运行TLT docker映像(确保添加您自己的项目文件夹)。在我们的例子中，我们已经将数据上传到Github。我们通过Git将数据(这是在前面步骤中创建的数据文件夹)提取到DGX-1，并将其移动到一个purestorage目录。</a></p><pre class="jf jg jh ji fd lp jx lq lr aw ls bi"><span id="6424" class="lb jz hh jx b fi lt lu l lv lw"><em class="jd">docker run --gpus all -it -v /purestorage/{project_name}:/workspace/{project_name} -p 8848:8848 nvcr.io/nvidia/tlt-streamanalytics:v2.0_py3 /bin/bash</em></span></pre><p id="f95d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">由于我们的数据存储在purestorage中，我们的位置从<code class="du ju jv jw jx b">/purestorage</code>开始。您应该用数据的位置替换这一部分。此外，<code class="du ju jv jw jx b">-p 8848:8848</code>线路支持端口8848上的端口转发，我们需要这样做以便从远程桌面访问DGX-1上的Jupyter笔记本。如果您没有远程运行任何东西，您可能不需要运行这行代码。</p><p id="b748" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第一次运行可能需要几分钟。本质上，这启动了一个docker容器，其中包含NVIDIA用于对象检测的示例Jupyter笔记本。在我们的例子中，我们想使用YOLO的例子。</p><p id="617e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">将目录切换到您感兴趣的示例(如<code class="du ju jv jw jx b">/workspace/examples/yolo</code>)并运行<code class="du ju jv jw jx b">jupyter notebook</code>。打开localhost并导航到相关的。ipynb文件(本例中为<code class="du ju jv jw jx b">yolo.ipynb</code>)。为了在给定的设置下运行Jupyter Notebook，我们使用了以下命令:</p><pre class="jf jg jh ji fd lp jx lq lr aw ls bi"><span id="b0d4" class="lb jz hh jx b fi lt lu l lv lw">jupyter notebook –-ip 0.0.0.0 –-port 8848 –-allow-root</span></pre><p id="0159" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这将允许在端口8848上进行根访问和端口转发。在远程桌面中，在Chrome中打开<code class="du ju jv jw jx b"><a class="ae jc" href="http://localhost:8848" rel="noopener ugc nofollow" target="_blank">http://localhost:8848</a></code>,或者使用带有令牌的终端中提供的URL之一。</p><p id="8a25" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">注意:如果你完成了并想离开docker，只需按下<code class="du ju jv jw jx b">CTRL + P + Q</code>即可离开docker，但保持容器运行。如果你想完全停止容器，只需键入exit。要查看所有正在运行的容器，可以运行<code class="du ju jv jw jx b">docker ps -a</code>。要移除容器，请键入<code class="du ju jv jw jx b">docker rm [container_name]</code>。要启动一个容器(假设您已经启动了一个项目，已经对它进行了配置，并且想要恢复工作)，您可以运行下面的命令:<code class="du ju jv jw jx b">docker start -i [container_id]</code>并按下<code class="du ju jv jw jx b">Enter</code>。</p><p id="19e0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">假设您已经成功启动并打开了Jupyter笔记本(例如<code class="du ju jv jw jx b">yolo.ipynb</code>)，您首先需要输入一些关于数据存储位置的信息。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es mp"><img src="../Images/689795e157cf77c5f2543af81c091318.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2LmClgJwYQCkZIUMqtNnOQ.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">If You Run Everything Successfully, This Will Be The Jupyter Notebook.</figcaption></figure><p id="5bdb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第一步是设置我们的环境变量。首先，在Set up Env variables部分，将前一部分中的API键放在名为key的变量下。然后，在<code class="du ju jv jw jx b">USER_EXPERIMENT_DIR</code>下，放置包含<code class="du ju jv jw jx b">yolo</code>文件夹的目录(在我们的例子中，这是<code class="du ju jv jw jx b">workspace/{project_name}/yolo</code>)。接下来，在<code class="du ju jv jw jx b">DATA_DOWNLOAD_DIR</code>下，放置包含前一部分中的<code class="du ju jv jw jx b">Data</code>文件夹的目录(对我们来说，这是<code class="du ju jv jw jx b">/workspace/{project_name}/data</code>)。然后，运行代码块。您可以通过以下方式查看文件夹中是否包含图像和标签:</p><pre class="jf jg jh ji fd lp jx lq lr aw ls bi"><span id="c8c9" class="lb jz hh jx b fi lt lu l lv lw">!dir /workspace/{project_name}/data/training/image_2<br/>!dir /workspace/{project_name}/data/training/label_2</span></pre><p id="e5a4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">接下来，您可以跳到“准备数据集和预训练模型”中的最后一个代码块用下面的代码添加一个新的代码块，它将根据您的数据生成最佳的锚点大小。</p><pre class="jf jg jh ji fd lp jx lq lr aw ls bi"><span id="c1ed" class="lb jz hh jx b fi lt lu l lv lw">!python kmeans.py -l $DATA_DOWNLOAD_DIR/training/label_2 -n 9</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es mq"><img src="../Images/19c0c5324dc54d37c3cdafbb6dd91ab2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4ttzDa9dI5_Zcfd8y1xv8Q.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">Example Output of Running the Above Command.</figcaption></figure><p id="7cf8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，我们需要修改yolo_tfrecords规范中的路径。如果你去<code class="du ju jv jw jx b">127.0.0.1:{port_number. For us, this was 8848}/tree</code>点击<code class="du ju jv jw jx b">specs</code>目录，就叫<code class="du ju jv jw jx b">yolo_tfrecords_kitti_trainval.txt</code>。更改<code class="du ju jv jw jx b">root_directory_path</code>和<code class="du ju jv jw jx b">image_directory_path</code>以匹配您所拥有的(您的训练数据所在的位置)。在我们的例子中，格式如下:</p><pre class="jf jg jh ji fd lp jx lq lr aw ls bi"><span id="89a1" class="lb jz hh jx b fi lt lu l lv lw">root_directory_path: "/workspace/{project_name}/data/training"<br/>image_directory_path: "/workspace/{project_name}/data/training"</span></pre><p id="6912" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一旦你修改了这个文件，确保你保存它，然后回到Jupyter笔记本。现在可以用<code class="du ju jv jw jx b">tlt-dataset-convert</code>运行代码块。这将创建一个目录并将TF记录放在那里。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es mr"><img src="../Images/ee24b8515050b2bfa2dd164d7a4e20ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TDUgxU4XtAl95IuAGY5Ynw.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">Successfully Running the Above Command.</figcaption></figure><p id="3c7f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果一切顺利，最后的输出应该会说<code class="du ju jv jw jx b">Tfrecords generation complete.</code>接下来，Juptyer笔记本会引导你查看生成的TF记录。</p><p id="3656" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下一步是下载预先训练好的模型。我们将使用NGC CLI获取预训练模型(<code class="du ju jv jw jx b">!ngc registry model list nvidia/tlt_pretrained_object_detection:*</code>将显示存在哪些模型)。我们对Darknet感兴趣，所以让我们在创建目录后运行下面的命令(<code class="du ju jv jw jx b">!mkdir -p $USER_EXPERIMENT_DIR/pretrained_darknet19/</code>)。这些步骤应该已经在Juptyer笔记本上了。</p><pre class="jf jg jh ji fd lp jx lq lr aw ls bi"><span id="d66a" class="lb jz hh jx b fi lt lu l lv lw">!ngc registry model download-version nvidia/tlt_pretrained_object_detection:darknet19 --dest $USER_EXPERIMENT_DIR/pretrained_darknet19</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ms"><img src="../Images/d3d62f4e8184c6803843f8987597a40c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rcF25rPdkL4Rl5XEtu235A.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">Example Output for Running the Above.</figcaption></figure><p id="a532" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下一步是提供培训规范。还记得我们之前运行的命令吗？我们现在将使用该输出。我们需要修改<code class="du ju jv jw jx b">yolo_train_resnet18_kitti.txt</code>中的信息。如果你去<code class="du ju jv jw jx b">127.0.0.1:{port_number. For us, this was 8848}/tree</code>点击<code class="du ju jv jw jx b">specs</code>目录，它被称为<code class="du ju jv jw jx b">yolo_train_resnet18_kitti.txt</code>。在<code class="du ju jv jw jx b">yolo_config</code>下，改变锚点形状以匹配输出。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es mt"><img src="../Images/2010c06571758eef9b38cc118d5e7785.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p2fS7N6_K19Ta62_opy3mA.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">Changing the Anchor Boxes for Yolo_Config.</figcaption></figure><p id="8599" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后，将<code class="du ju jv jw jx b">arch</code>参数改为“暗网”，将<code class="du ju jv jw jx b">nlayers</code>改为19。您也可以在这里更改<code class="du ju jv jw jx b">batch_size_per_gpu</code>参数和<code class="du ju jv jw jx b">num_epochs</code>，这是推荐的，但会根据您的情况(即工作站)和您拥有的数据量而有所不同。如果你得到的结果很差，试着改变这些值，看看是否有区别。</p><p id="a249" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在<code class="du ju jv jw jx b">augmentation_config</code>下，可以更改，比如<code class="du ju jv jw jx b">output_image_width</code>为800，<code class="du ju jv jw jx b">output_image_height</code>为576。另外，<code class="du ju jv jw jx b">crop_right</code>和<code class="du ju jv jw jx b">crop_bottom</code>将分别为800和576。现在，在<code class="du ju jv jw jx b">dataset_config</code>下，更改<code class="du ju jv jw jx b">tfrecords_path</code>以匹配您的tfrecords的存储位置(例如<code class="du ju jv jw jx b">“/workspace/{project_name}/data/tfrecords/kitti_trainval/kitti_trainval*</code>)。您还需要将<code class="du ju jv jw jx b">image_directory_path</code>更改为图像的路径，如下所示:<code class="du ju jv jw jx b">/workspace/{project_name}/data/training</code>。最后也可能是最重要的部分是确保你包含了<code class="du ju jv jw jx b">target_class_mapping</code>下的所有类，这些类应该有一个键和值以及你的类名。把你要检测的所有类放在这里。例如，如果我有一个数据集，并试图检测不同的耐克鞋，我的<code class="du ju jv jw jx b">dataset_config</code>可能如下所示:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es mu"><img src="../Images/28c61c6b58a43013e9f47d18ce532db8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z9LvFR4j5UDR4vR2zRQiJA.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">Part of the Yolo_Train_Resnet18_KITTI.txt File.</figcaption></figure><p id="6f66" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">完成此操作后，保存文件并在Jupyter笔记本中继续第3步。在此步骤中，我们将运行实际的培训过程，这可能需要一些时间，具体取决于您机器的容量。此外，请更改GPU的数量以匹配您的系统，并包括DarkNet-19预训练模型(我们没有更改规格文件的名称，所以它仍然显示resnet18，尽管它使用的是darknet19)。它应该如下所示:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es mv"><img src="../Images/53fc0a8aa46714ff2e1b0b26fe270402.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DXE7ZCe9g-8pviD5QPvApQ.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">Running the Training Command.</figcaption></figure><p id="64f1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">完成后，您将看到最终的纪元编号将分别显示类别/模型的AP和mAP值。然后您可以检查每个纪元的模型是否通过<code class="du ju jv jw jx b">!ls -ltrh $USER_EXPERIMENT_DIR/experiment_dir_unpruned/weights</code>保存。然后，您希望通过以下方式浏览并选择精度最高的模型:</p><pre class="jf jg jh ji fd lp jx lq lr aw ls bi"><span id="f5cd" class="lb jz hh jx b fi lt lu l lv lw"># Now check the evaluation stats in the csv file and pick the model with highest eval accuracy. Outputs all the models' accuracies. </span><span id="8eb8" class="lb jz hh jx b fi mc lu l lv lw">!cat $USER_EXPERIMENT_DIR/experiment_dir_unpruned/yolo_training_log_darknet19.csv</span><span id="7d11" class="lb jz hh jx b fi mc lu l lv lw"># For example. Likely, you may have more than 80 epochs and the most accurate epoch may be a different number. <br/>%set_env EPOCH=080</span></pre><p id="8749" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下一步是通过以下方式评估经过培训的模型:</p><pre class="jf jg jh ji fd lp jx lq lr aw ls bi"><span id="2080" class="lb jz hh jx b fi lt lu l lv lw">!tlt-evaluate yolo -e $SPECS_DIR/yolo_train_resnet18_kitti.txt \ -m $USER_EXPERIMENT_DIR/experiment_dir_unpruned/weights/yolo_darknet19_epoch_$EPOCH.tlt \ -k $KEY</span></pre><h1 id="bf74" class="jy jz hh bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">优化模型&amp;使用TLT可视化结果</h1><p id="06ee" class="pw-post-body-paragraph ie if hh ig b ih kw ij ik il kx in io ip ky ir is it kz iv iw ix la iz ja jb ha bi translated">下一步涉及模型修剪。您只需按照Juptyer笔记本中的说明进行操作，该部分如下所示:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es mv"><img src="../Images/98d59782a790ab8a563b7983cb043b84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pRU8Un1KMh0_oAeuyAmGNw.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">The Output of the Pruning Trained Models Step.</figcaption></figure><p id="83a3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">接下来，我们将重新训练修剪后的模型，以恢复修剪后的精度。在这种情况下，我们需要更改<code class="du ju jv jw jx b">yolo_retrain_resnet18_kitti.txt</code>的规格文件，该文件位于规格文件中(与其他规格文件位于同一位置)。在这种情况下，进行与在这里对<code class="du ju jv jw jx b">yolo_train_resnet18_kitti.txt</code>文件所做的相同的更改，并保存该文件。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es mw"><img src="../Images/406861317c0fe8d5be56ecb549254642.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1tRXwaMOOocBdh5RdfzPEg.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">Output of Running the Above Commands.</figcaption></figure><p id="008b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">就像上一节一样，在运行第七步之前，确保您<code class="du ju jv jw jx b">%set_env EPOCH</code>到了评估精度最高的模型，如下所示。</p><pre class="jf jg jh ji fd lp jx lq lr aw ls bi"><span id="7ca7" class="lb jz hh jx b fi lt lu l lv lw">!tlt-evaluate yolo -e $SPECS_DIR/yolo_retrain_resnet18_kitti.txt \-m $USER_EXPERIMENT_DIR/experiment_dir_retrain/weights/yolo_darknet19_epoch_$EPOCH.tlt \ -k $KEY</span></pre><p id="6ffd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，为了可视化输出(最后)，我们运行以下程序(它将复制一些测试图像并在这些图像上运行对象检测):</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es mx"><img src="../Images/8617eed339c2d4d6dd36c8877cf82b2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o3zbALthJJIF92sLX-aDtQ.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">Running the Output of the Above Commands.</figcaption></figure><p id="c915" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Jupyter笔记本确实包含代码，允许您以网格状格式可视化输出，但我们觉得图像太小，看不到标签。这是所提供代码的示例输出:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es mr"><img src="../Images/73c9adb0b735b23f23823b9066ff5bed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7bJICWmUST4jd3cLeQXppg.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">Example Output of the YOLO Object Detection Model</figcaption></figure><p id="2813" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，我们使用以下代码逐个查看图像:</p><pre class="jf jg jh ji fd lp jx lq lr aw ls bi"><span id="507d" class="lb jz hh jx b fi lt lu l lv lw">from IPython.display import Image</span><span id="3a92" class="lb jz hh jx b fi mc lu l lv lw">Image(filename='/workspace/{project_name}/yolo/yolo_infer_images/000038.png') # replace with the pathname of the image you want. </span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/1d5dca51b1c8b6636faee623f8f012fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b6vHBTPQi5A76SyzpU9uIg.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">Example Output of the Object Detection Model</figcaption></figure><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es my"><img src="../Images/556377a9ef7369f5c42e486c371e0f78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MtxyIqTci8TKzVHrr0ZkSw.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">Another Example Output of the Object Detection Model</figcaption></figure><p id="3352" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果结果不令人满意，请考虑更改一些参数(例如，纪元大小)并重新训练您的模型。希望您会发现本指南很有帮助。如果您有任何问题，请随时留言。</p></div></div>    
</body>
</html>