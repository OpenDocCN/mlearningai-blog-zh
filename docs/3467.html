<html>
<head>
<title>Gradient Descent, the Dart way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">梯度下降，飞镖方式</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/gradient-descent-the-dart-way-2d6c39416a8a?source=collection_archive---------8-----------------------#2022-09-06">https://medium.com/mlearning-ai/gradient-descent-the-dart-way-2d6c39416a8a?source=collection_archive---------8-----------------------#2022-09-06</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="d737" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jc">本帖是Dart中关于机器学习系列文章的一部分:</em></p><ul class=""><li id="8b83" class="jd je hh ig b ih ii il im ip jf it jg ix jh jb ji jj jk jl bi translated"><a class="ae jm" rel="noopener" href="/mlearning-ai/machine-learning-in-dart-programming-language-fbfffd7deb18?source=friends_link&amp;sk=12ba21f2c7a01f1aa18954ba2a82fae9"> <em class="jc">飞镖编程语言中的机器学习</em> </a></li><li id="a361" class="jd je hh ig b ih jn il jo ip jp it jq ix jr jb ji jj jk jl bi translated"><a class="ae jm" rel="noopener" href="/mlearning-ai/a-gentle-introduction-to-linear-regression-the-dart-way-9750214e6fa2?source=friends_link&amp;sk=e199d8f5b0bb71c97525be2ee7f5819b"> <em class="jc">线性回归简介</em> </a></li><li id="7251" class="jd je hh ig b ih jn il jo ip jp it jq ix jr jb ji jj jk jl bi translated"><a class="ae jm" rel="noopener" href="/mlearning-ai/linear-regression-ordinary-least-squares-in-a-nutshell-c2e0d7ed260f?source=friends_link&amp;sk=5c8bc0228d29bc67ebe524a91d687619"> <em class="jc">线性回归:简单地说就是普通最小二乘法</em> </a></li><li id="8966" class="jd je hh ig b ih jn il jo ip jp it jq ix jr jb ji jj jk jl bi translated"><a class="ae jm" rel="noopener" href="/mlearning-ai/ordinary-least-squares-closed-form-solution-the-dart-way-d7c0ee0e0d02?source=friends_link&amp;sk=9ba5a9da7fd3160b28c450ff6dc446a4"> <em class="jc">线性回归:闭式解，飞镖方式</em> </a></li></ul><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="er es js"><img src="../Images/52d9138a803d1ff8cbc9bee5f893a759.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rC6CLnLGiULOT2or"/></div></div><figcaption class="ke kf et er es kg kh bd b be z dx">Photo by <a class="ae jm" href="https://unsplash.com/@ericmuhr?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Eric Muhr</a> on <a class="ae jm" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="da22" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在我上一篇<a class="ae jm" rel="noopener" href="/mlearning-ai/ordinary-least-squares-closed-form-solution-the-dart-way-d7c0ee0e0d02?source=friends_link&amp;sk=9ba5a9da7fd3160b28c450ff6dc446a4">文章</a>中，我们熟悉了普通最小二乘问题的一个简洁优雅的解决方案——封闭形式的解决方案。</p><p id="d795" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">本文将深入探讨另一种优化算法—梯度下降。最后，我们将使用Dart编程语言对算法进行编码。</p><p id="e083" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">目录:</strong></p><ol class=""><li id="e9c9" class="jd je hh ig b ih ii il im ip jf it jg ix jh jb ki jj jk jl bi translated">梯度下降背后的直觉</li><li id="da40" class="jd je hh ig b ih jn il jo ip jp it jq ix jr jb ki jj jk jl bi translated">算法的数学基础</li><li id="1b26" class="jd je hh ig b ih jn il jo ip jp it jq ix jr jb ki jj jk jl bi translated">Dart编程语言中梯度下降的实现</li></ol></div><div class="ab cl kj kk go kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="ha hb hc hd he"><h2 id="6665" class="kq kr hh bd ks kt ku kv kw kx ky kz la ip lb lc ld it le lf lg ix lh li lj lk bi translated"><strong class="ak">梯度下降背后的直觉</strong></h2><p id="84a0" class="pw-post-body-paragraph ie if hh ig b ih ll ij ik il lm in io ip ln ir is it lo iv iw ix lp iz ja jb ha bi translated">让我们记住我们的目标是什么:我们必须找到成本函数的最小值，在我们的情况下是平方误差。该函数的典型图形:</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="er es lq"><img src="../Images/49af593abf86f00f65804d80d73a2abe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L3ztNnWT_YuGc5KX_fGlqg.png"/></div></div></figure><p id="29c6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">图表看起来像一个坑。所以让我们想象我们正处在它的边缘。天完全黑了，我们得找到坑底。</p><p id="d19c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们后退一步。很明显，我们正在上升；我们能感觉到，上升总是比下降难。我们错了，落后的方向不会把我们引向谷底。所以让我们改变方向，向前迈一步。现在我们能感觉到我们在下降。走了很多步后，坑变得不那么陡了。最后，我们到达了底部，但我们还不知道它。我们向前迈一步，我们觉得我们开始提升，所以我们需要后退。现在我们完全知道我们已经到了谷底。</p><p id="3697" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们刚刚描述了梯度下降算法。为了让计算机理解它，我们应该首先将直观的描述翻译成数学，然后翻译成编程语言的代码。</p></div><div class="ab cl kj kk go kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="ha hb hc hd he"><h2 id="41fa" class="kq kr hh bd ks kt ku kv kw kx ky kz la ip lb lc ld it le lf lg ix lh li lj lk bi translated"><strong class="ak">算法的数学基础</strong></h2><p id="932d" class="pw-post-body-paragraph ie if hh ig b ih ll ij ik il lm in io ip ln ir is it lo iv iw ix lp iz ja jb ha bi translated">数学意义上的一步是指在某一点找到函数的导数。导数反过来意味着函数在该点的陡度:</p><ul class=""><li id="fa67" class="jd je hh ig b ih ii il im ip jf it jg ix jh jb ji jj jk jl bi translated">导数的绝对值很大意味着函数在这一点上很陡；</li><li id="9f40" class="jd je hh ig b ih jn il jo ip jp it jq ix jr jb ji jj jk jl bi translated">值小意味着函数在该点比较平坦；</li><li id="fdf3" class="jd je hh ig b ih jn il jo ip jp it jq ix jr jb ji jj jk jl bi translated">等于零的值意味着该点是函数的局部最优值；</li><li id="5a2b" class="jd je hh ig b ih jn il jo ip jp it jq ix jr jb ji jj jk jl bi translated">导数的正号意味着函数是上升的；</li><li id="c4d4" class="jd je hh ig b ih jn il jo ip jp it jq ix jr jb ji jj jk jl bi translated">导数的负号意味着函数在下降。</li></ul><p id="64a3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">形式上，最小值是最低点的坐标。对于梯度下降过程的每次迭代，坐标被更新。</p><p id="6acb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这里我们应该提出一个更新规则。</p><p id="56a6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们需要把坐标往最小值的方向改，但是怎么确定方向呢？这很简单——如果新点的导数是负的，这意味着函数在下降，我们可以将坐标向右移动:</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="er es lr"><img src="../Images/62296d7a3afb813027116805a9f15fda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6nyHP_v87sKia7O7gxfkeA.png"/></div></div></figure><p id="d1f1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果该点的导数为正，则函数是上升的，我们需要改变方向，将坐标向左移动:</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="er es ls"><img src="../Images/982a0a512e9aa57920f415197ebf7075.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VcSizGg-BEzzLuGzfJK3EQ.png"/></div></div></figure><p id="8018" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果导数为零，我们处于最小值:</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="er es lt"><img src="../Images/535570c56d407b65b71c602d8c95892a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kFei5lHpp5gpTpuvoKnrwA.png"/></div></div></figure><p id="0277" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">以下规则最恰当地描述了这一过程:</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div class="er es lu"><img src="../Images/224380272352681e77935338dd4c009d.png" data-original-src="https://miro.medium.com/v2/resize:fit:554/format:webp/1*TuLWBBaW1Tj8C9xG-AFWSw.png"/></div></figure><p id="5e45" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在负导数的情况下，我们将坐标向右移动:</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="er es lv"><img src="../Images/b6f4762a8575946b838cabffd7915d81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XmnSQhBxNIUx2WKkVHwX3w.png"/></div></div></figure><p id="fe2e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在正导数的情况下，我们将坐标向左移动:</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="er es lv"><img src="../Images/3b1b51a49f24bb08b95db73aea37f3e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3vdkyqLQVS-hYMT-5RrKyA.png"/></div></div></figure><p id="cddd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了更精确地收敛，最好为导数添加一个系数参数:</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div class="er es lw"><img src="../Images/6996f2de70ec6677f136d1daf05fb348.png" data-original-src="https://miro.medium.com/v2/resize:fit:590/format:webp/1*gKmwRl9QS4AFsK8Himlasg.png"/></div></figure><p id="1340" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">叫做<em class="jc">学习率</em>。</p><p id="ce44" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">何时停止该过程？让我们把新坐标和当前坐标相减:</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div class="er es lx"><img src="../Images/cb5d84843c272b977c33720fca653446.png" data-original-src="https://miro.medium.com/v2/resize:fit:316/format:webp/1*atryw42ZD0HN4nB3bL0g5Q.png"/></div></figure><p id="8d2d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果结果值太大，我们应该重复这个过程。</p><p id="eacd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们的下一个挑战是找出如何处理许多论点的成本函数。回想一下，功能是什么:</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div class="er es ly"><img src="../Images/e2a7e63702bf5803569fab3fb66288af.png" data-original-src="https://miro.medium.com/v2/resize:fit:446/format:webp/1*QOBKkWrf87x_roJ11gayJw.png"/></div></figure><p id="4e40" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">其中<code class="du lz ma mb mc b">M</code>是特征的数量，<code class="du lz ma mb mc b">i</code>是特征矩阵中行的索引，<code class="du lz ma mb mc b">j</code>是列索引。</p><p id="0b51" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们找到一个关于每个自变量的导数值的表达式。因为我们的函数是“复杂的”，这意味着它由几个部分组成，所以我们必须应用链式法则。首先，让我们找出平方的导数:</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div class="er es md"><img src="../Images/5353342e9ecc54504efa7b35c4b4e859.png" data-original-src="https://miro.medium.com/v2/resize:fit:452/format:webp/1*E5ZVyc6W_ieVCwQvii-j7A.png"/></div></figure><p id="977e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后让我们找出函数内部的导数:</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div class="er es me"><img src="../Images/f319b9eea435c48ea8b703845b4249c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1128/format:webp/1*7CuZ9IpzyUWqUUeANeOyrQ.png"/></div></figure><p id="4bec" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最后，让我们将两个表达式相乘:</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="er es mf"><img src="../Images/3df9adda94ac30b41e27ead665682803.png" data-original-src="https://miro.medium.com/v2/resize:fit:774/format:webp/1*eli5-R9fGvYWhL8fhAErMg.png"/></div></div></figure><p id="ef5e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">很好，现在我们有一堆偏导数了。所以我们需要以某种方式组织它们。这里我们来看一下梯度矢量的定义:</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div class="er es mg"><img src="../Images/6d2be91f5009d48164d176c81c82c055.png" data-original-src="https://miro.medium.com/v2/resize:fit:550/format:webp/1*X1YU4rw0NjNXy89iW1Lk8A.png"/></div></figure><p id="14ff" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">梯度是由偏导数组成的向量。</p><p id="9db0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">更新规则保持不变。我们只需要用向量符号重写它:</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div class="er es mh"><img src="../Images/fadb88a14922952903062b32ba353d61.png" data-original-src="https://miro.medium.com/v2/resize:fit:714/format:webp/1*t10YLFLWGjSQ7YVWulgJOg.png"/></div></figure><p id="769e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">详细的渐变看起来像这样:</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="er es mi"><img src="../Images/07dbc3fb33c63d75c415aa7f45b191b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1166/format:webp/1*ly-oMna7eBLUfK9RYLfcDg.png"/></div></div></figure><p id="68b1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">但是矩阵中有很多行；如果每一行都有自己的梯度，我们如何计算梯度呢？似乎我们可以只对所有行的梯度求和:</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div class="er es mj"><img src="../Images/58e6a6109f69f918c5e906b610067dd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:496/format:webp/1*a8pc4gMmql5QEMN7JlzSuQ.png"/></div></figure><p id="9fa6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，规则现在看起来如下:</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div class="er es mk"><img src="../Images/2706f7bd2e5a545b7015eedc426bfc99.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/format:webp/1*geoephP_TP4X_AG9QNrt1w.png"/></div></figure></div><div class="ab cl kj kk go kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="ha hb hc hd he"><h2 id="de2b" class="kq kr hh bd ks kt ku kv kw kx ky kz la ip lb lc ld it le lf lg ix lh li lj lk bi translated">Dart编程语言中梯度下降的实现</h2><p id="f4c2" class="pw-post-body-paragraph ie if hh ig b ih ll ij ik il lm in io ip ln ir is it lo iv iw ix lp iz ja jb ha bi translated">我们试着用Dart编写梯度下降程序吧！</p><p id="ca29" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我准备用<a class="ae jm" href="https://github.com/gyrdym/ml_linalg" rel="noopener ugc nofollow" target="_blank"> ml_linalg </a>包。该库简化了向量和矩阵的工作。此外，由于图书馆的SIMD性质，它有助于我们有效地做数学。</p><p id="5a53" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">该程序将按功能组织。让我们想出它的签名:</p><figure class="jt ju jv jw fd jx"><div class="bz dy l di"><div class="ml mm l"/></div></figure><p id="8801" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了执行梯度下降，我们需要一个特征矩阵<code class="du lz ma mb mc b">X</code>，一个带有标签的列矩阵<code class="du lz ma mb mc b">Y</code>和一个列矩阵<code class="du lz ma mb mc b">initialCoefficients</code>。该函数的输出是系数的列矩阵，其对应于成本函数的最小值点。</p><p id="6fd3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">梯度下降是一个迭代过程，这意味着我们必须定义停止标准。最明显的标准是迭代次数约束。第二标准可以是两次连续迭代之间的差；如果它小于或等于某个极限，我们应该停止程序:</p><figure class="jt ju jv jw fd jx"><div class="bz dy l di"><div class="ml mm l"/></div></figure><p id="823d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们来分解一下:</p><ul class=""><li id="1f49" class="jd je hh ig b ih ii il im ip jf it jg ix jh jb ji jj jk jl bi translated">我们选择一个值<code class="du lz ma mb mc b">50</code>作为迭代计数约束。希望，这将足以收敛。</li><li id="ef66" class="jd je hh ig b ih jn il jo ip jp it jq ix jr jb ji jj jk jl bi translated">如果新系数和当前系数之差小于<code class="du lz ma mb mc b">minCoefficientDiff</code>，则算法收敛，我们应该停止该过程。从数学上讲，我们处于成本函数的最佳状态，因为系数发生了一点变化；这一点的导数几乎为零。</li><li id="b05a" class="jd je hh ig b ih jn il jo ip jp it jq ix jr jb ji jj jk jl bi translated">差应该是一个数，但是新的和当前的系数相减就给了我们一个列矩阵；这就是我们使用矩阵方法<code class="du lz ma mb mc b">norm</code>的原因。这是完全正确的，因为新旧系数之间的差异越小，差异的范数就越小。通过将<code class="du lz ma mb mc b">newCoefficients</code>赋值给<code class="du lz ma mb mc b">coefficients</code>,我们链接了循环以开始新的迭代。新的系数不再是新的，而是当前的系数。</li></ul><p id="e63f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们对系数更新规则进行编码。根据我们上面推导的梯度公式:</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="er es mi"><img src="../Images/07dbc3fb33c63d75c415aa7f45b191b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1166/format:webp/1*ly-oMna7eBLUfK9RYLfcDg.png"/></div></div></figure><p id="ff9d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们应该一个接一个地从矩阵<code class="du lz ma mb mc b">X</code>的第I行中取出每个元素，并将其乘以括号中的表达式。该表达式又将整个第I行乘以当前系数。似乎我们可以用矩阵符号来缩短表达式。为什么要从<code class="du lz ma mb mc b">X</code>的第I行取每个元素，然后乘以表达式？我们可能会使用整个矩阵<code class="du lz ma mb mc b">X</code>！这同样适用于括号中的表达式:我们可以将整个矩阵<code class="du lz ma mb mc b">X</code>乘以当前系数:</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div class="er es mn"><img src="../Images/98f1769dc89525a884d121776e56e737.png" data-original-src="https://miro.medium.com/v2/resize:fit:552/format:webp/1*JTEmu9TKhMfGa_OwbL7stw.png"/></div></figure><p id="42cd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">代码:</p><figure class="jt ju jv jw fd jx"><div class="bz dy l di"><div class="ml mm l"/></div></figure><p id="239c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了符合维度，我们必须转置<code class="du lz ma mb mc b">X</code>。最后一行是更新规则。</p><p id="3f11" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在让我们一起收集所有的碎片:</p><figure class="jt ju jv jw fd jx"><div class="bz dy l di"><div class="ml mm l"/></div></figure><p id="ef52" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">很好，让我们用一个简单的例子来测试一下:</p><figure class="jt ju jv jw fd jx"><div class="bz dy l di"><div class="ml mm l"/></div></figure><p id="5f35" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">不用梯度下降很容易推断出系数:</p><ul class=""><li id="d9a2" class="jd je hh ig b ih ii il im ip jf it jg ix jh jb ji jj jk jl bi translated"><code class="du lz ma mb mc b">2 * w1 + 2 * w2 = 12; w1=w2=3</code></li><li id="f3f2" class="jd je hh ig b ih jn il jo ip jp it jq ix jr jb ji jj jk jl bi translated"><code class="du lz ma mb mc b">3 * w1 + 3 * w2 = 18; w1=w2=3</code></li><li id="1f2f" class="jd je hh ig b ih jn il jo ip jp it jq ix jr jb ji jj jk jl bi translated"><code class="du lz ma mb mc b">4 * w1 + 4 * w2 = 24; w1=w2=3</code></li><li id="cdb6" class="jd je hh ig b ih jn il jo ip jp it jq ix jr jb ji jj jk jl bi translated"><code class="du lz ma mb mc b">5 * w1 + 5 * w2 = 30; w1=w2=3</code></li></ul><p id="cf40" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第一个特征系数是<code class="du lz ma mb mc b">3</code>，第二个特征系数也是<code class="du lz ma mb mc b">3</code>。让我们运行上面的代码，看看输出。输出是:</p><pre class="jt ju jv jw fd mo mc mp mq aw mr bi"><span id="52ae" class="kq kr hh mc b fi ms mt l mu mv">Coefficients: Matrix 2 x 1:<br/>(2.9999842643737793)<br/>(2.9999842643737793)</span></pre><p id="55ec" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">由梯度下降推断的两个系数几乎与预期的一样<code class="du lz ma mb mc b">3</code>(有一些舍入误差)。似乎代码运行良好。</p><p id="d485" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">总结:</strong></p><ul class=""><li id="51c8" class="jd je hh ig b ih ii il im ip jf it jg ix jh jb ji jj jk jl bi translated">梯度下降法的计算成本比封闭解低得多，它不需要昂贵的矩阵求逆运算。可以对大量数据使用该算法。</li><li id="085c" class="jd je hh ig b ih jn il jo ip jp it jq ix jr jb ji jj jk jl bi translated">梯度下降不如闭合解精确，因为闭合解是“理想”解。</li><li id="4ead" class="jd je hh ig b ih jn il jo ip jp it jq ix jr jb ji jj jk jl bi translated">与封闭解不同，梯度下降法可以应用于非线性问题。</li></ul><p id="71e5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">差不多就是这样！</p><p id="de9c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">感谢您的阅读:)</p><div class="mw mx ez fb my mz"><a rel="noopener follow" target="_blank" href="/mlearning-ai/mlearning-ai-submission-suggestions-b51e2b130bfb"><div class="na ab dw"><div class="nb ab nc cl cj nd"><h2 class="bd hi fi z dy ne ea eb nf ed ef hg bi translated">Mlearning.ai提交建议</h2><div class="ng l"><h3 class="bd b fi z dy ne ea eb nf ed ef dx translated">如何成为Mlearning.ai上的作家</h3></div><div class="nh l"><p class="bd b fp z dy ne ea eb nf ed ef dx translated">medium.com</p></div></div><div class="ni l"><div class="nj l nk nl nm ni nn kc mz"/></div></div></a></div></div></div>    
</body>
</html>