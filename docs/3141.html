<html>
<head>
<title>Network Analysis and Community Detection on Political Tweets</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">政治微博的网络分析和社区发现</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/network-analysis-and-community-detection-on-political-tweets-9e0f21294e31?source=collection_archive---------2-----------------------#2022-07-25">https://medium.com/mlearning-ai/network-analysis-and-community-detection-on-political-tweets-9e0f21294e31?source=collection_archive---------2-----------------------#2022-07-25</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="ded9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">社交网络在人们的日常社交中发挥着重要作用。我一直着迷于社交网络的方方面面，以及人们使用社交网络时有趣的行为方式。例如，他们重新分享信息的速度，他们如何根据相似的兴趣相互分组，他们如何相互交流，等等。Twitter一直是我最喜欢观察这一点的网络。出于这个原因，我决定分享我的一个老项目，该项目旨在通过绘制将人们连接成网络的关系来了解Twitter上形成的社区，并试图找出网络中的关键个人、群体以及个人之间的联系。</p><p id="8cee" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在每个国家引起主要观点发布和转发的最大事件之一是选举。虽然来得有点晚，但我在这个项目中使用的目标数据是美国2016年总统选举推文。我从全部推文中选取了一个公平的子集，组成了一个网络，看看它是如何分布的，哪些法律对网络有效，以及检查用户是否根据他们喜欢的候选人形成了社区等等。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/a6b183c846fbb34097848b3f64f499fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tUX0qCTsaD_FdemQ"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Photo by <a class="ae js" href="https://unsplash.com/es/@unarchive?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Jeremy Bezanger</a> on <a class="ae js" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="5e1c" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">数据</h1><p id="afea" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">我从哈佛大学的<a class="ae js" href="https://dataverse.harvard.edu/dataset.xhtml?persistentId=doi:10.7910/DVN/PDI7IN" rel="noopener ugc nofollow" target="_blank"> <em class="kw">数据库</em> </a>中检索推文，其中包含了大约2.8亿个推文id的庞大语料库，分为几个文件。它们被分成几个tweet ids集合。出于这个项目的目的，从id集合<em class="kw">选举过滤器1 </em>到<em class="kw"> 6 </em>下载了几千条推文。使用<em class="kw"/><a class="ae js" href="https://github.com/DocNow/hydrator" rel="noopener ugc nofollow" target="_blank"><em class="kw">Hydrator</em></a>工具从六个不同的集合中检索推文。由于Twitter以json格式发布数据，因此tweets可以先用R处理，然后转换成csv格式。</p><p id="0293" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了做到这一点，我们可以使用R中的“jsonlite”包，在这里我们可以选择保存哪些json属性(我们不需要全部保存)，然后将它们作为属性添加到我们新保存的csv文件中。下面显示了代码的快照:</p><pre class="jd je jf jg fd kx ky kz la aw lb bi"><span id="e786" class="lc ju hh ky b fi ld le l lf lg">library(jsonlite) <br/>library(plyr) <br/>library(xlsx) <br/>library(csv) <br/>library(“data.table”) <br/>json1&lt;-lapply(readLines(“election-filter-6.json”), fromJSON) </span><span id="dc35" class="lc ju hh ky b fi lh le l lf lg">id&lt;-list()<br/>for(i in 1:length(json1)){ <br/>   id[i]&lt;-json1[[i]]$id } </span><span id="4620" class="lc ju hh ky b fi lh le l lf lg">user_screen&lt;-list()<br/>for(i in 1:length(json1)){ <br/>   user_screen[i]&lt;-json1[[i]]$user$screen_name } </span><span id="435e" class="lc ju hh ky b fi lh le l lf lg">original_author&lt;-list() <br/>for(i in 1:length(json1)){ <br/>        if(is.null(json1[[i]]$retweeted_status)==FALSE){    <br/>           tmp&lt;-json1[[i]]$retweeted_status$user$screen_name } else{              <br/>           tmp&lt;-”Null” } original_author[i]&lt;-tmp }<br/>...</span><span id="3269" class="lc ju hh ky b fi lh le l lf lg">to_export&lt;-cbind(id,user_screen,original_author,user_id,favorite_count,retweet_count,user_following,user_followers,user_friends,user_statuses,tweet_text)  <br/>                                                     to_export_df&lt;-data.frame(to_export)                                                           write.xlsx(to_export_df,"el-filter6_new.xlsx",row.names = FALSE)                             fwrite(to_export_df, file ="el-filter6_new.csv")</span></pre><p id="3ed0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">结果数据集总共包含162，520个条目和13个列属性。我们将关注网络创建的“用户屏幕”和“原创作者”属性。这个网络是用Python的<a class="ae js" href="https://networkx.org/" rel="noopener ugc nofollow" target="_blank"> networkx </a>包创建的，其中每个节点是一个用户，边是用户之间的“转发”连接。这意味着，如果该推文最初由用户X发布，并由用户Y转发；我们将有一个从用户Y到用户x的有向链接，换句话说，我们创建一个以‘user _ screen’为源，以‘original _ author’为目标的有向图，其中映射函数f是‘retweet’。首先，我们删除“original_author”字段为空的条目(它们不会被转发)，因为我们只检查用户之间的转发关系。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es li"><img src="../Images/c03b34947102c23ccc56bf0db5debdee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*JixCB8PNNcQIcuPjKgVnfw.png"/></div><figcaption class="jo jp et er es jq jr bd b be z dx">The way the graph is formed: The source node is the tweet author (who retweeted it) and the target node is the original author (who wrote it)</figcaption></figure><p id="7b07" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">结果数据集的统计如下所示:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es lj"><img src="../Images/e2b79befbd5ebc426119d70c7b0197b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vy1MoajDnfQKlXqDZDxDgg.png"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Dataset information</figcaption></figure><p id="feeb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们可以用以下函数创建图形(或网络，在这种情况下两个术语都是正确的):</p><pre class="jd je jf jg fd kx ky kz la aw lb bi"><span id="3b59" class="lc ju hh ky b fi ld le l lf lg">retweets_G = nx.from_pandas_edgelist(tmp, source=’user_screen’,                                                                                                               <br/>target=’original_author’, edge_attr=True,          create_using=nx.MultiDiGraph())</span><span id="7a55" class="lc ju hh ky b fi lh le l lf lg">nx.write_edgelist(retweets_G, ‘retweets_graph.csv’)</span></pre><h1 id="0ec7" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">网络属性</h1><p id="db7c" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">如前所述创建一个图，我们最终得到65，920个节点和104，718个连接。</p><h2 id="7efd" class="lc ju hh bd jv lk ll lm jz ln lo lp kd ip lq lr kh it ls lt kl ix lu lv kp lw bi translated"><strong class="ak"> <em class="lx">节点度</em> </strong></h2><p id="5302" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">我们可以用。degree()函数，它将返回网络中所有节点的度数。如果我们对它们进行排序，我们可以得到最大的枢纽，即指向和来自它的链接最多的节点。</p><pre class="jd je jf jg fd kx ky kz la aw lb bi"><span id="5738" class="lc ju hh ky b fi ld le l lf lg">node_and_degree = retweets_G.degree()</span><span id="83ef" class="lc ju hh ky b fi lh le l lf lg">(largest_hub, degree) = sorted(node_and_degree, key=itemgetter(1))[-1]</span></pre><p id="d1d4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在像这样的网络中，我们有像希拉里·克林顿和唐纳德·特朗普这样的受欢迎的个人资料，通常这些个人资料充当最大的枢纽，因此具有非常高的节点度，而其他个人资料最多只有1度(被转发一次，或者根本没有)。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es ly"><img src="../Images/4ed2c1533098e002656ad91a83bb6507.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AiKZdKBDuQ3Taq0ldVSODQ.png"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Graphical representation of the network</figcaption></figure><p id="aec3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们还可以计算其他网络统计数据，例如:自循环、密度等。</p><pre class="jd je jf jg fd kx ky kz la aw lb bi"><span id="06de" class="lc ju hh ky b fi ld le l lf lg">nx.density(retweets_G)</span><span id="1e13" class="lc ju hh ky b fi lh le l lf lg">nx.number_of_selfloops(retweets_G)</span><span id="c82e" class="lc ju hh ky b fi lh le l lf lg">nx.degree_assortativity_coefficient(retweets_G)</span></pre><h2 id="e0eb" class="lc ju hh bd jv lk ll lm jz ln lo lp kd ip lq lr kh it ls lt kl ix lu lv kp lw bi translated">幂定律</h2><p id="a80c" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">考虑到网络的不均匀分布，可以有把握地假设网页的幂定律适用于这个网络。在其定义中，它告诉我们有k个内链接的网站的数量大约是1/k。在我们的例子中，被转发k次的tweeters的比例大约等于1/k。如果我们将数据转换成双对数坐标，这种关系就形成了一个线性图。</p><p id="fd50" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们可以计算幂律，并通过首先计算入度和出度频率，然后绘制它们来以图形方式显示它:</p><pre class="jd je jf jg fd kx ky kz la aw lb bi"><span id="add8" class="lc ju hh ky b fi ld le l lf lg">def get_frequencies(degree_dict):<br/> degree_freq = {}</span><span id="f22f" class="lc ju hh ky b fi lh le l lf lg">for node, deg in degree_dict.items():<br/> if deg in degree_freq:<br/> degree_freq[deg] += 1<br/> else:<br/> degree_freq[deg] = 1</span><span id="b6ae" class="lc ju hh ky b fi lh le l lf lg">x = sorted(degree_freq.keys())<br/> y = [degree_freq[k] for k in x]<br/> return x, y</span><span id="ec6c" class="lc ju hh ky b fi lh le l lf lg">x, y = get_frequencies(dict(retweets_G.out_degree(set(data.user_screen))))<br/>plt.title(“out degree”)<br/>plt.loglog(x, y, linestyle=’None’, marker=’.’, )<br/>plt.show()</span></pre><p id="5e92" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们以一个证明幂律适用于此的图结束:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es lz"><img src="../Images/c573792553ef1ce92fad866462e7d90c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1230/format:webp/1*WeszZMGPmQlndLaSii-Kzg.png"/></div><figcaption class="jo jp et er es jq jr bd b be z dx">Power law for the out degree nodes</figcaption></figure><h2 id="ec7e" class="lc ju hh bd jv lk ll lm jz ln lo lp kd ip lq lr kh it ls lt kl ix lu lv kp lw bi translated">友谊悖论</h2><p id="fe6e" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">斯科特·费尔德研究了这一现象，他指出，一个人的朋友平均比他/她有更多的朋友。这被证明是真实的脸书友谊，推特关注连接，但在现实生活中也是如此。例如，你的伴侣平均比你拥有更多的伴侣。我们可以用转发网来检验友谊悖论，看看它在这里是否成立。由于它包含一定数量的高调节点，这些节点的转发量远远高于平均水平，因此友谊悖论不适用于整个网络。</p><p id="3e76" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">就这个网络而言，78%的人口都是如此。也就是说，平均有51，294名用户转发了他们的帖子。另外14，626人我们可以假设是政治家、报纸门户网站和其他有影响力的人。计算友谊悖论的代码快照可以在我的代码的完整版本中找到。</p><h2 id="56b1" class="lc ju hh bd jv lk ll lm jz ln lo lp kd ip lq lr kh it ls lt kl ix lu lv kp lw bi translated">页面等级</h2><p id="b74d" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">一种著名的链接分析算法，根据重要性和权威性对网页进行排序。一个页面的页面排名是递归计算的，它取决于链接到它的所有其他页面的页面排名指标的数量。按照这种逻辑，我们计算Twitter在网络中的页面排名，并根据重要性对它们进行排序。PageRank可以用networkx scipy实现来计算。</p><pre class="jd je jf jg fd kx ky kz la aw lb bi"><span id="b741" class="lc ju hh ky b fi ld le l lf lg">page_rank = nx.pagerank_scipy(retweets_G, alpha=0.9)</span><span id="8869" class="lc ju hh ky b fi lh le l lf lg">sorted(page_rank.items(), key=lambda kv: kv[1], reverse=True)[:30]</span></pre><h1 id="93e5" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">社区检测</h1><p id="de93" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">在这样的大型社交网络中，尤其是与政治选举等重要话题相关的社交网络中，人们通过与一些用户互动，根据观点将自己分组。我们将使用python实现Louvain社区检测算法。在Blondel等人的工作中描述了该算法。该算法的思想在于模块性计算的基础，作为用于测量划分质量的度量。模块性度量是区间[-1，1]中的标量值，并且与社区之间的链接相比，度量社区内部的链接密度。</p><p id="8daf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">它迭代地寻找分区，首先将每个节点作为自己的社区，然后基于模块性计算，在每次迭代中，它将节点移动到新的社区，以便最大化该社区中的模块性。如果模块性没有变化，那么节点就留在自己的社区中。该算法的一个很大的优点是，它给出了算法的每个层次的中间结果。根据网络的不同，在到达具有最大模块性的最后一个之前，层级上可能有不同的数字。</p><p id="4837" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">要找到社区，首先我们需要包含Louvain实现的“社区”包。</p><pre class="jd je jf jg fd kx ky kz la aw lb bi"><span id="b89f" class="lc ju hh ky b fi ld le l lf lg">import community<br/>retweets_new=retweets_G.to_undirected()<br/>partition = community.best_partition(retweets_new)</span><span id="40d4" class="lc ju hh ky b fi lh le l lf lg">size = float(len(set(partition.values())))<br/>pos = nx.spring_layout(retweets_new)<br/>count = 0.<br/>for com in set(partition.values()) :<br/> count = count + 1.<br/> list_nodes = [nodes for nodes in partition.keys()<br/> if partition[nodes] == com]<br/> nx.draw_networkx_nodes(retweets_new, pos, list_nodes, node_size = 20,<br/> node_color = str(count / size))</span><span id="a0ad" class="lc ju hh ky b fi lh le l lf lg">nx.draw_networkx_edges(retweets_new, pos, alpha=0.5)<br/>plt.show()</span></pre><p id="e4f9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">从这里，我们可以访问所有被鲁汶发现的社区，以及他们的成员。然而把它们都画在一起有点乱，特别是如果我们想给每个社区涂上不同的颜色。例如，如果我们删除成员数量低于某个阈值的社区，我们可以解决这个问题。它将给我们留下最大的社区。我们还可以打印出每个社区中最大的节点。</p><pre class="jd je jf jg fd kx ky kz la aw lb bi"><span id="36ed" class="lc ju hh ky b fi ld le l lf lg"># Keep only communities with a minimum of authors<br/>counter=0<br/>centers = {}<br/>communities = {}<br/>G_main_com = retweets_new.copy()<br/>min_nb = 500<br/>for com in set(partition.values()) :<br/> list_nodes = [nodes for nodes in partition.keys() if partition[nodes] == com]<br/> if len(list_nodes) &lt; min_nb:<br/> G_main_com.remove_nodes_from(list_nodes)<br/> else:<br/> # Get center<br/> H = G_main_com.subgraph(list_nodes)<br/> d_c = nx.degree_centrality(H)<br/> center = max(d_c, key=d_c.get)<br/> centers[center] = com<br/> communities[com] = center<br/> # Print community<br/> print(‘Community of ‘, center , ‘(ID ‘, com, ‘) — ‘, len(list_nodes), ‘ retweeters:’)<br/> counter=counter+1<br/> print(list_nodes, ‘\n’)</span></pre><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es ma"><img src="../Images/778a343220f631863c9db6a4542d59ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ryip7Xw7syNwTW4-TdGrJQ.png"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Visualization of the top 20 communities by number of members in the network</figcaption></figure><p id="3833" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">虽然社区之间有所分离，但社区成员之间仍有较高的相互联系。我们还可以根据关键字过滤推文，以获得更有趣的结果和更小的社区(希望能更好地概述)。例如，如果我们只包含像“希拉里”和“克林顿”这样的词，我们会得到一个非常有趣的图表。有两个非常不同的社区，中间有一堵墙，这表明有少量的转发量在两个方向流动。这两个区块确实是政治候选人和接近他们的个人资料。很酷，不是吗？</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es mb"><img src="../Images/5999559fe4a34dfc89a90bf6f366d590.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lNbiKcgtExZ3SgGbmbY2LA.png"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">The top 5 communities with over 1000 members plotted for the Clinton-related tweets graph</figcaption></figure><p id="524c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">你可以在<a class="ae js" href="https://github.com/popkristina/Twitter_community_detection" rel="noopener ugc nofollow" target="_blank">https://github.com/popkristina/Twitter_community_detection</a>查看我的完整代码</p><h1 id="3346" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">参考</h1><ol class=""><li id="e302" class="mc md hh ig b ih kr il ks ip me it mf ix mg jb mh mi mj mk bi translated"><em class="kw">社交网络分析:“如何引导”。</em>伦敦:内政部，2016年</li></ol><p id="f27c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">2.<em class="kw">优化Twitter社交网络中的社区发现。</em> <strong class="ig hi"> G. Suryateja，p . saravanan</strong>，2018</p><p id="1212" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">3.<em class="kw">规模问题:社区检测算法的比较分析。</em> <strong class="ig hi">保罗·瓦根瑟勒三世，汪锋</strong>，2017</p><p id="cf79" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">4.<em class="kw">大型网络中社区的快速展开。文森特·d·布隆德尔，让-卢普·纪尧姆，雷诺·朗比奥蒂，艾蒂安·列斐伏尔，2008年</em></p><p id="f5c3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">5.<a class="ae js" href="https://en.wikipedia.org/wiki/PageRank" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/PageRank</a></p><p id="7fe4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">6.<a class="ae js" href="https://www.technologyreview.com/s/523566/how-the-friendship-paradox-makes-your-friends-better-than-you-are/" rel="noopener ugc nofollow" target="_blank">https://www . technology review . com/s/523566/how-the-friendship-paradox-makes-your-friends-better-than-you-are/</a></p><p id="3cb9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">7.<a class="ae js" href="https://python-louvain.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">https://python-louvain.readthedocs.io/en/latest/</a></p><div class="ml mm ez fb mn mo"><a rel="noopener follow" target="_blank" href="/mlearning-ai/mlearning-ai-submission-suggestions-b51e2b130bfb"><div class="mp ab dw"><div class="mq ab mr cl cj ms"><h2 class="bd hi fi z dy mt ea eb mu ed ef hg bi translated">Mlearning.ai提交建议</h2><div class="mv l"><h3 class="bd b fi z dy mt ea eb mu ed ef dx translated">如何成为Mlearning.ai上的作家</h3></div><div class="mw l"><p class="bd b fp z dy mt ea eb mu ed ef dx translated">medium.com</p></div></div><div class="mx l"><div class="my l mz na nb mx nc jm mo"/></div></div></a></div></div></div>    
</body>
</html>