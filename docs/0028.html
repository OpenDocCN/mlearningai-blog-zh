<html>
<head>
<title>Text Pre-Processing: Smart Way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">文本预处理:聪明的方法</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/smart-text-pre-processing-c098afd97d65?source=collection_archive---------2-----------------------#2020-06-11">https://medium.com/mlearning-ai/smart-text-pre-processing-c098afd97d65?source=collection_archive---------2-----------------------#2020-06-11</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/4660fdbf8ccf5965a1ac31e123a98c57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o8VmN_epVhKbBZNL9Uhu6g.png"/></div></div></figure><div class=""/><h1 id="929b" class="ip iq hs bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">概观</h1><p id="e239" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">在这篇文章中，我们将讨论一些快速而简单的技巧，它们非常有效和强大，可以为你节省大量的时间。</p></div><div class="ab cl kl km go kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ha hb hc hd he"><h1 id="f426" class="ip iq hs bd ir is ks iu iv iw kt iy iz ja ku jc jd je kv jg jh ji kw jk jl jm bi translated">文本预处理中的问题</h1><p id="d29d" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">从文本数据中获取意义是一项棘手的工作，肮脏的文本会让它变得更加麻烦。我们所有人都遇到过与文本相关的问题陈述，并意识到清理文本数据比清理数字数据要困难得多(这是我所相信的)。</p><p id="7171" class="pw-post-body-paragraph jn jo hs jp b jq kx js jt ju ky jw jx jy kz ka kb kc la ke kf kg lb ki kj kk ha bi translated">当我说清理文本数据时，我到底在说什么:<br/> (1)拼写错误<br/> (2)文本缩写<br/> (3)连接单词</p><p id="72b0" class="pw-post-body-paragraph jn jo hs jp b jq kx js jt ju ky jw jx jy kz ka kb kc la ke kf kg lb ki kj kk ha bi translated">我不会谈论标记化、词干化、词汇化和其他预处理技术的重要性。</p><p id="f00c" class="pw-post-body-paragraph jn jo hs jp b jq kx js jt ju ky jw jx jy kz ka kb kc la ke kf kg lb ki kj kk ha bi translated">让我们一个一个地击倒他们。</p><h2 id="4840" class="lc iq hs bd ir ld le lf iv lg lh li iz jy lj lk jd kc ll lm jh kg ln lo jl lp bi translated">拼写错误</h2><figure class="lr ls lt lu fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lq"><img src="../Images/c349c0935d97eb183c8e688b08c35541.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eRQlyvuSUsZw2-zRh-odcg.png"/></div></div></figure><p id="b9d2" class="pw-post-body-paragraph jn jo hs jp b jq kx js jt ju ky jw jx jy kz ka kb kc la ke kf kg lb ki kj kk ha bi translated">大多数收集的数据都有这种人为插入的拼写错误。虽然我们有一些先进的NLP建模技术，但我更喜欢纠正这些术语，使它们更有意义。</p><h2 id="1238" class="lc iq hs bd ir ld le lf iv lg lh li iz jy lj lk jd kc ll lm jh kg ln lo jl lp bi translated">文本缩写</h2><figure class="lr ls lt lu fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lv"><img src="../Images/da48fde23d6cbef9652cf8252d91d346.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DqBe01KNxMHwYQDigGrq5w.png"/></div></div></figure><p id="3c9b" class="pw-post-body-paragraph jn jo hs jp b jq kx js jt ju ky jw jx jy kz ka kb kc la ke kf kg lb ki kj kk ha bi translated">作为人类，我们有惊人的能力来解释复杂的单词和句子，但机器是愚蠢的，我们需要用勺子喂它们。文本缩写就是这样一个问题。我在情绪理解问题上看到了它的有效性，其中否定词在预处理中没有被忽略。</p><h2 id="d2ba" class="lc iq hs bd ir ld le lf iv lg lh li iz jy lj lk jd kc ll lm jh kg ln lo jl lp bi translated">连接词</h2><figure class="lr ls lt lu fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lw"><img src="../Images/9314ff8228149625f8e37048d6c81b57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EoradH-tQM6nyodEXuo-ug.png"/></div></div></figure><p id="8988" class="pw-post-body-paragraph jn jo hs jp b jq kx js jt ju ky jw jx jy kz ka kb kc la ke kf kg lb ki kj kk ha bi translated">趋势由标签表示，标签决定趋势。在推文分类、极性分析、趋势分析等问题中非常重要。分离单词会带来更多关于主题的深刻信息。</p><h1 id="9c03" class="ip iq hs bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">传统方法</h1><p id="191b" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">我见过有人用穷举列表来表示缩写。类似这样的东西</p><pre class="lr ls lt lu fd lx ly lz ma aw mb bi"><span id="3010" class="lc iq hs ly b fi mc md l me mf">contractions = { <br/>"ain't": "am not / are not / is not / has not / have not",<br/>"aren't": "are not / am not",<br/>"can't": "cannot",<br/>"can't've": "cannot have",<br/>"'cause": "because",<br/>"could've": "could have",<br/>"couldn't": "could not",<br/>"couldn't've": "could not have",<br/>"didn't": "did not",<br/>"doesn't": "does not",<br/>"don't": "do not",<br/>"hadn't": "had not",<br/>"hadn't've": "had not have",<br/>"hasn't": "has not",<br/>"haven't": "have not",<br/>"he'd": "he had / he would",<br/>"he'd've": "he would have",<br/>"he'll": "he shall / he will",<br/>"he'll've": "he shall have / he will have",<br/>"he's": "he has / he is",<br/>"how'd": "how did",<br/>"how'd'y": "how do you",<br/>"how'll": "how will",<br/>"how's": "how has / how is / how does",<br/>"I'd": "I had / I would",<br/>"I'd've": "I would have",<br/>"I'll": "I shall / I will",<br/>"I'll've": "I shall have / I will have",<br/>"I'm": "I am",<br/>"I've": "I have",<br/>"isn't": "is not",<br/>"it'd": "it had / it would",<br/>"it'd've": "it would have",<br/>"it'll": "it shall / it will",<br/>"it'll've": "it shall have / it will have",<br/>"it's": "it has / it is",<br/>"let's": "let us",<br/>"ma'am": "madam",<br/>"mayn't": "may not",<br/>"might've": "might have",<br/>"mightn't": "might not",<br/>"mightn't've": "might not have",<br/>"must've": "must have",<br/>"mustn't": "must not",<br/>"mustn't've": "must not have",<br/>"needn't": "need not",<br/>"needn't've": "need not have",<br/>"o'clock": "of the clock",<br/>"oughtn't": "ought not",<br/>"oughtn't've": "ought not have",<br/>"shan't": "shall not",<br/>"sha'n't": "shall not",<br/>"shan't've": "shall not have",<br/>"she'd": "she had / she would",<br/>"she'd've": "she would have",<br/>"she'll": "she shall / she will",<br/>"she'll've": "she shall have / she will have",<br/>"she's": "she has / she is",<br/>"should've": "should have",<br/>"shouldn't": "should not",<br/>"shouldn't've": "should not have",<br/>"so've": "so have",<br/>"so's": "so as / so is",<br/>"that'd": "that would / that had",<br/>"that'd've": "that would have",<br/>"that's": "that has / that is",<br/>"there'd": "there had / there would",<br/>"there'd've": "there would have",<br/>"there's": "there has / there is",<br/>"they'd": "they had / they would",<br/>"they'd've": "they would have",<br/>"they'll": "they shall / they will",<br/>"they'll've": "they shall have / they will have",<br/>"they're": "they are",<br/>"they've": "they have",<br/>"to've": "to have",<br/>"wasn't": "was not",<br/>"we'd": "we had / we would",<br/>"we'd've": "we would have",<br/>"we'll": "we will",<br/>"we'll've": "we will have",<br/>"we're": "we are",<br/>"we've": "we have",<br/>"weren't": "were not",<br/>"what'll": "what shall / what will",<br/>"what'll've": "what shall have / what will have",<br/>"what're": "what are",<br/>"what's": "what has / what is",<br/>"what've": "what have",<br/>"when's": "when has / when is",<br/>"when've": "when have",<br/>"where'd": "where did",<br/>"where's": "where has / where is",<br/>"where've": "where have",<br/>"who'll": "who shall / who will",<br/>"who'll've": "who shall have / who will have",<br/>"who's": "who has / who is",<br/>"who've": "who have",<br/>"why's": "why has / why is",<br/>"why've": "why have",<br/>"will've": "will have",<br/>"won't": "will not",<br/>"won't've": "will not have",<br/>"would've": "would have",<br/>"wouldn't": "would not",<br/>"wouldn't've": "would not have",<br/>"y'all": "you all",<br/>"y'all'd": "you all would",<br/>"y'all'd've": "you all would have",<br/>"y'all're": "you all are",<br/>"y'all've": "you all have",<br/>"you'd": "you had / you would",<br/>"you'd've": "you would have",<br/>"you'll": "you shall / you will",<br/>"you'll've": "you shall have / you will have",<br/>"you're": "you are",<br/>"you've": "you have"<br/>}</span></pre><p id="e527" class="pw-post-body-paragraph jn jo hs jp b jq kx js jt ju ky jw jx jy kz ka kb kc la ke kf kg lb ki kj kk ha bi translated">它看起来不漂亮。</p><p id="ed99" class="pw-post-body-paragraph jn jo hs jp b jq kx js jt ju ky jw jx jy kz ka kb kc la ke kf kg lb ki kj kk ha bi translated">对于缩写，人们也准备了类似的详尽的列表和我们通常忽略的拼写错误。</p><h1 id="a2a6" class="ip iq hs bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">一个聪明的方法</h1><p id="3dbc" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">我发现了一些有用的python库，它们可以在一行中完成这个困难的单词。</p><p id="f855" class="pw-post-body-paragraph jn jo hs jp b jq kx js jt ju ky jw jx jy kz ka kb kc la ke kf kg lb ki kj kk ha bi translated">我们可以使用Textblob来重新训练你自己的拼写检查。</p><figure class="lr ls lt lu fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mg"><img src="../Images/7b60d127ac102b7f3f21d99b4ab10b3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o_x7vHlBGFlQViV-ZtpsGw.png"/></div></div></figure><figure class="lr ls lt lu fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mh"><img src="../Images/43c3db9e3a7c00c4b85f7ef85aa6ecde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GfknjBJuzMGMyxxPIHtcXQ.png"/></div></div></figure><figure class="lr ls lt lu fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mi"><img src="../Images/e829851fedd0ce6b77d21c9680d262f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k-NVu7cVnx7ANyZqG-4wEg.png"/></div></div></figure><p id="628e" class="pw-post-body-paragraph jn jo hs jp b jq kx js jt ju ky jw jx jy kz ka kb kc la ke kf kg lb ki kj kk ha bi translated">搞定了。</p><h2 id="0ecc" class="lc iq hs bd ir ld le lf iv lg lh li iz jy lj lk jd kc ll lm jh kg ln lo jl lp bi translated">复合词算法里面有什么？</h2><p id="979d" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">一个好的第一近似值是假设所有单词都是独立分布的。那么你只需要知道所有单词的相对频率。有理由假设它们遵循Zipf定律，即单词列表中排名为<em class="mj"> n </em>的单词的概率大致为1/( <em class="mj"> n </em> log <em class="mj"> N </em>)其中<em class="mj"> N </em>是字典中的单词数。</p><p id="4ce7" class="pw-post-body-paragraph jn jo hs jp b jq kx js jt ju ky jw jx jy kz ka kb kc la ke kf kg lb ki kj kk ha bi translated">一旦确定了模型，就可以使用动态编程来推断空间的位置。最有可能的句子是最大化每个单词的概率乘积的句子，用动态编程很容易计算出来。我们不直接使用概率，而是使用定义为概率倒数的对数的成本来避免溢出。</p></div></div>    
</body>
</html>