<html>
<head>
<title>Machine Learning 101:All things Classification</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">机器学习101:万物分类</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/machine-learning-101-all-things-classification-ee6dff9c2af5?source=collection_archive---------9-----------------------#2022-02-19">https://medium.com/mlearning-ai/machine-learning-101-all-things-classification-ee6dff9c2af5?source=collection_archive---------9-----------------------#2022-02-19</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="503f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在上一篇文章中，我谈到了不同类型的回归，这一次我们将深入分类和它的不同类型</p><p id="dd1f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">分类是一种受监督的学习算法，它用于预测离散值，如您是否患有癌症，是否是垃圾邮件，您属于3个经济类别中的哪一个，但基本上它将输入数据映射到特定的预定义类别，如恶性或良性(在肿瘤检测中)。正如我在上一篇文章中提到的，我将讨论分类算法中的逻辑回归，除此之外，我们还将看看其他一些算法，如决策树、KNN和朴素贝叶斯</p><h1 id="2623" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">逻辑回归</h1><p id="e13d" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">逻辑回归类似于线性回归，只是它预测事物是真还是假，而不是像线性回归那样用一条线来拟合数据，这里是一条S形曲线，称为Sigmoid函数，虽然逻辑回归给你真或假的概率，但它主要用于二元分类问题，现在它的工作原理是如果它为真的概率大于50%，它为真，否则它为假。正是这种使用连续和离散测量来提供概率和分类样本的能力使其成为一种流行的分类算法，除了二元分类之外，还有许多其他类型的逻辑回归，如多项逻辑回归(许多类)、有序逻辑回归(多个有序类)。</p><figure class="kf kg kh ki fd kj er es paragraph-image"><div class="ab fe cl kk"><img src="../Images/989e5a6e1e0c12fb257ab0d560e591b0.png" data-original-src="https://miro.medium.com/v2/format:webp/1*zfH9946AssCx4vzjaizWeg.png"/></div></figure><figure class="kf kg kh ki fd kj er es paragraph-image"><div class="er es kn"><img src="../Images/6356543086536b11ab183321ef495f12.png" data-original-src="https://miro.medium.com/v2/resize:fit:574/0*6mpc4duWzxOBMAAK"/></div></figure><p id="9a45" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">sigmoid函数是我们用来计算某事为真或为假的概率的函数，sigmoid函数中的“x”由变量的加权和表示，下图进一步解释了这一过程的工作原理</p><figure class="kf kg kh ki fd kj er es paragraph-image"><div class="er es ko"><img src="../Images/ca61585c94afdbfbdf625ddab1d529d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/0*gUsaFvek3AhvQe1d.png"/></div></figure><h1 id="bf3f" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">k-最近邻</h1><p id="d29e" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">在KNN，数据点的值由其周围的值决定，它基于多数获胜原则，如果有5个最近邻，其中3个属于A类，一个属于B类，一个属于C类，未知数据点将被分类为属于A类。K最近邻算法中的K给出了我们必须考虑的邻居数量，因此如果K=5，您将考虑5个邻居，现在我们已经了解了KNN的K，让我们了解最近邻是如何计算的</p><figure class="kf kg kh ki fd kj er es paragraph-image"><div class="er es kp"><img src="../Images/f3c37ec50d71de4f1c9b9c7d381b8f4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/0*Ef4KlcNKpcW7uVfh.gif"/></div></figure><p id="2c0c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">有几种方法可以识别最近的邻居，我将解释2种最常见的方法</p><figure class="kf kg kh ki fd kj er es paragraph-image"><div class="er es kq"><img src="../Images/57a15f9dc1d31937be61b0b82407f0ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/0*IckzchqnL4dJQK84.jpg"/></div></figure><p id="f756" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">曼哈顿距离</strong></p><p id="928e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">曼哈顿距离是使用笛卡尔坐标差的绝对和来计算的</p><figure class="kf kg kh ki fd kj er es paragraph-image"><div class="er es kr"><img src="../Images/2051576fec52e4becd3f056d6922c383.png" data-original-src="https://miro.medium.com/v2/resize:fit:1018/format:webp/0*fzsPnAPXko5BS40J.png"/></div></figure><p id="9f67" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">欧几里德距离</strong></p><p id="dddb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">欧几里得距离是使用笛卡尔坐标的差之和的平方来计算的，在Sklearn库中，这是计算KNN的默认度量。</p><figure class="kf kg kh ki fd kj er es paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="er es ks"><img src="../Images/69191586634bcbc9fc8ee238a79910c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*RsA6_3JMvDtcvI_a.png"/></div></div></figure><p id="4c04" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在没有办法知道数据集中K的最佳值是多少，因此确定最佳精度的最佳方法是将这些值放入一个循环中，并绘制K值与精度的关系曲线</p><h1 id="1824" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">朴素贝叶斯</h1><p id="04b6" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">有许多类型的朴素贝叶斯算法，我将集中讨论多项式朴素贝叶斯分类，其他类型的朴素贝叶斯将在另一篇文章中讨论</p><p id="9f52" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">朴素贝叶斯算法是围绕贝叶斯定理建模的，下图计算了假设B发生的概率，朴素贝叶斯分类器假设所有属性对结果的贡献相等，即它们都具有相同的权重，没有属性更重要或更不重要，这就是为什么我们称之为“朴素”</p><figure class="kf kg kh ki fd kj er es paragraph-image"><div class="er es kx"><img src="../Images/67d402f8bd233eeeb0b1cb214259cd61.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/format:webp/0*r2zyQWHCwe8EiQIa.jpeg"/></div></figure><h1 id="6aa5" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">决策树分类</h1><p id="20e3" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">决策树顾名思义就是做决策的树，这种算法遵循基于规则的方法。该算法所做的是，它使用所有的特征来创建是/否问题，并继续分割决策，直到所有的数据点被隔离在它们各自的类中，该树中的第一个节点被称为根，最底部的节点被称为叶节点</p><figure class="kf kg kh ki fd kj er es paragraph-image"><div class="er es ky"><img src="../Images/ad42ebd168dfa84214a7a0b0a6495af1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1084/format:webp/0*L97Qj0L3mi1GVbH7.png"/></div></figure><p id="3c9d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，你如何创建这些问题，本质上是如何分裂一棵树，为此我们使用一个损失函数来比较分裂前后的分布，即基尼不纯度和熵，目标是最小化这些函数，以便获得更好的分裂。</p><figure class="kf kg kh ki fd kj er es paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="er es kz"><img src="../Images/92bee9edd8f54a56b5054e5f47a1a265.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jNS3Tvu-DvURiySc"/></div></div></figure><p id="0a03" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="la">下一次我将写关于推荐系统的文章，如果你喜欢这篇文章，请投赞成票，如果你不喜欢，请让我知道我应该做些什么:)</em></p><div class="lb lc ez fb ld le"><a rel="noopener follow" target="_blank" href="/mlearning-ai/mlearning-ai-submission-suggestions-b51e2b130bfb"><div class="lf ab dw"><div class="lg ab lh cl cj li"><h2 class="bd hi fi z dy lj ea eb lk ed ef hg bi translated">Mlearning.ai提交建议</h2><div class="ll l"><h3 class="bd b fi z dy lj ea eb lk ed ef dx translated">如何成为Mlearning.ai上的作家</h3></div><div class="lm l"><p class="bd b fp z dy lj ea eb lk ed ef dx translated">medium.com</p></div></div><div class="ln l"><div class="lo l lp lq lr ln ls kl le"/></div></div></a></div><p id="4bf7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">🔵<a class="ae lt" rel="noopener" href="/mlearning-ai/mlearning-ai-submission-suggestions-b51e2b130bfb"> <strong class="ig hi">成为作家</strong> </a></p></div></div>    
</body>
</html>