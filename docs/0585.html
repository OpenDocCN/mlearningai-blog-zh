<html>
<head>
<title>Predicting Google’s Stock Prices Using Facebook’s Prophet</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用脸书的先知预测谷歌的股价</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/predicting-googles-stock-prices-using-facebook-s-prophet-4829c83a8590?source=collection_archive---------0-----------------------#2021-05-21">https://medium.com/mlearning-ai/predicting-googles-stock-prices-using-facebook-s-prophet-4829c83a8590?source=collection_archive---------0-----------------------#2021-05-21</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/82cd5e6dc4d406f6f65b05ce1c1dd89e.png" data-original-src="https://miro.medium.com/v2/resize:fit:578/format:webp/1*dfBCBG8_5-OHpdcqGa2r6g.png"/></div></figure><blockquote class="il im in"><p id="5b3d" class="io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Prophet是一种基于加法模型预测时间序列数据的过程，在该模型中，非线性趋势与每年、每周和每天的季节性以及假日影响相适应。它最适用于具有强烈季节效应的时间序列和几个季节的历史数据。</p></blockquote><p id="ce9b" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jn jb jc jd jo jf jg jh jp jj jk jl jm ha bi translated">预言者是<a class="ae jq" href="https://code.facebook.com/projects/" rel="noopener ugc nofollow" target="_blank">的开源软件</a>由<strong class="ir hi">脸书的</strong> <a class="ae jq" href="https://research.fb.com/category/data-science/" rel="noopener ugc nofollow" target="_blank"> <strong class="ir hi">核心数据科学团队</strong> </a>发布。可在<a class="ae jq" href="https://cran.r-project.org/package=prophet" rel="noopener ugc nofollow" target="_blank"> CRAN </a>和<a class="ae jq" href="https://pypi.python.org/pypi/fbprophet/" rel="noopener ugc nofollow" target="_blank"> PyPI </a>上下载。</p><figure class="js jt ju jv fd ii er es paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="er es jr"><img src="../Images/48c7fdb317c8ebe34863e10bb6bcc039.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WmzgicudIlvrOOEN"/></div></div></figure><p id="0964" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jn jb jc jd jo jf jg jh jp jj jk jl jm ha bi translated"><strong class="ir hi">先知模型背后的数学方程式定义为:</strong></p><figure class="js jt ju jv fd ii er es paragraph-image"><div class="er es ka"><img src="../Images/35fabc1daf6f948a95eab41af99657a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:958/format:webp/1*_bu8a7H46V0r2IzhwCtMIA.png"/></div></figure><p id="6c1e" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jn jb jc jd jo jf jg jh jp jj jk jl jm ha bi translated">有了，</p><ul class=""><li id="333d" class="kb kc hh ir b is it iw ix jn kd jo ke jp kf jm kg kh ki kj bi translated">代表趋势的g(t)</li><li id="32f9" class="kb kc hh ir b is kk iw kl jn km jo kn jp ko jm kg kh ki kj bi translated">s(t)代表周期性变化(每周、每月、每年)</li><li id="025a" class="kb kc hh ir b is kk iw kl jn km jo kn jp ko jm kg kh ki kj bi translated">h(t)代表假期的影响</li><li id="adcb" class="kb kc hh ir b is kk iw kl jn km jo kn jp ko jm kg kh ki kj bi translated">e(t)是误差项</li></ul><p id="ec09" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jn jb jc jd jo jf jg jh jp jj jk jl jm ha bi translated"><strong class="ir hi">使用FB先知的优势:</strong></p><ul class=""><li id="e863" class="kb kc hh ir b is it iw ix jn kd jo ke jp kf jm kg kh ki kj bi translated">开放源码</li><li id="6511" class="kb kc hh ir b is kk iw kl jn km jo kn jp ko jm kg kh ki kj bi translated">准确快速</li><li id="30e1" class="kb kc hh ir b is kk iw kl jn km jo kn jp ko jm kg kh ki kj bi translated">可调参数</li><li id="2832" class="kb kc hh ir b is kk iw kl jn km jo kn jp ko jm kg kh ki kj bi translated">对Python和R都可用</li><li id="5da2" class="kb kc hh ir b is kk iw kl jn km jo kn jp ko jm kg kh ki kj bi translated">能够轻松模拟任意数量的季节性</li><li id="635b" class="kb kc hh ir b is kk iw kl jn km jo kn jp ko jm kg kh ki kj bi translated">轻松地将假期集成到模型中</li></ul><p id="cd1e" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jn jb jc jd jo jf jg jh jp jj jk jl jm ha bi translated">在本文中，我们将使用FB Prophet模型来预测谷歌的股票价格。</p><h2 id="285e" class="kp kq hh bd kr ks kt ku kv kw kx ky kz jn la lb lc jo ld le lf jp lg lh li lj bi translated">第一步。装置</h2><p id="5d1b" class="pw-post-body-paragraph io ip hh ir b is lk iu iv iw ll iy iz jn lm jc jd jo ln jg jh jp lo jk jl jm ha bi translated">Prophet在<strong class="ir hi"> CRAN </strong>包中，所以你可以使用<strong class="ir hi"> install.packages </strong></p><pre class="js jt ju jv fd lp lq lr ls aw lt bi"><span id="6859" class="kp kq hh lq b fi lu lv l lw lx">install.packages('prophet')</span></pre><p id="5bbf" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jn jb jc jd jo jf jg jh jp jj jk jl jm ha bi translated">Prophet在<strong class="ir hi"> PyPI </strong>上，可以用pip安装。</p><pre class="js jt ju jv fd lp lq lr ls aw lt bi"><span id="7a77" class="kp kq hh lq b fi lu lv l lw lx">pip install pystan==2.19.1.1<br/>pip install prophet</span></pre><p id="787c" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jn jb jc jd jo jf jg jh jp jj jk jl jm ha bi translated">关于安装的更多信息:<a class="ae jq" href="https://facebook.github.io/prophet/docs/installation.html" rel="noopener ugc nofollow" target="_blank"> FB Prophet安装</a>。</p><p id="4c4c" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jn jb jc jd jo jf jg jh jp jj jk jl jm ha bi translated">在本文中，我们将使用Python</p><h2 id="fdb6" class="kp kq hh bd kr ks kt ku kv kw kx ky kz jn la lb lc jo ld le lf jp lg lh li lj bi translated">第二步。导入所需的库</h2><pre class="js jt ju jv fd lp lq lr ls aw lt bi"><span id="0de9" class="kp kq hh lq b fi lu lv l lw lx">import numpy as np<br/>import pandas as pd<br/>import matplotlib.pyplot as plt<br/>from fbprophet import Prophet<br/>import datetime as dt</span><span id="b134" class="kp kq hh lq b fi ly lv l lw lx">from plotly import tools<br/>import chart_studio.plotly as py<br/>import plotly.figure_factory as ff<br/>import plotly.tools as tls<br/>import plotly.graph_objs as go<br/>from plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot<br/>init_notebook_mode(connected=True)<br/>import warnings<br/>warnings.filterwarnings("ignore")</span><span id="a337" class="kp kq hh lq b fi ly lv l lw lx"># plt.style.available<br/>plt.style.use("seaborn-whitegrid")</span></pre><h2 id="abc6" class="kp kq hh bd kr ks kt ku kv kw kx ky kz jn la lb lc jo ld le lf jp lg lh li lj bi translated">第三步。导入数据集</h2><p id="4cbb" class="pw-post-body-paragraph io ip hh ir b is lk iu iv iw ll iy iz jn lm jc jd jo ln jg jh jp lo jk jl jm ha bi translated">数据集由谷歌的股票市场数据组成。并且可以从<a class="ae jq" href="https://finance.yahoo.com/quote/GOOG/history?p=GOOG" rel="noopener ugc nofollow" target="_blank">雅虎财经</a>下载。数据显示了谷歌从2015年1月1日到2020年10月28日的股价。</p><pre class="js jt ju jv fd lp lq lr ls aw lt bi"><span id="8826" class="kp kq hh lq b fi lu lv l lw lx">df = pd.read_csv('GOOG.csv', sep=";")<br/>df.head(8)</span></pre><figure class="js jt ju jv fd ii er es paragraph-image"><div class="er es lz"><img src="../Images/8067eb6d8c0e08d1f58faf905523c915.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*TVLSFFRyiDYV_a_j8I_TwA.png"/></div></figure><h2 id="b5a5" class="kp kq hh bd kr ks kt ku kv kw kx ky kz jn la lb lc jo ld le lf jp lg lh li lj bi translated">第四步。数据预处理</h2><p id="f5d9" class="pw-post-body-paragraph io ip hh ir b is lk iu iv iw ll iy iz jn lm jc jd jo ln jg jh jp lo jk jl jm ha bi translated">将列名从name替换为ticks。</p><pre class="js jt ju jv fd lp lq lr ls aw lt bi"><span id="1586" class="kp kq hh lq b fi lu lv l lw lx">df = df.rename(columns={'Name': 'Ticks'})<br/>google = df.loc[df['Ticks'] == 'GOOGL']</span></pre><figure class="js jt ju jv fd ii er es paragraph-image"><div class="er es ma"><img src="../Images/09452c71d1a0eb82421430e955fb6f32.png" data-original-src="https://miro.medium.com/v2/resize:fit:644/format:webp/1*Btx8rRTMhAAzXBRPS7GwzA.png"/></div></figure><pre class="js jt ju jv fd lp lq lr ls aw lt bi"><span id="eb13" class="kp kq hh lq b fi lu lv l lw lx"><strong class="lq hi"># Create a copy to avoid the SettingWarning .loc issue </strong><br/>google_df = google.copy()<br/><strong class="lq hi"># Change to datetime datatype</strong><br/>google_df.loc[:, 'date'] = pd.to_datetime(google.loc[:,'date'], format="%d/%m/%Y")</span></pre><p id="8511" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jn jb jc jd jo jf jg jh jp jj jk jl jm ha bi translated">分析数据集:</p><figure class="js jt ju jv fd ii er es paragraph-image"><div class="er es mb"><img src="../Images/e860335a2411d6fecfcb03308b4c33e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:752/format:webp/1*Gj52jzNaJ9breIizn4LJsw.png"/></div></figure><h2 id="47dc" class="kp kq hh bd kr ks kt ku kv kw kx ky kz jn la lb lc jo ld le lf jp lg lh li lj bi translated">第五步。使数据集符合“先知”标准</h2><ul class=""><li id="caa8" class="kb kc hh ir b is lk iw ll jn mc jo md jp me jm kg kh ki kj bi translated">Prophet的输入始终是一个包含两列的数据帧:<strong class="ir hi"> ds </strong>和<strong class="ir hi"> y </strong>。</li><li id="d66f" class="kb kc hh ir b is kk iw kl jn km jo kn jp ko jm kg kh ki kj bi translated"><strong class="ir hi"> ds </strong>(日期戳)列应该是Pandas所期望的格式，理想情况下<strong class="ir hi"> YYYY-MM-DD </strong>表示日期，或者<strong class="ir hi"> YYYY-MM-DD HH:MM:SS </strong>表示时间戳。</li><li id="def2" class="kb kc hh ir b is kk iw kl jn km jo kn jp ko jm kg kh ki kj bi translated"><strong class="ir hi"> y </strong>列必须是数字，代表我们希望预测的测量值。</li></ul><p id="5d9f" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jn jb jc jd jo jf jg jh jp jj jk jl jm ha bi translated">在本文中，我们将只使用日期和收盘价作为我们模型的特征。我们将日期重命名为“ds”，将收盘价重命名为“y”。</p><pre class="js jt ju jv fd lp lq lr ls aw lt bi"><span id="14c1" class="kp kq hh lq b fi lu lv l lw lx"><strong class="lq hi"># Drop the columns</strong><br/>ph_df = google_df.drop(['open', 'high', 'low','volume','adj close', 'Ticks'], axis=1)<br/>ph_df.rename(columns={'close': 'y', 'date': 'ds'}, inplace=True)</span><span id="cfc2" class="kp kq hh lq b fi ly lv l lw lx">ph_df.head()</span></pre><figure class="js jt ju jv fd ii er es paragraph-image"><div class="er es mf"><img src="../Images/b4332e56bd3c3993c8d3468830756066.png" data-original-src="https://miro.medium.com/v2/resize:fit:352/format:webp/1*Jzc0tluqNUX7dWzEwC2aWQ.png"/></div></figure><h2 id="d79a" class="kp kq hh bd kr ks kt ku kv kw kx ky kz jn la lb lc jo ld le lf jp lg lh li lj bi translated">第六步。绘制数据集</h2><p id="6ce9" class="pw-post-body-paragraph io ip hh ir b is lk iu iv iw ll iy iz jn lm jc jd jo ln jg jh jp lo jk jl jm ha bi translated">绘制数据集以获得洞察力:</p><pre class="js jt ju jv fd lp lq lr ls aw lt bi"><span id="8abf" class="kp kq hh lq b fi lu lv l lw lx">plt.figure(figsize=(10,6))<br/>plt.plot(ph_df.set_index('ds'))<br/>plt.legend(['Close'])</span></pre><figure class="js jt ju jv fd ii er es paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="er es mg"><img src="../Images/80e04175192a7af0d1c80a4af25aebf0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jJH6E5ljNbpVxQoqQXUlSg.png"/></div></div></figure><h2 id="fd8b" class="kp kq hh bd kr ks kt ku kv kw kx ky kz jn la lb lc jo ld le lf jp lg lh li lj bi translated">第七步。构建预测模型</h2><p id="7dd3" class="pw-post-body-paragraph io ip hh ir b is lk iu iv iw ll iy iz jn lm jc jd jo ln jg jh jp lo jk jl jm ha bi translated">我们通过实例化一个名为m1的新Prophet对象来适应这个模型。</p><pre class="js jt ju jv fd lp lq lr ls aw lt bi"><span id="6d7b" class="kp kq hh lq b fi lu lv l lw lx">m1 = Prophet(daily_seasonality=True)<br/>m1.fit(ph_df)</span></pre><p id="90e5" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jn jb jc jd jo jf jg jh jp jj jk jl jm ha bi translated">我们不会将数据分为训练集和测试集，但我们会使用所有数据来拟合模型。</p><p id="05b1" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jn jb jc jd jo jf jg jh jp jj jk jl jm ha bi translated">我们需要告诉先知未来要预测多远。我们可以使用帮助器方法<strong class="ir hi">prophet . make _ future _ data frame来获得延伸到未来指定天数的合适数据帧。</strong>我们只想预测未来365天的收盘价..</p><p id="d4b2" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jn jb jc jd jo jf jg jh jp jj jk jl jm ha bi translated">预测方法将为未来的每一行分配一个预测值，并将其命名为yhat。这里的预测对象是一个新的dataframe，它包括一个包含预测的列<strong class="ir hi"> yhat </strong>，以及组件和不确定性区间的列。</p><pre class="js jt ju jv fd lp lq lr ls aw lt bi"><span id="b921" class="kp kq hh lq b fi lu lv l lw lx"><strong class="lq hi"># Create Future Dates</strong><br/>future_prices = m1.make_future_dataframe(periods=365)</span><span id="af6c" class="kp kq hh lq b fi ly lv l lw lx"><strong class="lq hi"># Predict Prices<br/></strong>forecast1 = m1.predict(future_prices)<br/>forecast1[['ds', 'yhat', 'yhat_lower', 'yhat_upper']].tail()</span></pre><figure class="js jt ju jv fd ii er es paragraph-image"><div class="er es mh"><img src="../Images/f0176bd9a8510d521c62f3d6eceae057.png" data-original-src="https://miro.medium.com/v2/resize:fit:748/format:webp/1*mroFv_CmyHHpjZl9e54sWQ.png"/></div></figure><h2 id="7ee7" class="kp kq hh bd kr ks kt ku kv kw kx ky kz jn la lb lc jo ld le lf jp lg lh li lj bi translated">第八步。预测的结果</h2><pre class="js jt ju jv fd lp lq lr ls aw lt bi"><span id="9fe2" class="kp kq hh lq b fi lu lv l lw lx">import matplotlib.dates as mdates</span><span id="aefd" class="kp kq hh lq b fi ly lv l lw lx"># Dates<br/>starting_date = dt.datetime(2020, 10, 29)<br/>starting_date1 = mdates.date2num(starting_date)</span><span id="6f1a" class="kp kq hh lq b fi ly lv l lw lx">pointing_arrow = dt.datetime(2020, 10, 29)<br/>pointing_arrow1 = mdates.date2num(pointing_arrow)</span><span id="8df1" class="kp kq hh lq b fi ly lv l lw lx"># Learn more Prophet tomorrow and plot the forecast for amazon.<br/>fig = m1.plot(forecast1)<br/>ax1 = fig.add_subplot(111)<br/>ax1.set_title("Google Stock Price Forecast", fontsize=16)<br/>ax1.set_xlabel("date", fontsize=12)<br/>ax1.set_ylabel("Close Price", fontsize=12)</span><span id="9456" class="kp kq hh lq b fi ly lv l lw lx"># Forecast initialization arrow<br/>ax1.annotate('Forecast \n Initialization', xy=(pointing_arrow1, 1595), xytext=(starting_date1,1700),<br/>            arrowprops=dict(facecolor='#ff7f50', shrink=0.01),<br/>            )</span><span id="8067" class="kp kq hh lq b fi ly lv l lw lx">ax1.axhline(y=1560, color='b', linestyle='-')</span><span id="0d9e" class="kp kq hh lq b fi ly lv l lw lx">plt.show()</span></pre><figure class="js jt ju jv fd ii er es paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="er es mi"><img src="../Images/8f9401329f7e020b4cea0f0172c02367.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*obQQluTFpngfzJAvbjIw1w.png"/></div></div></figure><ul class=""><li id="b224" class="kb kc hh ir b is it iw ix jn kd jo ke jp kf jm kg kh ki kj bi translated"><strong class="ir hi">黑点</strong>:原始数据</li><li id="7738" class="kb kc hh ir b is kk iw kl jn km jo kn jp ko jm kg kh ki kj bi translated"><strong class="ir hi">蓝线</strong>:预测模型</li><li id="ee6a" class="kb kc hh ir b is kk iw kl jn km jo kn jp ko jm kg kh ki kj bi translated"><strong class="ir hi">浅蓝色区域</strong>:置信区间</li></ul><p id="f3cb" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jn jb jc jd jo jf jg jh jp jj jk jl jm ha bi translated">该模型使用所有数据进行训练(黑点)，并预测从2020年10月29日<strong class="ir hi">到2021年</strong>10月28日<strong class="ir hi">的未来股价。</strong></p><p id="53c6" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jn jb jc jd jo jf jg jh jp jj jk jl jm ha bi translated"><strong class="ir hi">结论:</strong>根据模型预测，2021年10月<strong class="ir hi">谷歌股价似乎会在<strong class="ir hi">1800</strong>左右。</strong></p><h2 id="ece4" class="kp kq hh bd kr ks kt ku kv kw kx ky kz jn la lb lc jo ld le lf jp lg lh li lj bi translated">第九步。绘制预测组件</h2><p id="38e8" class="pw-post-body-paragraph io ip hh ir b is lk iu iv iw ll iy iz jn lm jc jd jo ln jg jh jp lo jk jl jm ha bi translated">如果我们想要查看预测组件，我们可以使用<strong class="ir hi">prophet . plot _ components</strong>方法。默认情况下，我们将看到时间序列的<strong class="ir hi">趋势</strong>、<strong class="ir hi">年度</strong>季节性和<strong class="ir hi">每周</strong>季节性。</p><pre class="js jt ju jv fd lp lq lr ls aw lt bi"><span id="4f0c" class="kp kq hh lq b fi lu lv l lw lx">m1.plot_components(forecast1);</span></pre><figure class="js jt ju jv fd ii er es paragraph-image"><div class="er es mj"><img src="../Images/78a83839bf9acbc2abdaaafa7672abd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*Y2PFEFM4FEzPfHQXk62cpQ.png"/></div></figure><p id="a0a9" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jn jb jc jd jo jf jg jh jp jj jk jl jm ha bi translated">根据估计的趋势，我们可以看到，通常股票价格在1月中旬的<strong class="ir hi">和周日的</strong>最高。趋势图显示股票价格在不久的将来会上涨。</p><h2 id="e3e4" class="kp kq hh bd kr ks kt ku kv kw kx ky kz jn la lb lc jo ld le lf jp lg lh li lj bi translated">第十步。添加节日效果</h2><p id="ea9a" class="pw-post-body-paragraph io ip hh ir b is lk iu iv iw ll iy iz jn lm jc jd jo ln jg jh jp lo jk jl jm ha bi translated">Prophet提供了将这些节假日或特殊事件引起的波动包括在预测模型中的能力。节假日和事件会导致时间序列发生变化。我们可以通过创建一个包含两列<strong class="ir hi"> ds </strong>和<strong class="ir hi"> holiday的dataframe来为Prophet创建一个定制的假日列表。</strong></p><p id="73a9" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jn jb jc jd jo jf jg jh jp jj jk jl jm ha bi translated">我们将定义一个假日数据帧，其中包含<strong class="ir hi">日期</strong>和<strong class="ir hi">假日描述</strong>(在本文中，例如我们只包括耶稣升天日和圣诞节)<strong class="ir hi">。</strong></p><p id="df19" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jn jb jc jd jo jf jg jh jp jj jk jl jm ha bi translated">“假日”下部窗口和上部窗口的每个事件对应一行，将假日延长到日期前后的天。</p><pre class="js jt ju jv fd lp lq lr ls aw lt bi"><span id="f252" class="kp kq hh lq b fi lu lv l lw lx">ascensionday = pd.DataFrame({<br/>  'holiday': 'AscensionDay',<br/>  'ds': pd.to_datetime(['2015-05-14','2016-05-05','2017-05-25','2018-05-10','2019-05-30','2020-05-21']),<br/>  'lower_window': 0,<br/>  'upper_window': 1,<br/>})</span><span id="a582" class="kp kq hh lq b fi ly lv l lw lx">christmas = pd.DataFrame({<br/>  'holiday': 'Christmas',<br/>  'ds': pd.to_datetime(['2015-12-25','2016-12-25','2017-12-25','2018-12-25','2019-12-25','2020-12-25']),<br/>  'lower_window': -1,<br/>  'upper_window': 7,<br/>})</span><span id="be4b" class="kp kq hh lq b fi ly lv l lw lx">new_holidays = pd.concat((ascensionday, christmas))<br/>new_holidays.head()</span></pre><figure class="js jt ju jv fd ii er es paragraph-image"><div class="er es mk"><img src="../Images/71b9b89418713776eab19b19e0d68d7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:754/format:webp/1*4Oz_CUWJnt5GWL412j3smA.png"/></div></figure><p id="a3fb" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jn jb jc jd jo jf jg jh jp jj jk jl jm ha bi translated"><strong class="ir hi">做出预测</strong></p><p id="9272" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jn jb jc jd jo jf jg jh jp jj jk jl jm ha bi translated">一旦创建了数据帧，就可以通过传递<strong class="ir hi"> holidays = </strong>参数来包含假日效果。并且对于预测步骤保持与上面相同:</p><pre class="js jt ju jv fd lp lq lr ls aw lt bi"><span id="fa65" class="kp kq hh lq b fi lu lv l lw lx">m2 = Prophet(holidays=new_holidays,daily_seasonality=True).fit(ph_df)<br/>future2 = m2.make_future_dataframe(periods=365)<br/>forecast2 = m2.predict(future2)<br/>m2.plot(forecast2);</span></pre><figure class="js jt ju jv fd ii er es paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="er es ml"><img src="../Images/a8edd762254ccfebf084521794ad9359.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tTDCseC3CZsvvL3p0itTBQ.png"/></div></div></figure><p id="8dc9" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jn jb jc jd jo jf jg jh jp jj jk jl jm ha bi translated"><strong class="ir hi">预测组件</strong></p><figure class="js jt ju jv fd ii er es paragraph-image"><div class="er es mj"><img src="../Images/644b12d293fcfb9735f4e37aba1f4809.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*T3noGbVyokfuH317HJtd4A.png"/></div></figure><h2 id="c53a" class="kp kq hh bd kr ks kt ku kv kw kx ky kz jn la lb lc jo ld le lf jp lg lh li lj bi translated">第十一步。向Prophet添加变化点(附加)</h2><ul class=""><li id="356a" class="kb kc hh ir b is lk iw ll jn mc jo md jp me jm kg kh ki kj bi translated">变点是时间序列在轨迹中出现<strong class="ir hi">突变</strong>的日期时间点。</li><li id="0e4b" class="kb kc hh ir b is kk iw kl jn km jo kn jp ko jm kg kh ki kj bi translated">默认情况下，Prophet将<strong class="ir hi"> 25个变点</strong>添加到数据集的<strong class="ir hi">初始80% </strong>中。</li><li id="3f59" class="kb kc hh ir b is kk iw kl jn km jo kn jp ko jm kg kh ki kj bi translated">使用<strong class="ir hi">add _ change points _ to _ plot</strong>功能添加红线，垂直虚线是趋势发生变化的预测点，红色实线是去除所有季节性的趋势。</li></ul><pre class="js jt ju jv fd lp lq lr ls aw lt bi"><span id="bc09" class="kp kq hh lq b fi lu lv l lw lx">from fbprophet.plot import add_changepoints_to_plot<br/>fig = m2.plot(forecast2)<br/>a = add_changepoints_to_plot(fig.gca(), m2, forecast2)</span></pre><figure class="js jt ju jv fd ii er es paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="er es ml"><img src="../Images/73f72cab84ac5bab885afab25c494f3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*svvSedqo1nO9X_amUfBSnQ.png"/></div></div></figure><p id="8acb" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jn jb jc jd jo jf jg jh jp jj jk jl jm ha bi translated">我们可以查看变更点发生的日期:</p><figure class="js jt ju jv fd ii er es paragraph-image"><div class="er es mm"><img src="../Images/260541e2cb0fecd9347c271d4b5fe054.png" data-original-src="https://miro.medium.com/v2/resize:fit:326/format:webp/1*FE-SibL8MMA21lqaa99efA.png"/></div></figure><h2 id="42e3" class="kp kq hh bd kr ks kt ku kv kw kx ky kz jn la lb lc jo ld le lf jp lg lh li lj bi translated">第十二步。性能指标</h2><ul class=""><li id="464b" class="kb kc hh ir b is lk iw ll jn mc jo md jp me jm kg kh ki kj bi translated">使用<strong class="ir hi"> cross_validation函数</strong>可以在一系列历史临界值内自动完成交叉验证程序。我们指定预测范围(horizon)，然后可选地指定初始训练期的大小(initial)和截止日期之间的间隔(period)。默认情况下，初始训练周期设置为三倍范围，每半个范围进行一次截止。</li><li id="562c" class="kb kc hh ir b is kk iw kl jn km jo kn jp ko jm kg kh ki kj bi translated">cross_validation的输出可以用来计算yhat与y的误差度量。</li><li id="6958" class="kb kc hh ir b is kk iw kl jn km jo kn jp ko jm kg kh ki kj bi translated">performance_metrics实用程序可用于计算一些有用的预测性能统计数据(与y相比的yhat、yhat_lower和yhat_upper ),作为距截止点的距离的函数。</li></ul><pre class="js jt ju jv fd lp lq lr ls aw lt bi"><span id="f37b" class="kp kq hh lq b fi lu lv l lw lx">from fbprophet.diagnostics import cross_validation<br/>from fbprophet.diagnostics import performance_metrics<br/>from fbprophet.plot import plot_cross_validation_metric<br/>ph_df_cv = cross_validation(m2, initial='380 days', period='90 days', horizon = '60 days')<br/>ph_df_cv.head()</span></pre><figure class="js jt ju jv fd ii er es paragraph-image"><div class="er es mn"><img src="../Images/de119748b2aadf95d29b329f0d013ff4.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/format:webp/1*BM07ip95MCJlW2NsFEnbDQ.png"/></div></figure><pre class="js jt ju jv fd lp lq lr ls aw lt bi"><span id="2fdd" class="kp kq hh lq b fi lu lv l lw lx">ph_df_p = performance_metrics(ph_df_cv)<br/>ph_df_p.head()</span></pre><figure class="js jt ju jv fd ii er es paragraph-image"><div class="er es mo"><img src="../Images/9a55f8bdcdb1e85b9b135f2fde30b7c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/1*c6OSgOgRwgpGN4Fd_TrDyg.png"/></div></figure><p id="e19b" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jn jb jc jd jo jf jg jh jp jj jk jl jm ha bi translated">关于每种方法可用选项的更多细节可在文档字符串中获得，例如，通过<strong class="ir hi">帮助(Prophet) </strong>或<strong class="ir hi">帮助(Prophet.fit)。</strong></p><h1 id="84ba" class="mp kq hh bd kr mq mr ms kv mt mu mv kz mw mx my lc mz na nb lf nc nd ne li nf bi translated">参考资料:</h1><div class="ng nh ez fb ni nj"><a href="https://facebook.github.io/prophet/" rel="noopener  ugc nofollow" target="_blank"><div class="nk ab dw"><div class="nl ab nm cl cj nn"><h2 class="bd hi fi z dy no ea eb np ed ef hg bi translated">先知</h2><div class="nq l"><h3 class="bd b fi z dy no ea eb np ed ef dx translated">Prophet是一个用R和Python实现的预测程序。它速度很快，并提供完全自动化的预测…</h3></div><div class="nr l"><p class="bd b fp z dy no ea eb np ed ef dx translated">facebook.github.io</p></div></div><div class="ns l"><div class="nt l nu nv nw ns nx ij nj"/></div></div></a></div><div class="ng nh ez fb ni nj"><a href="https://github.com/raffg/prophet_forecasting" rel="noopener  ugc nofollow" target="_blank"><div class="nk ab dw"><div class="nl ab nm cl cj nn"><h2 class="bd hi fi z dy no ea eb np ed ef hg bi translated">raffg/prophet _预测</h2><div class="nq l"><h3 class="bd b fi z dy no ea eb np ed ef dx translated">这些是我关于先知的博文的支持笔记本…</h3></div><div class="nr l"><p class="bd b fp z dy no ea eb np ed ef dx translated">github.com</p></div></div><div class="ns l"><div class="ny l nu nv nw ns nx ij nj"/></div></div></a></div><div class="ng nh ez fb ni nj"><a href="https://towardsdatascience.com/predicting-the-future-with-facebook-s-prophet-bdfe11af10ff" rel="noopener follow" target="_blank"><div class="nk ab dw"><div class="nl ab nm cl cj nn"><h2 class="bd hi fi z dy no ea eb np ed ef hg bi translated">用脸书的先知预测“未来”</h2><div class="nq l"><h3 class="bd b fi z dy no ea eb np ed ef dx translated">利用脸书先知图书馆预测媒体的未来“观点”</h3></div><div class="nr l"><p class="bd b fp z dy no ea eb np ed ef dx translated">towardsdatascience.com</p></div></div><div class="ns l"><div class="nz l nu nv nw ns nx ij nj"/></div></div></a></div><div class="ng nh ez fb ni nj"><a href="https://towardsdatascience.com/forecasting-in-python-with-facebook-prophet-29810eb57e66" rel="noopener follow" target="_blank"><div class="nk ab dw"><div class="nl ab nm cl cj nn"><h2 class="bd hi fi z dy no ea eb np ed ef hg bi translated">用Python预测脸书预言家</h2><div class="nq l"><h3 class="bd b fi z dy no ea eb np ed ef dx translated">如何使用领域知识调整和优化Prophet，以便更好地控制您的预测。</h3></div><div class="nr l"><p class="bd b fp z dy no ea eb np ed ef dx translated">towardsdatascience.com</p></div></div><div class="ns l"><div class="oa l nu nv nw ns nx ij nj"/></div></div></a></div><div class="ng nh ez fb ni nj"><a href="https://towardsdatascience.com/time-series-forecasting-predicting-stock-prices-using-facebooks-prophet-model-9ee1657132b5" rel="noopener follow" target="_blank"><div class="nk ab dw"><div class="nl ab nm cl cj nn"><h2 class="bd hi fi z dy no ea eb np ed ef hg bi translated">时间序列预测:用脸书的先知模型预测股票价格</h2><div class="nq l"><h3 class="bd b fi z dy no ea eb np ed ef dx translated">使用可从《先知脸书》公开获得的预测模型预测股票价格</h3></div><div class="nr l"><p class="bd b fp z dy no ea eb np ed ef dx translated">towardsdatascience.com</p></div></div><div class="ns l"><div class="ob l nu nv nw ns nx ij nj"/></div></div></a></div><div class="ng nh ez fb ni nj"><a href="https://towardsdatascience.com/time-series-prediction-using-prophet-in-python-35d65f626236" rel="noopener follow" target="_blank"><div class="nk ab dw"><div class="nl ab nm cl cj nn"><h2 class="bd hi fi z dy no ea eb np ed ef hg bi translated">Python中使用Prophet进行时间序列预测</h2><div class="nq l"><h3 class="bd b fi z dy no ea eb np ed ef dx translated">在本帖中，我们将探索facebook的时间序列模型Prophet。我们会明白什么是先知，它是…</h3></div><div class="nr l"><p class="bd b fp z dy no ea eb np ed ef dx translated">towardsdatascience.com</p></div></div><div class="ns l"><div class="oc l nu nv nw ns nx ij nj"/></div></div></a></div></div></div>    
</body>
</html>