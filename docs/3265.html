<html>
<head>
<title>Introduction to NumPy : 5 Extremely Useful Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NumPy简介:5个非常有用的函数</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/introduction-to-numpy-5-extremely-useful-functions-798a65368df?source=collection_archive---------2-----------------------#2022-08-12">https://medium.com/mlearning-ai/introduction-to-numpy-5-extremely-useful-functions-798a65368df?source=collection_archive---------2-----------------------#2022-08-12</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="8c89" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">纠结数字？让NumPy解决问题。</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/8e863b4adacc19b8a94a8eb1be0bfe29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XLMfREdabo9laoYx"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx">Photo by <a class="ae jm" href="https://unsplash.com/@takeshi2?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">wu yi</a> on <a class="ae jm" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="55b8" class="jn jo hh bd jp jq jr js jt ju jv jw jx in jy io jz iq ka ir kb it kc iu kd ke bi translated">介绍</h1><p id="b00d" class="pw-post-body-paragraph kf kg hh kh b ki kj ii kk kl km il kn ko kp kq kr ks kt ku kv kw kx ky kz la ha bi translated">NumPy是为科学计算开发的python包。它使用各种数学公式，涉及数学的子领域，如线性代数，统计等。关于NumPy，有两个基本事实是大多数数据科学和机器学习社区的人不知道的；</p><ol class=""><li id="85b5" class="lb lc hh kh b ki ld kl le ko lf ks lg kw lh la li lj lk ll bi translated">NumPy让<strong class="kh hi"> Python </strong>极速<strong class="kh hi"/>。</li><li id="9a76" class="lb lc hh kh b ki lm kl ln ko lo ks lp kw lq la li lj lk ll bi translated">如果你是数据科学家或者机器学习科学家，大多数时候你<strong class="kh hi">不会直接和NumPy一起工作。</strong></li></ol><p id="4a0d" class="pw-post-body-paragraph kf kg hh kh b ki ld ii kk kl le il kn ko lr kq kr ks ls ku kv kw lt ky kz la ha bi translated">嗯，你可能会问“为什么？”</p><p id="f1dc" class="pw-post-body-paragraph kf kg hh kh b ki ld ii kk kl le il kn ko lr kq kr ks ls ku kv kw lt ky kz la ha bi translated"><strong class="kh hi"> NumPy数组比Python列表快，因为:</strong></p><ul class=""><li id="1511" class="lb lc hh kh b ki ld kl le ko lf ks lg kw lh la lu lj lk ll bi translated">首先，数组是存储在连续内存块中的同类数据类型的集合。相反，Python中的列表是存储在非连续内存块中的<em class="lv">异构</em>数据类型的集合。</li><li id="3013" class="lb lc hh kh b ki lm kl ln ko lo ks lp kw lq la lu lj lk ll bi translated">第二，NumPy包将一个任务分解成多个片段，然后并行处理所有的片段<em class="lv"/>。</li><li id="15ad" class="lb lc hh kh b ki lm kl ln ko lo ks lp kw lq la lu lj lk ll bi translated">最后但同样重要的是，NumPy包集成了Python中的<em class="lv"> C、C++和Fortran </em>代码。因为这些编程语言是低级的<em class="lv">(它们没有自动内存管理)，</em>与Python相比，它们的执行时间非常少。</li></ul><p id="ec76" class="pw-post-body-paragraph kf kg hh kh b ki ld ii kk kl le il kn ko lr kq kr ks ls ku kv kw lt ky kz la ha bi translated">请参见下面的示例，我在其中展示了Python list和NumPy array之间的执行时间比较；</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lw"><img src="../Images/01ce53087d61631fee9e7054111ff94b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SXzimy3dfddL-Ogqgkhe7A.png"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx">NumPy — C++ — Python Comparison</figcaption></figure></div><div class="ab cl lx ly go lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ha hb hc hd he"><p id="2169" class="pw-post-body-paragraph kf kg hh kh b ki ld ii kk kl le il kn ko lr kq kr ks ls ku kv kw lt ky kz la ha bi translated"><strong class="kh hi"> <em class="lv">“我们为什么要和NumPy间接合作？”</em> </strong></p><p id="7293" class="pw-post-body-paragraph kf kg hh kh b ki ld ii kk kl le il kn ko lr kq kr ks ls ku kv kw lt ky kz la ha bi translated">除非你是在练习应用数学或统计学，否则你需要将表格可视化并用<a class="ae jm" href="https://pandas.pydata.org" rel="noopener ugc nofollow" target="_blank"><strong class="kh hi"><em class="lv">Pandas</em></strong></a>软件包处理你的数据。为了执行必要的数据预处理，这是您必须遵循的程序。<strong class="kh hi"> <em class="lv"> Pandas </em> </strong>定义为在Python中提供高性能数据操作的开源库。</p><blockquote class="me mf mg"><p id="d2d6" class="kf kg lv kh b ki ld ii kk kl le il kn mh lr kq kr mi ls ku kv mj lt ky kz la ha bi translated">它建立在<strong class="kh hi"> NumPy </strong>包之上，这意味着<strong class="kh hi"> Numpy是操作熊猫</strong>所必需的。熊猫的名字来源于Panel Data这个词，意思是来自多维数据的一种计量经济学。</p></blockquote><h1 id="0a82" class="jn jo hh bd jp jq jr js jt ju jv jw jx in jy io jz iq ka ir kb it kc iu kd ke bi translated">有用的数字函数</h1><pre class="ix iy iz ja fd mk ml mm mn aw mo bi"><span id="958c" class="mp jo hh ml b fi mq mr l ms mt">import numpy as np</span></pre><h1 id="b4dd" class="jn jo hh bd jp jq jr js jt ju jv jw jx in jy io jz iq ka ir kb it kc iu kd ke bi translated"><strong class="ak"> <em class="mu"> 1。np.argmax() </em> </strong></h1><p id="39c3" class="pw-post-body-paragraph kf kg hh kh b ki kj ii kk kl km il kn ko kp kq kr ks kt ku kv kw kx ky kz la ha bi translated">返回轴上最大值的索引。当您键入<strong class="kh hi"> <em class="lv"> np.argmax() </em> </strong>时，按SHIFT+TAB查看docstring。</p><p id="5cd7" class="pw-post-body-paragraph kf kg hh kh b ki ld ii kk kl le il kn ko lr kq kr ks ls ku kv kw lt ky kz la ha bi translated">示例:</p><p id="8aed" class="pw-post-body-paragraph kf kg hh kh b ki ld ii kk kl le il kn ko lr kq kr ks ls ku kv kw lt ky kz la ha bi translated">我们正在创建一个2D数组，首先找到数组的<strong class="kh hi"> <em class="lv"> argmax() </em> </strong>。</p><pre class="ix iy iz ja fd mk ml mm mn aw mo bi"><span id="3bcb" class="mp jo hh ml b fi mq mr l ms mt">a = np.arange(6).reshape(2,3) + 10<br/>a</span></pre><p id="f7fe" class="pw-post-body-paragraph kf kg hh kh b ki ld ii kk kl le il kn ko lr kq kr ks ls ku kv kw lt ky kz la ha bi translated">输出如下所示:</p><pre class="ix iy iz ja fd mk ml mm mn aw mo bi"><span id="cdcf" class="mp jo hh ml b fi mq mr l ms mt">array([[10, 11, 12],<br/>       [13, 14, 15]])</span></pre><p id="38e4" class="pw-post-body-paragraph kf kg hh kh b ki ld ii kk kl le il kn ko lr kq kr ks ls ku kv kw lt ky kz la ha bi translated">如果我们将数组<em class="lv"> a </em>作为参数传入<strong class="kh hi"> <em class="lv"> np.argmax() </em> </strong>，我们将得到这个输出:</p><pre class="ix iy iz ja fd mk ml mm mn aw mo bi"><span id="ddd0" class="mp jo hh ml b fi mq mr l ms mt">np.argmax(a)<br/>Output: 5</span></pre><h1 id="7841" class="jn jo hh bd jp jq jr js jt ju jv jw jx in jy io jz iq ka ir kb it kc iu kd ke bi translated">2.np.tensordot()</h1><p id="24bd" class="pw-post-body-paragraph kf kg hh kh b ki kj ii kk kl km il kn ko kp kq kr ks kt ku kv kw kx ky kz la ha bi translated">计算沿指定轴的张量点积。如果您打开docstring，您可以看到这个例子；</p><blockquote class="me mf mg"><p id="9016" class="kf kg lv kh b ki ld ii kk kl le il kn mh lr kq kr mi ls ku kv mj lt ky kz la ha bi translated">给定两个张量a和b，以及一个包含两个array _ objects的array _ objects，`(a _ axes，b _ axes)`，将<br/> a和b元素(成分)在<br/>` a _ axis '和` b _ axes '指定的轴上的乘积相加。第三个参数可以是一个非负的<br/>整数类标量“n ”;如果是这样，那么“a”的最后“n”个维度<br/>和“b”的第一个“n”个维度相加。</p></blockquote><pre class="ix iy iz ja fd mk ml mm mn aw mo bi"><span id="c7eb" class="mp jo hh ml b fi mq mr l ms mt">a = np.arange(60.).reshape(3,4,5)<br/>&gt;&gt;&gt; b = np.arange(24.).reshape(4,3,2)<br/>&gt;&gt;&gt; c = np.tensordot(a,b, axes=([1,0],[0,1]))<br/>&gt;&gt;&gt; c.shape<br/>(5, 2)<br/>&gt;&gt;&gt; c<br/>array([[4400., 4730.],<br/>       [4532., 4874.],<br/>       [4664., 5018.],<br/>       [4796., 5162.],<br/>       [4928., 5306.]])<br/>&gt;&gt;&gt; # A slower but equivalent way of computing the same...<br/>&gt;&gt;&gt; d = np.zeros((5,2))<br/>&gt;&gt;&gt; for i in range(5):<br/>...   for j in range(2):<br/>...     for k in range(3):<br/>...       for n in range(4):<br/>...         d[i,j] += a[k,n,i] * b[n,k,j]<br/>&gt;&gt;&gt; c == d<br/>Output: array([[ True,  True],<br/>       [ True,  True],<br/>       [ True,  True],<br/>       [ True,  True],<br/>       [ True,  True]])<br/><br/>An extended example taking advantage of the overloading of + and \*:<br/><br/>&gt;&gt;&gt; a = np.array(range(1, 9))<br/>&gt;&gt;&gt; a.shape = (2, 2, 2)<br/>&gt;&gt;&gt; A = np.array(('a', 'b', 'c', 'd'), dtype=object)<br/>&gt;&gt;&gt; A.shape = (2, 2)<br/>&gt;&gt;&gt; a; A<br/>Output: array([[[1, 2],<br/>        [3, 4]],<br/>       [[5, 6],<br/>        [7, 8]]])<br/>array([['a', 'b'],<br/>       ['c', 'd']], dtype=object)<br/><br/>&gt;&gt;&gt; np.tensordot(a, A) # third argument default is 2 for double-contraction<br/>Output: array(['abbcccdddd', 'aaaaabbbbbbcccccccdddddddd'], dtype=object)<br/><br/>&gt;&gt;&gt; np.tensordot(a, A, 1)<br/>Output: array([[['acc', 'bdd'],<br/>        ['aaacccc', 'bbbdddd']],<br/>       [['aaaaacccccc', 'bbbbbdddddd'],<br/>        ['aaaaaaacccccccc', 'bbbbbbbdddddddd']]], dtype=object)<br/><br/>&gt;&gt;&gt; np.tensordot(a, A, 0) # tensor product (result too long to incl.)<br/>Output: array([[[[['a', 'b'],<br/>          ['c', 'd']],<br/>          ...<br/><br/>&gt;&gt;&gt; np.tensordot(a, A, (0, 1))<br/>Output: array([[['abbbbb', 'cddddd'],<br/>        ['aabbbbbb', 'ccdddddd']],<br/>       [['aaabbbbbbb', 'cccddddddd'],<br/>        ['aaaabbbbbbbb', 'ccccdddddddd']]], dtype=object)<br/><br/>&gt;&gt;&gt; np.tensordot(a, A, (2, 1))<br/>Output: array([[['abb', 'cdd'],<br/>        ['aaabbbb', 'cccdddd']],<br/>       [['aaaaabbbbbb', 'cccccdddddd'],<br/>        ['aaaaaaabbbbbbbb', 'cccccccdddddddd']]], dtype=object)<br/><br/>&gt;&gt;&gt; np.tensordot(a, A, ((0, 1), (0, 1)))</span><span id="b430" class="mp jo hh ml b fi mv mr l ms mt">Output: array(['abbbcccccddddddd', 'aabbbbccccccdddddddd'], dtype=object)<br/><br/>&gt;&gt;&gt; np.tensordot(a, A, ((2, 1), (1, 0)))</span><span id="608f" class="mp jo hh ml b fi mv mr l ms mt">Output: array(['acccbbdddd', 'aaaaacccccccbbbbbbdddddddd'], dtype=object)</span></pre><h1 id="8cad" class="jn jo hh bd jp jq jr js jt ju jv jw jx in jy io jz iq ka ir kb it kc iu kd ke bi translated">3.np .分位数()</h1><p id="a521" class="pw-post-body-paragraph kf kg hh kh b ki kj ii kk kl km il kn ko kp kq kr ks kt ku kv kw kx ky kz la ha bi translated">沿着指定的轴计算数据的第q个分位数。</p><pre class="ix iy iz ja fd mk ml mm mn aw mo bi"><span id="a430" class="mp jo hh ml b fi mq mr l ms mt">&gt;&gt;&gt; a = np.array([[10, 7, 4], [3, 2, 1]])<br/>&gt;&gt;&gt; a<br/>Output: array([[10,  7,  4],<br/>       [ 3,  2,  1]])<br/>&gt;&gt;&gt; np.quantile(a, 0.5)<br/>3.5<br/>&gt;&gt;&gt; np.quantile(a, 0.5, axis=0)<br/>Output: array([6.5, 4.5, 2.5])<br/>&gt;&gt;&gt; np.quantile(a, 0.5, axis=1)<br/>Output: array([7.,  2.])<br/>&gt;&gt;&gt; np.quantile(a, 0.5, axis=1, keepdims=True)<br/>Output: array([[7.],<br/>       [2.]])<br/>&gt;&gt;&gt; m = np.quantile(a, 0.5, axis=0)<br/>&gt;&gt;&gt; out = np.zeros_like(m)<br/>&gt;&gt;&gt; np.quantile(a, 0.5, axis=0, out=out)<br/>Output: array([6.5, 4.5, 2.5])<br/>&gt;&gt;&gt; m<br/>Output: array([6.5, 4.5, 2.5])<br/>&gt;&gt;&gt; b = a.copy()<br/>&gt;&gt;&gt; np.quantile(b, 0.5, axis=1, overwrite_input=True)<br/>Output: array([7.,  2.])</span></pre><h1 id="ab03" class="jn jo hh bd jp jq jr js jt ju jv jw jx in jy io jz iq ka ir kb it kc iu kd ke bi translated">4.np.std()</h1><p id="58a2" class="pw-post-body-paragraph kf kg hh kh b ki kj ii kk kl km il kn ko kp kq kr ks kt ku kv kw kx ky kz la ha bi translated">计算沿指定轴的标准偏差。返回数组元素的<em class="lv">标准偏差</em>，一种分布范围的度量。默认情况下，<em class="lv">标准差</em>是为<br/>展平数组计算的，否则会超过指定的轴。</p><p id="1f7a" class="pw-post-body-paragraph kf kg hh kh b ki ld ii kk kl le il kn ko lr kq kr ks ls ku kv kw lt ky kz la ha bi translated">示例:</p><pre class="ix iy iz ja fd mk ml mm mn aw mo bi"><span id="77e6" class="mp jo hh ml b fi mq mr l ms mt">&gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])<br/>&gt;&gt;&gt; np.std(a)<br/>Output: 1.1180339887498949 # may vary<br/>&gt;&gt;&gt; np.std(a, axis=0)<br/>Output: array([1.,  1.])<br/>&gt;&gt;&gt; np.std(a, axis=1)<br/>Output: array([0.5,  0.5])</span></pre><h1 id="06f5" class="jn jo hh bd jp jq jr js jt ju jv jw jx in jy io jz iq ka ir kb it kc iu kd ke bi translated">5.np .中位值()</h1><p id="7437" class="pw-post-body-paragraph kf kg hh kh b ki kj ii kk kl km il kn ko kp kq kr ks kt ku kv kw kx ky kz la ha bi translated">计算沿指定轴的中位值。返回数组元素的中值。</p><pre class="ix iy iz ja fd mk ml mm mn aw mo bi"><span id="5893" class="mp jo hh ml b fi mq mr l ms mt">&gt;&gt;&gt; a = np.array([[10, 7, 4], [3, 2, 1]])<br/>&gt;&gt;&gt; a<br/>Output: array([[10,  7,  4],<br/>       [ 3,  2,  1]])<br/>&gt;&gt;&gt; np.median(a)<br/>3.5<br/>&gt;&gt;&gt; np.median(a, axis=0)<br/>Output: array([6.5, 4.5, 2.5])<br/>&gt;&gt;&gt; np.median(a, axis=1)<br/>Output: array([7.,  2.])<br/>&gt;&gt;&gt; m = np.median(a, axis=0)<br/>&gt;&gt;&gt; out = np.zeros_like(m)<br/>&gt;&gt;&gt; np.median(a, axis=0, out=m)<br/>Output: array([6.5,  4.5,  2.5])<br/>&gt;&gt;&gt; m<br/>Output: array([6.5,  4.5,  2.5])<br/>&gt;&gt;&gt; b = a.copy()<br/>&gt;&gt;&gt; np.median(b, axis=1, overwrite_input=True)<br/>Output: array([7.,  2.])<br/>&gt;&gt;&gt; assert not np.all(a==b)<br/>&gt;&gt;&gt; b = a.copy()<br/>&gt;&gt;&gt; np.median(b, axis=None, overwrite_input=True)<br/>3.5</span></pre><div class="mw mx ez fb my mz"><a rel="noopener follow" target="_blank" href="/mlearning-ai/mlearning-ai-submission-suggestions-b51e2b130bfb"><div class="na ab dw"><div class="nb ab nc cl cj nd"><h2 class="bd hi fi z dy ne ea eb nf ed ef hg bi translated">Mlearning.ai提交建议</h2><div class="ng l"><h3 class="bd b fi z dy ne ea eb nf ed ef dx translated">如何成为移动人工智能的作者</h3></div><div class="nh l"><p class="bd b fp z dy ne ea eb nf ed ef dx translated">medium.com</p></div></div><div class="ni l"><div class="nj l nk nl nm ni nn jg mz"/></div></div></a></div></div></div>    
</body>
</html>