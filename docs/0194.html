<html>
<head>
<title>SHAP Force Plots for Classification</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用于分类的SHAP力图</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/shap-force-plots-for-classification-d30be430e195?source=collection_archive---------0-----------------------#2021-03-02">https://medium.com/mlearning-ai/shap-force-plots-for-classification-d30be430e195?source=collection_archive---------0-----------------------#2021-03-02</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="bafc" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">如何将SHAP力图函数化用于二元和多类分类</h2></div><p id="7ee3" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在这篇文章中，我将介绍两个函数:一个用于绘制二元分类问题的SHAP力图，另一个用于多类分类问题。</p><p id="5936" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">此时你可能会想“好吧，但是已经有一个<code class="du js jt ju jv b">shap.force_plot()</code>函数了，那么我们在这里做什么呢？”是的，从技术上讲你是正确的。<strong class="iy hi">但是</strong>我见过的几乎所有SHAP力图的例子都是针对连续或二元目标的。你实际上可以为多类目标制作力场图，只需要一点额外的挖掘。我的目标是帮助您进行挖掘，以便您得到一个额外可解释的输出。毕竟，这就是SHAP的全部:<a class="ae jw" rel="noopener" href="/@gabrieltseng/interpreting-complex-models-with-shap-values-1c187db6ec83">让复杂的“黑盒”模型更容易理解</a>。</p><figure class="jy jz ka kb fd kc er es paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="er es jx"><img src="../Images/ae5e9d94cffdf159967b7a8f1545f6f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kewz0xLvwocuc8INzphzmA.jpeg"/></div></div><figcaption class="kj kk et er es kl km bd b be z dx">Photo by <a class="ae jw" href="https://unsplash.com/@emilymorter?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Emily Morter</a> on <a class="ae jw" href="https://unsplash.com/s/photos/why?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="b14e" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我不打算花太多时间来谈论或解释什么是SHAP(SHapley Additive explaints ),因为有很多很棒的资源已经这样做了。如果你想了解更多关于Shapley values和SHAP的信息，我强烈推荐从这里开始<a class="ae jw" href="https://towardsdatascience.com/explain-your-model-with-the-shap-values-bc36aac4de3d" rel="noopener" target="_blank"/>。这击中了亮点，你会看到你可以用<a class="ae jw" href="https://github.com/slundberg/shap" rel="noopener ugc nofollow" target="_blank"> SHAP Python库</a>制作的各种各样的酷情节，锤打一个日志的故事是一个奇怪但有效的视觉理解Shapley值试图告诉我们什么。</p><p id="58b6" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">总结<strong class="iy hi"> <em class="kn">非常</em> </strong>简单来说，Shapley值给了我们一个评估一个预测因子相对于其他预测因子重要性的度量。本质上，这些值考虑了损失函数(模型误差)如何受到已知和未知预测特征的影响。这些值还指示预测特征和目标变量之间关系的方向(正或负)。</p><p id="2ecd" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">SHAP库为计算和可视化这些值提供了简单易用的工具。要启动并运行库<code class="du js jt ju jv b">pip install shap</code>，那么:</p><figure class="jy jz ka kb fd kc"><div class="bz dy l di"><div class="ko kp l"/></div></figure><p id="0f04" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">一旦你成功地导入了SHAP，你可以生成的可视化效果之一就是力图。如下图所示，力图可让您了解要素如何影响特定观测的模型预测。这非常适合向某人解释你的模型是如何得出它对特定观察的预测的。</p><figure class="jy jz ka kb fd kc er es paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="er es kq"><img src="../Images/7884f7d08caf74fb9280bfaf63c999d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XWtyM0-bqrm35ViIcmPnlQ.png"/></div></div></figure><p id="a2e4" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我在这篇文章中举的例子来自我参与的一个项目，该项目预测一名注册选民是否会在2020年大选中投票。二元目标是“是”,他们投了票(投票= 1 ),或者“否”,他们没有投(没有投票= 0)。在上面的图中，粗体的<strong class="iy hi"> 0.80 </strong>是模型在这次观察中的得分。较高的分数导致模型预测1，而较低的分数导致模型预测0。对本次观察进行预测很重要的要素以红色和蓝色显示，红色表示将模型得分推高的要素，蓝色表示将得分推低的要素。对分数影响较大的要素位于红色和蓝色之间的分界线附近，影响的大小由条形的大小表示。</p><p id="03f6" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">因此，这个特定的人最终被归类为Vote (1)，因为他们被红色显示的所有因素推得更高(他们的注册记录中缺少出生地区信息，他们是婴儿潮一代，等等。).</p><p id="56cf" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">然而，这个图是使用<code class="du js jt ju jv b">shap.force_plot()</code>得到的唯一输出。它没有告诉你模型的预测输出，也没有告诉你这个具体观察的地面真相标签。能够一次看到所有信息输出不是很有帮助吗？这是我们第一个函数的目的。</p></div><div class="ab cl kr ks go kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ha hb hc hd he"><h1 id="f12f" class="ky kz hh bd la lb lc ld le lf lg lh li in lj io lk iq ll ir lm it ln iu lo lp bi translated">二元分类的力图</h1><p id="f5bd" class="pw-post-body-paragraph iw ix hh iy b iz lq ii jb jc lr il je jf ls jh ji jj lt jl jm jn lu jp jq jr ha bi translated">在我们使用这个函数之前，让我们确保所有的东西都是以一种易于使用的方式来设置的。预处理和分割数据，以便训练模型。确保存储与预处理数据相对应的特征名称！你需要这些来让情节变得更有意义。如果您的预处理管道涉及到创建新列(比如当一个热编码分类变量时)，您可以从管道中正确步骤的<code class="du js jt ju jv b">.get_feature_names</code>属性中获得新的特性名称。例如，我设置这一切的代码如下:</p><figure class="jy jz ka kb fd kc"><div class="bz dy l di"><div class="ko kp l"/></div></figure><p id="8698" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果您得到的不仅仅是分类变量，您需要确保从它们的步骤中获取这些特性名称，然后按照它们在预处理管道中被处理的顺序，将所有特性名称放入一个列表<strong class="iy hi">中。</strong></p><p id="5d9e" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">一旦您训练和调整了您的模型，将拟合的分类器和增强器分别分配给一个变量(我在这个项目中使用了XGBoost分类器——如果您使用其他方法，这些函数应该很容易适应其他基于树的算法)。我们希望能够在接下来的步骤中轻松地调用它们，并将其作为函数中的参数。当我们存储有用的东西时，让我们把预处理过的<code class="du js jt ju jv b">X_train_tf</code>数组转换成使用<code class="du js jt ju jv b">feature_names</code>作为列名的数据帧。</p><figure class="jy jz ka kb fd kc"><div class="bz dy l di"><div class="ko kp l"/></div></figure><p id="3c13" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">接下来，我们需要实际获取我们训练好的模型的SHAP值。因为我使用了基于树的分类器，所以我使用SHAP的<code class="du js jt ju jv b">TreeExplainer()</code>来做这件事。这个解释器然后用于计算SHAP值，如下所示。</p><figure class="jy jz ka kb fd kc"><div class="bz dy l di"><div class="ko kp l"/></div></figure><p id="4fc4" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iy hi">重要提示:</strong>我见过一些生成可视化效果的函数，其中包括SHAP值的计算。我不建议这样做。根据数据集的大小，计算可能需要相当长的时间，没有理由每次都要为同一个模型生成一个图。</p></div><div class="ab cl kr ks go kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ha hb hc hd he"><p id="6ca1" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在我们已经准备好编写和调用我们的第一个函数，它将产生如下所示的更具信息性的输出:</p><figure class="jy jz ka kb fd kc"><div class="bz dy l di"><div class="ko kp l"/></div></figure><figure class="jy jz ka kb fd kc er es paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="er es lv"><img src="../Images/9eaa8cb93af3fd050a952c7eb5727ef6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*31WyTolbry38_uYYjSECmw.png"/></div></div></figure><p id="0e12" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">下面是如何编写这个<code class="du js jt ju jv b">shap_force()</code>函数:</p><figure class="jy jz ka kb fd kc"><div class="bz dy l di"><div class="ko kp l"/></div></figure><p id="0418" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">您可以调整f字符串中包含的信息，以您想要的方式格式化输出。也许你想变得超级严肃，去掉那个庆祝你的模型预测正确的感叹号。也许您希望映射标签来报告实际的类名，而不是一个数字，这样便于您跟踪。</p></div><div class="ab cl kr ks go kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ha hb hc hd he"><h1 id="8445" class="ky kz hh bd la lb lc ld le lf lg lh li in lj io lk iq ll ir lm it ln iu lo lp bi translated">用于多类分类的力图</h1><p id="11e2" class="pw-post-body-paragraph iw ix hh iy b iz lq ii jb jc lr il je jf ls jh ji jj lt jl jm jn lu jp jq jr ha bi translated">再次预处理您的数据，存储预处理后的特征名称，这次不要忘记对您的目标进行<a class="ae jw" href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.LabelEncoder.html" rel="noopener ugc nofollow" target="_blank"> <strong class="iy hi">标签编码</strong> </a>。稍后您将需要访问这些标签编码的类！</p><figure class="jy jz ka kb fd kc"><div class="bz dy l di"><div class="ko kp l"/></div></figure><p id="59b3" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">最后一行返回我的多类模型的以下输出:</p><p id="aa06" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><code class="du js jt ju jv b">array(['Early', 'Election Day', 'No Vote], dtype=object)</code></p><p id="dd39" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">因为我的模型的多类版本将在选举中投票的人根据他们选择投票的时间分为两类。因此，它们分别被编码为0、1和2。</p><p id="755f" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">接下来，训练和调整您的模型，存储您的最佳估计器和与二进制模型相同的增强器，并确保您已经将预处理的X训练集转换为数据帧，并使用适当的功能名称作为列名。然后使用助推器得到你的树解释器，并计算SHAP值。</p><figure class="jy jz ka kb fd kc"><div class="bz dy l di"><div class="ko kp l"/></div></figure><p id="c615" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果你试图像我们在二元函数中那样使用<code class="du js jt ju jv b">shap.force_plot()</code>，它会抛出一个错误:</p><p id="30cf" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><code class="du js jt ju jv b">TypeError: list indices must be integers or slices, not tuple</code>。</p><p id="756c" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这是因为，当您计算多类目标的SHAP值时，您会得到一个包含SHAP值的n个数组的列表。这里n是组成你的目标的类的总数。因此，由于我的模型有3个目标变量类，我应该发现我的列表中有3个数组。您可以用下面的代码来确认这些事情:</p><figure class="jy jz ka kb fd kc"><div class="bz dy l di"><div class="ko kp l"/></div></figure><p id="527b" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们可以用一种类似的方式来考虑SHAP值的每个数组，就像当我们有一个二进制目标时，我们得到的SHAP值的单个数组一样。在这种二元情况下，SHAP值将模型推向投票(1)或不投票(0)的分类。现在有了我们的3个类，每个数组都将每个类作为自己的二进制目标进行评估。所以提前投票(1)对不提前投票(0)，选举日投票(1)对非选举日投票(0)，无投票(1)对非无投票(0)。</p><p id="30fa" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">你的头有点晕吗？跟着我。可视化会有所帮助。</p><p id="c3ef" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这是我们希望从函数中得到的输出:</p><figure class="jy jz ka kb fd kc"><div class="bz dy l di"><div class="ko kp l"/></div></figure><figure class="jy jz ka kb fd kc er es paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="er es lw"><img src="../Images/152220fdb4bb83195606f78f8f39aa57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5pEJIt7rYjbq1VBcXN2zow.png"/></div></div></figure><p id="de96" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">三个力图，每个目标阶级一个，模型预测得分最高的阶级——选举日(假设它几乎不是最高的)。下面是如何编写一个函数来获得这种类型的输出:</p><figure class="jy jz ka kb fd kc"><div class="bz dy l di"><div class="ko kp l"/></div></figure><p id="402f" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">一旦您花了一分钟时间来检查每个函数的功能(我认为我已经提供了足够的上下文和注释，但是请随意给我添加注释)，您可能会想“这很好，但是您已经硬编码了您的目标类。可能会更好。”</p><p id="dafb" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我的回答是“这很公平。现在，您已经清楚地了解了这个函数在我们的特定示例中是如何工作的，下面是您如何重写它以应用于您的特定问题，无论您有3个还是333个目标类。”</p><figure class="jy jz ka kb fd kc"><div class="bz dy l di"><div class="ko kp l"/></div></figure><p id="2d7c" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">您只需提供一个额外的参数(标签编码的<code class="du js jt ju jv b">classes_</code>属性),这样函数就可以遍历这些参数来创建您的标签字典。我还改变了默认显示<code class="du js jt ju jv b">'all'</code>为只显示<code class="du js jt ju jv b">'both'</code>，以防你有333个类在目标变量中。</p><h1 id="36d8" class="ky kz hh bd la lb lx ld le lf ly lh li in lz io lk iq ma ir lm it mb iu lo lp bi translated">概括一下</h1><p id="d9ee" class="pw-post-body-paragraph iw ix hh iy b iz lq ii jb jc lr il je jf ls jh ji jj lt jl jm jn lu jp jq jr ha bi translated"><a class="ae jw" href="https://github.com/slundberg/shap" rel="noopener ugc nofollow" target="_blank"> SHAP图书馆</a>为评估某些“黑盒”算法的特征重要性提供了有用的工具，这些算法以不易解释而闻名。它还提供了可视化要素如何影响模型预测的方法。</p><p id="d282" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">SHAP力图显示了哪些要素对单次观测的模型预测影响最大。这本身就很有趣，但如果你发现自己必须解释一些事情，比如为什么你的模型决定你应该拒绝一个特定的人向你的老板申请贷款，这就特别有用。</p><p id="ddde" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">您可以在较大函数的一部分中使用这些图，为二元和多类分类问题生成更多信息输出。具体来说，能够看到以下内容非常有用:</p><ol class=""><li id="dbc0" class="mc md hh iy b iz ja jc jd jf me jj mf jn mg jr mh mi mj mk bi translated">观察的基本事实标签，</li><li id="30ea" class="mc md hh iy b iz ml jc mm jf mn jj mo jn mp jr mh mi mj mk bi translated">模型对相同观察的预测，</li><li id="f6e3" class="mc md hh iy b iz ml jc mm jf mn jj mo jn mp jr mh mi mj mk bi translated">为您进行比较并告诉您您的模型是否正确预测了这一观察结果的语句，以及</li><li id="9716" class="mc md hh iy b iz ml jc mm jf mn jj mo jn mp jr mh mi mj mk bi translated">解释该观察的模型输出的力图。</li></ol></div><div class="ab cl kr ks go kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ha hb hc hd he"><p id="f283" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我希望这能对你有所帮助，并能把你学到的东西应用到你自己的工作中去！</p></div></div>    
</body>
</html>