<html>
<head>
<title>Categorize invoices using Multimodal Transformers: Leveraging both structured and unstructured data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用多模式转换器对发票进行分类:利用结构化和非结构化数据</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/categorize-invoices-using-multimodal-transformers-leveraging-both-structured-and-unstructured-data-d291ee0295d6?source=collection_archive---------0-----------------------#2022-08-09">https://medium.com/mlearning-ai/categorize-invoices-using-multimodal-transformers-leveraging-both-structured-and-unstructured-data-d291ee0295d6?source=collection_archive---------0-----------------------#2022-08-09</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/4557b1be6ec68f8ea27c47172f057710.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ot17YpQ4PHEJ4H4VIaIepA.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">How to know the category of invoices automatically? (Source: <a class="ae it" href="https://unsplash.com/photos/0rHxkbcvQAE" rel="noopener ugc nofollow" target="_blank">Unsplash</a>)</figcaption></figure><p id="ab1a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在本文中，我们将对我们的“<strong class="iw hi">多模态”数据</strong>的预训练BERT模型进行微调，以按照类别对发票进行<strong class="iw hi">多类别分类。</strong></p><ol class=""><li id="318e" class="js jt hh iw b ix iy jb jc jf ju jj jv jn jw jr jx jy jz ka bi translated">商业理解</li><li id="3cae" class="js jt hh iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">工作环境准备</li><li id="731d" class="js jt hh iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">数据理解</li><li id="a765" class="js jt hh iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">什么是多模态变压器？</li><li id="a80a" class="js jt hh iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">数据准备</li><li id="2e6d" class="js jt hh iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">建模</li><li id="2c6d" class="js jt hh iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">评估结果</li></ol></div><div class="ab cl kg kh go ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="ha hb hc hd he"><h1 id="9c00" class="kn ko hh bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">1.商业理解</h1><p id="3006" class="pw-post-body-paragraph iu iv hh iw b ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn lp jp jq jr ha bi translated">首先，让我们看看这篇文章的商业方面。</p><p id="28d8" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">事实上，在大多数组织中，每张发票都被归入一个特定的类别。实际上，如果雇员发生了维修或维护办公室设施或设备的费用，这些发票将被归入“维修和维护”类别。</p><p id="cb8e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">因此，该类别是创建费用报告的重要信息，以便为员工报销符合条件的业务费用，并跟踪整个组织的费用或与特定产品、客户或项目相关的费用。</p><p id="64d8" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">尽管对费用进行分类是一项需要完成的重要任务，但是手动进行分类是一项真正的负担，并且会浪费时间和资源。当我们需要从发票中提取数据(如日期、TTC金额、税收和卖方)时，也会出现同样的问题。然而，随着深度学习模型(如Transformers)的最新进展，微调大型语言模型以满足特定的业务需求变得比以往任何时候都更容易。你需要的只是高质量的标注数据来训练模型。</p><p id="9f59" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">对于发票提取，我们需要找到一个注释工具，它提供OCR注释来解析发票中的文本和边界框，并允许本地标记。幸运的是，我找到了一个名为<a class="ae it" href="https://ubiai.tools/" rel="noopener ugc nofollow" target="_blank"> UBIAI </a>的工具，它将使你能够直接标记你的发票，还可以训练LayoutLM等深度学习模型自动从发票图像中提取信息(如下图所示)。</p><figure class="lr ls lt lu fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lq"><img src="../Images/46ccc95d8cfb9e7580734145520d4749.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vlOUpsYtReieah1u0rhvYA.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">UBIAI’s OCR Annotation (Source: <a class="ae it" href="https://ubiai.tools/features/r1-ocr-annotation-feature" rel="noopener ugc nofollow" target="_blank">UBIAI.tools</a>)</figcaption></figure><p id="c77b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">鉴于上述信息(日期、金额_TTC、税款……)在发票上明确注明，我们使用UBIAI注释工具提取这些信息，但发票上并未直接提及类别信息，因此必须从我们使用UBIAI工具提取的数据中推断(扣除)这些信息。</p><p id="dfc3" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在我们已经介绍了业务上下文，让我们准备工作环境来实现我们的发票类别分类模型。</p></div><div class="ab cl kg kh go ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="ha hb hc hd he"><h1 id="69aa" class="kn ko hh bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">2.工作环境准备</h1><p id="969c" class="pw-post-body-paragraph iu iv hh iw b ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn lp jp jq jr ha bi translated">对于本文，我们使用了<a class="ae it" href="http://github.com/50gramx/guess-the-product/blob/master/train_set.csv" rel="noopener ugc nofollow" target="_blank">公开可用的数据集</a>——我们对其进行了轻微的调整和补充以适应我们的业务需求——来训练我们的多模型转换器。</p><p id="5e04" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们使用Google Colab作为python的web IDE，它是免费的，所以继续创建一个新的笔记本，以最简单的方式跟随我们。</p><p id="65fc" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">接下来，我们需要导入我们将使用的库:</p><pre class="lr ls lt lu fd lv lw lx ly aw lz bi"><span id="91b2" class="ma ko hh lw b fi mb mc l md me">import numpy as np<br/>import pandas as pd<br/>from sklearn import preprocessing<br/>from sklearn.metrics import f1_score, matthews_corrcoef</span><span id="fc53" class="ma ko hh lw b fi mf mc l md me">!pip install multimodal-transformers<br/>from transformers import AutoTokenizer, AutoConfig, Trainer, EvalPrediction, set_seed<br/>from transformers.training_args import TrainingArguments</span><span id="39d4" class="ma ko hh lw b fi mf mc l md me">from multimodal_transformers.data import load_data_from_folder<br/>from multimodal_transformers.model import TabularConfig<br/>from multimodal_transformers.model import AutoModelWithTabular</span></pre><p id="ab23" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">不要担心导入的数量，我们会在相关的时候看到每一个的使用。但是现在让我们继续来看看我们的数据。</p></div><div class="ab cl kg kh go ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="ha hb hc hd he"><h1 id="6acd" class="kn ko hh bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">3.数据理解</h1><p id="3040" class="pw-post-body-paragraph iu iv hh iw b ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn lp jp jq jr ha bi translated">如上所述，类别是我们将从当前发票信息中推断出的一条信息:</p><pre class="lr ls lt lu fd lv lw lx ly aw lz bi"><span id="b23e" class="ma ko hh lw b fi mb mc l md me">df = pd.read_csv('/content/categorized ocr_annotated_invoices.csv')<br/>df.head()</span></pre><figure class="lr ls lt lu fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mg"><img src="../Images/4cadfaa86ce08d2b4ea8b80bffd71e6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nUgxjMNKYK8udIzY8rpcbQ.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">The head (first 5 rows) of the df data frame</figcaption></figure><pre class="lr ls lt lu fd lv lw lx ly aw lz bi"><span id="a1e5" class="ma ko hh lw b fi mb mc l md me">df.describe()</span></pre><figure class="lr ls lt lu fd ii er es paragraph-image"><div class="er es mh"><img src="../Images/e7bb92732e50ace8e52f5062a3497cd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:610/format:webp/1*0BzyHiMfB7UuxTY9C238gw.png"/></div><figcaption class="ip iq et er es ir is bd b be z dx">Descriptive statistics of df</figcaption></figure><pre class="lr ls lt lu fd lv lw lx ly aw lz bi"><span id="f213" class="ma ko hh lw b fi mb mc l md me">df.info()</span></pre><figure class="lr ls lt lu fd ii er es paragraph-image"><div class="er es mi"><img src="../Images/fcdff052d5971a095380ab2c2ca44625.png" data-original-src="https://miro.medium.com/v2/resize:fit:1014/format:webp/1*WIOIYUQVLTc4bFCZet3ySw.png"/></div><figcaption class="ip iq et er es ir is bd b be z dx">Summary info of df</figcaption></figure><p id="b033" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">正如我们所看到的，我们的数据是一组发票，这些发票类似于UBIAI注释工具正在处理的发票(我们只选择了几列进行处理)，它们以表格格式呈现；每行代表一张发票(观察)。每列代表一个特征(预测值)，例如<em class="mj">金额_TTC </em>、<em class="mj">增值税_增值税</em>、<em class="mj">卖方_ID、</em>和<em class="mj">发票_描述</em>。数据被标记，目标变量是<em class="mj">类别ID </em>。</p><p id="c5e1" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">因此，我们将基于其他特征来预测<em class="mj"> Category_ID </em>。让我们计算数据集中出现的不同类别的数量:</p><pre class="lr ls lt lu fd lv lw lx ly aw lz bi"><span id="cab9" class="ma ko hh lw b fi mb mc l md me">number_categories = df.Category_ID.nunique()</span><span id="cc3d" class="ma ko hh lw b fi mf mc l md me">print("We have ", number_categories, " classes, so it's a Multiclass Classification")</span></pre><p id="1a66" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们有36个类，所以这是一个多类分类。</p></div><div class="ab cl kg kh go ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="ha hb hc hd he"><h1 id="9460" class="kn ko hh bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">4.多模式变压器</h1><p id="7d4a" class="pw-post-body-paragraph iu iv hh iw b ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn lp jp jq jr ha bi translated">使用非结构化文本数据的基于Transformer的模型非常强大，得到了广泛的讨论，并且被广泛使用。然而，在我们的例子中，<strong class="iw hi">我们确实有文本数据呈现在<em class="mj"> Invoice_Description </em>列中，但是我们也有有价值的结构化数据</strong>。对于具有结构化数据的特性，我们有<em class="mj"> Seller_ID </em>、<em class="mj"> VAT_TVA </em>和<em class="mj"> Amount_TTC </em>，这些特性中的每一个都带来了单个特性无法提供的信息。</p><p id="3d25" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们称这些不同的感知数据的方式(非结构化文本，结构化数字数据…) <strong class="iw hi">模态</strong>。将来自几个模态的信息结合起来进行预测被称为“多模态融合”。</p><p id="d22b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为此，我们决定使用<a class="ae it" href="https://github.com/georgian-io/Multimodal-Toolkit" rel="noopener ugc nofollow" target="_blank">multimodal-transformers</a>包，用最简单的话来说，它将文本数据上的transformer模型的输出与分类和数字特征中的结构化数据相结合。</p></div><div class="ab cl kg kh go ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="ha hb hc hd he"><h1 id="bd52" class="kn ko hh bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">5.数据准备</h1><p id="7a34" class="pw-post-body-paragraph iu iv hh iw b ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn lp jp jq jr ha bi translated">既然我们已经熟悉了我们的业务案例、数据属性和适当的工具，我们就可以开始准备数据集了。</p><p id="7eac" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们定义了字典<em class="mj"> column_info </em>，其中我们将指定哪些列包含文本数据、数字数据、分类数据和目标变量:</p><pre class="lr ls lt lu fd lv lw lx ly aw lz bi"><span id="f7e8" class="ma ko hh lw b fi mb mc l md me">column_info = {<br/>'text_cols': ['Invoice_Description'],<br/>'num_cols': ['VAT_TVA', 'Amount_TTC'],<br/>'cat_cols': ['Seller_ID'],<br/>'label_col': 'Category_ID',<br/># 'label_list': list(df.Category_ID.unique( ))<br/>}</span></pre><p id="0702" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">那么我们应该将标签列<em class="mj"> Category_ID </em>编码为transformers。Trainer不处理定性标签列，它希望标签列包含从0到类别数-1的整数:</p><pre class="lr ls lt lu fd lv lw lx ly aw lz bi"><span id="df5c" class="ma ko hh lw b fi mb mc l md me">encoder = preprocessing.LabelEncoder( )</span><span id="2411" class="ma ko hh lw b fi mf mc l md me">df["Category_ID"] = encoder.fit_transform(df['Category_ID']).astype(int)</span></pre><blockquote class="mk ml mm"><p id="2e7d" class="iu iv mj iw b ix iy iz ja jb jc jd je mn jg jh ji mo jk jl jm mp jo jp jq jr ha bi translated">注意:对特征进行编码有多种方式，我们这里用的是sk learn . preprocessing . labelen coder(！请注意，如果您要使用此方法对非标签特征进行编码，您应该小心在维度中创建错误序号重要性的可能性，因此您可能需要使用sk learn . preprocessing . onehotencoder)。</p></blockquote><p id="c00e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了建立一个可靠的模型，我们不应该使用相同的数据集进行模型训练和评估，因此我们需要将数据分为训练集、验证集和测试集:</p><pre class="lr ls lt lu fd lv lw lx ly aw lz bi"><span id="8be1" class="ma ko hh lw b fi mb mc l md me">train_df, validation_df, test_df = np.split(df.sample(frac = 1), [int(.8 * len(df)), int(.9 * len(df))])</span><span id="5ba2" class="ma ko hh lw b fi mf mc l md me">print('TRAIN DATA is ~80% :', len(train_df))<br/>print('VALIDATION DATA is ~10% :', len(validation_df))<br/>print('TEST DATA is ~10% :', len(test_df))</span><span id="be42" class="ma ko hh lw b fi mf mc l md me">train_df.to_csv('train.csv')<br/>validation_df.to_csv('val.csv')<br/>test_df.to_csv('test.csv')</span></pre><figure class="lr ls lt lu fd ii er es paragraph-image"><div class="er es mq"><img src="../Images/e628a1697697c70f3a7197f6aad2249d.png" data-original-src="https://miro.medium.com/v2/resize:fit:524/format:webp/1*1FI899KFrbf7uAxQKLk6fg.png"/></div><figcaption class="ip iq et er es ir is bd b be z dx">Splitting the data</figcaption></figure><blockquote class="mk ml mm"><p id="0478" class="iu iv mj iw b ix iy iz ja jb jc jd je mn jg jh ji mo jk jl jm mp jo jp jq jr ha bi translated">注意:我们将3套保存在csv文件中，文件名必须为train.csv、test.csv和val.csv，否则multimodal _ transformers . data .<strong class="iw hi">load _ data _ from _ folder</strong>函数将无法加载它们。</p></blockquote><p id="625c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">然后，我们将数据集加载到TorchTabularTextDataset中，它将包括HuggingFace转换器的文本输入，以及我们指定的分类和数字特征列。为此，我们必须首先加载我们的HuggingFace标记器:</p><pre class="lr ls lt lu fd lv lw lx ly aw lz bi"><span id="4cd2" class="ma ko hh lw b fi mb mc l md me">pretrained_model_name = 'bert-base-uncased'<br/>tokenizer = AutoTokenizer.from_pretrained(pretrained_model_name)</span><span id="1f1f" class="ma ko hh lw b fi mf mc l md me">train_dataset, validation_dataset, test_dataset = load_data_from_folder(folder_path = '.',<br/>                       text_cols = column_info['text_cols'],<br/>                       tokenizer = tokenizer,<br/>                       label_col = column_info['label_col'],<br/>                       # label_list = column_info['label_list'],<br/>                       categorical_cols = column_info['cat_cols'],<br/>                       numerical_cols = column_info['num_cols'],<br/>                       sep_text_token_str = tokenizer.sep_token,<br/>)</span></pre><p id="4a73" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们选择使用预训练的BERT基础模型(未装箱)，根据您的要求，您可以从<a class="ae it" href="https://huggingface.co/models" rel="noopener ugc nofollow" target="_blank">这里</a>选择另一个预训练模型。</p><blockquote class="mk ml mm"><p id="9356" class="iu iv mj iw b ix iy iz ja jb jc jd je mn jg jh ji mo jk jl jm mp jo jp jq jr ha bi translated">注意:使用预先训练的模型(如BERT)时，不需要进行文本预处理，它使用句子中的所有信息，包括标点符号和停用词。</p></blockquote></div><div class="ab cl kg kh go ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="ha hb hc hd he"><h1 id="93be" class="kn ko hh bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">6.建模</h1><p id="e9f2" class="pw-post-body-paragraph iu iv hh iw b ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn lp jp jq jr ha bi translated">现在接下来要做的事情是用表格模型加载我们的转换器。</p><p id="277d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">首先，我们在TabularConfig对象中指定我们的表格配置，在该对象中，我们还指定我们希望如何将表格特性与文本特性相结合，并且我们将使用加权求和方法。</p><p id="029c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">其次，我们将这个配置定义为HuggingFace转换器的BertConfig对象的tabular_config成员变量。</p><p id="8a31" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">一旦我们定义了model_config，我们就可以使用hugging face multimodal _ transformers . model . automodelwithfatable .<strong class="iw hi">from _ pre trained</strong>方法加载模型。</p><pre class="lr ls lt lu fd lv lw lx ly aw lz bi"><span id="235c" class="ma ko hh lw b fi mb mc l md me">tabular_config = <br/>TabularConfig(<br/>        num_labels = number_categories,<br/>        cat_feat_dim = train_dataset.cat_feats.shape[1],<br/>        numerical_feat_dim = train_dataset.numerical_feats.shape[1],<br/>        combine_feat_method =     'weighted_feature_sum_on_transformer_cat_and_numerical_feats'<br/>)</span><span id="f72e" class="ma ko hh lw b fi mf mc l md me"><br/>model_config = AutoConfig.from_pretrained('bert-base-uncased')<br/>model_config.tabular_config = tabular_config</span><span id="63c2" class="ma ko hh lw b fi mf mc l md me"><br/>model = AutoModelWithTabular.from_pretrained('bert-base-uncased', config = model_config)</span></pre><p id="c20e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">加载模型后，在对我们的数据进行训练之前，我们需要定义一些相关的评估指标来提供对模型性能的深入了解，因此我们定义了返回精度、F1分数和Matthew相关系数的函数:</p><pre class="lr ls lt lu fd lv lw lx ly aw lz bi"><span id="d489" class="ma ko hh lw b fi mb mc l md me">def calculate_classification_metrics(p: EvalPrediction):</span><span id="24da" class="ma ko hh lw b fi mf mc l md me">  predicted_labels = np.argmax(p.predictions, axis = 1)<br/>  expected_labels = p.label_ids</span><span id="f199" class="ma ko hh lw b fi mf mc l md me">  accuracy = (predicted_labels == expected_labels).mean( )<br/>  f1 = f1_score(y_true = expected_labels, y_pred = predicted_labels, average = 'micro')</span><span id="76a4" class="ma ko hh lw b fi mf mc l md me">  eval_result = {<br/>         "acc": accuracy,<br/>         "f1": f1,<br/>         "mcc": matthews_corrcoef(expected_labels, predicted_labels)<br/>  }</span><span id="a32b" class="ma ko hh lw b fi mf mc l md me">  return eval_result</span></pre><p id="1f30" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">此时，我们只需要训练我们的模型，因此只剩下三个步骤🎉：</p><ol class=""><li id="4bb9" class="js jt hh iw b ix iy jb jc jf ju jj jv jn jw jr jx jy jz ka bi translated">在训练参数中定义训练超参数。</li><li id="ae09" class="js jt hh iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">将我们的训练参数以及我们的数据集、模型和评估函数传递给培训师。</li><li id="7e51" class="js jt hh iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">调用train()来微调我们的模型。</li></ol><pre class="lr ls lt lu fd lv lw lx ly aw lz bi"><span id="e929" class="ma ko hh lw b fi mb mc l md me">training_args = TrainingArguments(output_dir = "./UBIAI/model_out",<br/>                                  logging_dir = "./UBIAI/run_logs",<br/>                                  overwrite_output_dir = True,<br/>                                  do_train = True,<br/>                                  do_eval = True,<br/>                                  per_device_train_batch_size = 32,<br/>                                  num_train_epochs = 1,<br/>                                  evaluate_during_training = True,<br/>                                  logging_steps = 5,<br/>                                  eval_steps = 54)<br/>set_seed(training_args.seed)</span><span id="5efb" class="ma ko hh lw b fi mf mc l md me">trainer = Trainer(model = model,<br/>                 args = training_args,<br/>                 train_dataset = train_dataset,<br/>                 eval_dataset = validation_dataset,<br/>                 compute_metrics = calculate_classification_metrics)<br/></span><span id="44dc" class="ma ko hh lw b fi mf mc l md me">trainer.train( )</span></pre><figure class="lr ls lt lu fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mr"><img src="../Images/7cad9e2b3b47ab58463647d5632d37da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XN7UoAWw1Jhih7x17DWuqA.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">trainer.train( )</figcaption></figure></div><div class="ab cl kg kh go ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="ha hb hc hd he"><h1 id="f005" class="kn ko hh bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">7.估价</h1><p id="f0b0" class="pw-post-body-paragraph iu iv hh iw b ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn lp jp jq jr ha bi translated">训练完模型后，让我们看看验证指标:</p><pre class="lr ls lt lu fd lv lw lx ly aw lz bi"><span id="3b66" class="ma ko hh lw b fi mb mc l md me"># Load the TensorBoard notebook extension<br/>%load_ext tensorboard<br/>%tensorboard --logdir ./UBIAI/run_logs --port=6006</span></pre><figure class="lr ls lt lu fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ms"><img src="../Images/6401e5a2aca58b7389f1e890b4940396.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0T5bd079jj3UhCt9QJlw5w.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Training validation metrics</figcaption></figure><p id="7b77" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">作为模型预测的实际演示，我们现在将对一些新发票运行预测，这些发票不是用于微调模型的训练集或验证集的一部分:</p><pre class="lr ls lt lu fd lv lw lx ly aw lz bi"><span id="4c7d" class="ma ko hh lw b fi mb mc l md me"># Save our model<br/>trainer.save_model ("./UBIAI/model_out")</span><span id="479a" class="ma ko hh lw b fi mf mc l md me"><br/># Load it<br/>model = AutoModelWithTabular.from_pretrained("./UBIAI/model_out", local_files_only=True)</span><span id="3fec" class="ma ko hh lw b fi mf mc l md me">trainer = Trainer(model=model)</span><span id="5b11" class="ma ko hh lw b fi mf mc l md me"><br/># Predict with it<br/>y_predicted = [list(i).index(max(i)) for i in trainer.predict(test_dataset).predictions]</span><span id="fffb" class="ma ko hh lw b fi mf mc l md me">print("➡️Predicted categories for the test data set:", y_predicted)</span><span id="ea5e" class="ma ko hh lw b fi mf mc l md me"># Evaluate the prediction<br/>precision = sum(1 for x,y in zip(y_predicted,test_dataset.labels) if x == y) / float(len(y_predicted))</span><span id="b21f" class="ma ko hh lw b fi mf mc l md me">print("🥳 Our model is able to predict the invoice category with an accuracy score of", round(precision*100), "%")</span></pre><figure class="lr ls lt lu fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mt"><img src="../Images/527c321ba4e91011099062733bfa41c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7zFbRo5qYNlVtq7Q0arHaA.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Post-training prediction test results</figcaption></figure><blockquote class="mk ml mm"><p id="4127" class="iu iv mj iw b ix iy iz ja jb jc jd je mn jg jh ji mo jk jl jm mp jo jp jq jr ha bi translated">注意:让我们记住3个数据集的用途:</p><p id="734f" class="iu iv mj iw b ix iy iz ja jb jc jd je mn jg jh ji mo jk jl jm mp jo jp jq jr ha bi translated"><strong class="iw hi"><em class="hh">-</em></strong><em class="hh">train _ dataset</em>用于训练模型，让它学习数据中的隐藏模式。</p><p id="6040" class="iu iv mj iw b ix iy iz ja jb jc jd je mn jg jh ji mo jk jl jm mp jo jp jq jr ha bi translated"><strong class="iw hi"><em class="hh">-</em></strong><em class="hh">validation _ dataset</em>用于验证我们的模型在训练时的表现。</p><p id="5929" class="iu iv mj iw b ix iy iz ja jb jc jd je mn jg jh ji mo jk jl jm mp jo jp jq jr ha bi translated"><strong class="iw hi"> - </strong> test_dataset用于完成训练后对模型进行测试。</p></blockquote></div><div class="ab cl kg kh go ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="ha hb hc hd he"><h1 id="18f1" class="kn ko hh bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">结论</h1><p id="b37c" class="pw-post-body-paragraph iu iv hh iw b ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn lp jp jq jr ha bi translated">通过处理包含结构化数据(Amount_TTC…)和非结构化数据(Invoice_Description)的带注释的发票，我们能够加载一个利用文本和结构化数据的表格模型的转换器，根据我们的数据对预训练模型进行微调，并且能够以大约95%的精度预测发票的类别。</p><blockquote class="mk ml mm"><p id="ee77" class="iu iv mj iw b ix iy iz ja jb jc jd je mn jg jh ji mo jk jl jm mp jo jp jq jr ha bi translated"><em class="hh">链接到Colab </em> <a class="ae it" href="https://colab.research.google.com/drive/1gx_f0mth2PzPbzt8geSpOJEqJUJnXzPp?usp=sharing" rel="noopener ugc nofollow" target="_blank"> <em class="hh">笔记本</em> </a> <em class="hh">。(</em>所有非来源视觉均来自此处截图<em class="hh"> ) </em></p><p id="b8dd" class="iu iv mj iw b ix iy iz ja jb jc jd je mn jg jh ji mo jk jl jm mp jo jp jq jr ha bi translated"><em class="hh">如果你有兴趣了解</em> <strong class="iw hi"> <em class="hh">如何从非结构化数据(图片、文档……)</em></strong><em class="hh">中提取结构化信息(日期、金额_ TTC……)，可以考虑阅读来自UBIAI </em>  <em class="hh">的</em> <a class="ae it" href="https://ubiai.tools/blog/article/Fine_tuning_LayoutLM" rel="noopener ugc nofollow" target="_blank"> <em class="hh">这篇文章。</em></a></p></blockquote><div class="mu mv ez fb mw mx"><a rel="noopener follow" target="_blank" href="/mlearning-ai/mlearning-ai-submission-suggestions-b51e2b130bfb"><div class="my ab dw"><div class="mz ab na cl cj nb"><h2 class="bd hi fi z dy nc ea eb nd ed ef hg bi translated">Mlearning.ai提交建议</h2><div class="ne l"><h3 class="bd b fi z dy nc ea eb nd ed ef dx translated">如何成为Mlearning.ai上的作家</h3></div><div class="nf l"><p class="bd b fp z dy nc ea eb nd ed ef dx translated">medium.com</p></div></div><div class="ng l"><div class="nh l ni nj nk ng nl in mx"/></div></div></a></div></div></div>    
</body>
</html>