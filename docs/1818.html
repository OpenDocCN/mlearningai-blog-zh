<html>
<head>
<title>Machine learning frontiers: modelling basics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">机器学习前沿:建模基础</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/machine-learning-frontiers-modelling-basics-7269ae6f0729?source=collection_archive---------1-----------------------#2022-02-01">https://medium.com/mlearning-ai/machine-learning-frontiers-modelling-basics-7269ae6f0729?source=collection_archive---------1-----------------------#2022-02-01</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/ea5962db62363d2fdbd042017cc3cf6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ars2naQNOcoFEnuHxg9dig.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx"><a class="ae it" href="https://www.imdb.com/title/tt0212720/mediaviewer/rm2180580864/" rel="noopener ugc nofollow" target="_blank">Artificial Intelligence (2001) — copyrights of Warner Bros. Pictures - source</a></figcaption></figure><p id="fedf" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果世界今天重新启动，你必须知道哪些建模概念才能让机器学习重新启动？</p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><p id="f70f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">尽管有科学的努力，也不可能理解作用于一个物理或社会现象的每一种力。这是由于三类限制造成的:</p><ul class=""><li id="00c4" class="jz ka hh iw b ix iy jb jc jf kb jj kc jn kd jr ke kf kg kh bi translated"><strong class="iw hi">理论无知</strong>:对给定现象的关系和理论规则并不完全了解</li><li id="35dc" class="jz ka hh iw b ix ki jb kj jf kk jj kl jn km jr ke kf kg kh bi translated"><strong class="iw hi">实践无知</strong>:缺乏完整的观察，如事实、测量和实验读数</li><li id="92fc" class="jz ka hh iw b ix ki jb kj jf kk jj kl jn km jr ke kf kg kh bi translated"><strong class="iw hi">懒惰</strong>:作用于一个特定现象的所有力量是如此之大，以至于不可能列出它们或者精确计算它们的结果</li></ul><p id="6241" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">机器学习使用<strong class="iw hi">函数逼近</strong>来处理这样的场景。这些函数近似值被称为<strong class="iw hi">模型</strong>。</p><p id="b251" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">造型</strong></p><p id="2edc" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在机器学习的背景下，建模是通过<strong class="iw hi">训练过程找到<strong class="iw hi">有用的</strong>模型的过程。</strong></p><p id="bac0" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当一个模型对<strong class="iw hi">看不见的数据</strong>表现良好时，即<strong class="iw hi">在其构建</strong>期间未被使用的数据，该模型被认为是有用的。简而言之:</p><figure class="ko kp kq kr fd ii er es paragraph-image"><div class="er es kn"><img src="../Images/fb59f62d73a70d58e7afee39b6529947.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/1*M8VOPyfON-SnvGn7GbGEgw.png"/></div></figure><p id="74ca" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当然，我们想摆脱<strong class="iw hi">装备不足的</strong>和<strong class="iw hi">装备过度的</strong>车型。让我们考虑下面的合成场景，以便理解如何。</p><h2 id="4be4" class="ks kt hh bd ku kv kw kx ky kz la lb lc jf ld le lf jj lg lh li jn lj lk ll lm bi translated">合成数据拯救世界</h2><p id="a22c" class="pw-post-body-paragraph iu iv hh iw b ix ln iz ja jb lo jd je jf lp jh ji jj lq jl jm jn lr jp jq jr ha bi translated"><strong class="iw hi">合成数据</strong>是一种宝贵的资源。在将模型和算法应用于真实数据之前，更容易理解它们的行为。在这里和之后，我们将使用合成数据来了解机器学习建模的主要关注点。</p><p id="3e6e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们假设我们以某种方式知道支配所研究现象的生成源:</p><figure class="ko kp kq kr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ls"><img src="../Images/9255668486809b668cf52523c32f64b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iEmcXFMWeyBpSe0hj-OpNA.png"/></div></div></figure><p id="029c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">蓝线代表我们已经神奇地知道的源函数。这个特殊的函数就是周期性的<strong class="iw hi">正弦波</strong>函数<em class="lt"> f(x) = sin(x) </em>。生成正弦数据的JavaScript代码如下:</p><figure class="ko kp kq kr fd ii"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="c7ee" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">图表中的红叉是通过实验程序从真实现象中获得的测量值。注意，由于不同的噪声源，这些实验读数与源生成正弦函数并不完全共线。</p><p id="e602" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">&gt;<strong class="iw hi">正态分布</strong>很好地代表了这类噪声。的确，<strong class="iw hi">中心极限定理</strong>陈述了独立随机变量的和近似正态分布。</p><p id="c056" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在真实场景中，我们甚至不知道生成源信号的形状。通常我们只能获得实验数据:</p><figure class="ko kp kq kr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ls"><img src="../Images/8558d93c6ff7d71f52ff2b53251708e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qWSOEFTJaPIP_pQuxGmAug.png"/></div></div></figure><p id="3f46" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在本文的其余部分，我们将找到获得源生成信号的良好近似的方法，假设我们既不知道它的形状也不知道它的公式。</p><h2 id="038a" class="ks kt hh bd ku kv kw kx ky kz la lb lc jf ld le lf jj lg lh li jn lj lk ll lm bi translated">近似函数</h2><p id="c641" class="pw-post-body-paragraph iu iv hh iw b ix ln iz ja jb lo jd je jf lp jh ji jj lq jl jm jn lr jp jq jr ha bi translated">粗略地说，训练算法旨在找到给定训练数据的近似函数(或模型)。为了检查它的运行情况，让我们将训练数据设置为原始实验数据的67%，将剩余的33%留在一边以备将来的<strong class="iw hi">验证</strong>:</p><figure class="ko kp kq kr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lw"><img src="../Images/9c239b4d1b3597497a0267e816d8607b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QR3hh2rfV9pjkJNs7rckWg.png"/></div></div></figure><p id="8bf5" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">&gt;分割训练集和验证集中的数据称为<strong class="iw hi">保持</strong>。常见的拆分百分比有67%、80%、90%和99%。</p><p id="29e8" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了让事情尽可能简单，在这个实验中，我们将使用简单的基本教科书模型:直线(也称为一次多项式)，三次多项式(三次曲线)等等。因此，使用<strong class="iw hi">最小二乘法</strong>，我们可以找到以下近似值:</p><div class="ko kp kq kr fd ab cb"><figure class="lx ii ly lz ma mb mc paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><img src="../Images/a30bd3ab2bf193ad1555c740c050c0b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*axONF9p9Gge_zHm7AI3RZg.png"/></div></figure><figure class="lx ii ly lz ma mb mc paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><img src="../Images/27ac3b254d6a30abc3d21cbc6d1890c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*ayqqHOASBX_5yVMO6mwaJA.png"/></div></figure></div><div class="ab cb"><figure class="lx ii ly lz ma mb mc paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><img src="../Images/7a7a9d68767547f1d1b8eaa4dd8f0274.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*EsBT5kjF_QmFIp_9i1iV2g.png"/></div></figure><figure class="lx ii ly lz ma mb mc paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><img src="../Images/2117d87bd0e4841ad82890542ba5a561.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*BkhGMQqpKvxhvN6rh-bveQ.png"/></div></figure></div><p id="6f18" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">哪个模型更接近训练数据？检查图像，我们可以发现9次多项式曲线通过几乎每个训练点，而其他曲线或多或少更接近。但是，如何量化这种接近程度呢？</p><p id="b02d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">回答这个问题的一个很好的替代方法是<strong class="iw hi">均方误差</strong>或<strong class="iw hi"> mse </strong>:</p><figure class="ko kp kq kr fd ii er es paragraph-image"><div class="er es md"><img src="../Images/43834207a59db3fb26fd2e99825f8d7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1044/format:webp/1*g5zx9BZOhgMnZ33gZX-beg.png"/></div></figure><p id="6b56" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">mse是<strong class="iw hi">预测值</strong><em class="lt">ŷ</em>和<strong class="iw hi">观测值</strong> <em class="lt"> Y </em>的平方差的平均值。预测值是模型猜测的值，而观察值是数据集<em class="lt">中的原始值。</em>对于我们特定的一维数据，mse的实现非常简单:</p><figure class="ko kp kq kr fd ii"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="488b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">对于mse这样的误差指标，越小越好。对训练数据应用mse会导致:</p><figure class="ko kp kq kr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lw"><img src="../Images/8cfb793a0cb4507e9b02b45c25d4546f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Llwwrh4agz48tEZdcN0t7g.png"/></div></div></figure><p id="f061" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">基于这种性能，我们可以认为最佳模型是9次多项式逼近。当然，这是一个错误的发现:将mse应用于验证数据提供了实际模型性能的一个相当好的视图:</p><figure class="ko kp kq kr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lw"><img src="../Images/6a963b639e8689b2ef88f9ea722d66d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q1Sw3tCta9jjGtX6KYau1g.png"/></div></div></figure><p id="8b0c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">上图用的是对数刻度！它清楚地表明，9次多项式模型在验证数据上表现不佳，尽管它在训练数据上实现了高性能。换句话说，这个图表显示的是9次多项式模型遭受过拟合。</p><p id="07cb" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">另一方面，线性模型在训练集和验证集中的性能都很低。这被称为欠拟合。在真实的实验中，线性模型和9阶模型都应该被丢弃。</p><figure class="ko kp kq kr fd ii er es paragraph-image"><div class="er es me"><img src="../Images/16fbddcfafcdd779a7f048796af9bb09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*66SF_WbaQIYzo8gJ15bm4Q.jpeg"/></div><figcaption class="ip iq et er es ir is bd b be z dx">Famous picture of someone deploying an overfitted model in production</figcaption></figure><p id="82d3" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这里最重要的教训是:<strong class="iw hi">模型是用在训练中没有用到的数据来评估的</strong>。</p><p id="623f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在，我们知道如何检测过度拟合的模型。但是，是什么让一个模型过度拟合呢？如何避免？</p><h2 id="a115" class="ks kt hh bd ku kv kw kx ky kz la lb lc jf ld le lf jj lg lh li jn lj lk ll lm bi translated"><strong class="ak">过配合和欠配合的原因</strong></h2><p id="9249" class="pw-post-body-paragraph iu iv hh iw b ix ln iz ja jb lo jd je jf lp jh ji jj lq jl jm jn lr jp jq jr ha bi translated">过度拟合的常见原因是<strong class="iw hi">模型复杂性</strong>。我们可以将模型的复杂性恢复为模型中自由参数<strong class="iw hi">的数量</strong>。在9次多项式的情况下，有10个自由参数来拟合数据。自由参数越多，越容易过拟合。</p><figure class="ko kp kq kr fd ii er es paragraph-image"><div class="er es mf"><img src="../Images/de9d3c18e29362f84c470bc9357196b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*4tfG2FX_0d89uMb7-fegeQ.jpeg"/></div><figcaption class="ip iq et er es ir is bd b be z dx"><a class="ae it" href="https://quoteinvestigator.com/2011/05/13/einstein-simple/" rel="noopener ugc nofollow" target="_blank">Einsten citation investigation here</a></figcaption></figure><p id="bcb9" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">反之，参数少的模型容易欠拟合。这是使用线性模型来近似(非线性)正弦波函数的情况。</p><p id="ff80" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">模型复杂性的选择是建模阶段要做的最重要的决定之一。在训练算法中自动做出这种决定是机器学习的一个活跃研究来源。</p><p id="60c1" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">&gt;减少自由参数的数量或影响通常被称为r <strong class="iw hi">均衡</strong>。我们将在另一篇文章中详细讨论正则化。</p><h2 id="8703" class="ks kt hh bd ku kv kw kx ky kz la lb lc jf ld le lf jj lg lh li jn lj lk ll lm bi translated">过度装配和装配不足的其他来源</h2><p id="ecf5" class="pw-post-body-paragraph iu iv hh iw b ix ln iz ja jb lo jd je jf lp jh ji jj lq jl jm jn lr jp jq jr ha bi translated">拟合不足和过度还有其他原因，通常与数据质量有关。特别是，小数据是一个大问题，对欠拟合和过拟合都有很大影响。</p><p id="baf9" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">&gt;数据采集和准备过程是建模成功的关键。我们将在下一篇文章中讨论它。</p><p id="7f74" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">过度/欠拟合的另一个原因是训练<strong class="iw hi">超参数</strong>的选择。培训过程将在本系列的下一篇文章中介绍。</p><h2 id="16e5" class="ks kt hh bd ku kv kw kx ky kz la lb lc jf ld le lf jj lg lh li jn lj lk ll lm bi translated">最后，什么使得模型有用？</h2><p id="73d4" class="pw-post-body-paragraph iu iv hh iw b ix ln iz ja jb lo jd je jf lp jh ji jj lq jl jm jn lr jp jq jr ha bi translated">在我们之前的实验中，具有中等复杂度(第三和第五)的模型显示了训练和验证性能之间的最佳平衡。这种平衡是<strong class="iw hi">选型</strong>中的主要指标。</p><p id="9790" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">但是，在这种情况下，当两个或更多不同的模型具有大致相同的性能时，会发生什么呢？很简单！选择最简单的！</p><figure class="ko kp kq kr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lw"><img src="../Images/eb6646d8befa2efb55aceef08b5772ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0kITV-jUdYImhClea99DWQ.png"/></div></div></figure><p id="3492" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">使用不太复杂的模型而不是更复杂的模型的论点被称为<strong class="iw hi">奥卡姆剃刀原理</strong>。检查我们之前的示例，我们发现3次和5次多项式模型与原始源信号(蓝线)的形状非常相似。因此，根据奥卡姆剃刀原理，我们将选择第三个作为最终选择的模型。</p><p id="e8d3" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">&gt;在实时应用中，最简单的模型也是最快的模型。因此，对于两个性能相同的模型，最简单的总是被选中的。</p><h2 id="0ab8" class="ks kt hh bd ku kv kw kx ky kz la lb lc jf ld le lf jj lg lh li jn lj lk ll lm bi translated">结论</h2><p id="c725" class="pw-post-body-paragraph iu iv hh iw b ix ln iz ja jb lo jd je jf lp jh ji jj lq jl jm jn lr jp jq jr ha bi translated">在本文中，我们讨论了机器学习环境中建模的基本主题。</p><p id="2c05" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">使用一个合成场景和简单的学校级多项式函数说明了欠拟合和过拟合等概念。</p><p id="0d5f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在真实的场景中，更复杂的模型取代了位置，并且使用了适当的迭代训练算法。无论如何，这里讨论的核心建模主题，如训练和验证集、过拟合/欠拟合和模型复杂性，也同样有效。</p><h2 id="89d1" class="ks kt hh bd ku kv kw kx ky kz la lb lc jf ld le lf jj lg lh li jn lj lk ll lm bi translated">密码</h2><p id="4492" class="pw-post-body-paragraph iu iv hh iw b ix ln iz ja jb lo jd je jf lp jh ji jj lq jl jm jn lr jp jq jr ha bi translated">本文中使用的代码是用JavaScript编写的。你可以在这个<a class="ae it" href="https://gist.github.com/doleron/742028d2dd2c02f476d7623977585b0d" rel="noopener ugc nofollow" target="_blank">要点</a>中找到它，或者使用下面的小提琴:</p><figure class="ko kp kq kr fd ii"><div class="bz dy l di"><div class="mg lv l"/></div></figure><p id="d7c4" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果JavaScript不是您的首选语言，不用担心。将这些代码移植到不同的语言上并不困难，比如Python、Java或C++。如有任何问题，请不要犹豫，请发邮件至:doleron gmail com</p><div class="mh mi ez fb mj mk"><a rel="noopener follow" target="_blank" href="/mlearning-ai/mlearning-ai-submission-suggestions-b51e2b130bfb"><div class="ml ab dw"><div class="mm ab mn cl cj mo"><h2 class="bd hi fi z dy mp ea eb mq ed ef hg bi translated">Mlearning.ai提交建议</h2><div class="mr l"><h3 class="bd b fi z dy mp ea eb mq ed ef dx translated">如何成为Mlearning.ai上的作家</h3></div><div class="ms l"><p class="bd b fp z dy mp ea eb mq ed ef dx translated">medium.com</p></div></div><div class="mt l"><div class="mu l mv mw mx mt my in mk"/></div></div></a></div></div></div>    
</body>
</html>