<html>
<head>
<title>Iterators and Generators in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的迭代器和生成器</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/iterators-and-generators-in-python-8d392382f158?source=collection_archive---------7-----------------------#2022-01-31">https://medium.com/mlearning-ai/iterators-and-generators-in-python-8d392382f158?source=collection_archive---------7-----------------------#2022-01-31</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><blockquote class="ie if ig"><p id="0ed6" class="ih ii ij ik b il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf ha bi translated">python中的生成器和迭代器是什么，如何高效地使用它们。</p></blockquote><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jg"><img src="../Images/90d0f234b2a8696559df528964f904b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wjvngPk2VLw5hfgN"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx">Photo by <a class="ae jw" href="https://unsplash.com/@lucabravo?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Luca Bravo</a> on <a class="ae jw" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="4e3a" class="jx jy hh bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">让我们先从迭代器开始。</h2><p id="7581" class="pw-post-body-paragraph ih ii hh ik b il kv in io ip kw ir is ki kx iv iw km ky iz ja kq kz jd je jf ha bi translated">你有没有想过如何在列表中循环“列表中的元素”？迭代器是这一功能的基础。要理解迭代器和生成器，首先要理解什么是迭代器和可迭代的。</p><p id="84b3" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is ki iu iv iw km iy iz ja kq jc jd je jf ha bi translated"><strong class="ik hi">迭代器</strong>是一个通过一系列值(iterable)管理迭代的对象。对于迭代器对象' I '，每次调用内置函数next(i)都会从底层序列中产生一个后续元素。如果一个序列中没有其他元素，则会引发StopIteration异常，指示已到达该序列的末尾。我们可以通过<em class="ij"> iter(obj)创建一个迭代器。</em></p><p id="9b74" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is ki iu iv iw km iy iz ja kq jc jd je jf ha bi translated"><strong class="ik hi"> iterable </strong>是迭代器迭代的对象，比如list和tuple。现在让我们看看语法。</p><pre class="jh ji jj jk fd la lb lc ld aw le bi"><span id="76c3" class="jx jy hh lb b fi lf lg l lh li">data = [1,2,3]<br/>i = iter(data)<br/>print(next(i))<br/>print(next(i))<br/>print(next(i))</span></pre><p id="958e" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is ki iu iv iw km iy iz ja kq jc jd je jf ha bi translated">python中的for-loop语法“for i in data”只是在幕后实现了上述过程。它为给定的iterable创建一个iterator对象，然后不断调用next(iterator ),直到捕捉到StopIteration异常。</p><p id="e4bd" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is ki iu iv iw km iy iz ja kq jc jd je jf ha bi translated">有些人可能会想，如果我在所有后续调用执行之前在列表中添加一个元素，会发生什么？它会简单地将该元素添加到列表中，该列表可以通过最后一次调用来检索。</p><pre class="jh ji jj jk fd la lb lc ld aw le bi"><span id="e993" class="jx jy hh lb b fi lf lg l lh li">data = [1,2,3,4,5]<br/>i = iter(data)<br/>print(next(i))<br/>print(next(i))</span><span id="49da" class="jx jy hh lb b fi lj lg l lh li">data.append('hi')</span><span id="f994" class="jx jy hh lb b fi lj lg l lh li">print(next(i))<br/>print(next(i))<br/>print(next(i))<br/>print(next(i))</span><span id="6bd7" class="jx jy hh lb b fi lj lg l lh li">#output<br/>1<br/>2<br/>3<br/>4<br/>5<br/>hi</span></pre><p id="f04e" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is ki iu iv iw km iy iz ja kq jc jd je jf ha bi translated">现在让我们在一个类中实现迭代器。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="5d27" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is ki iu iv iw km iy iz ja kq jc jd je jf ha bi translated">您可能想知道为什么__next__和__iter__方法前后有双下划线。这是因为它们都是python中<strong class="ik hi"> Dunder </strong>函数的一部分，也称为神奇函数。这些Dunder函数是内置Python类的预定义方法，但是可以被覆盖以实现良好的多态形式。我将会写另一篇关于这个主题的文章，但是现在，让我们只关注迭代器。在上面的代码<strong class="ik hi"> __iter__ </strong>中，方法返回self，这个self就是我们调用__iter_的同一个类对象。我们通过__iter__返回self，因为我们覆盖了iter dunder函数，这样我们就可以为我们的类创建一个迭代器，并指定它的行为方式。每次调用__next__方法都会返回后面的偶数。for循环“for num in evennum(10):”的底层机制现在被覆盖，因为我们已经覆盖了我们的类的__iter__和__next__方法，所以for循环的每次迭代都将返回下一个偶数，并在捕获到__next__方法引发的StopIteration异常时立即停止。</p></div><div class="ab cl lm ln go lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ha hb hc hd he"><h2 id="d498" class="jx jy hh bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">现在让我们看看发电机。</h2><p id="a96b" class="pw-post-body-paragraph ih ii hh ik b il kv in io ip kw ir is ki kx iv iw km ky iz ja kq kz jd je jf ha bi translated"><strong class="ik hi">生成器</strong>被认为是在python中创建迭代器最方便的技术。生成器的语法类似于传统函数的语法，但不是使用<strong class="ik hi"> return </strong>语句，而是使用<strong class="ik hi"> yield </strong>语句来指示序列的每个元素。考虑下面的例子。</p><pre class="jh ji jj jk fd la lb lc ld aw le bi"><span id="bfde" class="jx jy hh lb b fi lf lg l lh li">def factors_return(n):<br/>  results = []<br/>  for k in range(1,n+1):<br/>      if n%k == 0:<br/>          results.append(k)<br/>  return results</span><span id="2cda" class="jx jy hh lb b fi lj lg l lh li"><br/>def factors_yield(n):<br/>  for k in range(1,n+1):<br/>    if n%k == 0:<br/>      yield k</span></pre><p id="1914" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is ki iu iv iw km iy iz ja kq jc jd je jf ha bi translated">在上面的代码中，可以看到关键字yield的使用。Python用这个来区分普通函数和生成器。函数factors_return(n)将返回包含所有因子的列表，而factors_yield(n)将生成一系列值，yield关键字用于迭代这些值。如果我们为factors(100)中的 <strong class="ik hi">因子编写<strong class="ik hi">:</strong>，就会创建一个生成器实例，并且对于循环的每次迭代，python都会执行factors_yield()中的过程，直到yield语句指示下一个值。此时，该过程被暂时挂起，只有在请求另一个值时才会恢复。当整个控制流到达过程的自然结尾时，会自动引发StopIteration异常。换句话说，yield语句中断过程的执行，并将一个值发送回调用者，但保持足够的状态，使过程能够从停止的地方恢复，并且当for循环请求下一个值时，过程从上一次yield运行后立即恢复其功能。与此相反，factors_return(n)将返回一个包含所有因子的列表，而不是生成一个序列，因此，如果传递一个很大的数，如100000000000000000，就会占用很大的内存。</strong></p><p id="c2ee" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is ki iu iv iw km iy iz ja kq jc jd je jf ha bi translated"><strong class="ik hi">为什么要使用迭代器和生成器？</strong></p><p id="7b87" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is ki iu iv iw km iy iz ja kq jc jd je jf ha bi translated">使用迭代器和生成器的好处是它们使用传统函数不使用的<strong class="ik hi">惰性求值、</strong>。只有在请求时才计算结果，整个系列不需要立即驻留在内存中，从而避免了与内存相关的问题。生成器可以有效地生成无限系列的值。考虑下面的一个例子。</p><pre class="jh ji jj jk fd la lb lc ld aw le bi"><span id="f5fb" class="jx jy hh lb b fi lf lg l lh li"># fibonacci using generator<br/>def fibonacci_generator(n):<br/>  a = 0<br/>  b = 1<br/>  for i in range(n):<br/>    yield a<br/>    future = a+b<br/>    a = b<br/>    b = future</span><span id="f94d" class="jx jy hh lb b fi lj lg l lh li">for i in fibonacci_generator(10000):<br/>    print(i)<br/></span><span id="3bae" class="jx jy hh lb b fi lj lg l lh li"># fibonacci using list<br/>def fibonacci_list(n):<br/>  a=0<br/>  b=1<br/>  lis = []<br/>  count = 0<br/>  while count&lt;n:<br/>     lis.append(a)<br/>     future = a+b<br/>     a=b<br/>     b=future<br/>     count+=1<br/>  return lis</span><span id="95e7" class="jx jy hh lb b fi lj lg l lh li">print(fibonacci_list(10000))</span></pre><p id="f442" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is ki iu iv iw km iy iz ja kq jc jd je jf ha bi translated">在上面的代码中，函数fibonacci_list将创建一个列表对象，并将所有fibonacci元素存储在该列表中。随着新元素被推入列表，这个列表将不断增加，导致它占据越来越多的空间。因此，在某一点之后会导致内存问题。与此相反，函数fibonacci_generator将产生一系列fibonacci数列，Fibonacci元素不会存储在列表中，而是在for循环的每次迭代后返回每个Fibonacci元素，因此不会占用内存。这样，我们就可以使用生成器生成无限的斐波那契数列。</p><p id="f905" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is ki iu iv iw km iy iz ja kq jc jd je jf ha bi translated">在为机器学习和深度学习问题加载数据时，生成器也被广泛使用。这是因为，例如，包含数千幅图像的整个数据集无法加载到内存中。因此，发电机被用来救援。考虑这个来自使用深度学习项目的图像字幕的小代码片段。</p><pre class="jh ji jj jk fd la lb lc ld aw le bi"><span id="49d3" class="jx jy hh lb b fi lf lg l lh li">def data_generator(descriptions, features, tokenizer, max_length):<br/>   while 1:<br/>    for key, description_list in descriptions.items():<br/>        feature = features[key][0]<br/>        input_image, input_sequence, output_word<br/>        create_sequences(tokenizer, max_length, description_list,   feature)<br/>        yield ([input_image, input_sequence], output_word)</span></pre><h2 id="64cb" class="jx jy hh bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">摘要</h2><p id="d273" class="pw-post-body-paragraph ih ii hh ik b il kv in io ip kw ir is ki kx iv iw km ky iz ja kq kz jd je jf ha bi translated">在本文中，我们介绍了迭代器和生成器的基础知识，以及如何实现它们。我们还讨论了为什么我们应该使用这些迭代器和生成器。</p><div class="lt lu ez fb lv lw"><a rel="noopener follow" target="_blank" href="/mlearning-ai/mlearning-ai-submission-suggestions-b51e2b130bfb"><div class="lx ab dw"><div class="ly ab lz cl cj ma"><h2 class="bd hi fi z dy mb ea eb mc ed ef hg bi translated">Mlearning.ai提交建议</h2><div class="md l"><h3 class="bd b fi z dy mb ea eb mc ed ef dx translated">如何成为Mlearning.ai上的作家</h3></div><div class="me l"><p class="bd b fp z dy mb ea eb mc ed ef dx translated">medium.com</p></div></div><div class="mf l"><div class="mg l mh mi mj mf mk jq lw"/></div></div></a></div></div></div>    
</body>
</html>