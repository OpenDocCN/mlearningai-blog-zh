<html>
<head>
<title>Modified Genetic Algorithm to solve the Zero-One Knapsack Problem</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">求解0-1背包问题的改进遗传算法</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/modified-genetic-algorithm-to-solve-the-zero-one-knapsack-problem-cc2f76d0050f?source=collection_archive---------4-----------------------#2021-09-15">https://medium.com/mlearning-ai/modified-genetic-algorithm-to-solve-the-zero-one-knapsack-problem-cc2f76d0050f?source=collection_archive---------4-----------------------#2021-09-15</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/1be61708fe3e455547dc36c5d42d664a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vtUAOpkR-YNq4BN-.jpg"/></div></div></figure><p id="a14a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi jn translated"><span class="l jo jp jq bm jr js jt ju jv di"> T </span>他的文章是我上一篇文章的第三部分:<a class="ae jw" href="https://shashank3199.medium.com/genetic-algorithms-to-solve-the-zero-one-knapsack-problem-d38856beaa35" rel="noopener">遗传算法解决零一背包问题</a>。请在继续阅读本文之前阅读那篇文章，以便更好地理解这个概念。本系列的第二篇文章讨论了0-1背包问题的传统遗传算法的实现，点击这里查看文章<a class="ae jw" href="https://shashank3199.medium.com/genetic-algorithms-to-solve-the-zero-one-knapsack-problem-implementation-26c1982f44b3" rel="noopener"/>。</p><p id="1c2e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这篇文章中，我们将讨论一种改进的遗传算法，这种改进的遗传算法受到遗传算法的两种变体的启发，每种变体都采用了与传统算法不同的方法。这种改进的遗传算法已经由<a class="ae jw" href="https://ieeexplore.ieee.org/author/37086354115" rel="noopener ugc nofollow" target="_blank"> Mojtaba Montazeri </a>、<a class="ae jw" href="https://ieeexplore.ieee.org/author/37086354555" rel="noopener ugc nofollow" target="_blank"> Rasoul Kiani </a>和<a class="ae jw" href="https://ieeexplore.ieee.org/author/37086355185" rel="noopener ugc nofollow" target="_blank"> Seyed Saleh Rastkhadiv </a>在这里发表。<br/>现在，不要再拖延了，让我们开始吧……</p><h1 id="38ef" class="jx jy hh bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">基于重启遗传算法</h1><p id="b427" class="pw-post-body-paragraph ip iq hh ir b is kv iu iv iw kw iy iz ja kx jc jd je ky jg jh ji kz jk jl jm ha bi translated">简而言之，这种实现与传统方法相同，唯一的区别在于，在收敛点(即，当算法未能提高获胜者基因组的质量时的点)期间，当阈值未被达到时，这种版本的遗传算法引入新的随机群体，而来自上一代的获胜者继续在新的循环中。</p><h1 id="fa1d" class="jx jy hh bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">岛屿遗传算法-</h1><p id="2e47" class="pw-post-body-paragraph ip iq hh ir b is kv iu iv iw kw iy iz ja kx jc jd je ky jg jh ji kz jk jl jm ha bi translated">该算法是传统遗传算法的并行版本，具有执行<em class="la">“k”</em>单独遗传算法的<em class="la">“k”</em>单独世代。然而，这种方法的主要亮点是他们可以一起分享最佳答案。除了速度之外，这个版本的主要优点是在交叉和变异操作中的随机性。</p><p id="2c04" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">另一种思考方式是，在传统的遗传算法中，我们运行“k”个并行交叉和变异操作。这在算法的进化阶段给了我们更多的多样性。</p><p id="f5b5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在让我们转到这篇文章的主要亮点，即…..</p><h1 id="f915" class="jx jy hh bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">改进的遗传算法-</h1><p id="9131" class="pw-post-body-paragraph ip iq hh ir b is kv iu iv iw kw iy iz ja kx jc jd je ky jg jh ji kz jk jl jm ha bi translated"><a class="ae jw" href="https://ieeexplore.ieee.org/document/8324863" rel="noopener ugc nofollow" target="_blank">论文</a>提出了改进的遗传算法，作为前面提到的两个版本的混合。所提出的解决方案旨在运行“M”个并行遗传算法，每个并行遗传算法针对“子循环”次数的迭代具有“子”种群大小，以获得“子”集合的局部最优解。<br/>这些子程序中的每一个都返回一个染色体“C ”,对应于这些不同分区的局部最优值。然后这些染色体最终被用作外部遗传算法的优势种群，以生成优势染色体，这被认为是最终结果。因为“subM”值很小，所以可以很快达到局部最优。</p><p id="6a16" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为了更好地理解这种方法，让我们试着用下面的图片来理解它</p><figure class="lc ld le lf fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lb"><img src="../Images/a7e909ec75ec6e60c2433581abbebeb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*8KDX-AuW0FHiioInmUZKMw.gif"/></div></div></figure><p id="76e6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">上图有多个局部最小值，这对传统方法构成了威胁。为了解决这个问题，我们首先将图的x轴(即搜索空间)分成“M”个子集，每个子集具有“subM”个群体大小。接下来，我们对每个子集运行“M”个并行遗传算法。这给了我们每个“M”子集的局部最小值。然后，我们使用这些“M”个获胜者作为我们的种群，并在这个“优势种群”上运行外部遗传算法，以找到全局最小值。</p><p id="be80" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">本文的主要目的是克服遗传算法的两个主要限制，即</p><ul class=""><li id="747d" class="lg lh hh ir b is it iw ix ja li je lj ji lk jm ll lm ln lo bi translated">高时间复杂度</li><li id="5c1d" class="lg lh hh ir b is lp iw lq ja lr je ls ji lt jm ll lm ln lo bi translated">无法摆脱局部最优</li></ul><p id="d969" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">所提出的算法通过实现以下内容来解决这些问题</p><ul class=""><li id="1b6e" class="lg lh hh ir b is it iw ix ja li je lj ji lk jm ll lm ln lo bi translated">运行并行线程以降低时间复杂度。</li><li id="b2a9" class="lg lh hh ir b is lp iw lq ja lr je ls ji lt jm ll lm ln lo bi translated">每个线程在搜索空间的一个子集上工作，这有助于避免收敛于局部最优。</li></ul><p id="5038" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在让我们通过比较它们各自的伪代码来比较修改版本和传统算法</p><figure class="lc ld le lf fd ii er es paragraph-image"><div class="er es lu"><img src="../Images/4d01a9a780cf352ace3173d0bd9bbf0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*jMX6uMn6nvndpi58f_wfdw.png"/></div><figcaption class="lv lw et er es lx ly bd b be z dx">Traditional Genetic Algorithm</figcaption></figure><figure class="lc ld le lf fd ii er es paragraph-image"><div class="er es lz"><img src="../Images/f0e9fea052ce8ef04626d6635a01da78.png" data-original-src="https://miro.medium.com/v2/resize:fit:732/format:webp/1*akz80Vdrx3ntG3eB0esoGw.png"/></div><figcaption class="lv lw et er es lx ly bd b be z dx">Proposed Genetic Algorithm</figcaption></figure><p id="e232" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> <em class="la">结论:</em> </strong>在对一组测试用例评估了所提出的算法之后，凭着一些直觉，我们能够得出结论，所提出的算法在准确性和时间复杂度方面确实优于传统方法。</p></div><div class="ab cl ma mb go mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ha hb hc hd he"><p id="342b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="la">你可以在</em> <a class="ae jw" href="https://github.com/shashank3199/GeneticAlgorithm-ZeroOneKnapsack/blob/main/restart_base_genetic_algorithm.py" rel="noopener ugc nofollow" target="_blank"> <em class="la">重启-基础遗传算法</em> </a> <em class="la">、</em> <a class="ae jw" href="https://github.com/shashank3199/GeneticAlgorithm-ZeroOneKnapsack/blob/main/island_genetic_algorithm.py" rel="noopener ugc nofollow" target="_blank"> <em class="la">孤岛遗传算法</em> </a> <em class="la">、</em> <a class="ae jw" href="https://github.com/shashank3199/GeneticAlgorithm-ZeroOneKnapsack/blob/main/modified_genetic_algorithm.py" rel="noopener ugc nofollow" target="_blank"> <em class="la">改良遗传算法</em> </a> <em class="la">找到上述各种遗传算法的Python实现。如果你觉得这篇文章很有帮助，请跟我上</em> <a class="ae jw" href="https://shashank-goyal-blogs.medium.com/" rel="noopener"> <em class="la">中</em> </a> <em class="la">和</em><a class="ae jw" href="https://github.com/shashank3199/" rel="noopener ugc nofollow" target="_blank"><em class="la">GitHub</em></a><em class="la">和star</em><a class="ae jw" href="https://github.com/shashank3199/GeneticAlgorithm-ZeroOneKnapsack" rel="noopener ugc nofollow" target="_blank"><em class="la">项目库</em> </a> <em class="la">。</em></p></div><div class="ab cl ma mb go mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ha hb hc hd he"><p id="2b14" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">请查看本系列文章的其他部分</p><ul class=""><li id="62ae" class="lg lh hh ir b is it iw ix ja li je lj ji lk jm ll lm ln lo bi translated"><strong class="ir hi"> <em class="la">第一部分:</em> </strong> <a class="ae jw" href="https://shashank3199.medium.com/genetic-algorithms-to-solve-the-zero-one-knapsack-problem-d38856beaa35" rel="noopener">遗传算法求解零一背包问题</a>。</li><li id="1bac" class="lg lh hh ir b is lp iw lq ja lr je ls ji lt jm ll lm ln lo bi translated"><strong class="ir hi"> <em class="la">第二部分:</em> </strong> <a class="ae jw" href="https://shashank3199.medium.com/genetic-algorithms-to-solve-the-zero-one-knapsack-problem-implementation-26c1982f44b3" rel="noopener">遗传算法求解零一背包问题:实现</a>。</li><li id="687d" class="lg lh hh ir b is lp iw lq ja lr je ls ji lt jm ll lm ln lo bi translated"><strong class="ir hi"> <em class="la">第四部分:</em> </strong> <a class="ae jw" href="https://shashank3199.medium.com/modified-genetic-algorithm-to-solve-the-zero-one-knapsack-problem-implementation-72d85c1c72" rel="noopener">改进的遗传算法求解零一背包问题:实现</a>。</li></ul></div></div>    
</body>
</html>