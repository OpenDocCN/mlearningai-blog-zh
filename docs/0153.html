<html>
<head>
<title>Coding Dijkstra’s Algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编码Dijkstra算法</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/coding-dijkstras-algorithm-97cc6f2fbd50?source=collection_archive---------4-----------------------#2021-02-22">https://medium.com/mlearning-ai/coding-dijkstras-algorithm-97cc6f2fbd50?source=collection_archive---------4-----------------------#2021-02-22</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="eb15" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在本文中，我们将讨论如何编写Dijkstra算法的代码。查看我之前关于Dijkstra算法的<a class="ae jc" rel="noopener" href="/@riya.tendulkar16/solving-single-source-shortest-path-using-dijkstras-algorithm-c2348eea3183">文章</a>了解算法。就时间复杂度而言，我不会说这是最有效的代码，但它非常容易理解，所以如果你是编码新手，那么这段代码就是为你准备的！</p><h1 id="92f4" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">邻接矩阵</h1><p id="2126" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">在我们编写算法之前，我们需要理解什么是邻接矩阵。邻接矩阵是用来表示有限图的方阵。该矩阵表示两个节点是否相邻，即两个节点之间是否有具有某种权重的边。如果节点不相邻，那么对于这些节点，矩阵将具有无穷大的值。</p><p id="7e86" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们看一个例子:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es kg"><img src="../Images/1552a7fdf81f1e584e5d4d0636240f49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t8df_PNRZbsFBQbPrjbAqQ.jpeg"/></div></div><figcaption class="ks kt et er es ku kv bd b be z dx">A directed weighted graph</figcaption></figure><p id="7158" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对于此图，邻接矩阵将为:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es kw"><img src="../Images/f8e080aabf361819843691b543a6b3ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:730/format:webp/1*IUx2DnUVB2NzVscBtUQemQ.png"/></div><figcaption class="ks kt et er es ku kv bd b be z dx">Adjacency Matrix for the above graph.</figcaption></figure><p id="f3a2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">正如我们所看到的，对角线的值为0，这是因为对角线代表节点本身之间的距离，这将是0(例如，从A到A的距离将是0)。凡是有“inf”的地方，表示各个节点之间没有边，不相邻。</p><p id="0faf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">要查找两个节点之间的距离，只需检查节点所在行和列中的值。例如，如果我们想知道从C到E的距离，那么在C行中检查E列，也就是2。要找出从E到C的距离，在E行检查C列，因为C列是无穷大，所以没有边连接它们。</p><h1 id="62d4" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">编码Dijkstra的</h1><p id="683f" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">现在让我们开始编码算法。我们将做的事情和我在上一篇文章中解释的完全一样。代码是用C++写的。</p><p id="0088" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">正如我们在算法中看到的，我们维护一个表来跟踪最短距离和父节点。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es kx"><img src="../Images/9a8a6c4d1e9c428e8d45b82bf20044c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/0*X2oUYTnBK7zDW-sN.jpeg"/></div><figcaption class="ks kt et er es ku kv bd b be z dx">Initial table for Dijkstra’s algorithm</figcaption></figure><p id="cec6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们将在代码中做同样的事情，我们维护一个<strong class="ig hi">二维数组</strong>，其中数组的行对应于节点，索引是节点号，列对应于访问过的节点、当前最短距离和父节点。</p><h2 id="3af8" class="ky je hh bd jf kz la lb jj lc ld le jn ip lf lg jr it lh li jv ix lj lk jz ll bi translated">接受输入</h2><p id="cd6a" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">我们需要输入顶点和邻接矩阵。在获取邻接矩阵的边值时，我们需要确保用户不会输入负值。</p><p id="96f5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">正如我们所知，当两个节点之间没有边时，它们之间的距离是无穷大。为了在代码中表示无穷大，我使用了数字2147483647。原因是C++ 中的<a class="ae jc" href="https://docs.microsoft.com/en-us/cpp/c-language/cpp-integer-limits?view=msvc-160" rel="noopener ugc nofollow" target="_blank">最大整数值基本上是无穷大。但是我们不能要求用户每次都输入这么长的数字，所以我要求用户输入-1表示没有边，稍后我会将它转换为无穷大(2147483647)。</a></p><p id="3c65" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下面的代码片段接受用户输入的顶点和邻接矩阵，并检查输入的权重是否正确。</p><pre class="kh ki kj kk fd lm ln lo lp aw lq bi"><span id="9a1a" class="ky je hh ln b fi lr ls l lt lu"> int n; //n stores the number of vertices <br/> cout&lt;&lt;”Enter the number of vertices in the graph: “;<br/> cin&gt;&gt;n;</span><span id="f5e9" class="ky je hh ln b fi lv ls l lt lu"> char vertices[n]; //to store the vertices names </span><span id="7a11" class="ky je hh ln b fi lv ls l lt lu"> int adjacency[n][n]; //adjacency matrix </span><span id="636b" class="ky je hh ln b fi lv ls l lt lu"> int vertex; //storing the source node <br/> <br/> //Inputing the vertices<br/> cout&lt;&lt;”Enter the vertrices names: “&lt;&lt;endl;<br/> for(int i=0;i&lt;n;i++)<br/> {<br/>     cin&gt;&gt;vertices[i];<br/> }<br/> <br/> //Inputing adajency matrix<br/> cout&lt;&lt;”Enter the adjacency matrix(distance between vertices)(Enter -1 for no link-inf): “&lt;&lt;endl;<br/> for(int i=0;i&lt;n;i++)<br/> {<br/>     int input;<br/>     for(int j=0;j&lt;n;j++)<br/>     {<br/>        cout&lt;&lt;”Distance between “&lt;&lt;vertices[i]&lt;&lt;” and “&lt;&lt;vertices[j]<br/>         &lt;&lt;” : “; <br/>        cin&gt;&gt;input;<br/> <br/>         //As in dijkstras , the graph can have only positive <br/>           weight, we check if the input is correct<br/>          if (input&lt;-1)<br/>          {<br/>             cout&lt;&lt;”Distance can not be negative! Enter<br/>             again”&lt;&lt;endl;<br/>             j=j-1;<br/>          }<br/>          else if(i==j&amp;&amp;input!=0)<br/>         {<br/>            cout&lt;&lt;”Distance between the node and the node itself<br/>            will always be 0! Changing the value to 0.”&lt;&lt;endl;<br/>            input=0;<br/>         } <br/>         else<br/>         {<br/>           adjacency[i][j]=input;<br/>           //Changing the value of -1 to infinity <br/>           if (adjacency[i][j]==-1)<br/>           {<br/>              adjacency[i][j]=2147483647;<br/>           }<br/>         } <br/>      }<br/>   }</span></pre><p id="23e7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在我们还需要询问用户哪个节点将是源节点，这是下一步。我写了一个函数来查找源节点。代码将检查用户给定的源节点是否出现在代码中，否则将显示一条错误消息。用户将给出顶点的名称，所以我们需要找到源节点的索引。</p><pre class="kh ki kj kk fd lm ln lo lp aw lq bi"><span id="fbca" class="ky je hh ln b fi lr ls l lt lu">do <br/> {<br/>  vertex=sourceNode(vertices,n);<br/>  if(vertex==-1)<br/>  {<br/>  cout&lt;&lt;"Source node not available!"&lt;&lt;endl;<br/>  }<br/> }while(vertex==-1);</span></pre><p id="cff3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">查找源节点的函数是:</p><pre class="kh ki kj kk fd lm ln lo lp aw lq bi"><span id="1364" class="ky je hh ln b fi lr ls l lt lu">int sourceNode(char vertices[],int n)<br/>{<br/>     //Inputing the source node <br/>     char vertexNode;<br/>     cout&lt;&lt;”Enter the source node: “;<br/>     cin&gt;&gt;vertexNode;<br/> <br/>     //Finding the index value of the source node<br/>     for(int i=0;i&lt;n;i++)<br/>     {<br/>       if (vertices[i]==vertexNode)<br/>       {<br/>          return i;<br/>       }<br/>     }<br/>     return -1;<br/>}</span></pre><p id="b34c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果不想接受用户的输入，可以跳过上面的代码片段，直接给出硬编码的输入。我使用了上面显示的图表作为例子。</p><pre class="kh ki kj kk fd lm ln lo lp aw lq bi"><span id="575f" class="ky je hh ln b fi lr ls l lt lu">int adjacency[6][6]={{0,1,5,2147483647,2147483647,2147483647},<br/> {2147483647,0,2,2,1,2147483647},<br/> {2147483647,2147483647,0,2147483647,2,2147483647},<br/> {2147483647,2147483647,2147483647,0,3,1},<br/> {2147483647,2147483647,2147483647,2147483647,0,2},<br/> {2147483647,2147483647,2147483647,2147483647,2147483647,0}};<br/> char vertices[6]={‘A’,’B’,’C’,’D’,’E’,’F’};<br/> int n=6;<br/> int vertex=0;</span></pre><p id="603a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在硬编码输入中，你不需要问源代码。在这个例子中，我将源节点命名为“A ”,其索引号为0(见顶点数组)。</p><p id="43e7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了对算法进行编码，我们将使用一个表示表格的二维数组。数组<em class="lw"> dijkstraMatrix </em>的行数=节点数，列数=3。第一列是<em class="lw">访问过的</em>列，其初始值为0。第二列是<em class="lw">距离</em>列，其初始值为无穷大。最后一列的父列<em class="lw">最初被设置为0。如您所见，该矩阵与上表相似。</em></p><pre class="kh ki kj kk fd lm ln lo lp aw lq bi"><span id="2f34" class="ky je hh ln b fi lr ls l lt lu">//Initializing the dijkstras matrix: visited=0, distance=inifinty, parent=0<br/> for(int i=0;i&lt;n;i++)<br/> {<br/>       dijkstraMatrix[i][0]=0;<br/>       dijkstraMatrix[i][1]=2147483647;<br/>       dijkstraMatrix[i][2]=0;<br/> }</span></pre><p id="1978" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">尽管我们已经为所有节点设置了相同的初始条件，但我们知道对于源节点，距离将为0，因此我们进行了更改。</p><pre class="kh ki kj kk fd lm ln lo lp aw lq bi"><span id="44de" class="ky je hh ln b fi lr ls l lt lu">//Making the distance for the source node as 0 <br/> dijkstraMatrix[vertex][1]=0;</span></pre><p id="d238" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，我们需要做的下一件事是遍历邻接矩阵，并检查每个节点的当前最短距离。</p><pre class="kh ki kj kk fd lm ln lo lp aw lq bi"><span id="a044" class="ky je hh ln b fi lr ls l lt lu">for(int i=0;i&lt;n;i++)<br/> {<br/>     int min=2147483647;<br/>     for(int j=0;j&lt;n;j++)<br/>     {<br/>        if (dijkstraMatrix[j][0]==0)<br/>        {<br/>           if(dijkstraMatrix[j][1]&lt;=min)<br/>           {<br/>               min=dijkstraMatrix[j][1];<br/>               vertex=j;<br/>           }<br/>        }<br/>     }<br/>   <br/>     dijkstraMatrix[vertex][0]=1;<br/>     for (int k=0;k&lt;n;k++)<br/>     {<br/>       if(dijkstraMatrix[k][0]==0) //checking for visited<br/>       {<br/>          if(adjacency[vertex][k]!=2147483647&amp;&amp;adjacency[vertex][k]+<br/>             dijkstraMatrix[vertex][1]&lt;=dijkstraMatrix[k][1]        <br/>         {<br/>            dijkstraMatrix[k][1]=adjacency[vertex][k]<br/>            +dijkstraMatrix[vertex][1]; //alloting the distance <br/>            dijkstraMatrix[k][2]=vertex; //alloting the parent <br/>         }<br/>       }<br/>     }<br/> }</span></pre><p id="38d7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们详细看看上面的代码片段。在算法中，为了考虑下一个顶点，我们在表的距离列中取未被访问的并且具有最短距离值的顶点。</p><p id="c579" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第一个<em class="lw"> for </em>循环(代码的第2行)遍历n个节点的整个邻接矩阵。然后，我们首先检查节点是否未被访问(第4行)，即Dijkstra表的第一列(第0列)是否为0。如果它是零，那么我们将它与当前的最小值进行比较，如果它小于当前的最小值，那么这个顶点将成为下一个最小值。如此进行比较，直到检查完所有未访问的节点。</p><pre class="kh ki kj kk fd lm ln lo lp aw lq bi"><span id="16db" class="ky je hh ln b fi lr ls l lt lu">     int min=2147483647;<br/>     for(int j=0;j&lt;n;j++)<br/>     {<br/>        if (dijkstraMatrix[j][0]==0)<br/>        {<br/>           if(dijkstraMatrix[j][1]&lt;=min)<br/>           {<br/>               min=dijkstraMatrix[j][1];<br/>               vertex=j;<br/>           }<br/>        }<br/>     }</span></pre><p id="3730" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这个<em class="lw"> for </em>循环终止后，我们将得到一个顶点，它将是我们考虑的下一个顶点。所以我们把这个顶点的访问次数改为1。</p><pre class="kh ki kj kk fd lm ln lo lp aw lq bi"><span id="cd4c" class="ky je hh ln b fi lr ls l lt lu">dijkstraMatrix[vertex][0]=1;</span></pre><p id="9a17" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在我们检查顶点的所有相邻的未访问节点。为此，我们首先遍历dijkstraMatrix并检查未访问的节点。如果一个节点未被访问，我们检查它是否与当前选择的顶点相邻，即在邻接矩阵中顶点和节点之间是否有距离值(不等于无穷大)。如果节点和顶点是相邻的，那么我们检查表中顶点的距离值和节点与顶点之间的距离之和是否小于表中节点的当前距离值。如果小于这个值，我们就更新这个表，改变这个节点的距离值，同时更新作为顶点的父值。</p><pre class="kh ki kj kk fd lm ln lo lp aw lq bi"><span id="5c26" class="ky je hh ln b fi lr ls l lt lu">for (int k=0;k&lt;n;k++)<br/>{<br/>   if(dijkstraMatrix[k][0]==0) //checking for unvisited nodes<br/>   {</span><span id="7d85" class="ky je hh ln b fi lv ls l lt lu">     /* checking if there is an edge between the node and the vertex <br/>        and if the (distance value of vertex + edge (vertex, node))<br/>        &lt; distance value of node*/</span><span id="0c1d" class="ky je hh ln b fi lv ls l lt lu">     if(adjacency[vertex][k]!=2147483647&amp;&amp;adjacency[vertex][k]+<br/>         dijkstraMatrix[vertex][1]&lt;=dijkstraMatrix[k][1]        <br/>     {<br/>         //Updating the distance and parent value for the node<br/>         dijkstraMatrix[k][1]=adjacency[vertex][k]<br/>         +dijkstraMatrix[vertex][1]; //allocating the distance                    <br/>         dijkstraMatrix[k][2]=vertex; //allocating the parent <br/>     }<br/>   }<br/>}</span></pre><p id="ce11" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对图中的所有节点重复上述步骤，然后我们将得到最终的矩阵。</p><p id="0bc4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">您可以使用此代码打印Dijkstra表:</p><pre class="kh ki kj kk fd lm ln lo lp aw lq bi"><span id="0a04" class="ky je hh ln b fi lr ls l lt lu">cout&lt;&lt;”Dijkstra’s Table: “&lt;&lt;endl;<br/> cout&lt;&lt;”___________________________________________________________”&lt;&lt;endl;<br/> cout&lt;&lt;”Vertex”&lt;&lt;”\t\t”&lt;&lt;”Visited”&lt;&lt;”\t\t”&lt;&lt;”Distance”&lt;&lt;”\t”&lt;&lt;”Parent”&lt;&lt;endl;<br/> cout&lt;&lt;”___________________________________________________________”&lt;&lt;endl;<br/> int minimumDistance=0;<br/> for(int i=0;i&lt;n;i++)<br/>{<br/>   cout&lt;&lt;vertices[i]&lt;&lt;”\t\t”&lt;&lt;dijkstraMatrix[i][0]&lt;&lt;”\t\t”;<br/>   if(dijkstraMatrix[i][1]==2147483647)<br/>   {<br/>     cout&lt;&lt;”inf”;<br/>   }<br/>   else<br/>   {<br/>     cout&lt;&lt;dijkstraMatrix[i][1];<br/>   }<br/> cout&lt;&lt;”\t\t”&lt;&lt;vertices[dijkstraMatrix[i][2]]&lt;&lt;”\t”&lt;&lt;endl;<br/>}</span></pre><p id="35c5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">以下是最终的组合代码:</p><pre class="kh ki kj kk fd lm ln lo lp aw lq bi"><span id="5267" class="ky je hh ln b fi lr ls l lt lu">#include&lt;iostream&gt;<br/>using namespace std;</span><span id="ffd0" class="ky je hh ln b fi lv ls l lt lu">//Function to print the table<br/>void printTable(int dijkstraMatrix[][3],int n,char vertices[])<br/>{<br/> cout&lt;&lt;”Dijkstra’s Table: “&lt;&lt;endl;<br/> cout&lt;&lt;”___________________________________________________________”&lt;&lt;endl;<br/> cout&lt;&lt;”Vertex”&lt;&lt;”\t\t”&lt;&lt;”Visited”&lt;&lt;”\t\t”&lt;&lt;”Distance”&lt;&lt;”\t”&lt;&lt;”Parent”&lt;&lt;endl;<br/> cout&lt;&lt;”___________________________________________________________”&lt;&lt;endl;<br/> int minimumDistance=0;<br/> for(int i=0;i&lt;n;i++)<br/> {<br/>   cout&lt;&lt;vertices[i]&lt;&lt;”\t\t”&lt;&lt;dijkstraMatrix[i][0]&lt;&lt;”\t\t”;<br/>   if(dijkstraMatrix[i][1]==2147483647)<br/>   {<br/>      cout&lt;&lt;”inf”;<br/>   }<br/>   else<br/>   {<br/>     cout&lt;&lt;dijkstraMatrix[i][1];<br/>   }<br/>   cout&lt;&lt;”\t\t”&lt;&lt;vertices[dijkstraMatrix[i][2]]&lt;&lt;”\t”&lt;&lt;endl;<br/>  }<br/>}</span><span id="29fe" class="ky je hh ln b fi lv ls l lt lu">int sourceNode(char vertices[],int n)<br/>{<br/> //Inputing the source node <br/> char vertexNode;<br/> cout&lt;&lt;”Enter the source node: “;<br/> cin&gt;&gt;vertexNode;<br/> <br/> //Finding the index value of the source node<br/> for(int i=0;i&lt;n;i++)<br/> {<br/>   if (vertices[i]==vertexNode)<br/>   {<br/>      return i;<br/>   }<br/> }<br/> return -1;<br/>}<br/>int main()<br/>{<br/> int n; //n stores the number of vertices <br/> cout&lt;&lt;”Enter the number of vertices in the graph: “;<br/> cin&gt;&gt;n;<br/> char vertices[n]; //to store the vertices names <br/> int adjacency[n][n]; //adjacency matrix <br/> int vertex=0; //storing the source node <br/> <br/> //Inputing the vertices<br/> cout&lt;&lt;”Enter the vertrices names: “&lt;&lt;endl;<br/> for(int i=0;i&lt;n;i++)<br/> {<br/>   cin&gt;&gt;vertices[i];<br/> }<br/> <br/> //Inputing adajency matrix<br/> cout&lt;&lt;”Enter the adjacency matrix(distance between vertices)(Enter -1 for no link-inf): “&lt;&lt;endl;<br/> for(int i=0;i&lt;n;i++)<br/> {<br/>   int input;<br/>   for(int j=0;j&lt;n;j++)<br/>   {<br/>      cout&lt;&lt;”Distance between “&lt;&lt;vertices[i]&lt;&lt;” and “&lt;&lt;vertices[j]&lt;&lt;” : “; <br/>      cin&gt;&gt;input;<br/> <br/>      //As in dijkstras , the graph can have only positive weight, <br/>       we check if the input is correct<br/>      if (input&lt;-1)<br/>      {<br/>         cout&lt;&lt;”Distance can not be negative! Enter again”&lt;&lt;endl;<br/>         j=j-1;<br/>      }<br/>      else if(i==j&amp;&amp;input!=0)<br/>     {<br/>        cout&lt;&lt;”Distance between the node and the node itself will<br/>        always be 0! Changing the value to 0.”&lt;&lt;endl;<br/>        input=0;<br/>     } <br/>     else<br/>     {<br/>       adjacency[i][j]=input;<br/>       //Changing the value of -1 to infinity <br/>       if (adjacency[i][j]==-1)<br/>       {<br/>          adjacency[i][j]=2147483647;<br/>       }<br/>     } <br/>   }<br/>   cout&lt;&lt;endl;<br/> }<br/> <br/> <br/> <br/> <br/> do <br/> {<br/> vertex=sourceNode(vertices,n);<br/> if(vertex==-1)<br/> {<br/> cout&lt;&lt;”Source node not available!”&lt;&lt;endl;<br/> }<br/> }while(vertex==-1);<br/> <br/> <br/> /*<br/> If you want to skip the user input and hardcode the value, you can use this code snippet(comment the earlier part). Here I have used the graph shown in the example.<br/> int adjacency[6][6]={{0,1,5,2147483647,2147483647,2147483647},<br/> {2147483647,0,2,2,1,2147483647},<br/> {2147483647,2147483647,0,2147483647,2,2147483647},<br/> {2147483647,2147483647,2147483647,0,3,1},<br/> {2147483647,2147483647,2147483647,2147483647,0,2},<br/> {2147483647,2147483647,2147483647,2147483647,2147483647,0}};<br/> char vertices[6]={‘A’,’B’,’C’,’D’,’E’,’F’};<br/> int n=6;<br/> int vertex=0;<br/> */<br/> <br/> <br/> /*<br/> The dijkstra’s array will have row=number of nodes and 3 columns. The columns will be similiar to the table we have used in the example<br/> column 0 -&gt; visited value<br/> column 1 -&gt; distance value<br/> column 2 -&gt; parent<br/> */<br/> <br/> int dijkstraMatrix[n][3];<br/> <br/> //Initializing the dijkstras matrix: visited=0, distance=inifinty, parent=0<br/> for(int i=0;i&lt;n;i++)<br/> {<br/> dijkstraMatrix[i][0]=0;<br/> dijkstraMatrix[i][1]=2147483647;<br/> dijkstraMatrix[i][2]=0;<br/> }<br/> cout&lt;&lt;endl;<br/> <br/> //Making the distacnce for the source node as 0 <br/> dijkstraMatrix[vertex][1]=0;<br/> <br/> //finding the minimum distance among the the non visited vertices<br/> for(int i=0;i&lt;n;i++)<br/> {<br/> int min=2147483647;<br/> for(int j=0;j&lt;n;j++)<br/> {<br/> if (dijkstraMatrix[j][0]==0)<br/> {<br/> if(dijkstraMatrix[j][1]&lt;=min)<br/> {<br/> min=dijkstraMatrix[j][1];<br/> vertex=j;<br/> }<br/> }<br/> }<br/> <br/> //Changing the visited of the current vertex as 1<br/> dijkstraMatrix[vertex][0]=1;<br/> <br/> <br/> //checking for the adjacent unvisited nodes of the current vertex<br/> for (int k=0;k&lt;n;k++)<br/> {<br/> if(dijkstraMatrix[k][0]==0) //checking for visited<br/> {<br/> <br/> <br/> /* checking if there is an edge between the node and the vertex <br/> and if the (distance value of vertex + edge (vertex, node))&lt; distance value of node*/<br/> if(adjacency[vertex][k]!=2147483647&amp;&amp;adjacency[vertex][k]+dijkstraMatrix[vertex][1]&lt;=dijkstraMatrix[k][1])<br/> {<br/> dijkstraMatrix[k][1]=adjacency[vertex][k]+dijkstraMatrix[vertex][1]; //allocating the distance <br/> dijkstraMatrix[k][2]=vertex; //allocating the parent <br/> }<br/> }<br/> }<br/> <br/> //The next two lines are for printing the table after every node, if you don’t want that you can just comment the next 2 lines<br/> cout&lt;&lt;”For vertex: “&lt;&lt;vertices[vertex]&lt;&lt;endl;<br/> printTable(dijkstraMatrix,n,vertices); <br/> cout&lt;&lt;endl; <br/> }<br/> <br/> //Printing the final table<br/> cout&lt;&lt;”***SOLUTION**”&lt;&lt;endl;<br/> printTable(dijkstraMatrix,n,vertices);<br/> <br/>}</span></pre><p id="ec64" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">你可以在我的GitHub链接上查看代码-<a class="ae jc" href="https://github.com/riya1620/Dijkstra-s-Algorithm" rel="noopener ugc nofollow" target="_blank">https://github.com/riya1620/Dijkstra-s-Algorithm</a></p></div></div>    
</body>
</html>