<html>
<head>
<title>Train and Test Data Split</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">训练和测试数据分割</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/train-and-test-data-split-152bad0afbb2?source=collection_archive---------1-----------------------#2021-07-06">https://medium.com/mlearning-ai/train-and-test-data-split-152bad0afbb2?source=collection_archive---------1-----------------------#2021-07-06</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="96d4" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">对于ML型号</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/cb967e270d316717e69a9230a300f00e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pEKWlj1BRf3IKclpOQYpgw.png"/></div></div></figure><p id="12e1" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">收到数据后，您应该做的第一步是将数据集一分为二。最常见的比例是80:20。</p><p id="8da9" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这样做是为了让我们或我们的模型看不到一组特定的数据，并留在一边测试我们训练好的模型。并且较大的集合总是用于训练，而后者用于测试。</p><blockquote class="ke kf kg"><p id="197f" class="ji jj kh jk b jl jm ii jn jo jp il jq ki js jt ju kj jw jx jy kk ka kb kc kd ha bi translated">当我们不分割数据集时会发生什么？</p></blockquote><p id="4544" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">然后，我们将不得不在训练模型的同一个数据集上进行测试。虽然这在我们测试时会给我们很高的精确度，但这不是一个好的模型。这可能意味着我们的模型过度拟合，对于任何以前未见过的数据可能表现不佳。</p><p id="0a1c" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">过度拟合是指模型对数据的描述过于精确。下图解释了过度拟合。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es kl"><img src="../Images/dac4028952b98706398ff8965728988e.png" data-original-src="https://miro.medium.com/v2/resize:fit:754/format:webp/1*NJnMs89pwUO9ZjORpXBohA.png"/></div><figcaption class="km kn et er es ko kp bd b be z dx">The blue line represents a linear model overfitted to exactly replicate the training data this will always give correct label values for the features that it is trained on but when we give a new unseen value it may give a value far off from the optimal value. We always want our model to be like the black line which is much more generalized. It will give some error for trined values but will give reliable values for any unseen data also. <a class="ae kq" href="https://www.wikiwand.com/en/Overfitting" rel="noopener ugc nofollow" target="_blank">Image credit WIKI</a></figcaption></figure></div><div class="ab cl kr ks go kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ha hb hc hd he"><blockquote class="ke kf kg"><p id="0308" class="ji jj kh jk b jl jm ii jn jo jp il jq ki js jt ju kj jw jx jy kk ka kb kc kd ha bi translated">现在我们已经理解了拆分数据的必要性，让我们看看如何做到这一点。</p></blockquote><h2 id="315a" class="ky kz hh bd la lb lc ld le lf lg lh li jr lj lk ll jv lm ln lo jz lp lq lr ls bi translated">使用Python</h2><p id="7aba" class="pw-post-body-paragraph ji jj hh jk b jl lt ii jn jo lu il jq jr lv jt ju jv lw jx jy jz lx kb kc kd ha bi translated">在这里，我们将使用python来实现一个函数，它将为我们完成这种拆分。</p><p id="ff89" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">首先，我们需要一个数据集。我们将使用pandas创建一个样本数据框。</p><pre class="ix iy iz ja fd ly lz ma mb aw mc bi"><span id="90d5" class="ky kz hh lz b fi md me l mf mg"><strong class="lz hi">import</strong> pandas <strong class="lz hi">as</strong> pd</span><span id="0bcd" class="ky kz hh lz b fi mh me l mf mg"><strong class="lz hi">df</strong> = pd.DataFrame({‘Temprature’: [98.3, 99.8, 97.3,96.4, 92.5 ], ‘Humidity’: [0.23, 0.67, 1.7, 0.8, 1.3], ‘Rained’ : [0, 0, 1, 1, 1]})<br/><strong class="lz hi">print(</strong>df<strong class="lz hi">)</strong></span></pre><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mi"><img src="../Images/4543e8b934895a8a6fb02ba8c2efc3f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XCWppxNAgzni4b-bZk6MQA.png"/></div></div><figcaption class="km kn et er es ko kp bd b be z dx">This sample data tells us the temperature, humidity and if it has rained on that particular day</figcaption></figure><p id="059e" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">现在，我们可以编写一个函数，将数据和拆分比率作为参数，并返回两个数据集，一个用于测试，一个用于训练。为此，我们将使用NumPy。</p><pre class="ix iy iz ja fd ly lz ma mb aw mc bi"><span id="b867" class="ky kz hh lz b fi md me l mf mg"><strong class="lz hi">import</strong> numpy <strong class="lz hi">as</strong> np</span><span id="d5ed" class="ky kz hh lz b fi mh me l mf mg"><em class="kh"># mannual basic train test spliting funtion</em><br/><strong class="lz hi">def split_train_test(</strong>data, test_ratio<strong class="lz hi">)</strong>:<br/> shuffled_indicies = np.random.permutation(len(data))<br/> test_data_size = int(len(data) * test_ratio)<br/> test_indicies = shuffled_indicies[:test_data_size]<br/> train_indicies = shuffled_indicies[test_data_size:]<br/> <strong class="lz hi">return</strong> data.iloc[train_indicies], data.iloc[test_indicies]</span><span id="e604" class="ky kz hh lz b fi mh me l mf mg"><strong class="lz hi">train_data, test_data</strong> = <strong class="lz hi">split_train_test(</strong>df, 0.2<strong class="lz hi">)</strong><br/><strong class="lz hi">print(</strong>f’Train data set count {len(train_data)}\nTest data set count {len(test_data)}’<strong class="lz hi">)</strong></span></pre><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mj"><img src="../Images/a039250f7da4e5d5d4d9621ff8157561.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ocHIJRn-QaZJkMp9XvXIFQ.png"/></div></div></figure><p id="49e6" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在这个方法中，我们为数据集的长度创建了一个混洗索引数组。这样做是为了使数据在按特定特征排序时不代表一种模式。然后我们得到测试数据的长度大小。</p><p id="5749" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们使用这些变量来获得训练和测试数据的索引，并返回测试和训练的数据集。</p><p id="f4a8" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">但是在这种方法中，我们会遇到一个问题。如果我们多次调用这个函数，我们将总是得到一个不同的数据集用于测试和训练，我们使用np.random来生成混洗指数。</p><p id="39f0" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这将导致我们试图消除的问题，从长远来看，我们的整个数据集将暴露于模型，我们将不会有任何模型看不到的数据。</p><p id="6b6d" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">因此，为了消除这种情况，每次都得到相同的混洗索引，我们可以为np.random设置一个种子，这样每次都会创建相同的混洗索引。种子将采用整数值，并且只要种子值相同，就会生成相同的混洗索引。</p><p id="5c36" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">因此，我们将添加一个名为random_seed的参数，并在split_train_test方法中将它传递给np.random.seed()。</p><pre class="ix iy iz ja fd ly lz ma mb aw mc bi"><span id="b745" class="ky kz hh lz b fi md me l mf mg"><strong class="lz hi">import</strong> numpy <strong class="lz hi">as</strong> np</span><span id="11d0" class="ky kz hh lz b fi mh me l mf mg"><em class="kh"># mannual basic train test spliting funtion</em><br/><strong class="lz hi">def split_train_test(</strong>data, test_ratio, random_seed<strong class="lz hi">)</strong>:</span><span id="8196" class="ky kz hh lz b fi mh me l mf mg">#<em class="kh"> setting random seed value to genrate same shuffled indicies</em>         <br/> np.random.seed(random_seed)</span><span id="2b8c" class="ky kz hh lz b fi mh me l mf mg"> shuffled_indicies = np.random.permutation(len(data))<br/> test_data_size = int(len(data) * test_ratio)<br/> test_indicies = shuffled_indicies[:test_data_size]<br/> train_indicies = shuffled_indicies[test_data_size:]<br/> <strong class="lz hi">return</strong> data.iloc[train_indicies], data.iloc[test_indicies]</span><span id="ac74" class="ky kz hh lz b fi mh me l mf mg"><strong class="lz hi">train_data, test_data</strong> = <strong class="lz hi">split_train_test(</strong>df, 0.2, 42<strong class="lz hi">)</strong><br/><strong class="lz hi">print(</strong>f’Train data set count {len(train_data)}\nTest data set count {len(test_data)}’<strong class="lz hi">)</strong></span></pre><p id="193d" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">只要种子值相同，这个方法现在将总是返回相同的数据集，即使它被多次调用。</p><p id="1bef" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">现在，我们将创建的每个ML模型都需要这种数据分割，因此为了使我们的任务更容易，scikit-learn有一些内置的方法来为我们处理这种分割。</p><h2 id="d4ea" class="ky kz hh bd la lb lc ld le lf lg lh li jr lj lk ll jv lm ln lo jz lp lq lr ls bi translated">使用scikit-learn拆分数据。</h2><p id="ab48" class="pw-post-body-paragraph ji jj hh jk b jl lt ii jn jo lu il jq jr lv jt ju jv lw jx jy jz lx kb kc kd ha bi translated">在sklearn.model_selection中，我们有一个train_test_split方法，我们可以用它将数据分成训练集和测试集。</p><p id="9254" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">下面是实现</p><pre class="ix iy iz ja fd ly lz ma mb aw mc bi"><span id="153a" class="ky kz hh lz b fi md me l mf mg">from <strong class="lz hi">sklearn.model_selection</strong> import <strong class="lz hi">train_test_split</strong></span><span id="3ed4" class="ky kz hh lz b fi mh me l mf mg">#<em class="kh">basic train test split using sklearn</em><br/><strong class="lz hi">train_data, test_data</strong> = <strong class="lz hi">train_test_split(</strong>df, test_size = 0.2, random_state = 42<strong class="lz hi">)</strong><br/><strong class="lz hi">print(</strong>f’Train data set count {len(train_data)}\nTest data set count {len(test_data)}’<strong class="lz hi">)</strong></span></pre><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mk"><img src="../Images/b9ac9bbbd9bd2b3f671cbd21b4ef351e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HWLhwop4d5gl_wMgOJQ1Vw.png"/></div></div></figure><p id="ed27" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在这里，我们传递的是我们在上面创建的函数中使用的所有相同的值。</p><p id="8cc2" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">现在，有时我们有一个功能，我们希望平均分为训练和测试数据。</p><p id="cb76" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">例如，我有一个数据集(Bostan housing数据集)，其中有一个名为“CHAS”的要素，它包含两个值0和1。</p><p id="1299" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我已经复制了住房数据框中的数据，现在我可以打印“CHAS”功能的值计数。</p><pre class="ix iy iz ja fd ly lz ma mb aw mc bi"><span id="5c29" class="ky kz hh lz b fi md me l mf mg">print(f’Data set value counts for CHAS column\n{housing[“CHAS”].value_counts()}’ )</span></pre><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es ml"><img src="../Images/6e76d0a074a835ec1ec8900f433c101a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A9whfQQh20ZFI0CULTPRxg.png"/></div></div></figure><p id="a0fa" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这里有367个数据点的值为0，27个数据点的值为1。对于数据集中的0和1分布，这是一个约为13.6的比率。</p><p id="a346" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">现在，在分析了这些数据之后，我们决定这个特性需要在训练和测试数据中平均分配。</p><p id="389f" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们可以使用scikit-learn的StratifiedShuffleSplit来实现这一点</p><pre class="ix iy iz ja fd ly lz ma mb aw mc bi"><span id="937e" class="ky kz hh lz b fi md me l mf mg">from <strong class="lz hi">sklearn.model_selection</strong> import <strong class="lz hi">StratifiedShuffleSplit</strong></span><span id="29d0" class="ky kz hh lz b fi mh me l mf mg"><strong class="lz hi">split </strong>= <strong class="lz hi">StratifiedShuffleSplit(</strong>n_splits=1, test_size = 0.2, random_state = 42<strong class="lz hi">)</strong><br/><strong class="lz hi">for</strong> train_i, test_i in <strong class="lz hi">split.split(</strong> housing, housing[‘CHAS’]):<br/> <strong class="lz hi">strat_train_data</strong> = housing.iloc[train_i]<br/> <strong class="lz hi">strat_test_data</strong> = housing.iloc[test_i]<br/> <br/><strong class="lz hi">print(</strong>f’Train data set count {len(strat_train_data)}\nTest data set count {len(strat_test_data)}’))<br/><strong class="lz hi">print(</strong>f”Train value count for CHAS column\n{strat_train_data[‘CHAS’].value_counts()}”<strong class="lz hi">)</strong><br/><strong class="lz hi">print(</strong>f’Test value count for CHAS column\n{strat_test_data[“CHAS”].value_counts()}’<strong class="lz hi">)</strong></span></pre><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mm"><img src="../Images/d4d2db36a0cc3636825d69c4ad3119e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OrbNk1A4ZyXg4EKmCz1OFg.png"/></div></div></figure><p id="872e" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这里我们可以看到，对于0和1分布，训练集的比率约为13.3，测试集的比率约为14.8。因此，考虑到“CHAS”特征，数据几乎平分秋色。</p><p id="7c9d" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这是一个非常简短的介绍，介绍了如何为您的ML模型分割训练和测试数据。</p><blockquote class="ke kf kg"><p id="1e45" class="ji jj kh jk b jl jm ii jn jo jp il jq ki js jt ju kj jw jx jy kk ka kb kc kd ha bi translated">感谢阅读，如果您有任何意见，请留下评论。</p><p id="f36d" class="ji jj kh jk b jl jm ii jn jo jp il jq ki js jt ju kj jw jx jy kk ka kb kc kd ha bi translated">享受你的编码！</p></blockquote></div></div>    
</body>
</html>