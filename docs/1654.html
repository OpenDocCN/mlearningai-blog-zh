<html>
<head>
<title>Navigating Through Time Series Clustering</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在时序聚类中导航</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/navigating-through-time-series-clustering-a7401d8e4004?source=collection_archive---------4-----------------------#2022-01-16">https://medium.com/mlearning-ai/navigating-through-time-series-clustering-a7401d8e4004?source=collection_archive---------4-----------------------#2022-01-16</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/a478f02d4392ac289977870a9018e231.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/format:webp/1*XHiuykll4_GkTbC90j24Vw.jpeg"/></div><figcaption class="il im et er es in io bd b be z dx">Meme by Author | Source: <a class="ae ip" href="https://imgflip.com/memesearch?q=one+does+not+simply" rel="noopener ugc nofollow" target="_blank">https://imgflip.com/memesearch?q=one+does+not+simply</a> | Inspired by Boromir (Sean Bean) from Lord of The Rings franchise (2011)</figcaption></figure><p id="738e" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">聚类分析或更广为人知的聚类与社会科学领域有着紧密的联系。它最初起源于人类学领域，后来被罗伯特·泰伦引入心理学。从那时起，它已经发展成为一个包含数学严谨性的领域。聚类分析的主要目的是将物体分成不同的组，这比听起来要困难得多。这是因为算法不知道什么是“相似”，什么是“不同”。为了解决这个问题，我们需要客观的测量方法，定量地告诉我们空间中各种物体的相对距离。一个衡量标准是<em class="jo">闵可夫斯基</em>距离:</p><figure class="jq jr js jt fd ii er es paragraph-image"><div class="er es jp"><img src="../Images/2a5e9e7a0862c4c4dbd428894cbfbbeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/format:webp/1*FBQMdhePS90K91DQMdSGmA.png"/></div></figure><p id="b78f" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated"><em class="jo">闵可夫斯基</em>距离是我们熟悉的<em class="jo">几个距离度量的概括。</em>举个例子，<em class="jo"> w </em>当我们设q = 2时，我们会得到<em class="jo">欧氏</em>距离。如果我们足够雄心勃勃，也可以创建自定义距离指标，只要它满足以下标准:</p><figure class="jq jr js jt fd ii er es paragraph-image"><div class="er es ju"><img src="../Images/36b9ca4f525cd876f14c679539154439.png" data-original-src="https://miro.medium.com/v2/resize:fit:190/format:webp/1*IudqrtdjWrtPPQFYdtnDog.png"/></div></figure><figure class="jq jr js jt fd ii er es paragraph-image"><div class="er es jv"><img src="../Images/e34ac79e1ccfb52d439de3ad8628dfb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:300/format:webp/1*5akqukMbyAktTeC02_FEHQ.png"/></div></figure><figure class="jq jr js jt fd ii er es paragraph-image"><div class="er es jw"><img src="../Images/d6e4b53302d52c9c4c3ccc6a88e307ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:480/format:webp/1*twviJDc1ZGu7pQ7zmIzgKA.png"/></div></figure><p id="14da" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">一旦选择了邻近度，像<em class="jo"> Kmeans </em>这样的聚类算法就可以用来对我们的对象进行分类。</p><h2 id="1b91" class="jx jy hh bd jz ka kb kc kd ke kf kg kh jb ki kj kk jf kl km kn jj ko kp kq kr bi translated">这对时间序列有用吗？</h2><p id="79f2" class="pw-post-body-paragraph iq ir hh is b it ks iv iw ix kt iz ja jb ku jd je jf kv jh ji jj kw jl jm jn ha bi translated">虽然我们可以在时间序列数据上直接使用<em class="jo"> Kmeans </em>和<em class="jo">欧几里德</em>距离，但它可能不会产生良好的聚类，因为<em class="jo">欧几里德</em>距离忽略了时间偏移。它也不能处理不同长度的数据。其他“正常”距离度量也是如此。同时，时间序列数据有各种大小和时间变化。幸运的是，对时间序列进行聚类的技术已经发展了多年，可以分为三大类:</p><ul class=""><li id="fcb7" class="kx ky hh is b it iu ix iy jb kz jf la jj lb jn lc ld le lf bi translated">将时间序列直接输入具有特定距离度量的聚类算法——自定义距离度量方法</li><li id="e4b8" class="kx ky hh is b it lg ix lh jb li jf lj jj lk jn lc ld le lf bi translated">在利用聚类算法之前从时间序列中提取特征—特征提取方法</li><li id="0cdf" class="kx ky hh is b it lg ix lh jb li jf lj jj lk jn lc ld le lf bi translated">对时间序列建模，然后对模型执行聚类——建模方法</li></ul><h2 id="4de6" class="jx jy hh bd jz ka kb kc kd ke kf kg kh jb ki kj kk jf kl km kn jj ko kp kq kr bi translated">a)自定义距离度量方法</h2><p id="6404" class="pw-post-body-paragraph iq ir hh is b it ks iv iw ix kt iz ja jb ku jd je jf kv jh ji jj kw jl jm jn ha bi translated">这种方法用更适合时间序列的距离度量代替了传统的距离度量。一个流行的度量是<em class="jo">动态时间扭曲</em><em class="jo">【DTW】</em>。与<em class="jo">欧几里得</em>、<em class="jo">不同，DTW </em>并没有忽略时间的转移。它甚至适用于长度不等的两个时间序列。下图显示了<em class="jo">欧几里得</em>和<em class="jo"> DTW </em>的区别:</p><figure class="jq jr js jt fd ii er es paragraph-image"><div class="er es ll"><img src="../Images/4732714fb1f8c0bd3f7ef7bf13ace244.png" data-original-src="https://miro.medium.com/v2/resize:fit:892/format:webp/1*eONlKweqWYmELTyw6D23kw.png"/></div><figcaption class="il im et er es in io bd b be z dx">source:<a class="ae ip" href="https://commons.wikimedia.org/wiki/File:Euclidean_vs_DTW.jpg" rel="noopener ugc nofollow" target="_blank">https://commons.wikimedia.org/wiki/File:Euclidean_vs_DTW.jpg</a></figcaption></figure><p id="6903" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">如上所示，当我们对有时间偏移的时间序列进行欧几里德匹配时，我们会将时间序列的错误部分匹配在一起。因此，我们的聚类算法可以得出结论，这两个时间序列相距甚远，因此是不同的。</p><p id="0764" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">要求DTW距离，首先要构造一个n x m <em class="jo">局部代价矩阵(LCM) </em>，其值对应于时间序列A和时间序列B中元素之间的累积距离，通俗地说，就是通过穷尽性地考虑时间序列A和B中的值，用公式填充空矩阵。一旦构建好矩阵，DTW距离就是从<em class="jo"> LCM </em>左下角到右上角的最短可能路径:</p><figure class="jq jr js jt fd ii er es paragraph-image"><div class="er es lm"><img src="../Images/a9abb5f59c31352d4f12c5632ea78107.png" data-original-src="https://miro.medium.com/v2/resize:fit:336/format:webp/1*TXWnK_yNfYaBgzjZBuj3hQ.png"/></div></figure><p id="4ba3" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">然后我们可以使用这个距离代替<em class="jo">欧几里德</em>用于我们的聚类算法。幸运的是，到处都有python包，所以我们不必从头开始构建<em class="jo"> DTW </em>。但是对于纯粹主义者来说，网上有很多资源可以帮助我们从头开始构建DTW。当然，也随时欢迎你阅读原文。</p><h2 id="5480" class="jx jy hh bd jz ka kb kc kd ke kf kg kh jb ki kj kk jf kl km kn jj ko kp kq kr bi translated">b)特征提取方法</h2><p id="ad8b" class="pw-post-body-paragraph iq ir hh is b it ks iv iw ix kt iz ja jb ku jd je jf kv jh ji jj kw jl jm jn ha bi translated">在这种方法下，我们将在利用聚类算法之前从时间序列中提取特征。一个有趣的方法是执行<em class="jo">离散傅立叶变换</em> <em class="jo"> (DFT) </em>。DFT背后的主要思想是引人注目的:转型。在这种方法下，时间序列被转换成各种频率。然后，聚类算法和我们选择的距离度量可以应用于这些频率。使用<em class="jo"> DFT </em>的一个好处是降维。幸运的是，scipy库可以用来执行<em class="jo"> DFT </em>并计算这些频率。此外，还有许多关于well⁴.的在线资源</p><h2 id="d6bd" class="jx jy hh bd jz ka kb kc kd ke kf kg kh jb ki kj kk jf kl km kn jj ko kp kq kr bi translated">c)建模方法</h2><p id="37d9" class="pw-post-body-paragraph iq ir hh is b it ks iv iw ix kt iz ja jb ku jd je jf kv jh ji jj kw jl jm jn ha bi translated">在这种方法下，我们考虑到每个时间序列都是由某种过程产生的，因此可以建模。例如，在对<em class="jo">隐马尔可夫模型</em> ⁴.使用聚类算法之前，我们可以首先为时间序列建立<em class="jo">隐马尔可夫模型(HMMs) </em><em class="jo"> </em>另一种方法将是使用经典的<em class="jo"> ARIMA </em> ⁵.当然，与自定义距离度量和特征提取方法相比，建模方法可能更加耗时。例如，使用<em class="jo"> ARIMA </em>方法，我们必须注意时间序列的平稳性以及其他考虑因素。虽然有python包可以用来自动完成寻找<em class="jo"> AR(p) </em>、<em class="jo"> I(d) </em>和<em class="jo"> MA(q) </em>值的过程，但是模型的质量可能没有那么好。为了获得特别是ARIMA的最佳结果，我们必须手动微调模型。</p><h2 id="aaa4" class="jx jy hh bd jz ka kb kc kd ke kf kg kh jb ki kj kk jf kl km kn jj ko kp kq kr bi translated">我能用它做什么？</h2><p id="3a8f" class="pw-post-body-paragraph iq ir hh is b it ks iv iw ix kt iz ja jb ku jd je jf kv jh ji jj kw jl jm jn ha bi translated">找出一种对时间序列进行聚类的方法打开了许多有趣的应用。这是因为时间序列数据在任何行业都非常普遍。就我个人而言，我在我的大学论文中应用了其中一些方法，试图回答以下问题:</p><blockquote class="ln lo lp"><p id="cc64" class="iq ir jo is b it iu iv iw ix iy iz ja lq jc jd je lr jg jh ji ls jk jl jm jn ha bi translated">聚类分析可以用来帮助投资组合经理创建多样化的投资组合吗？</p></blockquote><p id="1d81" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">这只是时间序列聚类有趣应用的一个例子(至少对我来说是这样)。我希望通过分享这些知识，人们将能够从事许多有趣的项目。也就是说，如果你做过任何酷的时间序列聚类相关的项目，请告诉我！</p></div><div class="ab cl lt lu go lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ha hb hc hd he"><p id="10f3" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">[1]罗伯特·乔特·泰伦。聚类分析:相关简档和正交<br/>(因子)分析，用于分离思想和人格的统一性。爱德华兹兄弟公司，平版印刷和出版商，1939年。</p><p id="3b62" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">[2]T沃伦廖。时间序列数据的聚类-综述。模式识别，38(11):1857–1874，2005。</p><p id="8ad0" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">[3]米勒，梅纳德。"动态时间扭曲"<em class="jo">音乐和动作信息检索</em>(2007):69–84。</p><p id="a317" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">[4]<a class="ae ip" href="https://pythonnumericalmethods.berkeley.edu/notebooks/chapter24.02-Discrete-Fourier-Transform.html" rel="noopener ugc nofollow" target="_blank">https://python numerical methods . Berkeley . edu/notebooks/chapter 24.02-离散傅立叶变换. html </a></p><p id="5e33" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">[5]科维耶洛、伊曼纽、安东尼·陈和格特·兰克利特。"具有变边的聚类隐马尔可夫模型."《机器学习研究杂志》15.1(2014):697–747。</p><p id="81ae" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">[6]Kalpakis、Konstantinos、Dhiral Gada和Vasundhara Puttagunta。" ARIMA时间序列有效聚类的距离度量."2001年IEEE数据挖掘国际会议论文集。IEEE，2001年。</p><div class="ma mb ez fb mc md"><a rel="noopener follow" target="_blank" href="/mlearning-ai/mlearning-ai-submission-suggestions-b51e2b130bfb"><div class="me ab dw"><div class="mf ab mg cl cj mh"><h2 class="bd hi fi z dy mi ea eb mj ed ef hg bi translated">Mlearning.ai提交建议</h2><div class="mk l"><h3 class="bd b fi z dy mi ea eb mj ed ef dx translated">如何成为Mlearning.ai上的作家</h3></div><div class="ml l"><p class="bd b fp z dy mi ea eb mj ed ef dx translated">medium.com</p></div></div><div class="mm l"><div class="mn l mo mp mq mm mr ij md"/></div></div></a></div></div></div>    
</body>
</html>