<html>
<head>
<title>Designing an optimal KNN regression model for predicting house price with Boston Housing Dataset</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用波士顿住房数据设计预测房价的最优KNN回归模型</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/designing-a-optimal-knn-regression-model-for-predicting-house-price-with-boston-housing-dataset-faef377536e3?source=collection_archive---------0-----------------------#2021-03-07">https://medium.com/mlearning-ai/designing-a-optimal-knn-regression-model-for-predicting-house-price-with-boston-housing-dataset-faef377536e3?source=collection_archive---------0-----------------------#2021-03-07</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/6b32d45b7705348843f8138accf93a7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C3-_BodK7QE9lDwsbq9ioA.jpeg"/></div></div></figure><div class=""/><p id="c1cb" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">亲爱的读者们好，在本文中，我展示了使用K近邻算法(KNN)预测波士顿房价的回归模型的Python代码。该代码还包含一个从肘曲线估计k的最佳值的函数。该代码是从零开始开发的，仅使用欧几里德距离度量，并且每个邻域中的所有点被同等加权。</p><p id="15ca" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">(请注意，本文并不介绍和描述KNN算法及其概念。请参考medium.com上其他帖子的相关文章。)</p><p id="3daf" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir ht">波士顿住房数据集</strong>来自美国人口普查局收集的关于马萨诸塞州<a class="ae jn" href="http://www.cs.toronto.edu/~delve/data/boston/bostonDetail.html" rel="noopener ugc nofollow" target="_blank">波士顿</a>地区住房的信息。有506个观察值，有13个特征(独立变量)，如房间数量(rm)、犯罪率(crim)、空气污染变量(nox)、每个社区的公共服务成本(税收)、学生教师比率(ptratio)等。因变量/目标变量是以千美元为单位的房价。</p><p id="133c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir ht">问题陈述</strong>:给定一组描述波士顿房子的特征，设计一个最优KNN回归模型，该模型可以预测任何给定房子的房价。</p><p id="ae70" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir ht">代码放在这里</strong>:</p><p id="4257" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在本节中，将加载所需的库并导入数据集。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="926e" class="jx jy hs jt b fi jz ka l kb kc"># built in datasets and other required functions are imported from <br/># sklearn <br/>from sklearn import datasets<br/>from sklearn.model_selection import train_test_split<br/>import numpy as np<br/>from sklearn.metrics import mean_squared_error<br/>import matplotlib.pyplot as plt<br/>import math</span><span id="61f9" class="jx jy hs jt b fi kd ka l kb kc">#Loading the Boston dataset<br/>boston=datasets.load_boston()<br/>x=boston.data[:,:]<br/>y=boston.target<br/>print(x.shape,y.shape)</span><span id="883c" class="jx jy hs jt b fi kd ka l kb kc">tsize=0.30 #30% of total data is used for testing and 70% used for training</span><span id="8542" class="jx jy hs jt b fi kd ka l kb kc">## splitting the dataset into training and testing sets,<br/># (parameter random state is fixed at some integer, to ensure the <br/># same train and test sets across various runs)<br/>xtrain,xtest,ytrain,ytest=train_test_split(x,y,test_size=tsize,random_state=102)</span></pre><p id="cad2" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这里给出了探索数据集特征和查看少量观察值(记录)的代码。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="d1fc" class="jx jy hs jt b fi jz ka l kb kc">## Exploring the dataset characteristics and having glimpse of data<br/># printing the sizes of training and testing data sets<br/>print(xtrain.shape,ytrain.shape)<br/>print(xtest.shape,ytest.shape)</span><span id="119c" class="jx jy hs jt b fi kd ka l kb kc"># Print the information contained within the dataset<br/>print("\nKeys of iris_dataset: \n{}".format(boston.keys()))<br/>print(boston['DESCR'][:500] + "\n...")</span><span id="46d1" class="jx jy hs jt b fi kd ka l kb kc">#Print the feature names<br/>print("\nFeature names: \n{}".format(boston['feature_names']))<br/>#Printing the  Few Rows<br/>print("\nFirst five rows of data:\n{}".format(boston['data'][:5]))<br/>#Print the class values few datapoints<br/>print("\nTarget:\n{}".format(boston['target'][:5]))<br/>#Print the dimensions of data<br/>print("\nShape of data: {}".format(boston['data'].shape))</span></pre><p id="b8fe" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">接下来给出用于预测给定房屋的房价的函数(特征向量tx)。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="8568" class="jx jy hs jt b fi jz ka l kb kc">##function to find Euclidean distance<br/>def edist(v1,v2):<br/>    return np.sqrt(np.sum((v1-v2)**2))</span><span id="8afb" class="jx jy hs jt b fi kd ka l kb kc">##function to predict values using knn for given test data tx<br/>def knn_reg(tr_x, tr_y, tx , k):<br/>   <br/>    distances = []<br/>    <br/>    #Find distances between new data and all the training data<br/>    for i in range(tr_x.shape[0]):<br/>        distances.append(edist(tr_x[i], tx))<br/>    <br/>    #sort the distances in ascending order<br/>    distances = np.array(distances)<br/>    inds = np.argsort(distances)<br/>    <br/>    distances = distances[inds]<br/>    tr_y_sorted = tr_y[inds] #sorted values of target variable<br/>    <br/>    #predicted value is the average of first k values of target<br/>    #vector<br/>    value = np.average(tr_y_sorted[:k])<br/>    return value</span></pre><p id="08de" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">下面给出了对于给定的k值求均方误差(MSE)的函数。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="ceac" class="jx jy hs jt b fi jz ka l kb kc">##Function to find mean squared error for the entire test dataset<br/>def knn_mse(tr_x , tr_y, test_x , test_y , k):<br/>    preds = []<br/>    for i in range(test_x.shape[0]):<br/>        value = knn_reg(tr_x, tr_y, test_x[i] , k)<br/>        preds.append(value)<br/>    <br/>    preds  = np.array(preds)<br/>    err = mean_squared_error(test_y , preds)<br/>    return err</span></pre><p id="1225" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">上述函数用于计算不同k值的均方误差(MSEs ),如下所示。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="0e28" class="jx jy hs jt b fi jz ka l kb kc">##Finding MSEs for different values of k <br/>maxk=int(math.sqrt(xtrain.shape[0])) #maximum value of k <br/>mse_val = [] #to store rmse values for different k<br/>for k in range(1,maxk):<br/>    error= knn_mse(xtrain , ytrain , xtest , ytest ,k)<br/>    mse_val.append(error) #store rmse values<br/>    print('MSE value for k= ' , k , 'is:', error)</span></pre><p id="1896" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">还绘制了肘曲线，并使用find_elbow()函数自动找到k的最佳值。请注意，在所有情况下选择最小MSE点是不够的，因此代码确保选择一个弯头点而不是最小值。参见下面的代码。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="c007" class="jx jy hs jt b fi jz ka l kb kc">##plotting the elbow curve <br/>k=np.arange(1,maxk)<br/>xl="k"<br/>yl="MSE"<br/>plt.xlabel(xl) <br/>plt.ylabel(yl)<br/>plt.title("Elbow Curve")<br/>plt.plot(k,mse_val)</span><span id="0f08" class="jx jy hs jt b fi kd ka l kb kc">##finding the k for the elbow point <br/>ke=find_elbow()<br/>print("Best Value of k using elbow curve is ",ke)<br/>plt.plot(ke,mse_val[ke-1],'rx')<br/>plt.annotate("  elbow point", (ke,mse_val[ke-1]))</span></pre><p id="a68c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在观察下图中肘点的k值，并检查它是否与find_elbow()函数找到的值相同。这里通过使用两种方法得到9。我得到了以下输出:</p><p id="d9c1" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="ke">使用弯头曲线的最佳k值为9 </em></p><figure class="jo jp jq jr fd hj er es paragraph-image"><div class="er es kf"><img src="../Images/e1a9e7a67904d1b73212cd3270405947.png" data-original-src="https://miro.medium.com/v2/resize:fit:764/format:webp/1*9Ykbwy_O5Cq8GaWZWutvxQ.png"/></div></figure><p id="4bc6" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在上图中，使用红色十字(x)显示弯头点。</p><p id="994d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在这个模型已经准备好了最优k和它的时间来预测给定房屋的价格。下面给出了相同的代码。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="80d1" class="jx jy hs jt b fi jz ka l kb kc">## Now model is ready to predict the cost for new house with given features in xnew vector and ke as k</span><span id="4ce5" class="jx jy hs jt b fi kd ka l kb kc">xnew=np.array([2.7310e-02, 0.0000e+00, 7.0700e+00, 0.0000e+00, \ 4.6900e-01, 6.4210e+00, 7.8900e+01, 4.9671e+00, 2.0000e+00, \ 2.4200e+02, 1.7800e+01, 3.9690e+02 ,9.1400e+00])<br/>hcost=knn_reg(xtrain, ytrain, xnew , ke)</span><span id="3d67" class="jx jy hs jt b fi kd ka l kb kc">print("Predicted price of the given house is {:.2f}".format(hcost),\ "thousand dollars")</span></pre><p id="c482" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我在这里得到的输出是:</p><p id="fc2d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="ke">给定房屋的预测价格为24.00万美元</em></p><p id="763c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">总之，从头开始编码(而不是使用机器学习算法的库函数)需要对算法有更好的理解，而且如果一个人试图从头开始编码，他/她可以对算法有更好的理解。</p><p id="58ec" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">希望你喜欢这篇文章。这是我关于使用Python进行机器学习的第一篇文章，所以请给出您的评论和建议，以改进代码并报告错误(如果有的话)。</p></div></div>    
</body>
</html>