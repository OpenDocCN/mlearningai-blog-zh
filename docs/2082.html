<html>
<head>
<title>It's Just a Network of neurons!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">这只是一个神经元网络！</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/its-just-a-network-of-neurons-73baf88ed680?source=collection_archive---------9-----------------------#2022-03-04">https://medium.com/mlearning-ai/its-just-a-network-of-neurons-73baf88ed680?source=collection_archive---------9-----------------------#2022-03-04</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="7d8a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">用TensorFlow创建简单的神经网络</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/478330bc20e60e764c1b1463eaa95bd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fuYqVgfmHJ391cPx"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Photo by <a class="ae js" href="https://unsplash.com/@clintadair?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Clint Adair</a> on <a class="ae js" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="5dc8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">注:</strong>本博客是使用Tensorflow开发深度神经网络系列博客的一部分。前一部分请阅读下面的博客。</p><div class="jt ju ez fb jv jw"><a rel="noopener follow" target="_blank" href="/mlearning-ai/basic-operations-of-tensorflow-bf206868f491"><div class="jx ab dw"><div class="jy ab jz cl cj ka"><h2 class="bd hi fi z dy kb ea eb kc ed ef hg bi translated">张量流的基本运算</h2><div class="kd l"><h3 class="bd b fi z dy kb ea eb kc ed ef dx translated">DNN张量流基本原理</h3></div><div class="ke l"><p class="bd b fp z dy kb ea eb kc ed ef dx translated">medium.com</p></div></div><div class="kf l"><div class="kg l kh ki kj kf kk jm jw"/></div></div></a></div></div><div class="ab cl kl km go kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ha hb hc hd he"><p id="f86a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">代码笔记本可从以下链接下载:</p><div class="jt ju ez fb jv jw"><a href="https://github.com/rajsandhu1989/Tensorflow_projects/tree/main/Simple%20Neural%20Network" rel="noopener  ugc nofollow" target="_blank"><div class="jx ab dw"><div class="jy ab jz cl cj ka"><h2 class="bd hi fi z dy kb ea eb kc ed ef hg bi translated">tensor flow _ projects/main rajsandhu 1989年的简单神经网络/Tensorflow_projects</h2><div class="kd l"><h3 class="bd b fi z dy kb ea eb kc ed ef dx translated">此库包含从基础到高级的所有使用Tensorflow API的项目…</h3></div><div class="ke l"><p class="bd b fp z dy kb ea eb kc ed ef dx translated">github.com</p></div></div><div class="kf l"><div class="ks l kh ki kj kf kk jm jw"/></div></div></a></div></div><div class="ab cl kl km go kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ha hb hc hd he"><h1 id="da96" class="kt ku hh bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">介绍</h1><p id="0784" class="pw-post-body-paragraph ie if hh ig b ih lr ij ik il ls in io ip lt ir is it lu iv iw ix lv iz ja jb ha bi translated">在之前的博客中，我们已经讨论了在使用TensorFlow开发神经网络时可能会用到的一些常用函数。在这个博客中，我们将为回归和分类等各种活动建立一些简单的神经网络。如下所示，神经网络包含从输入层到输出层的多个层。这些层需要按顺序编码以开发神经网络，这些层将在下一节中详细解释。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es lw"><img src="../Images/e30555159f0e70df17edebed24d8aacb.png" data-original-src="https://miro.medium.com/v2/resize:fit:470/format:webp/1*ehZ7cItY54F1mQ8-fS7nwQ.png"/></div><figcaption class="jo jp et er es jq jr bd b be z dx">Figure 1 Sample Neural Network</figcaption></figure><h1 id="882a" class="kt ku hh bd kv kw lx ky kz la ly lc ld le lz lg lh li ma lk ll lm mb lo lp lq bi translated">层</h1><p id="7cb2" class="pw-post-body-paragraph ie if hh ig b ih lr ij ik il ls in io ip lt ir is it lu iv iw ix lv iz ja jb ha bi translated">神经网络是多个层的组合，它获取输入数据，通过隐藏层传递，并生成输出。输入图层通常标记为图层0，因为它不执行任何计算。每一层都包含一个数学单元，将边的权重与输入相乘并添加偏差，这个单元称为神经元。一层是一个或多个神经元的集合，一层中神经元的数量可以多于或少于前一层。因此，对于神经网络的更好输出，没有层的数量和每层中神经元的数量的经验法则。坦率地说，这是一种尝试，或者深度学习程序员可以做出有根据的猜测的经验。下面讨论TensorFlow框架中一些最常用的层。</p><h2 id="91aa" class="mc ku hh bd kv md me mf kz mg mh mi ld ip mj mk lh it ml mm ll ix mn mo lp mp bi translated">稠密的</h2><p id="0902" class="pw-post-body-paragraph ie if hh ig b ih lr ij ik il ls in io ip lt ir is it lu iv iw ix lv iz ja jb ha bi translated">密集层或全连接层是前一层的每个神经元与下一层的每个神经元连接的层，如图1所示。密集层是设计深度神经网络中最常用的层之一。下图显示了Keras库提供的密集图层的各种选项。</p><pre class="jd je jf jg fd mq mr ms mt aw mu bi"><span id="e464" class="mc ku hh mr b fi mv mw l mx my">tf.keras.layers.Dense(<br/>    units, activation=None, use_bias=True,<br/>    kernel_initializer='glorot_uniform',<br/>    bias_initializer='zeros', kernel_regularizer=None,<br/>    bias_regularizer=None, activity_regularizer=None,  kernel_constraint=None,<br/>    bias_constraint=None, **kwargs<br/>)</span></pre><p id="ebeb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">将输入作为<strong class="ig hi"> <em class="mz">输入_数据</em> </strong>的模型的示例密集层如下所示。我们已经使用Keras包创建了三个密集层。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="na nb l"/></div></figure><h2 id="2e6e" class="mc ku hh bd kv md me mf kz mg mh mi ld ip mj mk lh it ml mm ll ix mn mo lp mp bi translated">激活</h2><p id="eacd" class="pw-post-body-paragraph ie if hh ig b ih lr ij ik il ls in io ip lt ir is it lu iv iw ix lv iz ja jb ha bi translated">密集图层可以选择需要应用于该图层输出的激活函数。然而，Keras有一个单独的激活层，如果需要可以在不同层之间使用。这完全取决于我们需要的模型的要求和种类，在极端情况下，我们可以应用双激活层。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="na nb l"/></div></figure><h2 id="e61f" class="mc ku hh bd kv md me mf kz mg mh mi ld ip mj mk lh it ml mm ll ix mn mo lp mp bi translated">拒绝传统社会的人</h2><p id="7253" class="pw-post-body-paragraph ie if hh ig b ih lr ij ik il ls in io ip lt ir is it lu iv iw ix lv iz ja jb ha bi translated">过度拟合是具有小训练数据的深度神经网络的问题。Dropout是通过消除每层中的一些节点来提高训练精度的技术之一。这种消除只发生在训练阶段，并且可以使用Keras中的Dropout层轻松完成。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="na nb l"/></div></figure><p id="2fab" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Keras提供了大量的层，可以在这里<a class="ae js" href="https://www.tensorflow.org/api_docs/python/tf/keras/layers" rel="noopener ugc nofollow" target="_blank">找到</a>，并且可以在需要的时候使用。可以在Keras的重要层上写一篇单独的博客文章，然而，为了博客的简洁，只讨论我们将用来创建一个简单的神经网络的层。</p><h1 id="856a" class="kt ku hh bd kv kw lx ky kz la ly lc ld le lz lg lh li ma lk ll lm mb lo lp lq bi translated">使用Keras的DNN模型</h1><p id="10d4" class="pw-post-body-paragraph ie if hh ig b ih lr ij ik il ls in io ip lt ir is it lu iv iw ix lv iz ja jb ha bi translated">Keras是TensorFlow包中提供的高级API，可用于创建神经网络模型。它支持各种模型的快速实现，运行在其他框架之上，由Franç ois Chollet编写。Keras比Tensorflow更好，因为它提供了快速的行业就绪模型，使用更少的代码构建模型，构建任何架构，并将其部署在多个平台上。</p><h2 id="5b3a" class="mc ku hh bd kv md me mf kz mg mh mi ld ip mj mk lh it ml mm ll ix mn mo lp mp bi translated">埃及蜜蜂</h2><p id="7d89" class="pw-post-body-paragraph ie if hh ig b ih lr ij ik il ls in io ip lt ir is it lu iv iw ix lv iz ja jb ha bi translated">Keras建立神经网络模型有两种主要方法，即顺序模型和函数API。序列模型是一种广泛使用的模型，表示一个简单的层堆栈，其中每一层都有一个输入张量和一个输出张量。顺序模型不允许多个输入和图层共享。相反，函数式API提供了比顺序模型更灵活的开发神经网络的方法。函数式API可以处理具有非线性拓扑、共享层甚至多个输入或输出的模型。</p><h1 id="5a93" class="kt ku hh bd kv kw lx ky kz la ly lc ld le lz lg lh li ma lk ll lm mb lo lp lq bi translated">序列模型</h1><p id="43a9" class="pw-post-body-paragraph ie if hh ig b ih lr ij ik il ls in io ip lt ir is it lu iv iw ix lv iz ja jb ha bi translated">在顺序模型中，我们创建一个模型，并根据需求一层一层地添加。顺序模型的所有基本步骤讨论如下:</p><p id="43cf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">第一步:创建模型</strong></p><pre class="jd je jf jg fd mq mr ms mt aw mu bi"><span id="32fb" class="mc ku hh mr b fi mv mw l mx my"><strong class="mr hi">model=tf.keras.models.Sequential()</strong></span></pre><p id="75af" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">第二步:添加一层</strong></p><p id="818c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在下面的代码中，我们添加了两层，分别是<strong class="ig hi"> <em class="mz">输入层</em> </strong>和<strong class="ig hi"> <em class="mz">密集层。输入</em> </strong>层包含2个神经元，我们需要在参数<code class="du nc nd ne mr b">input_shape</code>中提到输入层的大小。不要将输入层与第0层混淆，是第1层产生实际输出，见图1。然后，我们有一个密集层，它有两个参数，即神经元的数量和该层的激活函数。</p><pre class="jd je jf jg fd mq mr ms mt aw mu bi"><span id="5233" class="mc ku hh mr b fi mv mw l mx my"># Add and input and dense layer<br/><strong class="mr hi">model.add(Dense(2, input_shape=(3,), activation="relu"))</strong><br/># Add a final 1 neuron layer<br/><strong class="mr hi">model.add(Dense(1), activation="sigmoid")</strong></span></pre><p id="2367" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们为我们在上面几节中创建的神经网络创建一个顺序模型，并打印其模型摘要。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="na nb l"/></div></figure><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es nf"><img src="../Images/94499fe6cc1cf37219fc04126eb75c7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1274/format:webp/1*f17CTQVNoJi-prOz6Rrhlg.png"/></div><figcaption class="jo jp et er es jq jr bd b be z dx">Figure 2 Model Summary</figcaption></figure><p id="766d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">第三步:编译模型</strong></p><p id="11f2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">创建模型后，我们需要编译模型，在这里我们将让模型知道将要使用的<strong class="ig hi"><em class="mz"/></strong>和<strong class="ig hi"> <em class="mz">优化器</em> </strong>。</p><pre class="jd je jf jg fd mq mr ms mt aw mu bi"><span id="e999" class="mc ku hh mr b fi mv mw l mx my"># Compiling your previously built model<br/><strong class="mr hi">model.compile(optimizer="adam", loss="mse")</strong></span></pre><p id="6ca5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">第四步:拟合模型</strong></p><p id="065d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最后，我们需要拟合模型，或者我们可以说用训练数据训练模型。请参见下面的代码:</p><pre class="jd je jf jg fd mq mr ms mt aw mu bi"><span id="d57b" class="mc ku hh mr b fi mv mw l mx my"># Train your model<br/><strong class="mr hi">model.fit(X_train, y_train, epochs=5)</strong></span></pre><p id="b68e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们对我们的数据集<strong class="ig hi"> <em class="mz"> UCI信用卡</em> </strong>运行编译和拟合方法。图3显示了输出的最后三行。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="na nb l"/></div></figure><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es ng"><img src="../Images/0ad8cc98b322537725be258ce47a6230.png" data-original-src="https://miro.medium.com/v2/resize:fit:1330/format:webp/1*Wu4GTvss8Ald5bjELtZexg.png"/></div><figcaption class="jo jp et er es jq jr bd b be z dx">Figure 3 model.fit() output</figcaption></figure><p id="2239" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们可以看到损失已经达到了0.5303的水平。你可能想知道为什么一个时期的样本大小是657？这是因为小批量算法将所有样本分成批次。该方法在<code class="du nc nd ne mr b">model.fit()</code>中的默认批量是32，而在<code class="du nc nd ne mr b">x_train</code>中的总样本数是21000，21000/32=656进行计算。我们将在以后的博客文章中详细研究这个小批量。</p><p id="65a4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">第五步:预测和评估</strong></p><p id="3783" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们可以使用以下命令，使用在步骤4中用训练数据拟合的训练模型进行预测。</p><pre class="jd je jf jg fd mq mr ms mt aw mu bi"><span id="f541" class="mc ku hh mr b fi mv mw l mx my"># Predict on new data<br/>preds = model.predict(X_test)<br/># Look at the predictions<br/>print(preds)</span></pre><p id="a9a2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">此外，我们可以使用下面的代码来评估我们的模型，这将产生如图4所示的输出。</p><pre class="jd je jf jg fd mq mr ms mt aw mu bi"><span id="6e7a" class="mc ku hh mr b fi mv mw l mx my"><em class="mz"># Evaluate your results<br/></em>model.evaluate(X_test, y_test)</span></pre><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es nh"><img src="../Images/a6fc66caf6677fa83e7e28e675dd7f6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1338/format:webp/1*yZphCnOksCfaLk0BwTRaBQ.png"/></div><figcaption class="jo jp et er es jq jr bd b be z dx">Figure 4 Model Evaluation</figcaption></figure><h1 id="fc38" class="kt ku hh bd kv kw lx ky kz la ly lc ld le lz lg lh li ma lk ll lm mb lo lp lq bi translated">Keras模型中的其他选项</h1><p id="e847" class="pw-post-body-paragraph ie if hh ig b ih lr ij ik il ls in io ip lt ir is it lu iv iw ix lv iz ja jb ha bi translated">我们在上面使用的函数中有多个选项，可以根据应用或预测模型的要求来使用。复杂的选项将在后续的博客中讨论，但是，这里将讨论一些最常用的选项。</p><h2 id="e50e" class="mc ku hh bd kv md me mf kz mg mh mi ld ip mj mk lh it ml mm ll ix mn mo lp mp bi translated"><strong class="ak">指标</strong></h2><p id="da84" class="pw-post-body-paragraph ie if hh ig b ih lr ij ik il ls in io ip lt ir is it lu iv iw ix lv iz ja jb ha bi translated">我们可以在compile方法中使用多个指标和缺省损失值。最常用的度量是准确度和曲线下面积。</p><h2 id="aa07" class="mc ku hh bd kv md me mf kz mg mh mi ld ip mj mk lh it ml mm ll ix mn mo lp mp bi translated">验证溢出</h2><p id="49e5" class="pw-post-body-paragraph ie if hh ig b ih lr ij ik il ls in io ip lt ir is it lu iv iw ix lv iz ja jb ha bi translated">在模型训练期间执行拟合方法时，Keras可以自动创建验证数据集。验证准确度和损失将单独输出。下面的代码在上面创建的模型中使用了两个指标，以及一个占训练数据集20%的验证数据集。图5显示了笔记本中的输出，现在它还显示了每个时期后模型的准确性以及AUC值。此外，它还显示了验证分数、准确性和AUC数据。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="na nb l"/></div></figure><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es ni"><img src="../Images/aee6bc5745c9b15846ec3437484dee1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VVdAlaFqoPYnfyelP83cMw.png"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Figure 5 Output</figcaption></figure><h1 id="7f14" class="kt ku hh bd kv kw lx ky kz la ly lc ld le lz lg lh li ma lk ll lm mb lo lp lq bi translated">结论</h1><p id="463e" class="pw-post-body-paragraph ie if hh ig b ih lr ij ik il ls in io ip lt ir is it lu iv iw ix lv iz ja jb ha bi translated">在这篇博客中，我们讨论了一些常用的层和使用简单的API创建神经网络模型。然后，我们讨论了如何使用Keras API创建一个序列DNN模型。</p><p id="35ce" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这是一个创建密集神经网络的简单教程，我们将深入研究Keras提供的各种选项和回调，以获得更好的理解。</p><div class="jt ju ez fb jv jw"><a rel="noopener follow" target="_blank" href="/mlearning-ai/mlearning-ai-submission-suggestions-b51e2b130bfb"><div class="jx ab dw"><div class="jy ab jz cl cj ka"><h2 class="bd hi fi z dy kb ea eb kc ed ef hg bi translated">Mlearning.ai提交建议</h2><div class="kd l"><h3 class="bd b fi z dy kb ea eb kc ed ef dx translated">如何成为Mlearning.ai上的作家</h3></div><div class="ke l"><p class="bd b fp z dy kb ea eb kc ed ef dx translated">medium.com</p></div></div><div class="kf l"><div class="nj l kh ki kj kf kk jm jw"/></div></div></a></div></div></div>    
</body>
</html>