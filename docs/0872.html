<html>
<head>
<title>Python Multiprocessing for 3D Data Processing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用于3D数据处理的Python多重处理</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/python-multiprocessing-for-3d-data-processing-b657037479ff?source=collection_archive---------3-----------------------#2021-08-09">https://medium.com/mlearning-ai/python-multiprocessing-for-3d-data-processing-b657037479ff?source=collection_archive---------3-----------------------#2021-08-09</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="d2ba" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">今天我们将讨论如何使用Python多重处理来处理大量数据。我将讲述一些可能在手册中找到的一般信息，并分享一些我发现的小技巧，例如将<code class="du jc jd je jf b">tqdm</code>与多重处理<code class="du jc jd je jf b">imap</code>一起使用，以及并行处理档案。</p><p id="aedb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">那么我们为什么要求助于并行计算呢？处理数据有时会出现与大数据相关的问题。每次我们有不适合RAM的数据时，我们需要一点一点地处理它。幸运的是，现代编程语言允许我们产生能够在多核处理器上完美工作的多个进程(甚至线程)(注意:这并不意味着单核处理器不能处理多处理，<a class="ae jg" href="https://stackoverflow.com/questions/52465317/can-i-run-multiprocessing-python-programs-on-a-single-core-machine" rel="noopener ugc nofollow" target="_blank">这里是关于该主题的</a>堆栈溢出线程)</p><p id="d45b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">今天，我们将尝试经常性的3D计算机视觉任务，计算网格和点云之间的距离。例如，当您需要在所有可用网格中找到一个网格来定义与给定点云相同的3D对象时，您可能会遇到这个问题。</p><p id="f04b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们的数据由存储在<code class="du jc jd je jf b">.7z</code>归档中的<code class="du jc jd je jf b">.obj</code>文件组成，这在存储效率方面非常好。但是当我们需要访问它的确切部分时，我们应该做出努力。这里我定义了包装7-zip存档并提供底层数据接口的类。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="jm jn l"/></div><figcaption class="jo jp et er es jq jr bd b be z dx">MeshesArchive class</figcaption></figure><p id="4cd3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这个类几乎不依赖于<code class="du jc jd je jf b">py7zlib</code>包，它允许我们每次调用<code class="du jc jd je jf b">get</code>方法时解压数据，并给出存档中的文件数量。我们还定义了<code class="du jc jd je jf b">__iter__</code>,这将有助于我们像在iterable上一样在那个对象上开始多重处理<code class="du jc jd je jf b">map</code>。</p><p id="f877" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这个定义为我们提供了迭代归档的可能性，但是它允许我们对内容进行随机并行访问吗？这是一个有趣的问题，我还没有在网上找到答案，但如果我们深入研究<code class="du jc jd je jf b">py7zlib</code>的源代码，我们可以找到答案。</p><p id="83eb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这里，我提供了来自<a class="ae jg" href="https://github.com/fancycode/pylzma/blob/master/py7zlib.py" rel="noopener ugc nofollow" target="_blank"> pylzma </a>的精简代码片段</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="jm jn l"/></div><figcaption class="jo jp et er es jq jr bd b be z dx">Extract from pylzma source code, there’s a lot omitted</figcaption></figure><p id="086a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我相信，从上面的要点可以清楚地看出，无论何时同时读取多次，都没有理由阻止存档。</p><p id="e30c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">接下来，我们快速介绍一下什么是网格，什么是点云。首先是网格，它们是<strong class="ig hi">顶点</strong>、<strong class="ig hi">边</strong>和<strong class="ig hi">面的集合。</strong>顶点由空间中的<em class="js"> (x，y，z) </em>坐标定义，并分配有唯一的编号。相应地，边和面是点对和三元组的组，并且用提到的唯一点id来定义。通常，当我们谈到“网格”时，我们指的是“三角形网格”，即由三角形组成的表面。使用<code class="du jc jd je jf b">trimesh</code>库在Python中处理网格要容易得多，例如，它提供了在内存中加载<code class="du jc jd je jf b">.obj</code>文件的接口。要在<code class="du jc jd je jf b">jupyter notebook</code>中显示3D对象并与之交互，可以使用<code class="du jc jd je jf b">k3d</code>库。</p><p id="5fd1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，我用下面的代码片段来回答这个问题:“如何用<code class="du jc jd je jf b">k3d</code>在<code class="du jc jd je jf b">jupyter</code>中绘制一个<code class="du jc jd je jf b">trimesh</code>对象？”</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="jm jn l"/></div><figcaption class="jo jp et er es jq jr bd b be z dx">Plot trimesh mesh with k3d</figcaption></figure><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="er es jt"><img src="../Images/86b642385f553dee7f1f589c5deefdb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ms_1Id391jvGFVwwr0h7aw.png"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Stanford Bunny mesh displayed by k3d (unfortunately not responsive here)</figcaption></figure><p id="bd0d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">其次，点云，它们是表示空间中物体的3D点阵列。许多3D扫描仪产生点云作为扫描对象的表示。出于演示的目的，我们可以读取相同的网格，并将其顶点显示为点云。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="jm jn l"/></div><figcaption class="jo jp et er es jq jr bd b be z dx">Plot vertices as point cloud</figcaption></figure><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="er es ka"><img src="../Images/fff077b50333427795bdcdd738aea0f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bDO3x359-88GirmH-EVjJA.png"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Point cloud drawn by k3d</figcaption></figure><p id="6c35" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如上所述，3D扫描仪为我们提供了一个点云。让我们假设我们有一个网格数据库，我们想在我们的数据库中找到一个网格，它与被扫描的对象即点云对齐。为了解决这个问题，我们可以提出一个简单的方法。我们将从我们的档案中搜索给定点云和每个网格点之间的最大距离。如果这样的距离对于某些网格来说小于<code class="du jc jd je jf b">1e-4</code>，我们将认为这个网格与点云对齐。</p><p id="621d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最后，我们来到了多重处理部分。记住，我们的档案有大量的文件可能不适合一起在内存中，我们更喜欢并行处理它们。为了实现这一点，我们将使用多重处理<code class="du jc jd je jf b">Pool</code>，它使用<code class="du jc jd je jf b">map</code>或<code class="du jc jd je jf b">imap/imap_unordered</code>方法处理用户定义函数的多个调用。影响我们的<code class="du jc jd je jf b">map</code>和<code class="du jc jd je jf b">imap</code>之间的区别在于<code class="du jc jd je jf b">map</code>在将iterable发送到worker进程之前将其转换为list。如果一个归档文件太大而无法写入RAM，那么就不应该解压到Python列表中。在其他情况下，它们的执行速度是相似的。</p><pre class="jh ji jj jk fd kb jf kc kd aw ke bi"><span id="fa56" class="kf kg hh jf b fi kh ki l kj kk">[Loading meshes: pool.map w/o manager] Pool of 4 processes elapsed time: 37.213207403818764 sec<br/>[Loading meshes: pool.imap_unordered w/o manager] Pool of 4 processes elapsed time: 37.219303369522095 sec</span></pre><p id="5515" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">上面你可以看到从内存中的网格档案中简单读取的结果。</p><p id="0557" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">用<code class="du jc jd je jf b">imap</code>继续前进。让我们讨论如何完成我们的目标，找到一个接近点云的网格。这是<a class="ae jg" href="https://github.com/zetyquickly/mutliprocessing-manager/blob/master/data/meshes.7z" rel="noopener ugc nofollow" target="_blank">数据</a>，我们有来自斯坦福模型的5个不同的网格。我们将通过向斯坦福兔子网格的顶点添加噪声来模拟3D扫描。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="jm jn l"/></div></figure><p id="87e3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当然，我们之前在下面标准化了点云和网格顶点，以在3D立方体中缩放它们。</p><p id="be0c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了计算点云和网格之间的距离，我们将使用<code class="du jc jd je jf b">igl</code>。为了最终确定，我们需要编写一个函数，在每个进程及其依赖项中调用。让我们用下面的片段来总结一下。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="jm jn l"/></div></figure><p id="8d9d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这里的<code class="du jc jd je jf b">read_meshes_get_distances_pool_imap</code>是一个中心功能，完成以下工作:</p><ul class=""><li id="7cc5" class="kl km hh ig b ih ii il im ip kn it ko ix kp jb kq kr ks kt bi translated"><code class="du jc jd je jf b">MeshesArchive</code>和<code class="du jc jd je jf b">multiprocessing.Pool</code>已初始化</li><li id="5165" class="kl km hh ig b ih ku il kv ip kw it kx ix ky jb kq kr ks kt bi translated"><code class="du jc jd je jf b">tqdm</code>用于查看池进度，整个池的配置文件是手动完成的</li><li id="a943" class="kl km hh ig b ih ku il kv ip kw it kx ix ky jb kq kr ks kt bi translated">执行结果的输出</li></ul><p id="ad39" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">请注意我们如何将参数传递给<code class="du jc jd je jf b">imap</code>，使用<code class="du jc jd je jf b">zip(archive, itertools.repeat(point_cloud))</code>从<code class="du jc jd je jf b">archive</code>和<code class="du jc jd je jf b">point_cloud</code>创建一个新的itearable。这允许我们将一个点云数组粘贴到存档的每个条目上，避免将<code class="du jc jd je jf b">archive</code>转换成一个列表。</p><p id="caa2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">执行的结果如下所示</p><pre class="jh ji jj jk fd kb jf kc kd aw ke bi"><span id="5659" class="kf kg hh jf b fi kh ki l kj kk">100%|####################################################################| 5/5 [00:00&lt;00:00,  5.14it/s]<br/>100%|####################################################################| 5/5 [00:00&lt;00:00,  5.08it/s]<br/>100%|####################################################################| 5/5 [00:00&lt;00:00,  5.18it/s]<br/>[Process meshes: pool.imap w/o manager] Pool of 4 processes elapsed time: 1.0080536206563313 sec<br/>armadillo.obj 0.16176825266293382<br/>beast.obj 0.28608649819198073<br/>cow.obj 0.41653845909820164<br/>spot.obj 0.22739556571296735<br/>stanford-bunny.obj 2.3699851136074263e-05</span></pre><p id="e7d9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们可以看出，斯坦福兔子是最接近给定点云的网格。还可以看到，我们没有使用大量的数据，但我们已经表明，即使我们在归档中有大量的网格，这种解决方案也是可行的。</p><p id="bace" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">多重处理允许数据科学家不仅在3D计算机视觉中，而且在机器学习的其他领域中实现巨大的性能。理解并行执行比循环内执行快得多是非常重要的。这种差异变得非常明显，尤其是当一个算法被正确编写时。大量的数据揭示了一些问题，如果没有创造性的方法来使用有限的资源，这些问题是无法解决的。幸运的是，Python语言及其丰富的函数库帮助我们这些数据科学家解决了这些问题。</p></div></div>    
</body>
</html>