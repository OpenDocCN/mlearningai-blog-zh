<html>
<head>
<title>LSTM with Keras. Data reshaping in Many To One Architecture.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LSTM和克拉斯。多对一架构中的数据整形。</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/lstm-with-keras-data-reshaping-in-many-to-one-architecture-c7d3669e3a5c?source=collection_archive---------0-----------------------#2021-11-11">https://medium.com/mlearning-ai/lstm-with-keras-data-reshaping-in-many-to-one-architecture-c7d3669e3a5c?source=collection_archive---------0-----------------------#2021-11-11</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/df99974cda6473a20b9564fe5f354bb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RsRIEyJyfgvisdW363CbDw.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Image source: <a class="ae it" href="http://karpathy.github.io/2015/05/21/rnn-effectiveness/" rel="noopener ugc nofollow" target="_blank">Andrej Karpathy</a></figcaption></figure><p id="45b7" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">尝试为我的大学任务实现LSTM神经网络时，我面临着将数据拟合到用Keras框架制作的模型中的问题:需要将输入数据转换为适合维度的框架(LSTM层可接受的输入形状)。因此，本教程可能有助于节省时间的初学者谁想要使用LSTM建筑的力量。</p><p id="b3db" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">举个例子，让我们使用多机位的电影制作方法:</p><figure class="jt ju jv jw fd ii er es paragraph-image"><div class="er es js"><img src="../Images/b97c0ee7d1ad6a23a4c32ffe6c367b27.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*iDsoFI9BYLg-3KN4.png"/></div><figcaption class="ip iq et er es ir is bd b be z dx"><a class="ae it" href="https://en.wikipedia.org/wiki/Multiple-camera_setup" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Multiple-camera_setup</a></figcaption></figure><p id="c1d6" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">基于该图像，我们的数据将包括4个视频信号或4个稳定图像序列(例如每秒25帧)。现在，让我们假设在一些信号(图像)预处理之后，来自每个摄像机的每个帧可以被表示为一些数字(例如，与前一帧相比，在当前帧中已经改变的像素数)。所以最后，我们的数据将具有以下形式:</p><figure class="jt ju jv jw fd ii er es paragraph-image"><div class="er es jx"><img src="../Images/b32eb210d3c6eff91201fb70ae297763.png" data-original-src="https://miro.medium.com/v2/resize:fit:538/format:webp/1*hCtB0ZU4Isv4EN8RiZer9A.png"/></div></figure><p id="8cd5" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">其中X1、X2、X3、X4是表示来自4个视频摄像头的视频帧之间的变化的变量，Y是某个目标(例如，定义对象A和B在当前帧是否移动的二进制变量)。</p><p id="32e0" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">将视频帧序列视为时间序列数据是很自然的，因此仅基于4个数据帧(X71、X72、X73、X74)来预测例如帧7 (Y7)处的Y是不够的:在先前帧的k长度序列中应该有额外的有用信息。K-length意味着我们取k个以前的帧，把它们当作一个样本。此外，仅基于先前帧而不包括第x7帧来预测Y7更现实。示意性地，对于k=5，上述数据应转换如下:</p><figure class="jt ju jv jw fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es jy"><img src="../Images/a1fbc51536aad42def168c31238610ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nBnlD4uM1-BBirgtr5nHIA.png"/></div></div></figure><p id="8b51" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">或者更简洁地说:</p><figure class="jt ju jv jw fd ii er es paragraph-image"><div class="er es jz"><img src="../Images/8938477095c44c0792973755bb46e0cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:702/format:webp/1*dCQMFaMuBdOWM1Wj2Ij8DA.png"/></div></figure><p id="6462" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">因此，代替(n，p)形状的数据，其中n是帧(行)的数量，p是预测器(列)的数量，我们将适合(n-k-1，k，p)形状的LSTM模型数据，其中k是预测Y的下一个值所需的先前帧序列的长度。目标也将具有n-k-1个数据点，因为首先，我们将数据移动一行来预测“下一帧”事件，在第二个，我们需要至少k个第一行来预测Y因此，对于X和Y，可能的行的总数将是n-k-1。</p><p id="a886" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们用真实的数据来看看这是如何实现的。为了避免对4个网络摄像头的视频数据进行大量转换，我将使用距离Chievres机场(比利时)最近的气象站的4个时间序列气象测量值。它是<a class="ae it" href="http://archive.ics.uci.edu/ml/datasets/Appliances+energy+prediction" rel="noopener ugc nofollow" target="_blank">“家电能源预测数据集”</a>的一部分。</p><p id="0081" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">导入库，加载数据集，并打印表头:</p><figure class="jt ju jv jw fd ii"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="14f4" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">正如我们所看到的，这些数据代表了从2016年1月11日开始的4.5个月中以10分钟为间隔记录的4种不同天气测量的19735次观测:</p><figure class="jt ju jv jw fd ii"><div class="bz dy l di"><div class="ka kb l"/></div></figure><figure class="jt ju jv jw fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kc"><img src="../Images/059ff478c9bcab4b6fcb4071fb2a315b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lNSzmpWPRHNfzBa38mg3zQ.jpeg"/></div></div></figure><p id="a4ed" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">目标呢？在这里，我们可以设定很多目标，我选择了预测未来10分钟的温度是否会高于当前温度的想法:</p><figure class="jt ju jv jw fd ii"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="3237" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在我们需要一个函数将原始数据转换成一组k长度的序列，并带有相应的目标——如前所述。</p><figure class="jt ju jv jw fd ii"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="b914" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这个函数的输入应该是带有原始数据的NumPy数组，其中最后一列是目标变量。输出将是具有(n-k，k，p)形状的预测器的矩阵和具有(n-k，)形状的目标向量。由于我们之前删除了最后一行，与初始数据相比，输出矩阵的真实形状是(n-k-1，k，p)。在这种情况下，在开始时，我们看到了具有(19735，5)形状的表，但是现在我们有了(19724，10，4)作为预测器和(19724，)作为目标。</p><p id="3b22" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">以下函数有助于检查“create_lstm_data”函数是否工作正常:</p><figure class="jt ju jv jw fd ii"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="46c0" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们可以发现，LSTM数据的第0行包含一个5长度的序列，它对应于原始数据中的第0:4行。LSTM数据的第0行的目标是0，这对应于初始数据的“T_out”列中第5行与第4行的比较:“T_out”在第5个指数时低于第4个指数，这意味着在下一个间隔中温度没有增加，因此目标变量被设置为“0”。对LSTM数据的第100行进行相同的检查。</p><p id="0ecf" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">接下来，我们定义训练集、有效集和测试集:</p><figure class="jt ju jv jw fd ii"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="a1b3" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了建立一个LSTM神经网络，我使用了Keras框架。一般模型设置如下:</p><ul class=""><li id="30c7" class="kd ke hh iw b ix iy jb jc jf kf jj kg jn kh jr ki kj kk kl bi translated">1个LSTM层，100个单元，默认<a class="ae it" href="https://keras.io/api/layers/recurrent_layers/lstm/" rel="noopener ugc nofollow" target="_blank"> Keras层参数</a>；</li><li id="ec06" class="kd ke hh iw b ix km jb kn jf ko jj kp jn kq jr ki kj kk kl bi translated">1具有2个单元和sigmoid激活函数的稠密层(正如我们正在处理的二元分类)；</li><li id="9af6" class="kd ke hh iw b ix km jb kn jf ko jj kp jn kq jr ki kj kk kl bi translated">学习率为0.01的Adam优化器；</li><li id="3ef9" class="kd ke hh iw b ix km jb kn jf ko jj kp jn kq jr ki kj kk kl bi translated">二元交叉熵损失函数；</li><li id="4475" class="kd ke hh iw b ix km jb kn jf ko jj kp jn kq jr ki kj kk kl bi translated">如果在当前时期，模型在验证集上显示出最佳精度，则保存模型；</li><li id="2700" class="kd ke hh iw b ix km jb kn jf ko jj kp jn kq jr ki kj kk kl bi translated">如果在最后20个周期内，验证损失没有减少，则停止训练。</li></ul><figure class="jt ju jv jw fd ii"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="5165" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">请注意:</p><ul class=""><li id="1dea" class="kd ke hh iw b ix iy jb jc jf kf jj kg jn kh jr ki kj kk kl bi translated">LSTM层的输入形状设置为(k，p ),其中k是序列的长度，p是预测值的数量；</li><li id="e135" class="kd ke hh iw b ix km jb kn jf ko jj kp jn kq jr ki kj kk kl bi translated">按照模型设置的要求，目标向量用一键编码进行变换。</li></ul><p id="2fc9" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">最后，由于我们不知道k的“真实”值，即序列的长度，使用它可以最好地预测目标，我将把训练-验证过程包装到循环中:在每个循环中，新的k将用于转换数据和训练模型。</p><figure class="jt ju jv jw fd ii"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="d46a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">此外，添加内部循环来训练和测试每个k长度的“num_init”个模型:这些循环的测试精度存储在列表中，然后计算特定k长度的平均精度分数。这样做是为了减少偶然的“超差”或“超好”初始层权重的影响。此外，最小最大值定标器被应用于数据，以便<a class="ae it" href="https://machinelearningmastery.com/how-to-improve-neural-network-stability-and-modeling-performance-with-data-scaling/" rel="noopener ugc nofollow" target="_blank">改进和加快训练过程。</a></p><p id="693c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">最后，我们绘制图表，其中x轴是插入模型的k长度值，y轴是每个k长度的“num_init”模型初始化的平均准确度分数:</p><figure class="jt ju jv jw fd ii"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="e303" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">下面是一个图表，显示了每k长度训练和测试一次的LSTM模型的准确度分数:正如我们在这里看到的，50长度的序列“偶尔”会获得最高的准确度。</p><figure class="jt ju jv jw fd ii"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="983e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">而不是结论:</p><ul class=""><li id="a6a3" class="kd ke hh iw b ix iy jb jc jf kf jj kg jn kh jr ki kj kk kl bi translated">LSTM模型是处理时间序列数据的有力工具；</li><li id="7fed" class="kd ke hh iw b ix km jb kn jf ko jj kp jn kq jr ki kj kk kl bi translated">一旦理解了数据应该如何转换并适合模型，LSTM模型的实现就不那么复杂了。</li></ul></div></div>    
</body>
</html>