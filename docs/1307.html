<html>
<head>
<title>How To Use Sklearn’s Pipelines To Optimize Your Analysis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Sklearn的管道优化您的分析</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/how-to-use-sklearns-pipelines-to-optimize-your-analysis-b6cd91999be?source=collection_archive---------3-----------------------#2021-11-18">https://medium.com/mlearning-ai/how-to-use-sklearns-pipelines-to-optimize-your-analysis-b6cd91999be?source=collection_archive---------3-----------------------#2021-11-18</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/4f428f7b0f0f781897527fb0f225bf3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KhGjyzBk6ZkSlHYN3m_ruw.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Photo by <a class="ae it" href="https://unsplash.com/@mbenna?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Mike Benna</a> on <a class="ae it" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="8ef9" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在数据科学和机器学习中，<strong class="iw hi">管道是一组连续的步骤，允许我们控制数据流</strong>。它们非常有用，因为它们使我们的代码更干净、更具可伸缩性和可读性。它们用于组织项目的各个阶段，例如预处理、训练模型等等。事实上，通过管道，我们可以将所有这些操作压缩到一个对象中，从而使我们的代码简洁明了。</p><p id="6a35" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">实现管道不是强制性的，但有显著的优势，例如</p><ul class=""><li id="52f6" class="js jt hh iw b ix iy jb jc jf ju jj jv jn jw jr jx jy jz ka bi translated"><strong class="iw hi">更干净的代码</strong>:我们以更有条理的方式编写更少的代码。这促进了结果的可读性和解释</li><li id="1f0b" class="js jt hh iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated"><strong class="iw hi">减少出错的空间</strong>——通过编写有组织的代码，我们减少了在“自由”环境中经常发生的人为错误</li><li id="8208" class="js jt hh iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">使用Scikit-Learn，<strong class="iw hi">管道的使用类似于带有。适合()。</strong></li></ul><p id="6f1f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">下面是一个如何将管道用于合成Scikit-Learn数据集的示例。文档可以在<a class="ae it" href="https://scikit-learn.org/stable/modules/generated/sklearn.pipeline.Pipeline.html" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="fcd6" class="kp kq hh kl b fi kr ks l kt ku"><strong class="kl hi">from</strong> <strong class="kl hi">sklearn.svm</strong> <strong class="kl hi">import</strong> SVC<br/><strong class="kl hi">from</strong> <strong class="kl hi">sklearn.preprocessing</strong> <strong class="kl hi">import</strong> StandardScaler<br/><strong class="kl hi">from</strong> <strong class="kl hi">sklearn.datasets</strong> <strong class="kl hi">import</strong> make_classification<br/><strong class="kl hi">from</strong> <strong class="kl hi">sklearn.model_selection</strong> <strong class="kl hi">import</strong> train_test_split<br/><strong class="kl hi">from</strong> <strong class="kl hi">sklearn.pipeline</strong> <strong class="kl hi">import</strong> Pipeline</span><span id="9135" class="kp kq hh kl b fi kv ks l kt ku"># create dataset<br/>X, y = make_classification(random_state=<strong class="kl hi">0</strong>)</span><span id="50b0" class="kp kq hh kl b fi kv ks l kt ku"># create train-test split<br/>X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=<strong class="kl hi">0</strong>)</span><span id="8d3d" class="kp kq hh kl b fi kv ks l kt ku"># create a Pipeline object that scales the data and feeds it to a Support Vector Machine<br/>pipe = Pipeline([('scaler', StandardScaler()), ('svc', SVC())])<br/><br/># an Sklearn Pipeline is used as any other estimator - run everything with .fit()<br/>pipe.fit(X_train, y_train)<br/>Pipeline(steps=[('scaler', StandardScaler()), ('svc', SVC())])<br/>pipe.score(X_test, y_test)<br/><br/>&gt;&gt;&gt; <strong class="kl hi">0.88</strong></span></pre><p id="e212" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这里我们通过Scikit-Learn的<em class="kw"> make_classification </em>创建我们的<em class="kw"> X </em>特性集和<em class="kw"> y </em>目标。然后我们使用<em class="kw"> train_test_split </em>将X和y分成训练集和测试集。</p><p id="2e35" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">然后，我们将在管道中放置<strong class="iw hi">两个步骤:第一个是处理数据标准化的步骤(定标器)，另一个是SVC模型的应用(支持向量分类器)。</strong></p><p id="d950" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">您可以在Pipeline对象的列表中看到这两个步骤。最后，就像我们通过<em class="kw">训练任何模型一样训练管道。</em>fit(X _ train，y_train)。流水线将负责在各个步骤中“传递”X_train和y_train，并通过<em class="kw">返回能够进行预测的模型。预测()。</em></p><h1 id="5cec" class="kx kq hh bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">实践示例+模板</h1><p id="45db" class="pw-post-body-paragraph iu iv hh iw b ix lu iz ja jb lv jd je jf lw jh ji jj lx jl jm jn ly jp jq jr ha bi translated">以下是在具有回归任务的机器学习项目中使用Pipeline的模板。</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="1c40" class="kp kq hh kl b fi kr ks l kt ku"><strong class="kl hi">import</strong> <strong class="kl hi">pandas</strong> <strong class="kl hi">as</strong> <strong class="kl hi">pd</strong><br/><strong class="kl hi">from</strong> <strong class="kl hi">sklearn.model_selection</strong> <strong class="kl hi">import</strong> train_test_split<br/><strong class="kl hi">from</strong> <strong class="kl hi">sklearn.compose</strong> <strong class="kl hi">import</strong> ColumnTransformer<br/><strong class="kl hi">from</strong> <strong class="kl hi">sklearn.impute</strong> <strong class="kl hi">import</strong> SimpleImputer<br/><strong class="kl hi">from</strong> <strong class="kl hi">sklearn.preprocessing</strong> <strong class="kl hi">import</strong> OneHotEncoder<br/><strong class="kl hi">from</strong> <strong class="kl hi">xgboost</strong> <strong class="kl hi">import</strong> XGBRegressor<br/><br/># bring in our dataset<br/>data = pd.read_csv("./my_dataset.csv")<br/><br/># split features and target<br/>y = data.Price<br/>X = data.drop("Price", axis=<strong class="kl hi">1</strong>)<br/><br/># create train-test split<br/>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<strong class="kl hi">0.75</strong>)<br/><br/># isolate categorical variables (if present)<br/>categorical_columns = [col <strong class="kl hi">for</strong> col <strong class="kl hi">in</strong> X_train.columns <strong class="kl hi">if</strong> X_train[col].dtype == "object"]<br/><br/># isolate numerical variables (if present)<br/>numerical_columns = [col <strong class="kl hi">for</strong> col <strong class="kl hi">in</strong> X_train.columns <strong class="kl hi">if</strong> X_train[col].dtype \<br/>    <strong class="kl hi">in</strong> ["int64", "float64"]]<br/><br/># define preprocessing steps<br/># 1) Manage missing values in numerical columns<br/># 2) Manage missing values and apply one-hot encoding in categorical columns<br/># We'll use Sklearn's ColumnTransformer to group the objects that will apply transformations to our columns<br/><br/># preprocessing for numerical data <br/># only one step in this case - imputation for missing values<br/>numerical_transformer = SimpleImputer()<br/><br/># preprocessing for categorical data<br/># two steps: missing values imputation, one-hot encoding<br/>categorical_transformer = Pipeline(steps=[<br/>    ("imputer", SimpleImputer(strategy="most_frequent")),<br/>    ("ohe", OneHotEncoder(handle_unknown="ignore"))<br/>])<br/><br/># bundle everything in ColumnTransformer<br/>preprocessor = ColumnTransformer(<br/>    transformers=[<br/>        ("numerical", numerical_transformer, numerical_columns),<br/>        ("categorical", categorical_transformer, categorical_columns),<br/>    ]<br/>)<br/><br/># preprocessor completed - now initialize a regression model with XGB<br/>regressor = XGBRegressor()</span></pre><p id="8c1e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们花点时间来分析一下<em class="kw"> ColumnTransformer </em>。非常简单:这个Sklearn对象允许我们对dataframe或Numpy数组中的列进行转换。在上面的代码中，我们已经将转换器(比如One-Hot编码器和Simple Imputer)应用于数字和分类列。然后，作为其中一个步骤，ColumnTransformer被直接传递到管道中。如果你想了解更多关于它是如何工作的，请参考这里的文档。</p><p id="bb3b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们以一种清晰和可解释的方式创建了预处理管道。现在让我们创建最终的管道，它包含预处理和XGBRegressor模型。</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="3885" class="kp kq hh kl b fi kr ks l kt ku">final_pipeline = Pipeline(steps=[<br/>    ("preprocessor", preprocessor),<br/>    ("xgb", regressor)<br/>])<br/><br/># pass training data to the pipeline<br/>final_pipeline.fit(X_train, y_train)<br/><br/># create predictions<br/>preds = final_pipeline.predict(X_test)<br/><br/># evaluate the model<br/><strong class="kl hi">from</strong> <strong class="kl hi">sklearn.metrics</strong> <strong class="kl hi">import</strong> mean_squared_error<br/><br/># we use RMSE (Root Mean Squared Error) using mean_squared_error with argument squared=False<br/>eval_metric = mean_squared_error(y_test, preds, squared=False)<br/><strong class="kl hi">print</strong>(eval_metric)</span></pre><p id="dead" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们现在有了一个使用Scikit-Learn的管道结构的复制粘贴模板。</p></div></div>    
</body>
</html>