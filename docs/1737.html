<html>
<head>
<title>Model Performance and Confusion Matrix in Machine Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">机器学习中的模型性能和混淆矩阵</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/model-performance-and-confusion-matrix-in-machine-learning-688ca3a8743d?source=collection_archive---------4-----------------------#2022-01-24">https://medium.com/mlearning-ai/model-performance-and-confusion-matrix-in-machine-learning-688ca3a8743d?source=collection_archive---------4-----------------------#2022-01-24</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="a0b8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">开发机器学习算法最重要的一步是检查你建立的模型的性能。这就是混淆矩阵派上用场的地方。混淆矩阵是表示分类算法性能的表格。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/d186a523047442aacc820580737b6151.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vojBYhu4QlzAZIvTPwt1fA.jpeg"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Photo by <strong class="bd js">Guillaume Bourdages </strong>on<strong class="bd js"> </strong><a class="ae jt" href="https://unsplash.com/photos/WDbuusPOnkM" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="44d4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">混淆矩阵有什么迷惑性？</strong></p><p id="ffd9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">顾名思义，混淆矩阵是一种观察由预测结果产生的混淆的方法。我对混淆矩阵的解释是，当机器不能100%准确地对其预测进行分类时，它会感到混淆。</p><p id="095c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果机器每次都能正确预测数值，混淆矩阵将只包含真阳性和真阴性。然而，它有时会混淆和分类错误，从而导致假阳性和假阴性的产生。稍后我将解释我所说的<em class="ju">真阳性、真阴性、假阳性</em>和<em class="ju">假阴性</em>是什么意思，现在让我们进入编码。</p><p id="c845" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">探索数据</strong></p><p id="1bf7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我将使用来自<strong class="ig hi"/><a class="ae jt" href="https://www.kaggle.com/teertha/personal-loan-modeling" rel="noopener ugc nofollow" target="_blank"><strong class="ig hi">Kaggle</strong></a>的银行个人贷款建模数据集来创建逻辑回归模型，以预测Thera银行的负债客户是否会接受下一次活动中提供的个人贷款。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jv"><img src="../Images/467a5899fde2b433fd02c827c6e6abcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SdsMtwT09GR8lkFhy55fMw.jpeg"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Photo by<strong class="bd js"> Mathieu Stern</strong> on <a class="ae jt" href="https://unsplash.com/photos/1fzyz-bmKBw" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="b987" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们从导入熊猫来加载数据集开始，然后读取并研究它。</p><pre class="jd je jf jg fd jw jx jy jz aw ka bi"><span id="72c9" class="kb kc hh jx b fi kd ke l kf kg">import pandas as pd<br/>df = pd.read_csv('Bank_Personal_Loan_Modelling.csv')</span></pre><p id="819f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">数据集中的个人贷款列回答了以下问题:“该客户是否接受了上次活动中提供的个人贷款？”。该列由二进制变量组成，0表示拒绝报价的“否”客户，1表示接受报价的“是”客户。在5000名客户中，只有480名客户(9.6%)接受了在早期活动中向他们提供的个人贷款。</p><pre class="jd je jf jg fd jw jx jy jz aw ka bi"><span id="bb2e" class="kb kc hh jx b fi kd ke l kf kg">df['Personal Loan'].value_counts()</span></pre><p id="0b70" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">输出是:</p><pre class="jd je jf jg fd jw jx jy jz aw ka bi"><span id="ae9d" class="kb kc hh jx b fi kd ke l kf kg">0    4520<br/>1     480<br/>Name: Personal Loan, dtype: int64</span></pre><p id="9852" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下一步是创建特征变量X(预测值的数据框架)和目标变量y，然后使用sklearn将数据集分为训练集(X_train，y_train)和测试集(X_test，y_test)。</p><pre class="jd je jf jg fd jw jx jy jz aw ka bi"><span id="9d69" class="kb kc hh jx b fi kd ke l kf kg">from sklearn.model_selection import train_test_split <br/>X = df.drop('Personal Loan', axis=1)<br/>y = df['Personal Loan']<br/>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.25, random_state=42, stratify=y)</span></pre><p id="4a54" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">数据包含不同维度和比例的要素。我将对数据进行缩放，以防止不同的缩放比例对建模的影响。就错误分类误差和准确率而言，未经调整的数据可能会导致有偏差的预测结果。</p><p id="d480" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">python<em class="ju"/><strong class="ig hi">sk learn</strong>库为我们提供了<strong class="ig hi"> StandardScaler() </strong>函数将数据标准化为标准格式。</p><pre class="jd je jf jg fd jw jx jy jz aw ka bi"><span id="d5cb" class="kb kc hh jx b fi kd ke l kf kg">from sklearn.preprocessing import StandardScaler<br/>scaler = StandardScaler()<br/>X_train_scaled = scaler.fit_transform(X_train)<br/>X_test_scaled = scaler.transform(X_test)</span></pre><p id="b491" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">模型建筑</strong></p><p id="0395" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下面的代码符合一个<strong class="ig hi">逻辑回归模型</strong>来预测客户根据之前的活动批准或拒绝个人贷款的概率。</p><pre class="jd je jf jg fd jw jx jy jz aw ka bi"><span id="4de2" class="kb kc hh jx b fi kd ke l kf kg">from sklearn.linear_model import LogisticRegression<br/>logreg = LogisticRegression()<br/>logreg.fit(X_train_scaled, y_train)<br/>y_pred_train = logreg.predict(X_train_scaled)<br/>y_pred_test = logreg.predict(X_test_scaled)</span></pre><p id="a373" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们将训练和测试数据的预测输出存储在y_pred_train和y_pred_test中，我们将在下面的几个指标中使用它们。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es kh"><img src="../Images/d673db93bb612c12f17016ee309ccb79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cL-aR_2syKdmFS7igEU9fQ.jpeg"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Photo by <strong class="bd js">Taylor Deas-Melesh </strong>on <a class="ae jt" href="https://unsplash.com/photos/fkaQ-cqU4Uo" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="a585" class="kb kc hh bd js ki kj kk kl km kn ko kp ip kq kr ks it kt ku kv ix kw kx ky kz bi translated"><strong class="ak">真、假、正、负</strong></h2><ul class=""><li id="0f8d" class="la lb hh ig b ih lc il ld ip le it lf ix lg jb lh li lj lk bi translated"><strong class="ig hi">真阳性(TP): </strong>模型预测客户会贷款，而客户实际上贷款了。</li><li id="1a7a" class="la lb hh ig b ih ll il lm ip ln it lo ix lp jb lh li lj lk bi translated"><strong class="ig hi">真否定(TN): </strong>模型预测客户不会贷款，而客户实际上并没有贷款。</li><li id="14ec" class="la lb hh ig b ih ll il lm ip ln it lo ix lp jb lh li lj lk bi translated"><strong class="ig hi">误报(FP): </strong>模型预测客户会贷款，但客户实际上没有贷款。</li><li id="6cf1" class="la lb hh ig b ih ll il lm ip ln it lo ix lp jb lh li lj lk bi translated"><strong class="ig hi">假阴性(FN): </strong>模型预测客户不会贷款，但客户实际上贷款了。</li></ul><h1 id="a6a0" class="lq kc hh bd js lr ls lt kl lu lv lw kp lx ly lz ks ma mb mc kv md me mf ky mg bi translated">分类指标</h1><p id="6f69" class="pw-post-body-paragraph ie if hh ig b ih lc ij ik il ld in io ip mh ir is it mi iv iw ix mj iz ja jb ha bi translated"><strong class="ig hi">精度</strong></p><p id="7e2c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">准确度分数计算分类器做出正确预测的频率。</p><p id="a69a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Sklearn metrics提供了accuracy_score函数来获得准确性，我们可以在训练和测试数据上应用该方法来观察它们的性能。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es mk"><img src="../Images/8576a9adcf2a5a9ddd73db814a3e492b.png" data-original-src="https://miro.medium.com/v2/resize:fit:948/format:webp/1*P4iU_VJ8kQD_XnX3V1RPdg.png"/></div></figure><pre class="jd je jf jg fd jw jx jy jz aw ka bi"><span id="9f48" class="kb kc hh jx b fi kd ke l kf kg">from sklearn.metrics import accuracy_score<br/>train_acc = accuracy_score(y_train, y_pred_train)<br/>test_acc = accuracy_score(y_test, y_pred_test)<br/>print(f"Training Data Accuracy Score: {train_acc:.3f}\nTesting Data Accuracy Score: {test_acc:.3f}")</span></pre><p id="2dea" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">输出是:</p><pre class="jd je jf jg fd jw jx jy jz aw ka bi"><span id="5030" class="kb kc hh jx b fi kd ke l kf kg">Training Data Accuracy Score: 0.953<br/>Testing Data Accuracy Score: 0.949</span></pre><p id="1c11" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">该模型的准确率为95%，这是相当高的，但由于数据不平衡，它不是检查模型性能的正确指标。</p><p id="965e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">召回</strong></p><p id="5d28" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">回忆，也称为<em class="ju">敏感度</em>或<em class="ju">真阳性率(TPR) </em>衡量所有实际的1有多少是我们预测的1。它是被正确分类为阳性的阳性实例的比率。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es ml"><img src="../Images/57d5101da6746e7cf36be21860c7e973.png" data-original-src="https://miro.medium.com/v2/resize:fit:372/format:webp/1*HHfm8xbEAAA8ZIvSWJf27g.png"/></div></figure><pre class="jd je jf jg fd jw jx jy jz aw ka bi"><span id="0ba3" class="kb kc hh jx b fi kd ke l kf kg">from sklearn.metrics import recall_score<br/>train_recall = recall_score(y_train, y_pred_train)<br/>test_recall = recall_score(y_test, y_pred_test)<br/>print(f"Training Data Recall Score: {train_recall:.3f}\nTesting Data Recall Score: {test_recall:.3f}")</span></pre><p id="004c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">输出是:</p><pre class="jd je jf jg fd jw jx jy jz aw ka bi"><span id="04f7" class="kb kc hh jx b fi kd ke l kf kg">Training Data Recall Score: 0.639<br/>Testing Data Recall Score: 0.625</span></pre><p id="2846" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">该模型的召回分数非常低，为63%，这意味着该模型未能预测每100个客户中的37个潜在客户。银行认为这是机会的损失，应该尽可能地减少损失。根据我们的情况，召回率是我们想要最大化的最重要的指标，因为召回率越高，假阴性就越少。</p><p id="d01a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">精度</strong></p><p id="06a2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">精度衡量正面预测的准确性。它计算出我们预测的所有1中有多少实际上是1。换句话说，然后它预测积极的结果，它是正确的。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es mm"><img src="../Images/75c68a9bb1ef2cdb288a512ea32f07c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:450/format:webp/1*oPi-k-ylhqLR9sLYnZ_KrQ.png"/></div></figure><pre class="jd je jf jg fd jw jx jy jz aw ka bi"><span id="60f5" class="kb kc hh jx b fi kd ke l kf kg">from sklearn.metrics import precision_score<br/>train_precision = precision_score(y_train, y_pred_train)<br/>test_precision = precision_score(y_test, y_pred_test)<br/>print(f"Training Data Precision Score: {train_precision:.3f}\nTesting Data Precision Score: {test_precision:.3f}")</span></pre><p id="eb34" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">输出是:</p><pre class="jd je jf jg fd jw jx jy jz aw ka bi"><span id="b4fb" class="kb kc hh jx b fi kd ke l kf kg">Training Data Precision Score: 0.836<br/>Testing Data Precision Score: 0.798</span></pre><p id="4c71" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们的训练数据比测试数据得分更高，因此我们的模型预测了测试数据中更多的假阳性。</p><p id="4791" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> F1得分</strong></p><p id="dc28" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">F1得分是精确度和召回率的组合，是精确度和召回率的调和平均值。只有在精确度和召回率都很高的情况下，分类器才能获得高的F1分数。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es mn"><img src="../Images/af38985df72951203d24ac37ce7fa88a.png" data-original-src="https://miro.medium.com/v2/resize:fit:916/format:webp/1*oowlZ9NoNgPeNj3R0cqYOw.png"/></div></div></figure><p id="acdc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当你需要同时考虑精确度和召回率时，F1分数是最有用的。根据数据的上下文，您最关心的是精确度或召回率。提高精度降低召回率，提高召回率降低精度；这被称为<em class="ju">精度/召回权衡。</em></p><pre class="jd je jf jg fd jw jx jy jz aw ka bi"><span id="ac86" class="kb kc hh jx b fi kd ke l kf kg">from sklearn.metrics import f1_score<br/>train_f1 = f1_score(y_train, y_pred_train)<br/>test_f1 = f1_score(y_test, y_pred_test)<br/>print(f"Training Data F1 Score: {train_f1:.3f}\nTesting Data F1 Score: {test_f1:.3f}")</span></pre><p id="132f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">输出是:</p><pre class="jd je jf jg fd jw jx jy jz aw ka bi"><span id="c57d" class="kb kc hh jx b fi kd ke l kf kg">Training Data F1 Score: 0.724<br/>Testing Data F1 Score: 0.701</span></pre><p id="5137" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们的训练数据再次胜过测试数据，F1分数高出2%。在我们的例子中，F1分数比准确度分数更有用，因为准确度没有考虑到班级的不平衡。尽管如此，考虑到我们的数据和业务问题，召回分数是最有意义的优化指标。</p><h1 id="bdf5" class="lq kc hh bd js lr ls lt kl lu lv lw kp lx ly lz ks ma mb mc kv md me mf ky mg bi translated"><strong class="ak">绘制混乱矩阵</strong></h1><p id="019e" class="pw-post-body-paragraph ie if hh ig b ih lc ij ik il ld in io ip mh ir is it mi iv iw ix mj iz ja jb ha bi translated">混淆矩阵的第一行代表<em class="ju">负类</em>。真阳性在左上方，假阳性在右上方。</p><p id="9014" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第二排代表<em class="ju">正班</em>。左下方是假阴性，右下方是真阳性。</p><pre class="jd je jf jg fd jw jx jy jz aw ka bi"><span id="26ec" class="kb kc hh jx b fi kd ke l kf kg">from sklearn.metrics import confusion_matrix<br/>cm = confusion_matrix(y_test, y_pred_test)<br/>cm</span></pre><p id="1992" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">输出是:</p><pre class="jd je jf jg fd jw jx jy jz aw ka bi"><span id="648f" class="kb kc hh jx b fi kd ke l kf kg">array([[1111,   19],<br/>       [  45,   75]])</span></pre><p id="e9f3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们画出训练数据的混淆矩阵。</p><pre class="jd je jf jg fd jw jx jy jz aw ka bi"><span id="c50c" class="kb kc hh jx b fi kd ke l kf kg">sklearn.metrics import plot_confusion_matrix<br/>plot_confusion_matrix(logreg, X_train_scaled, y_train);</span></pre><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es mo"><img src="../Images/a3f9827c4565978c76e1613cb3fe044b.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*4kFzeFAZx8je1QsDNjZx8Q.png"/></div><figcaption class="jo jp et er es jq jr bd b be z dx">Photo by Author</figcaption></figure><p id="3621" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">测试数据的混淆矩阵:</p><pre class="jd je jf jg fd jw jx jy jz aw ka bi"><span id="24f4" class="kb kc hh jx b fi kd ke l kf kg">plot_confusion_matrix(logreg, X_test_scaled, y_test);</span></pre><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es mo"><img src="../Images/5396e47db4d5bed9874804481733a2c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*A2R6ClNs5qjyRv9SjWlaYw.png"/></div><figcaption class="jo jp et er es jq jr bd b be z dx">Photo by Author</figcaption></figure><p id="09c2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们可以用来自<em class="ju"> Seaborn </em>库的<em class="ju">热图</em>绘制更漂亮的混淆矩阵。</p><pre class="jd je jf jg fd jw jx jy jz aw ka bi"><span id="524d" class="kb kc hh jx b fi kd ke l kf kg">import seaborn as sns<br/>import matplotlib.pyplot as plt<br/>ax= plt.subplot()<br/>sns.heatmap(cm, annot=True, ax = ax, fmt = '.0f', cmap='Reds') #annot=True to annotate cells<br/>#labels and ticks<br/>ax.set_xlabel('Predicted', fontsize=20)<br/>ax.xaxis.set_label_position('bottom') <br/>ax.xaxis.set_ticklabels([0, 1], fontsize = 15)<br/>ax.xaxis.tick_top()</span><span id="da61" class="kb kc hh jx b fi mp ke l kf kg">ax.set_ylabel('True', fontsize=20)<br/>ax.yaxis.set_ticklabels([0, 1], fontsize = 15);</span></pre><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es mo"><img src="../Images/ff8157144d6727c4ba7b7c88225f3e31.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*YKGPeurEB9gEy4pjnPH1ow.png"/></div><figcaption class="jo jp et er es jq jr bd b be z dx">Photo by Author</figcaption></figure><p id="b05f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">你想看更好的<em class="ju">热图</em>吗？每个象限中标记有百分比的混淆矩阵提供了关于我们的预测和模型性能的更多信息。</p><pre class="jd je jf jg fd jw jx jy jz aw ka bi"><span id="e890" class="kb kc hh jx b fi kd ke l kf kg">import numpy as np<br/>ax= plt.subplot()<br/>sns.heatmap(cm/np.sum(cm), annot=True, ax = ax, fmt='.2%', cmap='Blues')<br/>ax.set_xlabel('Predicted', fontsize=20)<br/>ax.xaxis.set_label_position('bottom') <br/>ax.xaxis.set_ticklabels([0, 1], fontsize = 15)<br/>ax.xaxis.tick_top()</span><span id="0098" class="kb kc hh jx b fi mp ke l kf kg">ax.set_ylabel('True', fontsize=20)<br/>ax.yaxis.set_ticklabels([0, 1], fontsize = 15);</span></pre><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es mo"><img src="../Images/58c4ed69f78862e6486f984b163845f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*rYf_Z0H0nceJDOyem1L4Qw.png"/></div><figcaption class="jo jp et er es jq jr bd b be z dx">Photo by Author</figcaption></figure><p id="d595" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">该模型将1.52%的数据归类为<em class="ju">误报</em>，这意味着拒绝个人贷款的客户被归类为接受贷款的客户。该模型将我们数据的3.60%归类为<em class="ju">假阴性</em>，这意味着接受报价的客户被归类为拒绝。因此，在接受报价的9.6%的客户中，超过三分之一的客户被错误分类。这种模式需要在召回性能上进行改进，以减少<em class="ju">假阴性</em>，这样银行就不会失去潜在客户。</p><p id="ac4f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">注:</strong>本教程的目的是演示模型性能指标并可视化混淆矩阵。先前的数据清理或预处理还没有实践过。</p><p id="81c6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">本文的GitHub知识库可以在这里找到:</p><div class="mq mr ez fb ms mt"><a href="https://github.com/haticerdogan/Model-Performance" rel="noopener  ugc nofollow" target="_blank"><div class="mu ab dw"><div class="mv ab mw cl cj mx"><h2 class="bd hi fi z dy my ea eb mz ed ef hg bi translated">GitHub-haticerdogan/模型-性能:中等教程</h2><div class="na l"><h3 class="bd b fi z dy my ea eb mz ed ef dx translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="nb l"><p class="bd b fp z dy my ea eb mz ed ef dx translated">github.com</p></div></div><div class="nc l"><div class="nd l ne nf ng nc nh jm mt"/></div></div></a></div><div class="mq mr ez fb ms mt"><a rel="noopener follow" target="_blank" href="/mlearning-ai/mlearning-ai-submission-suggestions-b51e2b130bfb"><div class="mu ab dw"><div class="mv ab mw cl cj mx"><h2 class="bd hi fi z dy my ea eb mz ed ef hg bi translated">Mlearning.ai提交建议</h2><div class="na l"><h3 class="bd b fi z dy my ea eb mz ed ef dx translated">如何成为Mlearning.ai上的作家</h3></div><div class="nb l"><p class="bd b fp z dy my ea eb mz ed ef dx translated">medium.com</p></div></div><div class="nc l"><div class="ni l ne nf ng nc nh jm mt"/></div></div></a></div></div></div>    
</body>
</html>