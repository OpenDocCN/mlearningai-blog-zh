<html>
<head>
<title>Building an Image Colorization Neural Network — Part 1: Generative Models and Autoencoders</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建图像彩色化神经网络第1部分:生成模型和自动编码器</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/building-an-image-colorization-neural-network-part-1-generative-models-and-autoencoders-d68f5769d484?source=collection_archive---------4-----------------------#2022-08-28">https://medium.com/mlearning-ai/building-an-image-colorization-neural-network-part-1-generative-models-and-autoencoders-d68f5769d484?source=collection_archive---------4-----------------------#2022-08-28</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/23c47088455b135e9389bd60ccce7884.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*TNy8IYwLZnd_bGt5.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Source: <a class="ae hu" href="https://github.com/PacktPublishing/Advanced-Deep-Learning-with-Keras/blob/master/chapter3-autoencoders" rel="noopener ugc nofollow" target="_blank">https://github.com/PacktPublishing/Advanced-Deep-Learning-with-Keras/blob/master/chapter3-autoencoders</a></figcaption></figure><div class=""/><p id="d69a" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在我的人工智能研究生学习期间，我有机会非常详细地研究人工神经网络。其中一项作业是基于卷积神经网络的，我可以自由选择问题，然后提供解决方案。我过去，现在仍然对生成模型非常感兴趣，所以我选择了图像着色任务。在图像彩色化中，目标是建立一个能够将真实颜色应用于黑色和灰色图像的模型。在本文中，我将指导您创建一个生成模型的过程，该模型利用卷积神经网络对图像进行着色。</p><p id="9b15" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在我们开始描述实现之前，我们需要为它打下基础。因此，我们将该流程分为以下4个部分:</p><ol class=""><li id="9ac9" class="js jt hx iw b ix iy jb jc jf ju jj jv jn jw jr jx jy jz ka bi translated"><strong class="iw hy">第1部分(当前)</strong>:概述生成模型和<em class="kb">自动编码器</em>的基础知识。</li><li id="57a4" class="js jt hx iw b ix kc jb kd jf ke jj kf jn kg jr jx jy jz ka bi translated"><a class="ae hu" rel="noopener" href="/mlearning-ai/building-an-image-colorization-neural-network-part-2-artificial-neural-networks-ac591eb180"> <strong class="iw hy">第二部分</strong> </a>:展示人工<em class="kb">神经网络</em>的基本概念。</li><li id="78fd" class="js jt hx iw b ix kc jb kd jf ke jj kf jn kg jr jx jy jz ka bi translated"><a class="ae hu" rel="noopener" href="/mlearning-ai/building-an-image-colorization-neural-network-part-3-convolutional-neural-networks-21a45ef42dde"> <strong class="iw hy">第三部分</strong> </a>:介绍<em class="kb">卷积神经网络</em>的基础知识。</li><li id="c4c5" class="js jt hx iw b ix kc jb kd jf ke jj kf jn kg jr jx jy jz ka bi translated"><a class="ae hu" rel="noopener" href="/@geokam/building-an-image-colorization-neural-network-part-4-implementation-7e8bb74616c"> <strong class="iw hy">第四部分</strong> </a>:描述实际模型的实现。</li></ol><blockquote class="kh ki kj"><p id="0bc1" class="iu iv kb iw b ix iy iz ja jb jc jd je kk jg jh ji kl jk jl jm km jo jp jq jr ha bi translated">声明:这绝不是一个教程。它提供了一些基本知识，但主要目标是展示如何构建这样一个模型。</p></blockquote></div><div class="ab cl kn ko go kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="ha hb hc hd he"><h1 id="257d" class="ku kv hx bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">生成模型</h1><p id="f81a" class="pw-post-body-paragraph iu iv hx iw b ix ls iz ja jb lt jd je jf lu jh ji jj lv jl jm jn lw jp jq jr ha bi translated">首先，让我们确保对一个模型什么时候被贴上<em class="kb">创成式</em>的标签有一个很好的理解。实际上，有两种不同类型的模型:<em class="kb">生成型</em>和<em class="kb">鉴别型</em>。辨别模型被认为是为了成功地辨别不同种类的数据样本。最常见的判别场景是二进制分类，其中每个数据样本都有一个属于两个不同类别之一的目标值。如果图像包含一只猫或一只狗，分类是一个基本的例子。然而，判别模型也可以区分两个以上的类别。根据前面的例子，如果图像包含一只猫或一只狗或一个人或任何你喜欢的东西，或者甚至是这些的组合(多标签分类)，分类也被认为是一个辨别任务。放入更正式的，一个判别模型捕捉到了条件概率<em class="kb"> P(Y|X) </em>，可以翻译为“当已知<em class="kb"> X </em>(特征)时，<em class="kb"> Y </em>(目标值)的概率是多少”。</p><p id="2eec" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">相反，生成式模型试图生成新的数据实例。例如，基于书面提示生成图像的模型(如DALL E)或在提供全文时生成摘要的模型(如GPT-3)是生成模型的两个流行案例。基本上，这种模型可以根据提示创建“新”数据，当然，也可以根据它们在训练期间看到的所有数据创建“新”数据。更官方的定义是，生成模型捕获联合概率<em class="kb"> P(X，Y) </em>，其中<em class="kb"> X </em>是输入提示，或者在没有标签的情况下<em class="kb"> P(X) </em>。该模型尝试学习实际数据的分布，以便“很好地”理解训练数据集是如何生成的。</p><p id="ba05" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">有许多类型的生成模型，例如<em class="kb">生成对抗网络</em>，也称为<em class="kb">甘斯</em>，以及<em class="kb">变分自动编码器</em>等等。在图像着色任务中，我选择基于简单的<em class="kb">自动编码器</em>方法建立一个生成模型。</p><h1 id="a024" class="ku kv hx bd kw kx lx kz la lb ly ld le lf lz lh li lj ma ll lm ln mb lp lq lr bi translated">自动编码器</h1><p id="6818" class="pw-post-body-paragraph iu iv hx iw b ix ls iz ja jb lt jd je jf lu jh ji jj lv jl jm jn lw jp jq jr ha bi translated">自动编码器的基本原理是它们由两个不同的部分组成:编码器和解码器。编码器接收输入并将其转换到一个新的空间，称为潜在空间，而解码器获得这个新的表示并将其转换回原始空间。用数学的方式来表达，编码器<em class="kb"> f </em>将数据从空间<em class="kb"> X </em>转换到空间<em class="kb"> F </em>，解码器<em class="kb"> g </em>将数据从空间<em class="kb"> F </em>转换到空间<em class="kb"> X </em>。</p><figure class="md me mf mg fd hj er es paragraph-image"><div class="er es mc"><img src="../Images/cafd3fc05b3f8f8df6db4251235a67bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:912/format:webp/1*eaOUpI5sb9_0DAmftFG8IQ.png"/></div><figcaption class="hq hr et er es hs ht bd b be z dx">Illustration of the transformation of an Autoencoder</figcaption></figure><p id="52ca" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">通常，与输入相比，潜在空间具有较低的维度，因此编码器执行维度缩减。通过这个过程，自动编码器被迫保留来自初始空间的最有价值的信息，并因此捕获必要的依赖性。但是我们如何衡量自动编码器的性能呢？一种方法是通过计算二次损失。如果<em class="kb"> q </em>是在<em class="kb"> X </em>上的数据分布，我们需要最小化以下项:</p><figure class="md me mf mg fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mh"><img src="../Images/260987f43f1b6dcc62db6a7ad2e8e4f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ucTLkCNZjX_Gnf55.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Reconstruction error of the Autoencoder</figcaption></figure><p id="7c13" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">更具体地说，如果映射f和g具有可训练的权重，那么我们需要最小化以下损失:</p><figure class="md me mf mg fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mi"><img src="../Images/cb2709c1811f8028ec09e216c169e0e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6SXe8nAzCBwFCsjT.png"/></div></div></figure><h1 id="cac2" class="ku kv hx bd kw kx lx kz la lb ly ld le lf lz lh li lj ma ll lm ln mb lp lq lr bi translated">深度自动编码器</h1><p id="eb01" class="pw-post-body-paragraph iu iv hx iw b ix ls iz ja jb lt jd je jf lu jh ji jj lv jl jm jn lw jp jq jr ha bi translated">为了解决图像着色问题，我们必须调整自动编码器，以利用<em class="kb">神经网络</em>，因为<em class="kb">卷积神经网络</em>在计算机视觉任务上工作得非常好。结果是<em class="kb">深度自动编码器</em>，其中编码器和解码器都是独立的<em class="kb">卷积神经网络</em>。编码器接收输入图像，并将其通过一系列转置卷积层。在这个过程中，输入变得越来越小，直到我们到达最终的转置层。在这个阶段，图像已经被转换到一个较低维度的空间。另一方面，解码器获得压缩的输入，并通过连续的卷积层重建初始输入。如果训练集足够大，自动编码器可以通过从潜在空间中选择数据点来学习生成新的实例。</p><figure class="md me mf mg fd hj er es paragraph-image"><div class="er es mj"><img src="../Images/efd9292c575faf2de6406ff41cb06ebd.png" data-original-src="https://miro.medium.com/v2/resize:fit:882/format:webp/1*KhB_5tj4bX1vp3JYJ9Os4w.png"/></div><figcaption class="hq hr et er es hs ht bd b be z dx">Deep Autoencoder with multiple layers.</figcaption></figure><p id="9182" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">而在输入提示为黑灰图像的图像彩色化问题中，我们并不想严格的再造，而是在某种意义上增强。图像具有(通道、宽度、高度)的形状。输入图像只包含一个通道，但是它们的彩色版本包含三个通道:红色、绿色和蓝色。因此，自动编码器被认为总共产生2个通道。为了简化这一点，我们可以利用<em class="kb"> LAB </em>格式，而不是使用<em class="kb"> RGB </em>格式，其中L表示亮度，a表示绿色和品红色之间的平衡，b表示蓝色和黄色之间的平衡。虽然<em class="kb"> LAB </em>使用相同数量的元素来说明一个像素，但L部分本质上是我们的输入图像。换句话说，通过使用<em class="kb"> LAB </em>格式，考虑到第三个通道L将来自输入，自动编码器将仅生成2个通道a和b。</p><p id="fc2c" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">本系列的第一部分到此结束。下一集，我们将看看<em class="kb">人工神经网络</em>。敬请期待！</p><div class="hg hh ez fb hi mk"><a rel="noopener follow" target="_blank" href="/mlearning-ai/mlearning-ai-submission-suggestions-b51e2b130bfb"><div class="ml ab dw"><div class="mm ab mn cl cj mo"><h2 class="bd hy fi z dy mp ea eb mq ed ef hw bi translated">Mlearning.ai提交建议</h2><div class="mr l"><h3 class="bd b fi z dy mp ea eb mq ed ef dx translated">如何成为Mlearning.ai上的作家</h3></div><div class="ms l"><p class="bd b fp z dy mp ea eb mq ed ef dx translated">medium.com</p></div></div><div class="mt l"><div class="mu l mv mw mx mt my ho mk"/></div></div></a></div></div></div>    
</body>
</html>