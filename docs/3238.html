<html>
<head>
<title>A single function for all time series/regression model stats</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">所有时间序列/回归模型统计的单一函数</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/a-single-function-for-all-time-series-regression-model-stats-e0821b651f93?source=collection_archive---------6-----------------------#2022-08-08">https://medium.com/mlearning-ai/a-single-function-for-all-time-series-regression-model-stats-e0821b651f93?source=collection_archive---------6-----------------------#2022-08-08</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/ccce79f9479b2b24df21972846624a34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1376/format:webp/0*e9tztfQb5BrV_tcp.png"/></div></figure><p id="94e7" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">在过去的几周里，我一直在做一个回归分析项目。我从别人那里接手了这个项目，我被赋予了一个目标，那就是使代码库可复制且整洁。我通过做两件事达到了这个目的。从上到下重写脚本<br/> 2。编写函数以避免重复</p><p id="4fe3" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我得到了两个脚本，我发现它们之间有相似之处，所以这样做是有意义的，这样我就可以创建一个整洁的单一脚本来完成任务。</p><p id="96f4" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">由于这是一个回归分析项目，我注意到我们需要大量的诊断图来判断模型的性能和有效性。在我做STATA的时候，我会单独调用每个测试，因为每个人都这么做。然而，用python做这件事感觉有点“过时”,所以我决定为此写一个函数。</p><p id="8a70" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">def run_model_diagnostic_test(y，y_pred): <br/> #检查模型诊断状态以确保模型符合<br/><br/>PLT . fig size =(10，10)) <br/> plt.scatter(y.to_numpy()，y_pred，c = ' crimson ')<br/>PLT . yscale(' log ')<br/>PLT . xscale(' log ')<br/><br/>P1 = max(max(y _ pred)，max(y.toAvF —真实vs模拟图")<br/>PLT . show()<br/><br/>df _ pred = PD . concat([y _ pred，y]，axis = 1)<br/>df _ pred = df _ pred . rename({ 0:'预测'，'销售_总_无炒作':'实际' }，axis = 1)<br/>df _ pred[' resid ']= df _ pred . predicted—df _ pred . actual<br/><br/>PLT . plot(df _ pred线性度—目视检查目标变量与预测值之间的线性度")<br/>PLT . show()<br/><br/>fig = sm . QQ plot(df _ pred . resid，fit=True，line="45") <br/> plt.title("2。误差的正态性—目视检查残差以确认正态性")<br/>PLT . show()<br/><br/>SNS . kdeplot(df _ pred . resid，label = ' '，shade = True) <br/> plt.xlabel('模型残差')；plt.ylabel('密度')；plt.title(“残差分布”)；<br/>PLT . show()<br/><br/>PLT . plot(df _ pred . resid，' o '，alpha=0.5) <br/> plt.title("4。同质性-目视检查残差以确认恒定方差")<br/>PLT . show()<br/><br/>from stats models . stats . stat tools import Durbin _ Watson<br/>dw = Durbin _ Watson(df _ pred . resid)<br/>print(' Durbin-Watson '，dw)<br/><br/>if dw&lt;1.5:<br/>print('正自相关'，' \ n)<br/>elif dw&gt;2</p><p id="3e64" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">plt.plot( df_pred.predicted，df_pred.resid，' o '，alpha=0.5) <br/> plt.title("6。残差与预测值")<br/> plt.show()</p><p id="ba4f" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><a class="ae jj" rel="noopener" href="/mlearning-ai/mlearning-ai-submission-suggestions-b51e2b130bfb">https://medium . com/mlearning-ai/mlearning-ai-submission-suggestions-b 51e 2b 130 bfb</a></p></div></div>    
</body>
</html>