<html>
<head>
<title>Language Translation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">语言翻译</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/language-translation-8e24b4e40928?source=collection_archive---------13-----------------------#2022-05-21">https://medium.com/mlearning-ai/language-translation-8e24b4e40928?source=collection_archive---------13-----------------------#2022-05-21</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="e87e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">意大利语到英语</p><p id="ff52" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们来谈谈语言翻译。我花了一个月的时间来理解这一点，并注意和实施它。所以，今天我写这篇文章是为了让你不必花更多的时间去想。这项任务有多种模型，但今天我们将使用SEQ2SEQ。</p><p id="ca16" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">SEQ2SEQ模型包含两个部分编码器和解码器，我们将输入传递给编码器，获得相应句子的编码向量，并将其传递给解码器以获得相应的输出。</p><h2 id="2b0f" class="jc jd hh bd je jf jg jh ji jj jk jl jm ip jn jo jp it jq jr js ix jt ju jv jw bi translated">建筑看起来像</h2><figure class="jy jz ka kb fd kc er es paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="er es jx"><img src="../Images/b64e54d2b0eda94c5c63019be7942c5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0Tzh2WMZh0UfR2tD3B652A.jpeg"/></div></div><figcaption class="kj kk et er es kl km bd b be z dx">Encoder decoder model</figcaption></figure><p id="4afc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在图中，x1、x2、x3表示在特定时间标记处对RNN/LSTM的输入，其中h1、h2、h3表示隐藏状态，并且它在特定时间标记处缺少单元状态c。</p><p id="d13e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">编码器向量是我们从编码器传递给解码器的(<strong class="ig hi">单元和隐藏状态</strong>)。</p><p id="eeff" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">让我们开始编码部分</strong></p><p id="01c1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果你想继续，你可以下载意大利语到英语的数据集。</p><h2 id="2eb2" class="jc jd hh bd je jf jg jh ji jj jk jl jm ip jn jo jp it jq jr js ix jt ju jv jw bi translated"><strong class="ak">第一步——数据预处理</strong></h2><p id="9955" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">每个自然语言任务的第一步是预处理数据并理解它。</p><p id="fd87" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">所以如果你下载了数据，就可以查看。</p><figure class="jy jz ka kb fd kc er es paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="er es ks"><img src="../Images/60bddb5d9f976ffedf94a6731c5d8904.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vZ7xAaNIv8ZjESK4KD0Ayw.png"/></div></div></figure><p id="7827" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">数据包含第一个用制表符分隔并包含HI。/tCiao！/tCC —这里我们只需要英语和意大利语，所以我们删除了版权部分。为此，我们将迭代txt文件，用制表符(\t)分隔行，只取第0和第1个索引。我们准备好了。然后我们处理文本，这是所有自然语言任务的标准。</p><p id="87e4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">比如:</p><ol class=""><li id="0de5" class="kt ku hh ig b ih ii il im ip kv it kw ix kx jb ky kz la lb bi translated">去掉标点符号。</li><li id="0e86" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb ky kz la lb bi translated">删除特殊字符。</li><li id="45f1" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb ky kz la lb bi translated">删除多余的空格。</li><li id="863d" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb ky kz la lb bi translated">像don't to do not等词的连接。</li></ol><p id="f714" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我在这里为此创建了一个类，并在类内保存了上述所有工作。</p><figure class="jy jz ka kb fd kc er es paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="er es lh"><img src="../Images/78940a5fa5190d9def458a115e0457db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0EprXQ53RAxP3hHtl3NiBg.png"/></div></div><figcaption class="kj kk et er es kl km bd b be z dx">processing.</figcaption></figure><p id="7ede" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在只需用文件调用main，它将返回如下输出</p><figure class="jy jz ka kb fd kc er es paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="er es li"><img src="../Images/8d0b45bbd6704537cdf21f92b01160fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_j13FykQycLAD_pKhCB3DQ.png"/></div></div><figcaption class="kj kk et er es kl km bd b be z dx">Outputs.</figcaption></figure><p id="cd95" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">第二步:制定输入输出格式。</strong></p><p id="1ed4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们将处理过的意大利语传递给编码器层，将英语传递给解码器层。解码器包含英语作为我们的输入，必须预测给定输入的下一个单词，所以我们的输出也将是英语，所以从技术上来说，我们的模型将是多对多的。</p><p id="4b98" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们为意大利语和英语添加了<start>和<end>来表示句子的开始和结束，稍后我们将需要停止我们的模型。</end></start></p><p id="007d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">所以，</p><figure class="jy jz ka kb fd kc er es paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="er es lj"><img src="../Images/d906858464ad41c71cd4ff37e308b3a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nkviIBatyGHjQF0_bf2DjQ.png"/></div></div><figcaption class="kj kk et er es kl km bd b be z dx">token</figcaption></figure><p id="6723" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，我们将最终得到如下输出</p><figure class="jy jz ka kb fd kc er es paragraph-image"><div class="er es lk"><img src="../Images/3fd0d2f77273a5aa3f4cd6aaabc0f193.png" data-original-src="https://miro.medium.com/v2/resize:fit:1190/format:webp/1*CE1xnWy3NaF4wN4HIUohlw.png"/></div><figcaption class="kj kk et er es kl km bd b be z dx">Input and output decoder</figcaption></figure><h2 id="a87c" class="jc jd hh bd je jf jg jh ji jj jk jl jm ip jn jo jp it jq jr js ix jt ju jv jw bi translated"><strong class="ak">步骤3:标记化</strong></h2><p id="68bf" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">由于模型不理解英语/意大利语单词，我们需要将其转换成某种数值。为此，我们在这里使用标记化。</p><figure class="jy jz ka kb fd kc er es paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="er es ll"><img src="../Images/57873de9af050d4e1ac0eb04786e609b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nv3beKXwyoR2uny74KYDrQ.png"/></div></div><figcaption class="kj kk et er es kl km bd b be z dx">Tokenization language translation.</figcaption></figure><p id="69c4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">第三步:填充</strong></p><p id="1904" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们首先需要找到可以填充句子的最佳位置。填充通常是指如果句子长度超过填充长度，就对其进行剪裁，并添加零使其达到合适的长度。我们通常这样做是为了批量输入模型，这样我们的训练会变得更快。</p><p id="6d95" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了找到我们可以使用的所有英语/意大利语句子的长度，并绘制它的计数图和分布图，你可以填充两个不同长度的句子，我已经做了一个。</p><figure class="jy jz ka kb fd kc er es paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="er es lm"><img src="../Images/3c67f6b90af743fe9063beaa98e8cbbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kxISbDM_SP4-1LPHITWccQ.png"/></div></div><figcaption class="kj kk et er es kl km bd b be z dx">kdeplot</figcaption></figure><p id="5b1c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">从图中我们可以看到，大部分单词的长度都在0-20之间，所以我们将其剪切为20。这一点可以看得更清楚，如果你计算情节，这是对观众的锻炼。</p><p id="367b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">填充至长度20:</p><figure class="jy jz ka kb fd kc er es paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="er es ln"><img src="../Images/034c154f8c1418a4fbc522716490d586.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gbt8YY4kCSm-BlLP4qOzdg.png"/></div></div><figcaption class="kj kk et er es kl km bd b be z dx">padding</figcaption></figure><h2 id="3b9e" class="jc jd hh bd je jf jg jh ji jj jk jl jm ip jn jo jp it jq jr js ix jt ju jv jw bi translated">步骤4:创建数据加载器</h2><p id="4d7a" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">我就不多说了，因为我已经写了如何创建一个定制的数据加载器，你可以看看</p><div class="lo lp ez fb lq lr"><a rel="noopener follow" target="_blank" href="/@ashishjamarkattel123/custom-dataloader-for-deep-learning-8757bab0cd21"><div class="ls ab dw"><div class="lt ab lu cl cj lv"><h2 class="bd hi fi z dy lw ea eb lx ed ef hg bi translated">用于深度学习的定制数据加载器</h2><div class="ly l"><h3 class="bd b fi z dy lw ea eb lx ed ef dx translated">为深度学习的任务编写自定义数据加载器与训练模型一样重要。好的数据…</h3></div><div class="lz l"><p class="bd b fp z dy lw ea eb lx ed ef dx translated">medium.com</p></div></div><div class="ma l"><div class="mb l mc md me ma mf kh lr"/></div></div></a></div><p id="869c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，该任务的数据加载器的代码如下所示</p><figure class="jy jz ka kb fd kc er es paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="er es mg"><img src="../Images/b4327aca2140a3d2d5d895793fc2cf13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JOS-XZ6Xvo6xFfGqNDf6Wg.png"/></div></div><figcaption class="kj kk et er es kl km bd b be z dx">custom dataloader</figcaption></figure><p id="393a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">步骤5:创建编码器层</strong></p><p id="f1ff" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在编码器层中，我们将传递带有每个时间戳的意大利语句子，就像您如何训练经典的LSTM并从LSTM获取state_hidden和state_cell一样。为了获取状态值，我们定义return_state = True和return_sequences = True，这将返回encoder_output、encoder_h_state和encoder_c_state。我们将编码器_h_state和编码器_c_state组合起来传递给解码器。</p><p id="0b53" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们看看编码器，你会清楚得多。我为编码器和解码器都创建了一个自定义模型，但你仍然可以使用语言翻译编码器的Keras文档，这是类似的，但使用功能api。</p><figure class="jy jz ka kb fd kc er es paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="er es mh"><img src="../Images/8f1faff82af1863be1698a04f9ffb2e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hKJA9v0N8Zri2qloXEqwfQ.png"/></div></div><figcaption class="kj kk et er es kl km bd b be z dx">encoder layer</figcaption></figure><p id="0392" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在自定义层中，我们需要单独创建LSTMCell，并将其传递给RNN，作为我所知道的LSTM层。</p><p id="5f1a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">initialize_state包含state_h和state_c的大小，当我们传递batch size时，它们给出编码器初始状态的state_h和state_c。<strong class="ig hi">注意:你可以在任何地方定义这个，不需要在这里定义。</strong>如前所述，encoder将返回encoder_output、encoder_h_state和encoder_c_state。</p><p id="272c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这里隐藏状态和单元格状态将是(batch_size，lstm_unit)的形状。</p><h2 id="55da" class="jc jd hh bd je jf jg jh ji jj jk jl jm ip jn jo jp it jq jr js ix jt ju jv jw bi translated"><strong class="ak">步骤4:创建解码器层</strong></h2><figure class="jy jz ka kb fd kc er es paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="er es mi"><img src="../Images/ae6b4f27e799a5e646f69cd347f43596.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Agco_ydiR31FTNBPjUBoHA.png"/></div></div><figcaption class="kj kk et er es kl km bd b be z dx">decode layers</figcaption></figure><p id="10d4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">解码层的工作类似于编码器，唯一的区别是我们在这里用encoder_h_state和encoder_c_state初始化初始状态，而我们用零初始化编码器。我们将decoder_output传递给密集层，获得预测值并计算损失。</p><p id="d60f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这是我们执行编码器/解码器模型的方式。</p><p id="0954" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了训练模型，我们简单地</p><figure class="jy jz ka kb fd kc er es paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="er es mj"><img src="../Images/b269ffe5aad0606428d8c3619f1ba441.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TLY3c8BzVGD1wAHb0vKQwg.png"/></div></div><figcaption class="kj kk et er es kl km bd b be z dx">finallayer encoder decoder</figcaption></figure><figure class="jy jz ka kb fd kc er es paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="er es mk"><img src="../Images/433b0d83df4cc3b14345c7b29547e7f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KsOc-RHKFm8DEUqbHZvnKg.png"/></div></div><figcaption class="kj kk et er es kl km bd b be z dx">final layer</figcaption></figure><h2 id="b677" class="jc jd hh bd je jf jg jh ji jj jk jl jm ip jn jo jp it jq jr js ix jt ju jv jw bi translated">第五步:预测</h2><p id="1ce9" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">对于训练后的预测，对编码器重复与训练模型相同的过程，获得state_h和state_c，并将其传递给解码器。唯一不同的是，我们现在只将<start>令牌作为输入传递给解码器，并从密集层获得输出，该输出成为解码器的下一个输入。这个过程一直持续到我们找到<end>令牌，这就是我说的我们以后需要的。</end></start></p><figure class="jy jz ka kb fd kc er es paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="er es ml"><img src="../Images/2a296be1870933d83d45294204118c73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KPMjJbuo81jNuW36AOGmmw.png"/></div></div><figcaption class="kj kk et er es kl km bd b be z dx">prediction</figcaption></figure><p id="48d1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果你训练这个模型，你的输出看起来像这样</p><figure class="jy jz ka kb fd kc er es paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="er es mm"><img src="../Images/061e54d0d0169f1e7feea1d5382d52ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h62g6cqhIA-S83UhQi5MUA.png"/></div></div><figcaption class="kj kk et er es kl km bd b be z dx">final output</figcaption></figure><p id="23b4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">希望你喜欢这篇文章。</p><p id="bb16" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果你学到了一些东西，那会激励我写更多。</p><p id="2372" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">继续学习！！！！！</p><p id="2c63" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">完整代码可在此处找到:</p><p id="6e82" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae mn" href="https://github.com/ashishjamarkattel/Language-Translation--Italian-2-English" rel="noopener ugc nofollow" target="_blank"> <strong class="ig hi"> GITHUB </strong> </a></p><div class="lo lp ez fb lq lr"><a rel="noopener follow" target="_blank" href="/mlearning-ai/mlearning-ai-submission-suggestions-b51e2b130bfb"><div class="ls ab dw"><div class="lt ab lu cl cj lv"><h2 class="bd hi fi z dy lw ea eb lx ed ef hg bi translated">Mlearning.ai提交建议</h2><div class="ly l"><h3 class="bd b fi z dy lw ea eb lx ed ef dx translated">如何成为Mlearning.ai上的作家</h3></div><div class="lz l"><p class="bd b fp z dy lw ea eb lx ed ef dx translated">medium.com</p></div></div><div class="ma l"><div class="mo l mc md me ma mf kh lr"/></div></div></a></div></div></div>    
</body>
</html>