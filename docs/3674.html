<html>
<head>
<title>Kadane’s Algorithm (Dynamic Programming) to solve Maximum Subarray Problem</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kadane算法(动态规划)解决最大子阵列问题</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/kadanes-algorithm-dynamic-programming-to-solve-maximum-subarray-problem-d4e3a72f4e1e?source=collection_archive---------2-----------------------#2022-10-07">https://medium.com/mlearning-ai/kadanes-algorithm-dynamic-programming-to-solve-maximum-subarray-problem-d4e3a72f4e1e?source=collection_archive---------2-----------------------#2022-10-07</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="9c06" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">卡丹的算法用一种简单的方式解释</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/f41cd3a6597b4aa46ff2aecf94bf207d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GuGjm6woROpyx68MUo2l0Q.jpeg"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx">image source: <a class="ae jm" href="https://unsplash.com/photos/nuz3rK5iiKg" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/photos/nuz3rK5iiKg</a></figcaption></figure><h1 id="0a59" class="jn jo hh bd jp jq jr js jt ju jv jw jx in jy io jz iq ka ir kb it kc iu kd ke bi translated">介绍</h1><p id="aeed" class="pw-post-body-paragraph kf kg hh kh b ki kj ii kk kl km il kn ko kp kq kr ks kt ku kv kw kx ky kz la ha bi translated">最近我遇到了流行的编程问题“最大子阵列问题”，并决定尝试一下。在这个过程中我学到了一个非常有趣的算法，叫做“卡丹算法”。在这篇文章中，我将向你展示这个算法是如何工作的。</p><h1 id="f023" class="jn jo hh bd jp jq jr js jt ju jv jw jx in jy io jz iq ka ir kb it kc iu kd ke bi translated">什么是“最大子阵列问题”</h1><p id="c066" class="pw-post-body-paragraph kf kg hh kh b ki kj ii kk kl km il kn ko kp kq kr ks kt ku kv kw kx ky kz la ha bi translated">最大子阵列是这样一个问题:从给定的整数阵列中，我们必须在所有可能的子阵列中找到一个具有最大和的连续子阵列。</p><p id="4b42" class="pw-post-body-paragraph kf kg hh kh b ki lb ii kk kl lc il kn ko ld kq kr ks le ku kv kw lf ky kz la ha bi translated">首先让我们试着理解这个问题。</p><h2 id="9e25" class="lg jo hh bd jp lh li lj jt lk ll lm jx ko ln lo jz ks lp lq kb kw lr ls kd lt bi translated">什么是子阵列？</h2><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es lu"><img src="../Images/511e8e2c5f9590d641dae9075b2d15d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:722/format:webp/0*dvsnMCgp6Bd37e39.png"/></div></figure><p id="855e" class="pw-post-body-paragraph kf kg hh kh b ki lb ii kk kl lc il kn ko ld kq kr ks le ku kv kw lf ky kz la ha bi translated">子数组基本上是数组中的数组。所以在上面的例子中，子数组可以是[2，-1]或者只是一个元素[3]，也可以是整个数组[2，-1，3，1，-1]。但是如果我们取[3，-1]，那就不是子数组，因为它不是连续的元素。所以子数组是给定数组中一组连续的元素。</p><h2 id="5769" class="lg jo hh bd jp lh li lj jt lk ll lm jx ko ln lo jz ks lp lq kb kw lr ls kd lt bi translated">问题陈述</h2><p id="d8bd" class="pw-post-body-paragraph kf kg hh kh b ki kj ii kk kl km il kn ko kp kq kr ks kt ku kv kw kx ky kz la ha bi translated">目标是找到具有最大和的子阵列(在所有可能的组合中)。我的意思是。如果你考虑子阵列[-1，3]，总和就是-1 + 3 = 2。如果你取[3，1]，总和就是4。对于整个数组[2，-1，3，1，-1]，总和是4。</p><p id="ad84" class="pw-post-body-paragraph kf kg hh kh b ki lb ii kk kl lc il kn ko ld kq kr ks le ku kv kw lf ky kz la ha bi translated">在这个例子中，子阵列[2，-1，3，1]的最大子阵列和是5。我们需要通过编程找到它。</p><h1 id="21ac" class="jn jo hh bd jp jq jr js jt ju jv jw jx in jy io jz iq ka ir kb it kc iu kd ke bi translated">强力方法</h1><p id="5602" class="pw-post-body-paragraph kf kg hh kh b ki kj ii kk kl km il kn ko kp kq kr ks kt ku kv kw kx ky kz la ha bi translated">这个问题最简单的解决方案是强力方法，基本上是检查所有可能的子数组，并选择总和最大的一个，所以我会检查从第一个索引开始的子数组，然后检查从第二个索引开始的子数组，依此类推。这种方法是可行的，但是它需要数组中元素数量的平方时间，这不是最佳的解决方案。</p><pre class="ix iy iz ja fd lv lw lx ly aw lz bi"><span id="c2df" class="lg jo hh lw b fi ma mb l mc md">Starting with 1st Index <br/>[possible subarrrays]  [Sum]<br/>[2]                   = 2<br/>[2, -1]               = 1<br/>[2, -1, 3]            = 4<br/>[2, -1, 3, 1]         = 5<br/>[2, -1, 3, 1, -1]     = 4<br/><br/>Starting with 2nd Index <br/>[-1]                  = -1<br/>[-1, 3]               = 2<br/>[-1, 3, 1]            = 3<br/>[-1, 3, 1, -1]        = 2<br/><br/>Starting with 3rd Index<br/>[3]                   = 3<br/>[3, 1]                = 4<br/>[3, 1, -1]            = 3<br/>.<br/>.<br/>.<br/>and so on...</span></pre><h1 id="1ba6" class="jn jo hh bd jp jq jr js jt ju jv jw jx in jy io jz iq ka ir kb it kc iu kd ke bi translated">卡丹算法</h1><p id="78e5" class="pw-post-body-paragraph kf kg hh kh b ki kj ii kk kl km il kn ko kp kq kr ks kt ku kv kw kx ky kz la ha bi translated">为了优化上述解决方案，我们将使用动态规划的概念。这种算法称为Kadane算法，在这种算法中，我们使用前面子问题的解来寻找整体最优解。</p><h2 id="3a11" class="lg jo hh bd jp lh li lj jt lk ll lm jx ko ln lo jz ks lp lq kb kw lr ls kd lt bi translated">算法工作</h2><p id="0297" class="pw-post-body-paragraph kf kg hh kh b ki kj ii kk kl km il kn ko kp kq kr ks kt ku kv kw kx ky kz la ha bi translated">我们来试着理解一下这个算法。</p><ul class=""><li id="2088" class="me mf hh kh b ki lb kl lc ko mg ks mh kw mi la mj mk ml mm bi translated">我们迭代数组的每个元素，并跟踪该索引处元素的最大和，我们称之为<strong class="kh hi"> current_maximum </strong>。</li><li id="50d1" class="me mf hh kh b ki mn kl mo ko mp ks mq kw mr la mj mk ml mm bi translated">current_maximum或者是当前索引处的元素，或者是前一个current_maximum &amp; current元素的相加。</li><li id="fcae" class="me mf hh kh b ki mn kl mo ko mp ks mq kw mr la mj mk ml mm bi translated">除此之外，我们还跟踪整体最大值，我们称之为<strong class="kh hi">全局最大值</strong>，如果当前最大值大于全局最大值，那么我们用当前最大值替换全局最大值。</li><li id="6301" class="me mf hh kh b ki mn kl mo ko mp ks mq kw mr la mj mk ml mm bi translated">在最后一次迭代中<strong class="kh hi">全局最大值</strong>的任何值将是最大子阵列问题的解</li></ul><p id="9736" class="pw-post-body-paragraph kf kg hh kh b ki lb ii kk kl lc il kn ko ld kq kr ks le ku kv kw lf ky kz la ha bi translated">这些步骤可能看起来吓人，但这个算法相当简单。让我为上面的例子一步一步地解释这个算法。</p><p id="375b" class="pw-post-body-paragraph kf kg hh kh b ki lb ii kk kl lc il kn ko ld kq kr ks le ku kv kw lf ky kz la ha bi translated">我们将遍历所有元素，并在每个阶段计算Kadane算法中提到的值。</p><p id="043c" class="pw-post-body-paragraph kf kg hh kh b ki lb ii kk kl lc il kn ko ld kq kr ks le ku kv kw lf ky kz la ha bi translated"><strong class="kh hi">第一个元素</strong></p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es ms"><img src="../Images/7c4bda0ebdd8f27c0e7fff51f4753ad0.png" data-original-src="https://miro.medium.com/v2/resize:fit:998/format:webp/1*VykUbDmhpkC7X3muHsao5Q.png"/></div></figure><p id="4a48" class="pw-post-body-paragraph kf kg hh kh b ki lb ii kk kl lc il kn ko ld kq kr ks le ku kv kw lf ky kz la ha bi translated"><strong class="kh hi">二次元</strong></p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mt"><img src="../Images/450e52c06fd425185528774f1bd39bbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ytsaVB838ZpwiAtOm459DA.png"/></div></div></figure><p id="cee9" class="pw-post-body-paragraph kf kg hh kh b ki lb ii kk kl lc il kn ko ld kq kr ks le ku kv kw lf ky kz la ha bi translated"><strong class="kh hi">第三元素</strong></p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mu"><img src="../Images/c23ee2d08e3b4932728cbb720d50bcff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gcFLXjuuwtAPWlpIvVgrvg.png"/></div></div></figure><p id="4307" class="pw-post-body-paragraph kf kg hh kh b ki lb ii kk kl lc il kn ko ld kq kr ks le ku kv kw lf ky kz la ha bi translated"><strong class="kh hi">第四元素</strong></p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mv"><img src="../Images/f7a3c553c66c2668e0d0e939c235887c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yrZTiidNyba1FOWd8cWBJg.png"/></div></div></figure><p id="0273" class="pw-post-body-paragraph kf kg hh kh b ki lb ii kk kl lc il kn ko ld kq kr ks le ku kv kw lf ky kz la ha bi translated"><strong class="kh hi">第五元素</strong></p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mw"><img src="../Images/58730234db251ceeb8447156e8b27ac5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dXFODl2qO6_4cVvv2QyygA.png"/></div></div></figure><p id="ada5" class="pw-post-body-paragraph kf kg hh kh b ki lb ii kk kl lc il kn ko ld kq kr ks le ku kv kw lf ky kz la ha bi translated">正如您在最后看到的，global_maximum是5，这是我们的解决方案。此外，我们在一次迭代中得到结果，因此它是一个线性解决方案，比蛮力方法优化得多。</p><h2 id="81c1" class="lg jo hh bd jp lh li lj jt lk ll lm jx ko ln lo jz ks lp lq kb kw lr ls kd lt bi translated">Python实现</h2><p id="01a4" class="pw-post-body-paragraph kf kg hh kh b ki kj ii kk kl km il kn ko kp kq kr ks kt ku kv kw kx ky kz la ha bi translated">让我们试着用Python来实现它。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="mx my l"/></div></figure><pre class="ix iy iz ja fd lv lw lx ly aw lz bi"><span id="dc3b" class="lg jo hh lw b fi ma mb l mc md">Output should looks like this <br/>Maximum subarray sum for [2, -1, 3, 1, -1] is 5 <br/>Maximum subarray sum for [-3, 1, -8, 4, -1, 2, 1, -5, 5] is 6</span></pre><h1 id="ffdc" class="jn jo hh bd jp jq jr js jt ju jv jw jx in jy io jz iq ka ir kb it kc iu kd ke bi translated">结论</h1><p id="df72" class="pw-post-body-paragraph kf kg hh kh b ki kj ii kk kl km il kn ko kp kq kr ks kt ku kv kw kx ky kz la ha bi translated">在本教程中，我们看到了解决最大子阵列问题的两种方法。第一种方法不是最佳解决方案。随后，我们讨论了Kadane的算法，并使用动态规划在线性时间内解决问题。</p><p id="120e" class="pw-post-body-paragraph kf kg hh kh b ki lb ii kk kl lc il kn ko ld kq kr ks le ku kv kw lf ky kz la ha bi translated">希望我能够解释卡丹的算法。如果您有任何问题或任何反馈，请随时发表评论或在<a class="ae jm" href="https://www.linkedin.com/in/vinodvidhole/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>联系我。感谢您的阅读，下次再见…编码快乐！！</p><div class="mz na ez fb nb nc"><a rel="noopener follow" target="_blank" href="/mlearning-ai/mlearning-ai-submission-suggestions-b51e2b130bfb"><div class="nd ab dw"><div class="ne ab nf cl cj ng"><h2 class="bd hi fi z dy nh ea eb ni ed ef hg bi translated">Mlearning.ai提交建议</h2><div class="nj l"><h3 class="bd b fi z dy nh ea eb ni ed ef dx translated">如何成为Mlearning.ai上的作家</h3></div><div class="nk l"><p class="bd b fp z dy nh ea eb ni ed ef dx translated">medium.com</p></div></div><div class="nl l"><div class="nm l nn no np nl nq jg nc"/></div></div></a></div></div></div>    
</body>
</html>