<html>
<head>
<title>Intro to Graphs (part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">图表介绍(第二部分)</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/intro-to-graphs-part-2-954f6f8af70f?source=collection_archive---------6-----------------------#2021-03-26">https://medium.com/mlearning-ai/intro-to-graphs-part-2-954f6f8af70f?source=collection_archive---------6-----------------------#2021-03-26</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/5e7dcfeaa15dd7a021e19a1f94c50093.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*O2cEJecRPs8GZyfM"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Photo by <a class="ae it" href="https://unsplash.com/@nasa?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">NASA</a> on <a class="ae it" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="7400" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">大家好！这是图表介绍系列的第2部分。如果您错过了第1部分，链接是本文底部的<a class="ae it" rel="noopener" href="/mlearning-ai/intro-to-graphs-part-1-af14f5901a67">这里的</a>。概括地说，图数据结构是有限的顶点(节点)集合和连接一对节点的边集合。在图中，没有规则规定节点之间的连接。无论节点的位置如何，边都可以连接节点。在这篇文章中，我们将回顾表示图。表示图的两种标准方法是邻接矩阵和邻接表。</p><h1 id="4098" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">邻接矩阵</h1><figure class="kr ks kt ku fd ii er es paragraph-image"><div class="er es kq"><img src="../Images/c2c8b088d3852523ea8743ec5b0c3dcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/format:webp/1*xbnzV_eVavCagzBAwxJbXg.png"/></div><figcaption class="ip iq et er es ir is bd b be z dx">Adjacency Matrix of an Undirected Graph</figcaption></figure><p id="9703" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这个无向图的矩阵表示顶点之间的边。对于顶点A的列和行，其边B和f的值为1。未连接到A的顶点的值为0。每次你添加一个新的顶点，你将不得不添加一个新的行和新的列。让我们将这个邻接矩阵与有向图的邻接矩阵进行比较。</p><figure class="kr ks kt ku fd ii er es paragraph-image"><div class="er es kv"><img src="../Images/e67307ac3a1c82588b985e92d3afd0fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1258/format:webp/1*6ELdGziMw3SpEAxdbZ8nzA.png"/></div><figcaption class="ip iq et er es ir is bd b be z dx">Adjacency Matrix of a Directed Graph</figcaption></figure><p id="992d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果我们现在看A，它指向B和F，我们可以在A行清楚地看到B和F列的值都是1。但是，查看B行和F行，a列没有值1。行表示起点，列表示目的地。它是一个从A指向B和f的有向图。一个加权有向图看起来非常相似。我们不是用1来表示边，而是将它的权重存储在那里。</p><h1 id="b401" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">邻接表</h1><figure class="kr ks kt ku fd ii er es paragraph-image"><div class="er es kw"><img src="../Images/393fea33633ade0102acec76888480d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1198/format:webp/1*Fdt-QuULUPiYwkER7H2Yzw.png"/></div><figcaption class="ip iq et er es ir is bd b be z dx">Adjacency List of an Undirected Graph</figcaption></figure><p id="5933" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们可以使用哈希表为每个顶点存储一个键值对，其中的值表示边。例如，键A具有值B和f。对于有向图，顶点键将只具有它所指向的边作为其值。没有边的顶点的值为空</p><h1 id="01a3" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">邻接表vs邻接矩阵</h1><figure class="kr ks kt ku fd ii er es paragraph-image"><div class="er es kx"><img src="../Images/19e1ffb7d1116e908f4ffc7c288d77ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1084/format:webp/1*HA8KqOj6aib0USfBUG6mlg.png"/></div><figcaption class="ip iq et er es ir is bd b be z dx">From JavaScript Algorithms and Data Structures Masterclass by Colt Steele</figcaption></figure><p id="c82d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">查看邻接表的存储，它取决于顶点和边的数量。邻接矩阵本质上会更大，因为它是一个正方形矩阵，为所有未连接的顶点存储0值。为了从邻接矩阵中添加或删除顶点，我们必须添加或删除整个行和列，而不是一个键和它的边。另一方面，在邻接矩阵中搜索更快。例如，我们可以通过查看顶点1的行和顶点2的列的索引来检查两个顶点之间是否有边。对于邻接表，我们必须遍历每个顶点，直到找到其中一个，然后遍历它的边来找到匹配。这可能需要很长时间。</p><p id="ac68" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">利弊</strong></p><p id="cb2b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">邻接表与邻接矩阵的比较</p><p id="832a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">优点</strong> —可以占用更少的空间，更快地迭代所有的边。</p><p id="109b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">缺点</strong> —查找特定边缘可能会比较慢。</p><h1 id="8d56" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated"><strong class="ak">最终判决</strong></h1><p id="acca" class="pw-post-body-paragraph iu iv hh iw b ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr ha bi translated">由于邻接表占用空间，所以使用得更频繁。如果我们看看现实世界的例子，数据往往非常稀疏。如果我们想象一下所有脸书资料的图表，很少有人是彼此的“朋友”。截至2020年，大约有27亿脸书用户，每个用户平均有338个好友。用户之间的联系相对很少。很多顶点，没有那么多边。然而，邻接矩阵在未连接的用户之间会有数十亿个0值。这将是一吨不必要的存储。</p><p id="08bb" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">感谢您的阅读。下一篇文章将讨论图的遍历。</p><h1 id="45da" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">资源</h1><p id="146a" class="pw-post-body-paragraph iu iv hh iw b ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr ha bi translated">关于图表的更多资源，我建议看看这些有用的链接。</p><p id="f214" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">第一部分:<a class="ae it" rel="noopener" href="/mlearning-ai/intro-to-graphs-part-1-af14f5901a67">https://medium . com/mlearning-ai/intro-to-graphs-part-1-af 14 f 5901 a 67</a></p><p id="b0ec" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><a class="ae it" rel="noopener" href="/basecs/from-theory-to-practice-representing-graphs-cfd782c5be38">https://medium . com/base cs/from-theory-to-practice-representative-graphs-CFD 782 C5 be 38</a></p><p id="b83a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><a class="ae it" rel="noopener" href="/swlh/getting-started-with-graphs-2befaa509fc5">https://medium . com/swlh/getting-started-with-graphs-2 be FAA 509 fc5</a></p><p id="82aa" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><a class="ae it" href="https://www.udemy.com/course/js-algorithms-and-data-structures-masterclass/learn/lecture/8344874#overview" rel="noopener ugc nofollow" target="_blank">https://www . udemy . com/course/js-algorithms-and-data-structures-master class/learn/lecture/8344874 #概述</a></p><p id="b19f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><a class="ae it" rel="noopener" href="/swlh/data-structures-graphs-50a8a032db03">https://medium.com/swlh/data-structures-graphs-50a8a032db03</a></p></div></div>    
</body>
</html>