<html>
<head>
<title>Sudoku Solver — with source code — Fun project — Easiest Way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数独求解器-带源代码-有趣的项目-最简单的方法</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/sudoku-solver-with-source-code-fun-project-easiest-way-40c46ad4bc09?source=collection_archive---------2-----------------------#2021-12-30">https://medium.com/mlearning-ai/sudoku-solver-with-source-code-fun-project-easiest-way-40c46ad4bc09?source=collection_archive---------2-----------------------#2021-12-30</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="bcb7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">所以，伙计们，在今天的博客中，我们将看到如何使用计算机视觉和图像处理技术实现数独求解器。所以没有任何进一步的原因。</p><p id="9674" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">点击此处阅读带源代码的整篇文章—</strong>【https://machinelearningprojects.net/sudoku-solver/ T2】</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/a761f9c038ac0e04bf4816bb9617069b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1316/format:webp/0*L4y655EGrEySysPv.png"/></div><figcaption class="jl jm et er es jn jo bd b be z dx">SUDOKU SOLVER</figcaption></figure><h1 id="99ee" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">让我们开始吧…</h1><h2 id="4657" class="kn jq hh bd jr ko kp kq jv kr ks kt jz ip ku kv kd it kw kx kh ix ky kz kl la bi translated">数独求解器的代码…</h2><pre class="je jf jg jh fd lb lc ld le aw lf bi"><span id="f4dd" class="kn jq hh lc b fi lg lh l li lj">import cv2<br/>import imutils<br/>from imutils.perspective import four_point_transform<br/>from skimage.segmentation import clear_border<br/>from tensorflow.keras.models import load_model<br/>import numpy as np<br/>from Sudoku import solveSudoku<br/>from tensorflow.keras.preprocessing.image import img_to_array<br/>import matplotlib.pyplot as plt<br/><br/># Sudoku Solver<br/>model = load_model('model/model_mnist/')<br/>img_path = 'sudoku images/6.png'<br/>img_shape = [28,28]<br/><br/>def find_puzzle(img):<br/>    real = img.copy()<br/>    gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)<br/>    blur = cv2.GaussianBlur(gray,(7,7),1)<br/>    <br/>    thresh = cv2.adaptiveThreshold(blur,255,cv2.ADAPTIVE_THRESH_GAUSSIAN_C,cv2.THRESH_BINARY,11,2)<br/>    thresh = cv2.bitwise_not(thresh)<br/><br/>    cnts = cv2.findContours(thresh.copy(),cv2.RETR_EXTERNAL,cv2.CHAIN_APPROX_SIMPLE)<br/>    cnts = imutils.grab_contours(cnts)<br/>    cnts = sorted(cnts,key=cv2.contourArea,reverse=True)<br/><br/>    puzzle_cnt = None<br/><br/>    for c in cnts:<br/>        peri = cv2.arcLength(c,True)<br/>        approx = cv2.approxPolyDP(c,0.02*peri,True)<br/>        if len(approx)==4:<br/>            puzzle_cnt=approx<br/>            break<br/><br/>    if puzzle_cnt is None:<br/>        raise Exception(("Could not find Sudoku puzzle outline.Try debugging your thresholding and contour steps."))<br/><br/>    cv2.drawContours(real, [puzzle_cnt], -1, (0, 255, 0), 2)<br/><br/>    puzzle = four_point_transform(img, puzzle_cnt.reshape(4, 2))<br/>    warped = four_point_transform(gray, puzzle_cnt.reshape(4, 2))<br/><br/>    return puzzle,warped<br/><br/><br/><br/>def extract_digit(cell):<br/>    thresh = cv2.threshold(cell,0,255,cv2.THRESH_BINARY_INV|cv2.THRESH_OTSU)[1]<br/>    thresh = clear_border(thresh) #just clear the extra white pixels along the border<br/><br/><br/>    cnts = cv2.findContours(thresh.copy(), cv2.RETR_EXTERNAL,cv2.CHAIN_APPROX_SIMPLE)<br/>    cnts = imutils.grab_contours(cnts)<br/><br/>    # if no contours were found than this is an empty cell<br/>    if len(cnts) == 0:return None<br/><br/>    # otherwise, find the largest contour in the cell and create a mask for the contour<br/>    c = max(cnts, key=cv2.contourArea)<br/>    mask = np.zeros(thresh.shape, dtype="uint8")<br/>    cv2.drawContours(mask, [c], -1, 255, -1)<br/><br/>    (h, w) = thresh.shape<br/>    percentFilled = cv2.countNonZero(mask) / float(w * h)<br/><br/>    # if less than 3% of the mask is filled then we are looking at noise and can safely ignore the contour<br/>    if percentFilled &lt; 0.03:return None<br/><br/>    # apply the mask to the thresholded cell<br/>    digit = cv2.bitwise_and(thresh, thresh, mask=mask)<br/>    kernel = np.ones((1,1),np.uint8)<br/>    digit = cv2.dilate(digit,kernel,iterations=1)<br/><br/>    # return the digit to the calling function<br/>    return digit<br/><br/><br/>def display_numbers_on_board(board,puzzle):<br/>    x = puzzle.copy()<br/>    k = 0<br/>    for i in range(9):<br/>        for j in range(9):<br/>            startX,startY,endX,endY = cell_locs[k]<br/>            testX = int((endX - startX) * 0.33)<br/>            testY = int((endY - startY) * -0.2)<br/>            testX += startX<br/>            testY += endY<br/>            cv2.putText(x,str(board[i][j]),(testX,testY),cv2.FONT_HERSHEY_SIMPLEX,0.9,(0,0,255),2)<br/>            k+=1<br/>    plt.figure(figsize=(10,8))<br/>    plt.imshow(x)<br/>    plt.xticks([])<br/>    plt.yticks([])<br/>    plt.show()<br/>    return x<br/><br/>img = cv2.imread(img_path)<br/>img = imutils.resize(img,width=600)<br/><br/>puzzle,warped = find_puzzle(img)<br/>puzzle = imutils.resize(puzzle,width=600)<br/>warped = imutils.resize(warped,width=600)<br/><br/>step_x = warped.shape[1]//9<br/>step_y = warped.shape[0]//9<br/><br/>board = np.zeros(shape=(9,9),dtype='int')<br/>cell_locs = []<br/><br/>for i in range(9):<br/>    for j in range(9):<br/>        topleftx = j*step_x<br/>        toplefty = i*step_y<br/>        rightendx= (j+1)*step_x<br/>        rightendy = (i+1)*step_y<br/>        cell = warped[toplefty:rightendy, topleftx:rightendx]<br/>        digit = extract_digit(cell)<br/>        if digit is not None:<br/>            roi = cv2.resize(digit,tuple(img_shape))<br/>            roi = roi.astype('float')/255.0<br/>            roi = img_to_array(roi)<br/>            roi = np.expand_dims(roi,axis=0)<br/>            pred = model.predict(roi).argmax(axis=1)[0]<br/>            board[i,j] = pred<br/>        cell_locs.append([topleftx,toplefty,rightendx,rightendy])<br/><br/>        <br/><br/>_=display_numbers_on_board(board,puzzle)<br/><br/>while 1:<br/>    res = input('Are all numbers predicted correctly? (y/n)')<br/>    if res=='n':<br/>        cx,cy,ele = input('Input row no, col no, correct element of cell For eg. --&gt; 1 2 1:  ').split()<br/>        try:<br/>            board[int(cx),int(cy)] = int(ele)<br/>        except:<br/>            print('out of range...')<br/>        _ = display_numbers_on_board(board,puzzle)<br/>    elif res=='y':<br/>        break<br/>    else:<br/>        print('Wrong choice!!!')<br/>    <br/>solved = solveSudoku(board)<br/><br/>x = display_numbers_on_board(board,puzzle)<br/>cv2.imshow('solved',x)<br/><br/>cv2.waitKey(0)<br/>cv2.destroyAllWindows()</span></pre><ul class=""><li id="9598" class="lk ll hh ig b ih ii il im ip lm it ln ix lo jb lp lq lr ls bi translated">第1–10行-导入数独求解器所需的库。</li><li id="6ad4" class="lk ll hh ig b ih lt il lu ip lv it lw ix lx jb lp lq lr ls bi translated">第12–14行—加载mnist模型和数独图像。还要声明一个常量img_shape，它将是调整大小后数独图像的大小。</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ly"><img src="../Images/db6f979f76893d8de44686a93be4abec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/0*WW4X0d4qcVOomTJU.jpg"/></div></figure><ul class=""><li id="e263" class="lk ll hh ig b ih ii il im ip lm it ln ix lo jb lp lq lr ls bi translated">第16–45行—该函数将通过图像处理技术找到图像中的谜题。</li><li id="bdfd" class="lk ll hh ig b ih lt il lu ip lv it lw ix lx jb lp lq lr ls bi translated">读取图像，将其转换为灰度，然后应用<a class="ae jc" href="https://en.wikipedia.org/wiki/Gaussian_blur#:~:text=In%20image%20processing%2C%20a%20Gaussian,image%20noise%20and%20reduce%20detail." rel="noopener ugc nofollow" target="_blank">高斯模糊</a>去除高斯噪声。</li><li id="9fa2" class="lk ll hh ig b ih lt il lu ip lv it lw ix lx jb lp lq lr ls bi translated">阈值的图像，并将其逆转。意味着将白色转换为黑色，将黑色转换为白色。</li><li id="77f8" class="lk ll hh ig b ih lt il lu ip lv it lw ix lx jb lp lq lr ls bi translated">然后找到轮廓，提取图像中最大的轮廓。这大概就是我们的数独吧。</li><li id="16a2" class="lk ll hh ig b ih lt il lu ip lv it lw ix lx jb lp lq lr ls bi translated">应用<a class="ae jc" href="https://www.pyimagesearch.com/2014/08/25/4-point-opencv-getperspective-transform-example/" rel="noopener ugc nofollow" target="_blank">四点变换</a>获得拼图的直视图并返回。</li><li id="0d80" class="lk ll hh ig b ih lt il lu ip lv it lw ix lx jb lp lq lr ls bi translated">第49–77行——该函数将从难题中提取数字单元格并返回它，以便mnist模型可以识别其中的数字。</li><li id="6d51" class="lk ll hh ig b ih lt il lu ip lv it lw ix lx jb lp lq lr ls bi translated">第80–97行—该功能将简单地把数字放在图像/板上。</li><li id="eb7b" class="lk ll hh ig b ih lt il lu ip lv it lw ix lx jb lp lq lr ls bi translated">第99–100行—只需读取图像并调整其大小。</li><li id="6176" class="lk ll hh ig b ih lt il lu ip lv it lw ix lx jb lp lq lr ls bi translated">第102–104行——提取拼图并调整大小。</li><li id="68e5" class="lk ll hh ig b ih lt il lu ip lv it lw ix lx jb lp lq lr ls bi translated">第106–107行——这将告诉我们在x和y方向必须采取的步长。这一步基本上就是分别在x和y方向上的单元格大小。</li><li id="c7c3" class="lk ll hh ig b ih lt il lu ip lv it lw ix lx jb lp lq lr ls bi translated">第109行—创建电路板，所有值都用0初始化。</li><li id="5a94" class="lk ll hh ig b ih lt il lu ip lv it lw ix lx jb lp lq lr ls bi translated">第110行—创建数组<em class="lz"> cell_locs </em>，它将包含单元位置/坐标。</li><li id="16c0" class="lk ll hh ig b ih lt il lu ip lv it lw ix lx jb lp lq lr ls bi translated">第112–127行—遍历9*9循环，其中第一个9代表电路板的9行，第二个9代表电路板的9列。遍历时，它将提取单元格图像，使用mnist预测数字，并将该数字放入我们在第109行创建的板数组中。此外，我们将继续在cell_loc数组中存储单元格位置。</li><li id="cf0e" class="lk ll hh ig b ih lt il lu ip lv it lw ix lx jb lp lq lr ls bi translated">第133–145行——如果mnist偶然错误地预测了任何数字，请纠正它。</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ma"><img src="../Images/b4cd1dd25ed3ee91589154de735876b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1310/format:webp/0*Tk_5DvEaqESkmDp2.png"/></div></figure><p id="6b63" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">注意—蓝色数字是该单元格的预测数字。红色文本是该单元格的地址。如果任何数字被mnist错误地分类，纠正它。比如第一个错误的分类编号在(4，7)。原来的数字是1，但mnist说是7，所以我们将首先纠正它。</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="er es mb"><img src="../Images/9026a90016958e413257fd118aa55263.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*yt55uKP5dz6srvQq.png"/></div></div></figure><ul class=""><li id="b495" class="lk ll hh ig b ih ii il im ip lm it ln ix lo jb lp lq lr ls bi translated">第147行—使用我们从<strong class="ig hi"> <em class="lz"> Sudoku.py </em> </strong>导入的solveSudoku函数求解数独。这个<strong class="ig hi"> <em class="lz"> Sudoku.py </em> </strong>也是我写的，我用回溯来解数独。</li><li id="4b17" class="lk ll hh ig b ih lt il lu ip lv it lw ix lx jb lp lq lr ls bi translated">第149–150行—在最终图像上显示解出的数独数字并显示出来。</li><li id="abd7" class="lk ll hh ig b ih lt il lu ip lv it lw ix lx jb lp lq lr ls bi translated">第152–153行—破坏所有窗口。</li></ul><h1 id="2446" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">数独求解器的最终结果…</h1><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/a761f9c038ac0e04bf4816bb9617069b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1316/format:webp/0*L4y655EGrEySysPv.png"/></div><figcaption class="jl jm et er es jn jo bd b be z dx">SUDOKU SOLVER</figcaption></figure><p id="7603" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果有任何关于数独求解器的疑问，请通过电子邮件或LinkedIn联系我。你也可以在下面评论任何问题。</p><p id="60c6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="lz">探索更多机器学习、深度学习、计算机视觉、NLP、Flask项目访问我的博客— </em> </strong> <a class="ae jc" href="https://machinelearningprojects.net/" rel="noopener ugc nofollow" target="_blank"> <strong class="ig hi"> <em class="lz">机器学习项目</em> </strong> </a></p><p id="8146" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">如需进一步的代码解释和源代码，请访问此处—</strong><a class="ae jc" href="https://machinelearningprojects.net/sudoku-solver/" rel="noopener ugc nofollow" target="_blank">https://machinelearningprojects.net/sudoku-solver/</a></p><p id="883e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这就是我写给这个博客的全部内容，感谢你的阅读，我希望你在阅读完这篇文章后会有所收获，直到下次👋… </p><p id="7992" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="lz">看我以前的帖子:</em> </strong> <a class="ae jc" href="https://machinelearningprojects.net/human-segmentation-using-u-net/" rel="noopener ugc nofollow" target="_blank"> <strong class="ig hi"> <em class="lz">人体分割使用U-NET </em> </strong> </a></p><div class="mg mh ez fb mi mj"><a rel="noopener follow" target="_blank" href="/mlearning-ai/mlearning-ai-submission-suggestions-b51e2b130bfb"><div class="mk ab dw"><div class="ml ab mm cl cj mn"><h2 class="bd hi fi z dy mo ea eb mp ed ef hg bi translated">Mlearning.ai提交建议</h2><div class="mq l"><h3 class="bd b fi z dy mo ea eb mp ed ef dx translated">如何成为Mlearning.ai上的作家</h3></div><div class="mr l"><p class="bd b fp z dy mo ea eb mp ed ef dx translated">medium.com</p></div></div><div class="ms l"><div class="mt l mu mv mw ms mx jj mj"/></div></div></a></div></div></div>    
</body>
</html>