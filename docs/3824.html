<html>
<head>
<title>One-Hot encoding with shared categories space</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">共享类别空间的一键编码</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/one-hot-encoding-with-shared-categories-space-a6c55782c706?source=collection_archive---------4-----------------------#2022-10-26">https://medium.com/mlearning-ai/one-hot-encoding-with-shared-categories-space-a6c55782c706?source=collection_archive---------4-----------------------#2022-10-26</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="850a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">创建自定义类，对共享相同类别空间的特征进行编码，同时使结果可重复使用且可读</strong></p><p id="484a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jc">前言:这是我作为DS/ML爱好者的第一个故事，我非常兴奋地分享我在解决我最近面临的一个问题方面的经验。我知道这里描述的解决方案可能不太有效，但我没有找到任何其他替代方案。希望我的解决方案能对有同样任务的人有所帮助。</em></p><p id="e101" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当我使用Kaggle的<a class="ae jd" href="https://www.kaggle.com/competitions/house-prices-advanced-regression-techniques/" rel="noopener ugc nofollow" target="_blank">房价-高级回归技术</a>数据集时，我想创建一个管道来处理和转换数据。其中一个步骤是将无序的分类数据(即没有可应用的距离度量)编码成独一无二的形式。在简单的情况下，你需要做的就是用一些参数应用<em class="jc"> OneHotEncoder() </em>并玩得开心。但是这次的任务有一些特殊之处:</p><ul class=""><li id="5c57" class="je jf hh ig b ih ii il im ip jg it jh ix ji jb jj jk jl jm bi translated">编码必须在管道中间完成，我需要得到熊猫数据帧格式的结果；</li><li id="911e" class="je jf hh ig b ih jn il jo ip jp it jq ix jr jb jj jk jl jm bi translated">训练数据集可能不包含data_description文件中提到的所有类别。因此，解决方案必须能够处理所有必要的类别，因为相同的管道将应用于测试数据集；</li><li id="61af" class="je jf hh ig b ih jn il jo ip jp it jq ix jr jb jj jk jl jm bi translated">数据集包含具有相同类别的要素对，如“条件1:接近各种条件”和“条件2:接近各种条件(如果存在多个条件)”(在“条件1/2”的情况下，有9个条件)。</li></ul><figure class="jt ju jv jw fd jx er es paragraph-image"><div class="er es js"><img src="../Images/aa96b77dfa218496ef639f7d681e621d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1010/format:webp/1*KD5YKXL3cjAHlnKoW6Lh4A.png"/></div><figcaption class="ka kb et er es kc kd bd b be z dx">Screenshot from data_description.txt</figcaption></figure><p id="8a8c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果直接应用OneHotEncoder() 我们将得到18(！)新功能。但是有必要吗？</p><p id="b14f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一键编码是一种将数据转换为包含某个特性存在(1)或不存在(0)信息的形式的方法。因此，对于这个任务来说，9列就足够了，因为它足以对实例可能具有的1个或多个特征的任意组合进行编码。</p><p id="f1a7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Scikit-learn库被许多DS/ML从业者广泛使用，有时对于所有这类任务来说它就像一把瑞士军刀。但是这一次我确实需要一个定制的解决方案。</p><p id="44f2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我选择这个帖子作为起点。让我们看看结果如何。</p><p id="6341" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了与sklearn <em class="jc">管道</em>兼容，自定义转换器应该(1)从<em class="jc"> BaseEstimator </em>继承<em class="jc"> TransformerMixin </em>从<em class="jc"> sklearn.base </em>继承，并且(2)实现两个主要方法:<em class="jc"> fit() </em>和<em class="jc"> transform() </em>。让我们看看这个类的初始化方法:</p><pre class="jt ju jv jw fd ke kf kg kh aw ki bi"><span id="636f" class="kj kk hh kf b fi kl km l kn ko">class DFOneHotCategoriesCombined(BaseEstimator, TransformerMixin):<br/>    def __init(self, features_kits=None, drop_originals=True, return_full_df=True):<br/>        self.features_kits = features_kits<br/>        self.drop_originals = drop_originals<br/>        self.return_full_df = return_full_df</span></pre><p id="f42c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这里没什么特别的。“features_kits”参数应为元组列表。其格式应该如下:</p><pre class="jt ju jv jw fd ke kf kg kh aw ki bi"><span id="28a0" class="kj kk hh kf b fi kl km l kn ko">features_kits = [<br/>    (["columnA", "columnB",...], ["category1", "category2",...]),<br/>    (["columnC", "columnD",...], ["category3", "category4",...])<br/>]</span></pre><p id="392e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">每个元组描述了连接几个列的编码结果的一种情况，并给出了可用类别的完整列表。例如，对于我的任务，它看起来像:</p><pre class="jt ju jv jw fd ke kf kg kh aw ki bi"><span id="52e9" class="kj kk hh kf b fi kl km l kn ko">features_kits=[<br/>    (['Condition1', 'Condition2'], ['Abs', 'Norm',...,'RRAe']),<br/>]</span></pre><p id="31c9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">“drop_originals”参数用于调试目的，因为在编码后，我们更喜欢没有原始列的数据帧。</p><p id="ef16" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">' return_full_df '保留了对是返回具有附加一个热码编码的所有列还是只返回一个热码编码的所有列的控制。</p><p id="6083" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">sklearn最初的<em class="jc"> OneHotEncoder() </em>中的<em class="jc"> fit() </em>方法的目的是从列值中收集数据，并创建所用类别的列表。但是在我的例子中，我将在管道中传递所有需要的类别，所以<em class="jc"> fit() </em>方法应该只返回<em class="jc"> self </em>:</p><pre class="jt ju jv jw fd ke kf kg kh aw ki bi"><span id="c23e" class="kj kk hh kf b fi kl km l kn ko">def fit(self, X, y=None):<br/>    return self</span></pre><p id="0004" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jc"> transform() </em>方法实现了非常简单的主要逻辑:我们只需为传递的每个类别创建列，并将自定义函数(同一类的成员)应用于指定的列。下面给出了<em class="jc"> transform() </em>和<em class="jc"> get_onehot_encoding_() </em>方法的代码:</p><pre class="jt ju jv jw fd ke kf kg kh aw ki bi"><span id="aa4c" class="kj kk hh kf b fi kl km l kn ko">def transform(self, X, y=None):<br/>    if self.features_kits is None:<br/>        return X<br/>    onehot_features = None<br/>    drop_columns = []<br/>    for kit in self.feature_kits:<br/>        if self.drop_originals:<br/>            drop_columns += kit[0]<br/>        for category in kit[1]:<br/>            serie = X.apply(self.get_onehot_encoding_, args=[kit[0], category], axis=1)<br/>            serie.rename(category, inplace=True)<br/>            if onehot_features is None:<br/>                onehot_features = serie<br/>            else:<br/>                onehot_features = pd.concat([onehot_features, serie], axis=1)<br/>    <br/>    if self.return_full_df:<br/>        return pd.concat([X.drop(columns=drop_columns), onehot_features], axis=1)<br/>    else:<br/>        return onehot_features<br/></span><span id="f5e5" class="kj kk hh kf b fi kp km l kn ko">def get_onehot_encoding_(self, sample, col_names, target_value):<br/>    """<br/>    Function should return 1.0 if the 'target_value' has been found in sample at least in 1 column from 'col_names'<br/>    Otherwise return 0.0<br/>    """</span><span id="9f8d" class="kj kk hh kf b fi kp km l kn ko">    onehot_value = False<br/>    for column in col_names:<br/>        onehot_value = onehot_value or (sample[column] == target_value)<br/>    <br/>    return float(onehot_value)</span></pre><p id="ea14" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们来测试一下:</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="er es kq"><img src="../Images/efbce98b2a2a40311bce04dec3538b9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:618/format:webp/1*rSGloj4ksn0N62pzpSc2uQ.png"/></div></div><figcaption class="ka kb et er es kc kd bd b be z dx">Initial test data</figcaption></figure><pre class="jt ju jv jw fd ke kf kg kh aw ki bi"><span id="24f2" class="kj kk hh kf b fi kl km l kn ko">ohe_combined = DFOneHotCategoriesCombined(<br/>    features_kits=[<br/>        (['Condition1', 'Condition2'], ['Abs', 'Norm', 'Artery', 'Feedr', 'RRNn', 'RRAn', 'PosN', 'PosA', 'RRNe', 'RRAe'])<br/>    ],<br/>    return_full_df=True,<br/>    drop_originals=False<br/>)</span><span id="e34a" class="kj kk hh kf b fi kp km l kn ko">ohe_combined.fit_transform(test_data)</span></pre><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="er es kv"><img src="../Images/6d2a41054d71193a3cb4ef127f357a5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kSj_m6axIg0OLRKrQcnO_Q.png"/></div></div><figcaption class="ka kb et er es kc kd bd b be z dx">Test data after transformation</figcaption></figure><p id="098e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">就是这样！这里我留下了‘drop _ originals = False ’,以清楚地表明‘condition 1’和‘condition 2’特性的值在相应的类别中都正确地编码为1.0。</p><p id="4f33" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，我们不仅能够在一个共享的分类空间中编码2个或更多的特性，还可以在管道中使用这个自定义类来提高性能。</p><p id="f39f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我希望这篇文章是有帮助的。感谢您阅读本文！</p><div class="kw kx ez fb ky kz"><a rel="noopener follow" target="_blank" href="/mlearning-ai/mlearning-ai-submission-suggestions-b51e2b130bfb"><div class="la ab dw"><div class="lb ab lc cl cj ld"><h2 class="bd hi fi z dy le ea eb lf ed ef hg bi translated">Mlearning.ai提交建议</h2><div class="lg l"><h3 class="bd b fi z dy le ea eb lf ed ef dx translated">如何成为Mlearning.ai上的作家</h3></div><div class="lh l"><p class="bd b fp z dy le ea eb lf ed ef dx translated">medium.com</p></div></div><div class="li l"><div class="lj l lk ll lm li ln jy kz"/></div></div></a></div></div></div>    
</body>
</html>