<html>
<head>
<title>Neural Networks 101</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">神经网络101</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/neural-networks-101-a0f93a2db842?source=collection_archive---------5-----------------------#2021-09-23">https://medium.com/mlearning-ai/neural-networks-101-a0f93a2db842?source=collection_archive---------5-----------------------#2021-09-23</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="ab75" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">让我们来解开神经网络背后的工作原理。</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/67ee452ced76bc3ca79b4150b4dc6dad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*72Y4xok-qdgS-AWGk8DOMQ.jpeg"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx">Photo by <a class="ae jm" href="https://unsplash.com/@slmnbj?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Salmen Bejaoui</a> on <a class="ae jm" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="e9c7" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">神经网络这个术语根本不需要介绍，只有少数人知道神经网络的力量，很多人想学习这项非凡的技术。那你打算在这里读什么？与其讨论神经网络的类型和应用，我将通过神经网络的七个机制，使其强大和多才多艺。</p><h1 id="d624" class="kj kk hh bd kl km kn ko kp kq kr ks kt in ku io kv iq kw ir kx it ky iu kz la bi translated">什么时候我们称一个‘程序’为机器学习模型？</h1><p id="ed72" class="pw-post-body-paragraph jn jo hh jp b jq lb ii js jt lc il jv jw ld jy jz ka le kc kd ke lf kg kh ki ha bi translated">在深入研究之前，这是一个必须回答的重要问题，如果我们解开传统程序的警告，并用一些很酷的调整来代替它，那么我们可以称之为神经网络。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lg"><img src="../Images/9aaedf18ebf4a6061e0d95b72065ea25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OeXzesSabVENeeVKN3FOIg.png"/></div></div></figure><p id="ea28" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">在传统的编程中，我们通常按顺序编写步骤让它运行。但是机器学习模型确实不同，我们不是给出如何解决问题的步骤，而是向他们展示问题的例子，让他们自己找出如何解决问题。</p><p id="92e7" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">我们说过一些调整使传统程序成为机器学习模型，它们是:</p><ul class=""><li id="b5c8" class="lh li hh jp b jq jr jt ju jw lj ka lk ke ll ki lm ln lo lp bi translated"><strong class="jp hi">权重分配</strong>的想法。</li><li id="272f" class="lh li hh jp b jq lq jt lr jw ls ka lt ke lu ki lm ln lo lp bi translated">每个权重赋值都有一些<strong class="jp hi">实际表现</strong>的事实。</li><li id="5837" class="lh li hh jp b jq lq jt lr jw ls ka lt ke lu ki lm ln lo lp bi translated">要求有一个“<strong class="jp hi">自动装置来测试模型的性能。</strong></li><li id="6cd7" class="lh li hh jp b jq lq jt lr jw ls ka lt ke lu ki lm ln lo lp bi translated">需要一个“<strong class="jp hi">机构</strong>，通过改变<em class="lv">的重量分配</em>来提高性能。</li></ul><p id="05d2" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">好吧，上面的步骤可能看起来很混乱，但是相信我，我们会成功的。这是由IBM的研究员亚瑟·塞缪尔在1949年提出的。我把他的话总结如下:</p><p id="519a" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">因此，一个具有自动权重分配方法的传统程序，其中每个输入都乘以一个权重，我们需要一个性能指标来帮助我们检查权重是否有帮助，如果没有帮助，我们需要一个“<strong class="jp hi">机制</strong>”来自动更新权重。这个过程一直持续下去，直到我们得到想要的输出。但是请记住，这是一个简短的解释，我们将以更详细的方式深入研究上述步骤。</p><h1 id="39eb" class="kj kk hh bd kl km kn ko kp kq kr ks kt in ku io kv iq kw ir kx it ky iu kz la bi translated">将传统程序转化为成熟的机器学习模型</h1><p id="327c" class="pw-post-body-paragraph jn jo hh jp b jq lb ii js jt lc il jv jw ld jy jz ka le kc kd ke lf kg kh ki ha bi translated">我们的目标是创建一个程序，它可以识别3和7的图像，并且只使用传统的编程来记忆。</p><p id="4d15" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">找到3s的每个像素的平均像素值，然后对7s做同样的事情，怎么样？现在计算这个会给我们两组平均值，我们可以称它们为理想3和理想7。现在，我们将我们的3和7的图像与我们的理想图像进行比较，这将帮助我们分类为一个数字或另一个数字。</p><p id="ea5f" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">所以我们所做的基本上是找到3s和7s的像素与理想图像的像素之间的差异。言归正传，我们如何将它转换成一个全功能的机器学习模型？</p><p id="d4df" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">我们的像素相似度程序没有可用的参数，我们显然没有以下东西:</p><ul class=""><li id="977d" class="lh li hh jp b jq jr jt ju jw lj ka lk ke ll ki lm ln lo lp bi translated">当然是任何一种重量分配</li><li id="d05c" class="lh li hh jp b jq lq jt lr jw ls ka lt ke lu ki lm ln lo lp bi translated">任何基于测试权重分配有效性的改进方法。</li></ul><p id="c491" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">如果我们将这些调整整合到我们的像素相似性程序中，这确实可以称为机器学习模型。让我们对这种转换有一个高层次的概述，</p><ul class=""><li id="b1f0" class="lh li hh jp b jq jr jt ju jw lj ka lk ke ll ki lm ln lo lp bi translated">我们可以查看每个像素，并为每个像素得出一组权重，使得最高权重与特定类别中最有可能是黑色的像素相关联。</li><li id="fab6" class="lh li hh jp b jq lq jt lr jw ls ka lt ke lu ki lm ln lo lp bi translated">假设右下角的像素不太可能被7激活，所以我们可以说7的权重很低，但是它们被8激活了，所以现在8的权重很大。</li></ul><p id="28ca" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">长期以来，我们一直说有一个<strong class="jp hi">调整</strong>，但这不是解决它的理想方式，我们可以称之为<strong class="jp hi">优化函数</strong>，它将有助于权重分配，并通过测试所提供权重的有效性来改进它。更具体地说，我们将研究<strong class="jp hi">随机梯度函数(SGD)，神经网络中最常用的</strong>优化函数。</p><p id="9f28" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">简而言之，搜索像素中的最佳权重分配是搜索识别3和7的最佳函数的一种方式。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lw"><img src="../Images/c3516864b4987b01de8365da27030748.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LlHGgw0hPamt1v-W1tbIQg.png"/></div></div></figure><p id="8d92" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">下面是我们将程序转换成机器学习模型要执行的步骤:</p><ul class=""><li id="97d1" class="lh li hh jp b jq jr jt ju jw lj ka lk ke ll ki lm ln lo lp bi translated"><strong class="jp hi">第一步:</strong>想办法初始化随机权重。</li><li id="c204" class="lh li hh jp b jq lq jt lr jw ls ka lt ke lu ki lm ln lo lp bi translated"><strong class="jp hi">步骤2 </strong>:对于每幅图像，使用这些权重来预测它看起来是“3”还是“7”。</li><li id="291d" class="lh li hh jp b jq lq jt lr jw ls ka lt ke lu ki lm ln lo lp bi translated"><strong class="jp hi">第三步:</strong>根据上面的预测计算模型有多好。这就是我们引入术语<strong class="jp hi">损失函数的地方。</strong></li><li id="49b8" class="lh li hh jp b jq lq jt lr jw ls ka lt ke lu ki lm ln lo lp bi translated"><strong class="jp hi">第四步:</strong>计算<em class="lv">梯度</em>，在权重分配中起着至关重要的作用。它会告诉我们如何改变重量，这样我们的损失就会改变。</li><li id="7607" class="lh li hh jp b jq lq jt lr jw ls ka lt ke lu ki lm ln lo lp bi translated"><strong class="jp hi">步骤5: </strong>步进权重，即根据计算出的梯度改变权重。</li><li id="2093" class="lh li hh jp b jq lq jt lr jw ls ka lt ke lu ki lm ln lo lp bi translated"><strong class="jp hi">第六步:</strong>回到<strong class="jp hi">第二步</strong>，重复这个过程。</li><li id="fd4d" class="lh li hh jp b jq lq jt lr jw ls ka lt ke lu ki lm ln lo lp bi translated"><strong class="jp hi">第七步:</strong>迭代，直到我们决定停止训练过程。</li></ul><p id="1d39" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">好了，这里隐藏了一些术语，让我们来澄清一下。</p><h2 id="bd7c" class="lx kk hh bd kl ly lz ma kp mb mc md kt jw me mf kv ka mg mh kx ke mi mj kz mk bi translated">初始化</h2><p id="4204" class="pw-post-body-paragraph jn jo hh jp b jq lb ii js jt lc il jv jw ld jy jz ka le kc kd ke lf kg kh ki ha bi translated">我们首先将参数(或)权重初始化为随机值。人们认为，从随机权重值开始非常有效。</p><h2 id="66aa" class="lx kk hh bd kl ly lz ma kp mb mc md kt jw me mf kv ka mg mh kx ke mi mj kz mk bi translated">失败</h2><p id="4e5e" class="pw-post-body-paragraph jn jo hh jp b jq lb ii js jt lc il jv jw ld jy jz ka le kc kd ke lf kg kh ki ha bi translated">当模型的性能良好时，函数将返回一个较小的数字。标准的方法是将小损失视为好迹象，将大损失视为坏迹象。</p><h2 id="4dbc" class="lx kk hh bd kl ly lz ma kp mb mc md kt jw me mf kv ka mg mh kx ke mi mj kz mk bi translated">步骤</h2><p id="ea60" class="pw-post-body-paragraph jn jo hh jp b jq lb ii js jt lc il jv jw ld jy jz ka le kc kd ke lf kg kh ki ha bi translated">一个简单的方法来判断体重是应该增加还是减少，就是试着少量增加体重，然后观察体重是增加还是减少。我们做这种增加和减少，直到我们找到一个满足我们的数量。</p><p id="74cf" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">然而，我们使用微积分来处理这个问题。在不做上述调整的情况下，找到改变每个权重的方向和大致的幅度。我们通过计算<strong class="jp hi">梯度来做到这一点。</strong>这只是一个<strong class="jp hi">性能优化</strong>。</p><h2 id="0145" class="lx kk hh bd kl ly lz ma kp mb mc md kt jw me mf kv ka mg mh kx ke mi mj kz mk bi translated">停止</h2><p id="1f2c" class="pw-post-body-paragraph jn jo hh jp b jq lb ii js jt lc il jv jw ld jy jz ka le kc kd ke lf kg kh ki ha bi translated">这是我们选择历元来训练模型的阶段，我们将继续训练，直到模型的准确性开始变差或超时。</p><h1 id="b38d" class="kj kk hh bd kl km kn ko kp kq kr ks kt in ku io kv iq kw ir kx it ky iu kz la bi translated">渐变是怎么回事？</h1><p id="7b84" class="pw-post-body-paragraph jn jo hh jp b jq lb ii js jt lc il jv jw ld jy jz ka le kc kd ke lf kg kh ki ha bi translated">我们谈论性能优化已经很久了，但它到底意味着什么呢？</p><p id="7941" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">机器学习完全是关于数学的，通过利用数学的力量，我们可以更有效地自动化一些过程。在我们的SGD优化过程中，我们使用<strong class="jp hi">演算</strong>来提高优化步骤的性能。</p><p id="df36" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">微积分将帮助我们快速计算我们的损失是上升还是下降，这取决于我们如何调整模型中的参数。梯度是一个重要的现象，有助于我们找到模型的最佳参数。</p><p id="6d2c" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">简而言之，<strong class="jp hi">渐变会告诉我们需要改变多少权重来使我们的模型更好</strong>。现在我们将看到梯度的最一般的定义，</p><blockquote class="ml mm mn"><p id="bbf0" class="jn jo lv jp b jq jr ii js jt ju il jv mo jx jy jz mp kb kc kd mq kf kg kh ki ha bi translated"><em class="hh">梯度定义为上升/下降，即函数值的变化除以参数值的变化。</em></p></blockquote><p id="1c4c" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">当我们谈论微积分时，我们不应该忘记术语<strong class="jp hi">导数，</strong>它计算一个方程的变化。例如，二次函数在值3处的导数告诉我们该函数在值3处的变化有多快。简而言之，导数是方程的变化率。</p><p id="af2a" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">这里的想法是，当我们知道我们的损失函数将如何变化时，我们知道我们需要做什么来使它变得更小。机器学习中的重要机制是有办法改变损失函数的参数，使其变得更小。我们称这个机制为梯度。</p><p id="c412" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">当计算损失函数时，它将返回不是一个而是许多权重(参数)，当我们计算导数时，我们将得到每个权重(参数)的梯度。</p><p id="51aa" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">计算模型梯度的过程也称为<strong class="jp hi">反向传播</strong>。</p><p id="2df0" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">到目前为止，我们已经讨论了相当多的术语，在下一个系列的博客中，我们将直接跳到一些代码中，我们将在Pytorch中实现上述7个步骤。</p><h1 id="0fda" class="kj kk hh bd kl km kn ko kp kq kr ks kt in ku io kv iq kw ir kx it ky iu kz la bi translated">用代码弄脏双手</h1><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mr"><img src="../Images/44e889692613f709a356be612a95ad93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YNTPVeKKDKBlfJeZus8DCg.jpeg"/></div></div></figure><p id="6e2b" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">我们已经玩够了理论，现在是时候用代码弄脏我们的手了。在这一部分，我们将编写PyTorch和fastai代码，用称为MNIST的实际数据来表示这7个步骤。</p><blockquote class="ml mm mn"><p id="1471" class="jn jo lv jp b jq jr ii js jt ju il jv mo jx jy jz mp kb kc kd mq kf kg kh ki ha bi translated"><strong class="jp hi">注:本博客的笔记本版本可在此处获得</strong> <a class="ae jm" href="https://colab.research.google.com/drive/1kPD0IRk72akPOvqVpgOM5hNxRZoOeIja?usp=sharing" rel="noopener ugc nofollow" target="_blank"> <strong class="jp hi">神经网络101 Google Colab </strong> </a> <strong class="jp hi">，随意运行细胞并可视化结果。</strong></p></blockquote><p id="e881" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">说得够多了，让我们直接开始吧，在开始之前，我们必须确保数据，尽管我们稍后会处理这个问题，让我们加载它们。</p><pre class="ix iy iz ja fd ms mt mu mv aw mw bi"><span id="ca7c" class="lx kk hh mt b fi mx my l mz na"># Loading the mnist data and untar it</span><span id="1129" class="lx kk hh mt b fi nb my l mz na">data_path = untar_data(URLs.MNIST)</span></pre><p id="845d" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">在上面的代码单元中，我们刚刚下载了MNIST数据，函数<code class="du nc nd ne mt b">untar_data</code>负责下载并返回文件存储的路径。</p><p id="c402" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">我们将把它留在这里，现在，让我们看看如何用Pytorch计算梯度。</p><h1 id="f2f8" class="kj kk hh bd kl km kn ko kp kq kr ks kt in ku io kv iq kw ir kx it ky iu kz la bi translated">使用Pytorch计算渐变</h1><p id="b80d" class="pw-post-body-paragraph jn jo hh jp b jq lb ii js jt lc il jv jw ld jy jz ka le kc kd ke lf kg kh ki ha bi translated">我们知道什么是渐变以及为什么它们很重要，让我们看看如何使用Pytorch对它们进行编码。首先将看一看整个代码，然后将逐步分解每一行，看看他们做什么。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="nf ng l"/></div></figure><ul class=""><li id="3e3b" class="lh li hh jp b jq jr jt ju jw lj ka lk ke ll ki lm ln lo lp bi translated"><code class="du nc nd ne mt b">xt = tensor(8.).requires_grad_()</code>:首先创建一个张量，通过将<strong class="jp hi"> requires_grad_() </strong>设置为True，Pytorch中的任意张量将自动跟踪并计算该张量的梯度。</li><li id="8ef9" class="lh li hh jp b jq lq jt lr jw ls ka lt ke lu ki lm ln lo lp bi translated">我们知道下一步我们会用张量进行一些计算，然后，最后，激活反向传播，这有助于我们得到梯度。</li><li id="b1b5" class="lh li hh jp b jq lq jt lr jw ls ka lt ke lu ki lm ln lo lp bi translated"><code class="du nc nd ne mt b">yt.backward()</code>:这将通过激活反向传播来计算梯度。</li><li id="8407" class="lh li hh jp b jq lq jt lr jw ls ka lt ke lu ki lm ln lo lp bi translated"><code class="du nc nd ne mt b">xt.grad</code>:将在计算过程中给出该变量的计算梯度。</li></ul><p id="a01a" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">但是你可能会想，我们为什么要使用<strong class="jp hi"> require_grads_() </strong>呢，这个计算背后的底层机制是什么。在我最近的博客中，我解释了自动分化及其驱动这一切的潜在机制。</p><h2 id="abc0" class="lx kk hh bd kl ly lz ma kp mb mc md kt jw me mf kv ka mg mh kx ke mi mj kz mk bi translated">自动微分一瞥</h2><p id="0d5f" class="pw-post-body-paragraph jn jo hh jp b jq lb ii js jt lc il jv jw ld jy jz ka le kc kd ke lf kg kh ki ha bi translated">当我们第一次用参数计算损失函数时，它会返回偏导数，我们称这个过程为向前传递。</p><p id="db40" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">正向传递负责用我们的参数计算损失函数。但我们知道，神经网络必须优化其参数，以实现最佳结果，即获得最小的损失误差。</p><p id="5358" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">但是，我们如何找到有助于神经网络找到最佳参数以使损失最小化的值呢？</p><p id="f4bb" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">渐变。</p><p id="29c5" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">我们必须通过激活<strong class="jp hi">反向传播</strong>(或)反向通道来获取梯度。首先，我们执行一个正向传递，得到我们的偏导数，通过激活反向传播，使用链式法则来计算梯度。</p><p id="40d5" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated"><strong class="jp hi">但所有这些与汽车差异化有什么关系呢？</strong></p><p id="55cd" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">自动微分有助于我们跟踪这些计算，在反向传播过程中，它只需使用这些参数来计算梯度。我们知道，在偏导数的帮助下，我们能够计算可训练变量(权重和偏差)的梯度，并且仍然能够记录成千上万的导数和梯度。</p><blockquote class="ml mm mn"><p id="8c1e" class="jn jo lv jp b jq jr ii js jt ju il jv mo jx jy jz mp kb kc kd mq kf kg kh ki ha bi translated"><strong class="jp hi">注意</strong>:梯度只会告诉我们函数的斜率，并不会告诉我们参数应该调整到什么程度。</p></blockquote><p id="76b6" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">那么如何告诉我们的参数，他们应该移动的方式，以尽量减少损失呢？</p><p id="71b6" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">我们将使用一种叫做<strong class="jp hi">学习率</strong>的东西。</p><p id="f3e8" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">梯度告诉我们方向，但不是方向的大小(即我们必须采取的步骤)。这就是我们的<strong class="jp hi">学习率</strong>有所帮助的地方，它告诉我们每一步应该有多大(或者换句话说，它给了我们应该相信梯度的程度，并朝着梯度的方向前进。</p><p id="48bb" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">所以我们将梯度乘以一个小的数(学习率)来步进权重。</p><h1 id="c91b" class="kj kk hh bd kl km kn ko kp kq kr ks kt in ku io kv iq kw ir kx it ky iu kz la bi translated">和端到端SGD示例</h1><p id="0ea4" class="pw-post-body-paragraph jn jo hh jp b jq lb ii js jt lc il jv jw ld jy jz ka le kc kd ke lf kg kh ki ha bi translated">我们现在是有趣的部分。让我们对我们在博客的前一部分中讨论的七个步骤进行编码。在进入代码之前，让我们回顾一下这七个步骤，</p><ul class=""><li id="d3f0" class="lh li hh jp b jq jr jt ju jw lj ka lk ke ll ki lm ln lo lp bi translated"><strong class="jp hi">第一步</strong>:想办法初始化随机权重。</li><li id="5f96" class="lh li hh jp b jq lq jt lr jw ls ka lt ke lu ki lm ln lo lp bi translated"><strong class="jp hi">步骤2 </strong>:对于每一幅图像，使用这些权重来预测它看起来是<code class="du nc nd ne mt b">3</code>还是<code class="du nc nd ne mt b">7</code>。</li><li id="0159" class="lh li hh jp b jq lq jt lr jw ls ka lt ke lu ki lm ln lo lp bi translated"><strong class="jp hi">第三步</strong>:根据以上预测，计算模型有多好。这就是我们引入损失函数这个术语的地方。</li><li id="caae" class="lh li hh jp b jq lq jt lr jw ls ka lt ke lu ki lm ln lo lp bi translated"><strong class="jp hi">第四步</strong>:计算梯度，梯度在权重分配中起着至关重要的作用。它会告诉我们如何改变重量，这样我们的损失就会改变。</li><li id="bc9a" class="lh li hh jp b jq lq jt lr jw ls ka lt ke lu ki lm ln lo lp bi translated"><strong class="jp hi">步骤5 </strong>:步进权重，即根据计算出的梯度改变权重。</li><li id="4791" class="lh li hh jp b jq lq jt lr jw ls ka lt ke lu ki lm ln lo lp bi translated">第六步:回到第二步，重复这个过程。</li><li id="c38d" class="lh li hh jp b jq lq jt lr jw ls ka lt ke lu ki lm ln lo lp bi translated"><strong class="jp hi">第7步</strong>:迭代直到我们决定停止训练过程。</li></ul><p id="427a" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">现在代码来了！</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="nf ng l"/></div></figure><p id="ee29" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">正如我们所知，前4个步骤非常相似和简单，所以我不会谈论这一点。</p><ul class=""><li id="ae6c" class="lh li hh jp b jq jr jt ju jw lj ka lk ke ll ki lm ln lo lp bi translated"><code class="du nc nd ne mt b">params.data -= lr * params.grad.data</code>:在这里，我们将我们的学习乘以我们的梯度并更新值。一个特殊的方法告诉PyTorch我们想要计算值处变量的梯度w.r.t。(xt →变量，3 →值)</li><li id="cb88" class="lh li hh jp b jq lq jt lr jw ls ka lt ke lu ki lm ln lo lp bi translated"><code class="du nc nd ne mt b">params.grad = None</code>:将渐变设置为零，这样就不会与之前存在的渐变相加。</li></ul><p id="a879" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">让我们创建一些虚拟数据，并使用上述函数进行训练。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="nf ng l"/></div></figure><p id="5e62" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">如果有些代码没有意义也没关系，因为这篇博客的重点是渐变和在这个过程中发生的工作流程。就像我之前说的，笔记本包含打包的代码，人们可以按顺序执行它并可视化结果。</p><h1 id="191b" class="kj kk hh bd kl km kn ko kp kq kr ks kt in ku io kv iq kw ir kx it ky iu kz la bi translated">用Fastai结束</h1><p id="7240" class="pw-post-body-paragraph jn jo hh jp b jq lb ii js jt lc il jv jw ld jy jz ka le kc kd ke lf kg kh ki ha bi translated">让我们用实际数据结束这篇博客，并训练一个识别数字的模型。在这篇博客中，我们不会使用Fastai的中级组件，而是严格坚持使用低级API，并使用它创建一个模型。</p><p id="c519" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">此外，如果代码没有意义也没关系，我只是想向人们展示如何使用Fastai + Pytorch来构建模型。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="nf ng l"/></div></figure><p id="30f2" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">让我们分解上面的代码，</p><h2 id="ecef" class="lx kk hh bd kl ly lz ma kp mb mc md kt jw me mf kv ka mg mh kx ke mi mj kz mk bi translated"><code class="du nc nd ne mt b">Datasets</code></h2><p id="70e0" class="pw-post-body-paragraph jn jo hh jp b jq lb ii js jt lc il jv jw ld jy jz ka le kc kd ke lf kg kh ki ha bi translated">数据集预期，</p><ul class=""><li id="c7fd" class="lh li hh jp b jq jr jt ju jw lj ka lk ke ll ki lm ln lo lp bi translated">我们想要使用的项目</li><li id="3697" class="lh li hh jp b jq lq jt lr jw ls ka lt ke lu ki lm ln lo lp bi translated">转换(输入和输出应该如何构造和输出)</li><li id="72dc" class="lh li hh jp b jq lq jt lr jw ls ka lt ke lu ki lm ln lo lp bi translated">分割的类型(训练和测试)</li></ul><p id="ecc3" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">解码<code class="du nc nd ne mt b">dsets</code>:</p><ul class=""><li id="861d" class="lh li hh jp b jq jr jt ju jw lj ka lk ke ll ki lm ln lo lp bi translated"><code class="du nc nd ne mt b">PILImageBW</code> - &gt;创建PIL映像(接受文件路径)</li><li id="8af2" class="lh li hh jp b jq lq jt lr jw ls ka lt ke lu ki lm ln lo lp bi translated"><code class="du nc nd ne mt b">.create</code> - &gt;负责进入模型前的预处理。这适用于X和y，更像是各种输入的自定义实现。</li><li id="03d3" class="lh li hh jp b jq lq jt lr jw ls ka lt ke lu ki lm ln lo lp bi translated"><code class="du nc nd ne mt b">splits</code>本身并不做拆分，我们只是创建了对象的一个实例，稍后传递项目会给我们训练集和测试集。</li></ul><h2 id="6ea2" class="lx kk hh bd kl ly lz ma kp mb mc md kt jw me mf kv ka mg mh kx ke mi mj kz mk bi translated">转换</h2><p id="bd2c" class="pw-post-body-paragraph jn jo hh jp b jq lb ii js jt lc il jv jw ld jy jz ka le kc kd ke lf kg kh ki ha bi translated">我们将文件名转换为图像，但对于机器学习模型，我们必须将图像转换为张量(数字表示)，并使我们的模型易于在其上学习模式。</p><p id="a201" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">我们需要对数据进行一些转换！这些将需要:</p><ul class=""><li id="75c7" class="lh li hh jp b jq jr jt ju jw lj ka lk ke ll ki lm ln lo lp bi translated">确保我们的图像都是同样的大小</li><li id="2bb8" class="lh li hh jp b jq lq jt lr jw ls ka lt ke lu ki lm ln lo lp bi translated">确保我们的输出是我们的模型想要的张量</li><li id="b1cf" class="lh li hh jp b jq lq jt lr jw ls ka lt ke lu ki lm ln lo lp bi translated">给一些图像放大</li></ul><pre class="ix iy iz ja fd ms mt mu mv aw mw bi"><span id="0473" class="lx kk hh mt b fi mx my l mz na"># Creating transforms for our data by hand (left to right)</span><span id="fe72" class="lx kk hh mt b fi nb my l mz na">tfms = [ToTensor() , CropPad(size = 34 , pad_mode = PadMode.Zeros) , RandomCrop(size = 28)]</span></pre><p id="ae89" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">最后，我们还需要一件事，那就是在<strong class="jp hi"> GPU实例</strong>期间应用的转换，或者换句话说，应用于每个批处理的转换。</p><p id="6581" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">使用小批量的重要原因是它们可以在GPU上运行，因此计算速度会更快。此外，批处理可以防止训练过程中的偏差，并帮助训练更快地收敛。</p><p id="3df0" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">我们必须将我们的<strong class="jp hi">数据集</strong>加载到<code class="du nc nd ne mt b">DataLoaders</code>中，这样它将帮助我们对数据进行批处理，并在训练期间发送一批完整的数据。</p><pre class="ix iy iz ja fd ms mt mu mv aw mw bi"><span id="98a1" class="lx kk hh mt b fi mx my l mz na"># Creating the batch transforms<br/>gpu_tfms = [IntToFloatTensor() , Normalize()]</span><span id="56a2" class="lx kk hh mt b fi nb my l mz na"># Building our dataloaders<br/>dls = dsets.dataloaders(bs = 128 , after_item= tfms , after_batch= gpu_tfms)</span></pre><p id="1565" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">让我们想象一下我们的图像。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es nh"><img src="../Images/3bb9c1905dd6aab78efff92583149860.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*M0Cy38dVNkwl41i0mSbMyg.png"/></div></figure><p id="cc92" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">看那个，多漂亮啊？从文件路径到实际图像，我们已经走过了漫长的道路！</p><p id="76b5" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">但是我们已经达到了这个博客的目标，下一步是创建和拟合模型。这个总结部分更像是对了不起的Fastai人的一个大喊，没有他们，这个博客一开始就不可能。</p><p id="2073" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">在建立和训练我们的模型3个时期或3次迭代后，我们将有大约98%的准确率，这意味着我们的模型在识别数字方面做得很好。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es ni"><img src="../Images/033ac02a249e2f6c0a8b00bbabd2b8d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:858/format:webp/1*IjWJioGiSMeNlRYDg3dhIQ.png"/></div><figcaption class="ji jj et er es jk jl bd b be z dx">Our model’s result</figcaption></figure><p id="b466" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">建议您查看一下这个博客的笔记本版本，亲自接触一下这些代码。下面给出了该资源的链接。在那之前，</p><p id="a99a" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">快乐学习！</p></div><div class="ab cl nj nk go nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ha hb hc hd he"><p id="6ba4" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated"><strong class="jp hi">资源</strong></p><ul class=""><li id="2f23" class="lh li hh jp b jq jr jt ju jw lj ka lk ke ll ki lm ln lo lp bi translated"><a class="ae jm" href="https://colab.research.google.com/drive/1kPD0IRk72akPOvqVpgOM5hNxRZoOeIja?usp=sharing" rel="noopener ugc nofollow" target="_blank">本博客笔记本版</a></li><li id="e114" class="lh li hh jp b jq lq jt lr jw ls ka lt ke lu ki lm ln lo lp bi translated"><a class="ae jm" href="https://course.fast.ai/" rel="noopener ugc nofollow" target="_blank"> Fastai课程</a></li><li id="a0bd" class="lh li hh jp b jq lq jt lr jw ls ka lt ke lu ki lm ln lo lp bi translated"><a class="ae jm" href="https://pytorch.org/tutorials/" rel="noopener ugc nofollow" target="_blank"> Pytorch教程</a></li><li id="5ab5" class="lh li hh jp b jq lq jt lr jw ls ka lt ke lu ki lm ln lo lp bi translated"><a class="ae jm" href="https://ashikshafi0.medium.com/auto-differentiation-with-tensorflow-790edd34a50a" rel="noopener">张量流自动微分</a></li></ul><div class="nq nr ez fb ns nt"><a rel="noopener follow" target="_blank" href="/mlearning-ai/mlearning-ai-submission-suggestions-b51e2b130bfb"><div class="nu ab dw"><div class="nv ab nw cl cj nx"><h2 class="bd hi fi z dy ny ea eb nz ed ef hg bi translated">Mlearning.ai提交建议</h2><div class="oa l"><h3 class="bd b fi z dy ny ea eb nz ed ef dx translated">如何成为Mlearning.ai上的作家</h3></div><div class="ob l"><p class="bd b fp z dy ny ea eb nz ed ef dx translated">medium.com</p></div></div><div class="oc l"><div class="od l oe of og oc oh jg nt"/></div></div></a></div></div></div>    
</body>
</html>