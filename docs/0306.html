<html>
<head>
<title>Money Balling Cricket: Bayesian methods to get parameters</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">钱球板球:获取参数的贝叶斯方法</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/money-balling-cricket-bayesian-methods-to-get-parameters-3a40d90bde8f?source=collection_archive---------3-----------------------#2021-03-20">https://medium.com/mlearning-ai/money-balling-cricket-bayesian-methods-to-get-parameters-3a40d90bde8f?source=collection_archive---------3-----------------------#2021-03-20</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="5213" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Sabermetrics在预测棒球比赛结果方面非常有用，并已被职业球队用来取得更好的成绩。这个故事在电影《金钱球》中已经有了很好的记录。这个想法是使用统计数据来发现球员的隐藏价值，并在团队建设中做出更好的决策。</p><p id="e745" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，一个显而易见的问题出现了，那就是有没有一种方法可以利用统计学来发现其他运动中的“隐藏价值”，比如板球。这篇文章的目的是探讨这个问题，看看如何去做。本文灵感来源于这篇研究论文:<a class="ae jc" href="https://www.sfu.ca/~tswartz/papers/cricketsim.pdf" rel="noopener ugc nofollow" target="_blank">一日板球</a>的建模与仿真。对于任何对板球和统计学感兴趣的人来说，这份报纸都是一份有趣的读物。</p><p id="40ee" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">大多数方法都是直接从论文中改编而来的，但是我决定在我的方法中做一些细微的改变:</p><ul class=""><li id="a5b3" class="jd je hh ig b ih ii il im ip jf it jg ix jh jb ji jj jk jl bi translated">这篇论文是在考虑一天板球的情况下写的，我的方法已经被T-20采用</li><li id="0171" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb ji jj jk jl bi translated">论文对第二局进行了调整——为了降低复杂性，我的方法是不可知局的。因为，我的最终目标是分析个人球员，而不是完整的比赛。</li></ul><p id="1c4b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在第一部分中，我将向你展示如何为玩家生成评估，然后用于预测结果和模拟有趣的场景。</p><h1 id="1656" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">数据</h1><p id="5ff6" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">为了应用这种方法，你需要一个球一个球的数据；你需要击球的击球手、投球的投球手、每局的球数以及每一球的结果。幸运的是，在https://cricsheet.org/的T2有一个数据集。它们以yaml文件的形式存储数据，考虑到可以将yaml文件提取到数据帧中，您可以选择任何数据集。如果你不知道怎么做，你可以从这里下载我用过的数据集:【https://github.com/ArslanS1997/Cricket T4】</p><p id="7ad9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一旦准备好了，数据应该是这样的，你至少有球的结果，击球手和投球手。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es ku"><img src="../Images/df1de701b8356ee643f1780b25184837.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WY9T8FB9IYr5cJOsy-gaIw.png"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx">My dataset after extraction</figcaption></figure><p id="4255" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">您的数据集可能看起来略有不同，但只要它有四个元素，您就应该能够继续。</p><p id="3a15" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了将数据集传递到stan(我们将使用的统计库)中，您需要为每个击球手和投球手分配一个索引号，并且对于每个球，您需要为击球手和投球手分配编号。</p><h1 id="9a0a" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated"><strong class="ak">型号</strong></h1><p id="04ad" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">该模型从创建结果的离散概率分布开始。它考虑每个球的7个结果。如下图所示</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es lk"><img src="../Images/c3447b935f982aae17a00e451265cf1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7lIH7-xvJQfMZZb2QuIyvA.png"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx">Outcome of each ball</figcaption></figure><p id="6d41" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">它认为1是三柱门的结果，2是球导致零分的结果，3–7对应于得分1–6分，5分被排除在外，因为这是非常罕见的事件，可能会使结果产生偏差。这是一个多项式分布。所以本质上我们需要找到任何球b导致第k个结果的概率。概率取决于击球手、投球手、三柱门和b-1球的结果，直到球b。在数学符号中是</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es ll"><img src="../Images/bb2f79ff113d0b2096e66215451feb42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*omnAP9__SqXaK9bs5axUYg.png"/></div></div></figure><p id="4027" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">其中I是击球手，j是投球手，w是三柱门，b是球，k是结果。这些概率估计本质上是我们试图寻找的。</p><p id="01fb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，为了在数据帧中分配结果，您可以创建如下所示的函数。</p><pre class="kv kw kx ky fd lm ln lo lp aw lq bi"><span id="5cfd" class="lr js hh ln b fi ls lt l lu lv">def outcome(row):</span><span id="493d" class="lr js hh ln b fi lw lt l lu lv">if(row['The_wicket']==False):</span><span id="2a17" class="lr js hh ln b fi lw lt l lu lv">     return 1</span><span id="1f14" class="lr js hh ln b fi lw lt l lu lv">elif(row['batsmen runs']==0):</span><span id="0c89" class="lr js hh ln b fi lw lt l lu lv">     return 2</span><span id="022d" class="lr js hh ln b fi lw lt l lu lv">elif(row['batsmen runs']==1):</span><span id="21f4" class="lr js hh ln b fi lw lt l lu lv">     return 3</span><span id="b52f" class="lr js hh ln b fi lw lt l lu lv">elif(row['batsmen runs']==2):</span><span id="557a" class="lr js hh ln b fi lw lt l lu lv">     return 4</span><span id="a482" class="lr js hh ln b fi lw lt l lu lv">elif(row['batsmen runs']==3):</span><span id="dccf" class="lr js hh ln b fi lw lt l lu lv">     return 5</span><span id="acb0" class="lr js hh ln b fi lw lt l lu lv">elif(row['batsmen runs']==4):</span><span id="258b" class="lr js hh ln b fi lw lt l lu lv">     return 6</span><span id="964d" class="lr js hh ln b fi lw lt l lu lv">elif(row['batsmen runs']==6):</span><span id="df8b" class="lr js hh ln b fi lw lt l lu lv">     return 7</span><span id="bcf9" class="lr js hh ln b fi lw lt l lu lv">else:</span><span id="7546" class="lr js hh ln b fi lw lt l lu lv">     return np.nan</span><span id="47da" class="lr js hh ln b fi lw lt l lu lv">#You can use pandas apply function to assign this to each row<br/>df['outcome'] = df.apply(outcome, axis=1)</span></pre><p id="7014" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这篇论文说，为了估计这些概率，你可以使用基于有序逻辑回归的贝叶斯潜在变量模型。有序逻辑回归不同于普通逻辑回归，它输出有序结果或概率(X≤k ),而不是简单的分类或概率(X=k)。潜在变量本质上是指在数据中没有观察到的变量，但该变量的分布可以通过观察变量找到。该论文将变量U描述为“击球结果的质量”,并说给定U取某个阈值之间的值，每个球都会产生一个结果k。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es lx"><img src="../Images/ff9bcc34e8dddb6887d07d4a00cac888.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GWrv3Cjk11lCs4Jn_cMljQ.png"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx">Batting outcomes</figcaption></figure><h1 id="ae51" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">你是什么？</h1><p id="7c1c" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">本文根据前面提到的四个因素定义了这个潜在变量:击球手、投球手、三柱门(情况)和当前面对的球。为了使事情简单，本文首先做这个简单的推导，这里我们只考虑击球手和投球手。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div class="er es ly"><img src="../Images/bdb4dd4d6af2fcceae1702d910ffb5e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/format:webp/1*CuTC-ydKtsUJHTlNlq0AMQ.png"/></div></figure><p id="9d11" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这个you mu_i描述击球手的能力，mu_j描述投球手的能力，加上一个误差项。mu_i值越高，mu_j越优秀的选手。为了求出X≤k的概率，我们遵循这个数学过程。其中a_k是第k个结果的阈值，函数F()是逻辑/sigmoid函数。sigmoid函数输出0，1之间的数字，因此可用于创建所有值的概率分布。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es lz"><img src="../Images/5414ee48a10ff6af6fa634fe7ddba2af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jjbquSfGtqT-fV0nIvm-_Q.png"/></div></div></figure><figure class="kv kw kx ky fd kz er es paragraph-image"><div class="er es ma"><img src="../Images/654ceb76875484fc057c14616a85337f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1214/format:webp/1*1fg0FkAbaUtbJHabJcriOw.png"/></div><figcaption class="lg lh et er es li lj bd b be z dx">The Logistic function aka Sigmoid function</figcaption></figure><p id="991e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这似乎非常令人困惑，尤其是如果这是你第一次处理高级贝叶斯建模，但你需要从上面的推导中得到的关键是，当我们有三个东西mu_i，mu_j和阈值时，我们可以通过简单地将它们代入逻辑函数来获得X≤k的概率。为了计算概率X=k，我们需要用Prob(X≤k-1)减去Prob(X≤k)。</p><p id="fe94" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后，本文将这一概念扩展到包括各种情况(三柱门和超时)，并为每种情况引入一组阈值。它将每场比赛分为九种情况。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es mb"><img src="../Images/bf99fa52b2ec2c39e4d4eb9cb468f37c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iViDclDKssaMv7Mp9UE9Ig.png"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx">Situations for One day cricket</figcaption></figure><p id="1b38" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">解读这一点的方法是，如果每局有1-15次投球，0-3个检票口丢失，比赛的情况是1，类似地，如果36-50次投球，7-9个检票口丢失，那么我们是9。你可以得到这个想法。</p><p id="e3bc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因为我们的数据集是针对T-20比赛的，我们需要调整这些分配，我们每局只有20回合，所以我调整了如下所示的情况:</p><pre class="kv kw kx ky fd lm ln lo lp aw lq bi"><span id="987a" class="lr js hh ln b fi ls lt l lu lv"># Index variable denotes the overs played<br/>def assign_situation(row):<br/>  if(row['Wickets_lost']&gt;=0 and row['Wickets_lost'] &lt;=3):<br/>    if(row['index']&gt;0 and row['index']&lt;=5):<br/>      return 1<br/>    elif(row['index']&gt;5 and row['index']&lt;=15):<br/>      return 2<br/>    elif(row['index']&gt;15):<br/>      return 3<br/>  elif(row['Wickets_lost']&gt;3 and row['Wickets_lost'] &lt;=6):<br/>    if(row['index']&gt;0 and row['index']&lt;=5):<br/>      return 4<br/>    elif(row['index']&gt;5 and row['index']&lt;=15):<br/>      return 5<br/>    elif(row['index']&gt;15):<br/>      return 6<br/>  elif(row['Wickets_lost']&gt;6 and row['Wickets_lost'] &lt;=10):<br/>    if(row['index']&gt;0 and row['index']&lt;=5):<br/>      return 7<br/>    elif(row['index']&gt;5 and row['index']&lt;=15):<br/>      return 8<br/>    elif(row['index']&gt;15):<br/>      return 9<br/></span></pre><p id="4da0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，在调整后的模型中，情况是这样的</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es mc"><img src="../Images/f37e198130f683e9ef776b4b23ee8598.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UW9KApRzIya4O-eKZz3XbQ.png"/></div></div></figure><p id="dc95" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">其中下标l表示情况，a_lk是第1个情况和第k个结果的阈值，delta_l是当比赛情况变得更加困难时包含“压力”的变量。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es md"><img src="../Images/9e3649729f00a58d5583c21c0916bd20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f6aRCgJBj0uMNi1GAlGYZg.png"/></div></div></figure><p id="8392" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这些delta_1，delta_2是我们需要估计的两个新参数，这将给出每种情况下delta _ 1的值。强烈建议你此刻停下来思考一下提到的每一点，并阅读这篇文章和我的编码文章，以便获得更好的理解。正如以前在这个新模型中，如果我们要计算Prob(X=k ),我们需要如下，我们需要减去Prob(X≤k)和Prob(X≤k-1)或以逻辑函数的形式</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es me"><img src="../Images/e6f00ee59a675d0c4c9cfcec81a38987.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WpPGL67YByG-8gf3N5aURQ.png"/></div></div></figure><h1 id="588f" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">估计参数</h1><p id="5730" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">现在我们知道，如果我们有所有管理部门、a_lk和增量，我们需要做什么，但是我们如何估计它们。因为这是一个贝叶斯设置，我们需要给这些参数一些初始分布。本文对我们所有的参数使用这些先验分布。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es mf"><img src="../Images/da4f9cd1bce894b692b8513aafe86f62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YrTx0AF-4y-5zYv6mdFCAw.png"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx">priors for all parameters</figcaption></figure><p id="b364" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了从这些先验中计算出后验估计，你需要一个统计软件包。你可以使用任何能够做到这一点的软件，但我更喜欢使用stan，而报纸使用WINBUGS。Stan使用马尔可夫链蒙特卡罗(MCMC)方法计算这些后验分布，这是一种非常标准的计算贝叶斯参数的方法。</p><p id="92e5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">您可以在Python和r中使用stan作为库。您需要的只是Pystan和Rstan包，还需要在stan自己的统计编程语言中指定先验知识以及模型与stan的关系，这与C++非常相似。</p><p id="ee68" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果您不熟悉stan，您可以使用我用来指定模型的stan代码。或者如果你想了解这是如何工作的，请查看stan文档:<a class="ae jc" href="https://mc-stan.org/users/documentation/" rel="noopener ugc nofollow" target="_blank">https://mc-stan.org/users/documentation/</a></p><pre class="kv kw kx ky fd lm ln lo lp aw lq bi"><span id="12d3" class="lr js hh ln b fi ls lt l lu lv">import pystan <br/>modelcode = """<br/></span><span id="5a0a" class="lr js hh ln b fi lw lt l lu lv">data {<br/>    int&lt;lower=1&gt; N; <br/>    int&lt;lower =1&gt; BatNum;<br/>    int&lt;lower =1&gt; BowlNum;<br/>    int BatIndex[N];<br/>    int BowlIndex[N];<br/>    int&lt;lower=1,upper=9&gt; l[N];<br/>    int&lt;lower=1,upper=7&gt; F[N];<br/>    int&lt;lower=1&gt; index[N];<br/>    int matchballs;<br/>}</span><span id="a01c" class="lr js hh ln b fi lw lt l lu lv">parameters {</span><span id="a7e1" class="lr js hh ln b fi lw lt l lu lv">ordered[6] alk_tilda[9];<br/>    real&lt;lower=0&gt; sigma;<br/>    real&lt;lower=0&gt; tau;<br/>    real mu_1_tilda[BatNum];<br/>    real mu_2_tilda[BowlNum];<br/>    <br/>    <br/>    <br/>   real&lt;lower=0,upper=1&gt; delta_1;<br/>   real&lt;lower=0,upper=1&gt; delta_2;</span><span id="8f35" class="lr js hh ln b fi lw lt l lu lv">}<br/>transformed parameters{</span><span id="f2e6" class="lr js hh ln b fi lw lt l lu lv">real delta[9];<br/>real mu_1[BatNum];<br/>real mu_2[BowlNum];<br/>ordered[6] alk[9];<br/>   <br/>   <br/>for(n in 1:9){<br/>   delta[n] = D(l[n],delta_1,delta_2);<br/>   alk[n] = sqrt(1/sigma)*alk_tilda[n];<br/>   }<br/>for (n in 1:BatNum){</span><span id="484b" class="lr js hh ln b fi lw lt l lu lv">mu_1[n] = sqrt(1/tau)*mu_1_tilda[n];<br/>}<br/>for (n in 1:BowlNum){</span><span id="32db" class="lr js hh ln b fi lw lt l lu lv">mu_2[n] = sqrt(1/tau)*mu_2_tilda[n];<br/>}</span><span id="7894" class="lr js hh ln b fi lw lt l lu lv">}</span><span id="8067" class="lr js hh ln b fi lw lt l lu lv">model {<br/>  // <br/>   vector[N] s;</span><span id="bc70" class="lr js hh ln b fi lw lt l lu lv">    delta_1 ~uniform(0,1);<br/>    delta_2 ~uniform(0,1);<br/>      <br/>    sigma ~ gamma(1,1);<br/>     tau ~ gamma(1,1);<br/>    mu_1_tilda ~ normal(0,1);<br/>    mu_2_tilda ~ normal(0,1);<br/>   </span><span id="490f" class="lr js hh ln b fi lw lt l lu lv">for(t in 1:9){<br/>      alk_tilda[t] ~ normal(0,1);<br/>    }<br/> for(i in 1:N){<br/>  s[i] =  mu_1[BatIndex[i]] + delta[l[i]] - mu_2[BowlIndex[i]];<br/>   <br/>   <br/> }<br/> for(i in 1:N){<br/>F[i]~ ordered_logistic(s[i]',alk[l[i]]);<br/> }</span><span id="5617" class="lr js hh ln b fi lw lt l lu lv">}</span><span id="b8db" class="lr js hh ln b fi lw lt l lu lv">"""</span><span id="fe2f" class="lr js hh ln b fi lw lt l lu lv">sm = pystan.StanModel(model_code=modelcode)</span></pre><p id="54f6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">上面的代码允许您编译stan模型，接下来您需要提供数据并运行stan的采样。这是训练或运行采样器的代码。</p><pre class="kv kw kx ky fd lm ln lo lp aw lq bi"><span id="2328" class="lr js hh ln b fi ls lt l lu lv"># First creating a list of all the batsman and bowlers</span><span id="1ff4" class="lr js hh ln b fi lw lt l lu lv">batsman =complete_data_train['batsman'].unique()</span><span id="043e" class="lr js hh ln b fi lw lt l lu lv">bowler = complete_data_train['bowler'].unique()</span><span id="a454" class="lr js hh ln b fi lw lt l lu lv">#Assigning an index to each bowler and batsman respectively</span><span id="9ed1" class="lr js hh ln b fi lw lt l lu lv">bowler = [[bowler[i-1],i] for i in range(1,len(bowler)+1)]</span><span id="f7fd" class="lr js hh ln b fi lw lt l lu lv">batsman = [[batsman[i-1],i] for i in range(1,len(batsman)+1)]</span><span id="5f84" class="lr js hh ln b fi lw lt l lu lv">#Situation of each ball</span><span id="7813" class="lr js hh ln b fi lw lt l lu lv">l = [int(x) for x in complete_data_train['situation']]</span><span id="375c" class="lr js hh ln b fi lw lt l lu lv">#the actual outcome</span><span id="e1ad" class="lr js hh ln b fi lw lt l lu lv">F = [int(x) for x in complete_data_train['outcome']]</span><span id="61a4" class="lr js hh ln b fi lw lt l lu lv">#Functions that assign each batsman and bowler with their respective index in our dataframe</span><span id="ee96" class="lr js hh ln b fi lw lt l lu lv">complete_data_train['BatIndex'] = complete_data_train.apply(assign_num, theList= batsman, string = 'batsman',axis=1)</span><span id="5a0b" class="lr js hh ln b fi lw lt l lu lv">complete_data_train['BowlIndex'] = complete_data_train.apply(assign_num, args=(bowler,'bowler',),axis=1)</span><span id="387f" class="lr js hh ln b fi lw lt l lu lv">#converting that into a list</span><span id="efd0" class="lr js hh ln b fi lw lt l lu lv">BatIndex = [int(x) for x in complete_data_train['BatIndex2']]</span><span id="7d52" class="lr js hh ln b fi lw lt l lu lv">BowlIndex = [int(x) for x in complete_data_train['BowlIndex2']]</span><span id="e02a" class="lr js hh ln b fi lw lt l lu lv">BatNum = int(len(batsman))</span><span id="5554" class="lr js hh ln b fi lw lt l lu lv">BowlNum = len(bowler)</span><span id="647a" class="lr js hh ln b fi lw lt l lu lv">N = int(len(complete_data_train))</span><span id="5602" class="lr js hh ln b fi lw lt l lu lv">matchballs = 240</span><span id="11bf" class="lr js hh ln b fi lw lt l lu lv">index = [int(x) for x in complete_data_train['balls']]</span><span id="06fa" class="lr js hh ln b fi lw lt l lu lv">data = {'N':N,'l':l,'F':F,'BatIndex':BatIndex,'BowlIndex':BowlIndex,'BatNum':BatNum,'BowlNum':BowlNum,'matchballs':matchballs,'index':index}</span><span id="fb31" class="lr js hh ln b fi lw lt l lu lv">#Stan fit object will have all the trained parameters.</span><span id="1b5d" class="lr js hh ln b fi lw lt l lu lv">fit = sm.sampling(data, iter=2000, chains=4,n_jobs=1,verbose=True,refresh=100,control={'max_treedepth': 10})</span></pre><p id="eb24" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在数据集中，我有大约25000个球，86个独特的击球手和76个独特的投球手。这使得要估计的总参数等于1+1 (deltas) + 9(6) (a_lk) + 86(击球手)和76(投球手)，这等于要估计的218个参数。在当前的迭代设置下，训练数据集需要3-4个小时。</p><p id="fad0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">训练结束后，我们取斯坦斯输出的平均值如下</p><pre class="kv kw kx ky fd lm ln lo lp aw lq bi"><span id="c121" class="lr js hh ln b fi ls lt l lu lv"># Extract output <br/>alk=fit.extract()['alk']</span><span id="0fa6" class="lr js hh ln b fi lw lt l lu lv">mu1 = fit.extract()['mu_1']</span><span id="6e94" class="lr js hh ln b fi lw lt l lu lv">mu2 = fit.extract()['mu_2']</span><span id="2cbc" class="lr js hh ln b fi lw lt l lu lv">del1 = fit.extract()['delta_1']</span><span id="098f" class="lr js hh ln b fi lw lt l lu lv">del2 = fit.extract()['delta_2']</span><span id="e31d" class="lr js hh ln b fi lw lt l lu lv"># Assign mean <br/>#using previously made lists with name and index of bowler &amp; batsman # you can assign the mu_i and mu_j<br/>batsman = pd.DataFrame(batsman, columns=['name','number'])</span><span id="3ba8" class="lr js hh ln b fi lw lt l lu lv">bowler = pd.DataFrame(bowler, columns=['name','number'])</span><span id="ccb4" class="lr js hh ln b fi lw lt l lu lv">batsman['mean'] = [x for x in mu1.mean(axis=0)]</span><span id="7b26" class="lr js hh ln b fi lw lt l lu lv">bowler['mean'] = [x for x in mu2.mean(axis=0)]<br/># estimates for deltas</span><span id="7636" class="lr js hh ln b fi lw lt l lu lv">d1 = del1.mean(axis=0)<br/>d2 = del2.mean(axis=0)</span><span id="bbe5" class="lr js hh ln b fi lw lt l lu lv"># estimates for thresholds <br/>alk=pd.DataFrame(alk.mean(axis=0),columns=['mean_'+str(x) for x in range(1,7) ])</span></pre><p id="10c3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">每个数据帧的输出应该如下所示:</p><div class="kv kw kx ky fd ab cb"><figure class="mg kz mh mi mj mk ml paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><img src="../Images/e2e850494f94e7b05b37147d122cfa53.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/format:webp/1*wlRMPX74ISOlc_3sBybuBQ.png"/></div></figure><figure class="mg kz mm mi mj mk ml paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><img src="../Images/aae425f1a42d471f062c45214b42010a.png" data-original-src="https://miro.medium.com/v2/resize:fit:490/format:webp/1*ImLQjFzckaZWNLGw2WTqHw.png"/></div></figure><figure class="mg kz mn mi mj mk ml paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><img src="../Images/a4a975d3290671bfd97bfd91c5123c24.png" data-original-src="https://miro.medium.com/v2/resize:fit:528/format:webp/1*t5V5TFjVGvcrhMCda6vZKQ.png"/></div><figcaption class="lg lh et er es li lj bd b be z dx mo di mp mq">Fig 1. Thresholds for all 9 situations and 7 outcomes (only need 6 values for 7 outcomes), Estimates for batsman and Estimates for bowlers</figcaption></figure></div><h1 id="0bef" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">敬请关注</h1><p id="8d02" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">这当然是一个具有挑战性的演示，但我们刚刚进入最有趣的部分，即使用这些估计来预测一个球接一个球的结果，并进行模拟，看看在有趣的场景中会发生什么。跟着我，这样你就可以在下一部出来的时候得到通知。同时，保持好奇！</p></div></div>    
</body>
</html>