<html>
<head>
<title>Image Classification of Rock-Paper-Scissors Pictures using Convolutional Neural Network (CNN)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于卷积神经网络的石头剪子布图像分类</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/image-classification-of-rock-paper-scissors-pictures-using-convolutional-neural-network-cnn-c3d2db127cdb?source=collection_archive---------1-----------------------#2021-03-28">https://medium.com/mlearning-ai/image-classification-of-rock-paper-scissors-pictures-using-convolutional-neural-network-cnn-c3d2db127cdb?source=collection_archive---------1-----------------------#2021-03-28</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/fe51d5e678051277e5b10b735e659289.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6kxqwYSPtgda_CR9"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Photo by <a class="ae it" href="https://unsplash.com/@imanitor?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Fadilah N. Imani</a> on <a class="ae it" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="cd2a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这个项目是我提交给Dicoding Academy — <a class="ae it" href="https://www.dicoding.com/academies/184" rel="noopener ugc nofollow" target="_blank">初级班</a>的机器学习。该项目将讲述使用<strong class="iw hi">卷积神经网络</strong>对石头剪刀布图像进行<strong class="iw hi">图像分类。为了构建模型，我们将在Tensorflow和Keras包的帮助下使用Python。请参考<a class="ae it" href="https://github.com/imfdlh/dicoding/blob/master/CNN-rockpaperscissors/fadilahnurimani_submission.ipynb" rel="noopener ugc nofollow" target="_blank">这里的</a>获取完整的笔记本。请注意，一些包可能无法在Jupyter Notebook中工作，因为我使用了Colab Notebook(例如:从google.colab导入文件)。</strong></p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><p id="35a8" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi"> <em class="jz">卷积神经网络(CNN ) </em> </strong> <em class="jz">是一种深度学习算法，是为计算机视觉设计的，比如图像和视频数据。</em></p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><h1 id="d987" class="ka kb hh bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">数据集石头剪子布</h1><p id="a72f" class="pw-post-body-paragraph iu iv hh iw b ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr ha bi translated">这是我们将在这个项目中使用的一个名为“rockpaperscissors.zip”的目录文件的结构的一瞥。你可以在kaggle上的这里找到数据集<a class="ae it" href="https://www.kaggle.com/drgfreeman/rockpaperscissors" rel="noopener ugc nofollow" target="_blank">。</a></p><figure class="le lf lg lh fd ii er es paragraph-image"><div class="er es ld"><img src="../Images/1f5aeca857aae683c552e56ff69afb1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/1*2D_5vm2BB11NWjl7ThEKtA.png"/></div></figure><h1 id="2de8" class="ka kb hh bd kc kd li kf kg kh lj kj kk kl lk kn ko kp ll kr ks kt lm kv kw kx bi translated">导入包/库</h1><p id="9134" class="pw-post-body-paragraph iu iv hh iw b ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr ha bi translated">我们将使用的包是TensorFlow 2和Keras。在Tensorflow 2中，Keras包与Tensorflow集成在一起，这意味着一旦导入了Tensorflow，就可以使用Keras。</p><p id="7cc0" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">至于ImageDataGenerator，我们将在图像增强阶段使用它进行图像预处理。</p><figure class="le lf lg lh fd ii"><div class="bz dy l di"><div class="ln lo l"/></div></figure><h1 id="9bc9" class="ka kb hh bd kc kd li kf kg kh lj kj kk kl lk kn ko kp ll kr ks kt lm kv kw kx bi translated">下载并提取数据集</h1><p id="7e94" class="pw-post-body-paragraph iu iv hh iw b ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr ha bi translated">使用<code class="du lp lq lr ls b">wget</code> <strong class="iw hi"> </strong>命令从链接下载数据集。</p><figure class="le lf lg lh fd ii"><div class="bz dy l di"><div class="ln lo l"/></div></figure><figure class="le lf lg lh fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lt"><img src="../Images/5171b73f14f5e52465c8bf18f3946117.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FwIIWLBTCEjnKAoQ9qJdYA.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Download and extract dataset</figcaption></figure><p id="04a4" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了能够使用数据集，我们需要首先使用<code class="du lp lq lr ls b">zipfile</code> <strong class="iw hi"> </strong>库提取它们。</p><figure class="le lf lg lh fd ii"><div class="bz dy l di"><div class="ln lo l"/></div></figure><h1 id="11aa" class="ka kb hh bd kc kd li kf kg kh lj kj kk kl lk kn ko kp ll kr ks kt lm kv kw kx bi translated">检查目录</h1><p id="5fcc" class="pw-post-body-paragraph iu iv hh iw b ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr ha bi translated">我们用<code class="du lp lq lr ls b">listdir</code> <strong class="iw hi"> </strong>从<code class="du lp lq lr ls b">os</code>库<strong class="iw hi"> </strong>中读取“石头剪刀布”目录的内容。</p><figure class="le lf lg lh fd ii"><div class="bz dy l di"><div class="ln lo l"/></div></figure><figure class="le lf lg lh fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lu"><img src="../Images/d9434fefa3887deab71985487db04058.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gk2BmqaeoZ9i-wg7_Er1PQ.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">read the content of “rockpaperscissors”</figcaption></figure><p id="7ef8" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">同样的代码也适用于“rock paper scissors/RPS-cv-images”目录。这是将用于<strong class="iw hi">基本目录</strong>的目录。</p><figure class="le lf lg lh fd ii"><div class="bz dy l di"><div class="ln lo l"/></div></figure><figure class="le lf lg lh fd ii er es paragraph-image"><div class="er es lv"><img src="../Images/270c0248126402a1032ba8cd1c723e2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1136/format:webp/1*5txSf080Bn3wrPS4oHjm2g.png"/></div><figcaption class="ip iq et er es ir is bd b be z dx">read the content of “rockpaperscissors/rps-cv-images”</figcaption></figure><h1 id="06dd" class="ka kb hh bd kc kd li kf kg kh lj kj kk kl lk kn ko kp ll kr ks kt lm kv kw kx bi translated">图像增强的数据预处理</h1><p id="1920" class="pw-post-body-paragraph iu iv hh iw b ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr ha bi translated">图像增强是数据预处理阶段的一部分。图像增强用于从现有数据集生成新版本的训练图像。图像放大的一些例子是水平或垂直翻转图像、旋转、缩放等等。有了Keras，我们可以使用<code class="du lp lq lr ls b">ImageDataGenerator</code>功能来创建图像增强。</p><p id="6486" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在这个项目中，我们将在ImageDataGenerator中使用6个参数，如下3–8行所示:</p><figure class="le lf lg lh fd ii"><div class="bz dy l di"><div class="ln lo l"/></div></figure><ul class=""><li id="5653" class="lw lx hh iw b ix iy jb jc jf ly jj lz jn ma jr mb mc md me bi translated"><code class="du lp lq lr ls b">rescale</code> <strong class="iw hi"> = 1。/255 </strong>:重新缩放像素值1。/255从0–255范围到0–1范围。</li><li id="de7a" class="lw lx hh iw b ix mf jb mg jf mh jj mi jn mj jr mb mc md me bi translated"><code class="du lp lq lr ls b">rotation_range</code> <strong class="iw hi"> = 20 </strong>:在0-20度范围内旋转图像。</li><li id="948d" class="lw lx hh iw b ix mf jb mg jf mh jj mi jn mj jr mb mc md me bi translated"><code class="du lp lq lr ls b">horizontal_flip</code> <strong class="iw hi"> = True </strong>:水平旋转图像。</li><li id="11cf" class="lw lx hh iw b ix mf jb mg jf mh jj mi jn mj jr mb mc md me bi translated"><code class="du lp lq lr ls b">shear_range</code><strong class="iw hi">= 0.2</strong>:0.2度范围内逆时针方向的剪切角度。</li><li id="c0a8" class="lw lx hh iw b ix mf jb mg jf mh jj mi jn mj jr mb mc md me bi translated"><code class="du lp lq lr ls b">fill_mode</code> <strong class="iw hi"> = 'wrap' </strong>:用wrap (abcdabcd|abcd|abcdabcd)模式填充外部边界点。</li><li id="7b3f" class="lw lx hh iw b ix mf jb mg jf mh jj mi jn mj jr mb mc md me bi translated"><code class="du lp lq lr ls b">validation_split</code> <strong class="iw hi"> = 0.4 </strong>:按验证步骤总数据集的40%分割图像。</li></ul><p id="d4b1" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">图像数据生成器还可以帮助我们根据目录自动标记图片，这样我们就不必输入每张图片及其标签。</p><p id="1b44" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">关于每个参数的更多解释，你可以在这里阅读文档<a class="ae it" href="https://keras.io/api/preprocessing/image/" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="778a" class="ka kb hh bd kc kd li kf kg kh lj kj kk kl lk kn ko kp ll kr ks kt lm kv kw kx bi translated">为模型准备数据</h1><p id="ad29" class="pw-post-body-paragraph iu iv hh iw b ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr ha bi translated">在进入数据建模步骤之前，我们将采用当前路径到一个目标目录，并生成批量的扩充数据。我们使用<code class="du lp lq lr ls b">subset</code>参数，因为我们已经在前一步中设置了训练和验证阶段的数据百分比(<code class="du lp lq lr ls b">validation_split</code>参数)。</p><figure class="le lf lg lh fd ii"><div class="bz dy l di"><div class="ln lo l"/></div></figure><figure class="le lf lg lh fd ii er es paragraph-image"><div class="er es mk"><img src="../Images/c76da10585958d5272fa91fc658ee583.png" data-original-src="https://miro.medium.com/v2/resize:fit:904/format:webp/1*f3RFUwfi3-_0kILTOJW0DQ.png"/></div><figcaption class="ip iq et er es ir is bd b be z dx">1314 images for training and 874 images for validation</figcaption></figure><ul class=""><li id="b887" class="lw lx hh iw b ix iy jb jc jf ly jj lz jn ma jr mb mc md me bi translated"><strong class="iw hi"> base_dir </strong>:目标目录的路径(base_dir)。</li><li id="80af" class="lw lx hh iw b ix mf jb mg jf mh jj mi jn mj jr mb mc md me bi translated"><code class="du lp lq lr ls b">target_size</code> <strong class="iw hi"> = (100，150) </strong>:所有找到的图像将被调整到100像素x 150像素。</li><li id="d974" class="lw lx hh iw b ix mf jb mg jf mh jj mi jn mj jr mb mc md me bi translated"><code class="du lp lq lr ls b">class_mode</code><strong class="iw hi">=‘分类’</strong>:确定返回的标签数组的类型，我们使用‘分类’，因为我们有3类图像。</li><li id="c6cf" class="lw lx hh iw b ix mf jb mg jf mh jj mi jn mj jr mb mc md me bi translated"><code class="du lp lq lr ls b">subset</code> <strong class="iw hi"> </strong>:如果在<code class="du lp lq lr ls b">ImageDataGenerator</code>中设置了<code class="du lp lq lr ls b">validation_split</code>，则为数据‘训练’或‘验证’的子集。</li></ul><h1 id="af64" class="ka kb hh bd kc kd li kf kg kh lj kj kk kl lk kn ko kp ll kr ks kt lm kv kw kx bi translated">构建CNN架构</h1><p id="1b2b" class="pw-post-body-paragraph iu iv hh iw b ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr ha bi translated">因为我们要建立一个模型来对图片进行分类，所以我们要创建一个二维(2D) CNN架构。基本上，2D CNN由输入层、卷积层、最大池层、用于平坦化2D阵列的层以及最后的输出层构成。在这个项目中，我们将建立一个使用4层卷积和最大池的模型。</p><p id="5e7a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">卷积层用于提取图片的属性，而最大池层将有助于从卷积过程中减少每个图片的大小，从而训练的速度将更快。</p><p id="380a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">第一层是用<code class="du lp lq lr ls b">input_shape</code> = (100，150，3)表示的100 x 150 RGB图片数组形状的输入层。在同一行代码(第二行)中，我们有第一个32节点的2D卷积层，3×3滤波器，和ReLU(校正线性单元)激活函数。ReLU的使用是为了增加模型的非线性，因为图像自然是非线性的。这里可以阅读更多<a class="ae it" href="https://www.superdatascience.com/blogs/convolutional-neural-networks-cnn-step-1b-relu-layer/" rel="noopener ugc nofollow" target="_blank">关于ReLU激活函数在卷积层的作用。</a></p><p id="f099" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在下一行代码中，我们有一个大小为2 x 2的2D最大池层。最大池通过选择具有最大值的像素来工作，并将产生与最大池层相同大小的新图片(2 x 2)。</p><p id="7e7b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在最大池层中处理图像之后，图像将再次处理到下一个卷积层，然后是最大池层，等等。在最后一个max-pooling层之后，图片数组将被展平为一维数组，并在隐藏层中再次处理。</p><p id="0857" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">之后，已经处于1维形式的图片阵列被移动到输出层，并再次使用激活函数进行处理。这次，我们将使用softmax函数，而不是ReLU。当案例为多类别分类时，使用Softmax激活功能。因为我们有3个类，所以输出节点的数量将是3。</p><figure class="le lf lg lh fd ii"><div class="bz dy l di"><div class="ln lo l"/></div></figure><h1 id="4a47" class="ka kb hh bd kc kd li kf kg kh lj kj kk kl lk kn ko kp ll kr ks kt lm kv kw kx bi translated">编译模型:确定损失函数和优化器</h1><p id="1b24" class="pw-post-body-paragraph iu iv hh iw b ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr ha bi translated">在我们完成架构的构建之后，我们接着编译预构建的模型，并指定损失函数、优化器和评估指标。由于这个项目是一个多类分类案例，我们将使用分类交叉熵损失函数。至于优化器，我们将使用adam优化器，因为这种自适应优化器在大多数情况下工作良好。最后，为了监控模型性能，我们将使用准确性指标对它们进行评估。</p><figure class="le lf lg lh fd ii"><div class="bz dy l di"><div class="ln lo l"/></div></figure><h1 id="13bd" class="ka kb hh bd kc kd li kf kg kh lj kj kk kl lk kn ko kp ll kr ks kt lm kv kw kx bi translated">使用回调提前停止</h1><p id="7bdf" class="pw-post-body-paragraph iu iv hh iw b ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr ha bi translated">为了加快训练速度，我们将使用回调函数在模型达到精度阈值时提前停止。早期停止有助于减少模型过度拟合的趋势。对于这个项目，我们将声明准确率阈值为98%。</p><figure class="le lf lg lh fd ii"><div class="bz dy l di"><div class="ln lo l"/></div></figure><h1 id="075a" class="ka kb hh bd kc kd li kf kg kh lj kj kk kl lk kn ko kp ll kr ks kt lm kv kw kx bi translated">训练模型</h1><p id="8483" class="pw-post-body-paragraph iu iv hh iw b ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr ha bi translated">所以我们终于到了构建图像分类器的最后阶段。在此阶段，我们将使用已经在<code class="du lp lq lr ls b">train_generator</code>准备好的训练数据集在总共20个时期内训练预建模型，并使用在<code class="du lp lq lr ls b">validation_generator</code>准备好的验证数据集评估模型。</p><p id="d258" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在这个训练过程中，我们将训练样本分为25个批次，验证样本分为5个批次。我们还将verbose值声明为2，以使训练过程在输出单元格中可用。然后，由于我们实现了早期停止方法，训练过程将在达到最低98%的准确率时停止。</p><figure class="le lf lg lh fd ii"><div class="bz dy l di"><div class="ln lo l"/></div></figure><figure class="le lf lg lh fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ml"><img src="../Images/2de94bb62d5355c5bccbc921fd69f469.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iQtSnGIihkfFRr2xE8CKcA.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">data training result</figcaption></figure><h1 id="7b02" class="ka kb hh bd kc kd li kf kg kh lj kj kk kl lk kn ko kp ll kr ks kt lm kv kw kx bi translated">预测图像以检查模型</h1><p id="842c" class="pw-post-body-paragraph iu iv hh iw b ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr ha bi translated">耶，终于可以使用图像分类器模型了！</p><p id="b868" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了能够对新数据进行分类，我们构建了一个脚本来上传新图片，然后通过<code class="du lp lq lr ls b">model.predict</code>函数将它们加载到模型中。</p><figure class="le lf lg lh fd ii"><div class="bz dy l di"><div class="ln lo l"/></div></figure><figure class="le lf lg lh fd ii er es paragraph-image"><div class="er es mm"><img src="../Images/3dfeaa5ec3267072014d7bfd7b7ff293.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*6tbAyWC7zAay3xpXnQAAYg.png"/></div><figcaption class="ip iq et er es ir is bd b be z dx">image classifier output example</figcaption></figure><p id="905a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">预测新数据时，可能会有一些不正确的预测。这是因为我们之前使用的训练数据集。在训练数据集中，所有图片都使用绿色背景，因此如果我们不使用相似的背景，模型可能会错误地预测结果。</p><p id="e882" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">上面的例子似乎没有显示出错误，但在一些试错过程后，我发现大多数时候，模型会对没有使用绿色背景的图片进行错误分类。</p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><blockquote class="mn mo mp"><p id="1bd5" class="iu iv jz iw b ix iy iz ja jb jc jd je mq jg jh ji mr jk jl jm ms jo jp jq jr ha bi translated">读者你好，</p><p id="0946" class="iu iv jz iw b ix iy iz ja jb jc jd je mq jg jh ji mr jk jl jm ms jo jp jq jr ha bi translated">谢谢你读到这里，非常感谢！</p><p id="89ea" class="iu iv jz iw b ix iy iz ja jb jc jd je mq jg jh ji mr jk jl jm ms jo jp jq jr ha bi translated">此外，如果你认为这个帖子有用，请不要犹豫，在评论区或鼓掌区留下你的痕迹，这对我意义重大！:)</p></blockquote><p id="3e6f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">无论如何，你也可以访问<a class="ae it" href="https://www.tensorflow.org/tutorials/images/cnn" rel="noopener ugc nofollow" target="_blank">这里</a>看TensorFlow官方网站的CNN教程。</p></div></div>    
</body>
</html>