<html>
<head>
<title>Churn Prediction using BigQueryML</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用BigQueryML的流失预测</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/churn-prediction-using-bigqueryml-8a869fa636c9?source=collection_archive---------1-----------------------#2021-06-03">https://medium.com/mlearning-ai/churn-prediction-using-bigqueryml-8a869fa636c9?source=collection_archive---------1-----------------------#2021-06-03</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/37d8e9380c6ae7d3d167cfc3cbd61df6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GAZa1iXx-IDWufgTVIs6xA.jpeg"/></div></div></figure><p id="aba8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">有很多博客都在使用scikit-learn、R或其他高级ML工具包来构建流失预测模型。然而，他们中的大多数都需要强大的工程和数据科学技能。也就是说，现在可以利用SQL和数据科学的基本知识，通过利用谷歌等公司开发的工具来实现机器学习的民主化，来创建健壮的模型。</p><p id="8c46" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在本帖中，我们将使用Google的BigQueryML以及使用RudderStack平台收集和交付的点击流数据。该数据表示与移动娱乐场游戏相关联的事件，例如老虎机旋转。这种情况下的数据量是典型的，正如我们将看到的，执行流失分析既容易访问又高效，而不必在基础架构上花费大量资金。</p><h1 id="bcf9" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">什么是客户流失，我们为什么关注它</h1><p id="802d" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">客户流失是任何消费业务的问题，无论是电子商务还是手机游戏。它的定义很简单——每当客户停止与你的公司做生意或停止购买你的产品时，就会发生流失。失去客户的<strong class="ir hi">影响</strong>不仅仅导致<strong class="ir hi">收入损失</strong>。<strong class="ir hi">获客</strong>的<strong class="ir hi">成本</strong>可以从几块钱到几十块钱不等；因此，失去一个客户也意味着对投资回报的负面影响。</p><p id="c257" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">客户流失可能有多种原因，包括但不限于:</p><ul class=""><li id="3be2" class="kr ks hh ir b is it iw ix ja kt je ku ji kv jm kw kx ky kz bi translated">劣质产品质量</li><li id="9e49" class="kr ks hh ir b is la iw lb ja lc je ld ji le jm kw kx ky kz bi translated">不满意的客户服务</li><li id="cb94" class="kr ks hh ir b is la iw lb ja lc je ld ji le jm kw kx ky kz bi translated">消费者失去兴趣(尤其是游戏)</li><li id="8c86" class="kr ks hh ir b is la iw lb ja lc je ld ji le jm kw kx ky kz bi translated">只是产品本身的性质</li></ul><p id="3d47" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">不可能总是识别和控制这些因素，但是跟踪和尝试理解导致客户流失的因素是很重要的。这可以为产品和整体业务战略提供信息，还可以优化客户获取和支持等流程。</p><blockquote class="lf lg lh"><p id="e3fd" class="ip iq li ir b is it iu iv iw ix iy iz lj jb jc jd lk jf jg jh ll jj jk jl jm ha bi translated"><strong class="ir hi">不过，我们不会进入这场辩论。我们之所以考虑这种特殊情况，是因为数据的数量和类型是我们想要执行的分析类型的绝佳候选。此外，它使我们能够探索不同的复杂工具和技术来完成这项工作。</strong></p></blockquote><p id="a913" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">出于这篇博客的目的，我们将纯粹从预测的角度分析点击流数据——根据用户的应用内行为，我们能多准确、多快地预测用户是否会流失。我们可以使用相同的设置来预测其他领域的任何类型的流失。</p><h1 id="c32f" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">数据捕获和设置交付基础设施</h1><p id="d53a" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">对于我们的用例，手机游戏集成了RudderStack的<a class="ae jn" href="https://github.com/rudderlabs/rudder-sdk-unity" rel="noopener ugc nofollow" target="_blank"> <strong class="ir hi"> Unity SDK </strong> </a>用于生成事件。这些事件然后被发送到RudderStack的开源数据平面，从那里它们被路由到Google BigQuery进行进一步分析。</p><p id="c306" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们将所有由RudderStack路由的事件存储在<strong class="ir hi"> BigQuery </strong>中的<strong class="ir hi"> track </strong>表中，并将整个JSON有效负载作为一列。此外，我们还为每种事件类型创建单独的表，以事件属性作为列。这很重要，因为通过这种方式，如果需要的话，我们可以访问整个事件，利用BigQuery对半结构化数据的出色支持。我们还可以通过基于事件时间划分数据来优化BigQuery的使用。这允许我们优化查询执行时间和成本。</p><p id="44b8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">下图演示了在BigQuery中创建的两个表示例，一个用于特定事件类型，另一个用于所有事件:</p><figure class="ln lo lp lq fd ii er es paragraph-image"><div class="er es lm"><img src="../Images/4d45bf0bf13f8fc440a2299faa000386.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/format:webp/0*zd7PiiPwrAUM1CsZ.png"/></div></figure><p id="8ca7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">左:特定事件类型的BigQuery表&lt; br &gt;右:所有事件的BigQuery表</strong></p><p id="0687" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如上所述，特定事件的表包含特定于该事件的属性，而第二个表包含与事件无关的信息。这两个表可以通过<code class="du lr ls lt lu b">id</code>字段链接。</p><p id="84e5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">RudderStack自动进行模式管理。它基于事件结构创建表模式，并在新字段添加到事件JSON或现有字段的数据类型发生变化时保持表模式更新。这种方法可以最大限度地利用数据仓库，而不必担心数据管道是否损坏。它还可以确保您的仓库始终是最新的。</p><h1 id="51e0" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">探索性数据分析和流失预测策略</h1><p id="d9fb" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">构建任何ML模型的第一步是围绕您正在处理的数据建立直觉。BigQuery非常适合这个目的，因为它允许您通过其控制台对数据运行任意查询，并快速浏览它们，而不必依赖复杂的外部工具。当然，如果需要更复杂的分析，可以将BigQuery实例连接到各种第三方工具。</p><p id="3dab" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为了定义客户流失率，我们使用下图——该图显示了首次付款和客户流失率之间的天数分布。虽然不可能知道是否有人真的发生了变动，但我们假设<strong class="ir hi">七天不活动</strong>是发生变动的标准。我们基于从游戏产品经理那里得到的反馈做出这个假设，同时考虑到这个特定行业对流失的更广泛理解。对于这个游戏(以及其他大部分游戏)，人们一般都很活跃，一天玩好几次。如果在某个时候他们离开游戏——虽然他们可能会回来——普遍的共识是，用户不活动的时间越长，他们回来的可能性就越小。考虑到这个因素，七天的不活动是用我们的数据调查客户流失的一个很好的起点。</p><figure class="ln lo lp lq fd ii er es paragraph-image"><div class="er es lv"><img src="../Images/6f7579965047a95b7a7e24e7bc30fad5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/0*ct2eA4OLRU6aZm2P.png"/></div></figure><p id="25e3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">客户首次付款和最后一次旋转之间的天数分布</strong></p><p id="f707" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">正如最初观察到的，绝大多数人在第一次付款后的几天内就离开了。</p><h1 id="546a" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">流失预测策略</h1><p id="2a1e" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">减少客户流失的最简单的方法是在几天不活动后发出要约或其他东西。然而，这种方法并不是最好的。如果我们选择太低的门槛，我们将给出太多的优惠。另一方面，如果我们等得太久，用户早就走了，甚至可能卸载了游戏。目标是以非常高的准确度预测某人是否会在之前<strong class="ir hi">流失。因此，问题是，我们如何通过整合准确的客户流失预测模型来优化这种方法？</strong></p><p id="9cc4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们将在本博客的其余部分尝试回答这个问题。我们将尝试预测某人是否会在付款后的三天内流失。这意味着，第一次购买/支付日期和最后一次登录事件日期之间的天数为<strong class="ir hi">三天或更少</strong>的人被标记为<strong class="ir hi">流失阳性</strong>。否则，它们被标记为<strong class="ir hi">流失阴性</strong>。目标是预测某人在付费的一天内是否是积极的——因为大多数用户那时仍然是活跃的，可以参与其中。</p><h1 id="e7bc" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">客户流失预测的特征工程</h1><p id="776d" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">经过初步的探索性分析后，是时候开始构建客户流失预测模型了。为此，需要定义一组用于训练模型的数据维度或特征。特征工程介于艺术和科学之间，因为需要对数据和商业案例的直觉。在我们的案例中，我们与游戏的产品经理进行了一次“面谈”,他了解数据和问题陈述。这允许我们为我们的任务选择一组定义良好的数据特征。</p><p id="7d75" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在与游戏产品经理交谈后，发现以下特征与预测客户流失相关:</p><ul class=""><li id="abfd" class="kr ks hh ir b is it iw ix ja kt je ku ji kv jm kw kx ky kz bi translated"><strong class="ir hi"> coin_balance: </strong>如果有人剩下很多硬币，他们更有可能继续玩游戏。</li><li id="fe63" class="kr ks hh ir b is la iw lb ja lc je ld ji le jm kw kx ky kz bi translated"><strong class="ir hi">total _ bet/total _ win/total _ spins:</strong>更活跃的人通常是更铁杆的玩家，因此不太可能流失。通过对用户所有“旋转”事件的数量/数目求和，可以确定下注/获胜或旋转的总数或计数</li><li id="3b1f" class="kr ks hh ir b is la iw lb ja lc je ld ji le jm kw kx ky kz bi translated"><strong class="ir hi"> number_of_distinct_games </strong>:和上面类似，玩游戏多的人更有可能留下来。</li><li id="d5fe" class="kr ks hh ir b is la iw lb ja lc je ld ji le jm kw kx ky kz bi translated">赢得随机累积奖金的人更有可能感觉积极，从而继续下去。</li><li id="133f" class="kr ks hh ir b is la iw lb ja lc je ld ji le jm kw kx ky kz bi translated"><strong class="ir hi">胜率(total_win/total_bet): </strong>和上面类似，赢的多的人不容易流失。</li><li id="0783" class="kr ks hh ir b is la iw lb ja lc je ld ji le jm kw kx ky kz bi translated"><strong class="ir hi"> signup_to_first_pay: </strong>注册后立即付费的人很可能是更铁杆的玩家，不太可能流失。花很长时间付款的人可能是业余爱好者，更有可能在付款后流失。</li></ul><h1 id="9fde" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">验证功能</h1><p id="0a36" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">为了验证这些特性的选择，我们执行了一些进一步的探索性数据分析。举例来说，下图显示了搅动器和非搅动器之间这些特征的分布。为此，我们比较了上面提到的一些功能，如总投注额、总旋转数、总赢款等。对于流失积极和流失消极的用户。</p><p id="9e99" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">很明显，搅拌者的行为与不搅拌者大相径庭。下面生成的图表仅针对其中一种情况，即<strong class="ir hi"> total_jackpot </strong>的数量以及流失和未流失人员之间的差异。</p><figure class="ln lo lp lq fd ii er es paragraph-image"><div class="er es lv"><img src="../Images/2285b97cd4e9e18729f23070e7ee6b53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/0*KMNR-si6yLFNiglx.png"/></div></figure><p id="31c5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">流失客户和非流失客户的特征分布</strong></p><p id="858a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这些特性图是通过SQL转储数据并使用matplotlib绘图生成的(尽管可以使用任何其他绘图解决方案)。</p><p id="83e9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一般来说，发现流失积极用户的值的范围与流失消极用户的值的范围相比在明显更窄的范围内变化。</p><h1 id="2b74" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">使用BigQueryML构建客户流失预测模型</h1><p id="9b1d" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">基于我们已经确定的特征，现在是时候建立客户流失预测模型了。我们将使用Google BigQuery来做到这一点。</p><h1 id="0867" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">步骤1:创建训练集</h1><p id="8490" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">第一步是通过生成所有要素并将它们合并到一个视图中来生成数据集。</p><p id="5de9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">计算特征需要以下步骤:</p><ul class=""><li id="141e" class="kr ks hh ir b is it iw ix ja kt je ku ji kv jm kw kx ky kz bi translated">查找特定于用户的事件日期。比如他们第一次报名的时间，第一次付款的时间，最后一天的活动等等。如上所述，RudderStack维护一个包含所有事件的跟踪表，因此映射这些活动实质上就是在<strong class="ir hi">跟踪</strong>表中查找特定事件发生的日期。<strong class="ir hi"> RANK() </strong>函数非常方便，它让我们将一个单调递增的数字<em class="li"> rank </em>与每个用户的每次事件关联起来。</li></ul><p id="332f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">查询如下所示:</p><pre class="ln lo lp lq fd lw lu lx ly aw lz bi"><span id="3660" class="ma jp hh lu b fi mb mc l md me">CREATE TABLE FIRST_REV_DATE_TABLE AS <br/>     SELECT<br/>     anonymous_id, rev_date as first_rev_date<br/> FROM<br/>     ( <br/>     SELECT anonymous_id,     <br/>         DATE_TRUNC('d', sent_at) as rev_date,<br/>         RANK() OVER (PARTITION by anonymous_id ORDER BY sent_at DESC) as rank,<br/>     FROM<br/>                RUDDER.track<br/>     WHERE<br/>               event=’revenue’         <br/>     )<br/> WHERE<br/>    rank = 1</span></pre><p id="d3ed" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">其他特定于日期的表，如<code class="du lr ls lt lu b">SIGNUP_DATE_TABLE</code>(第一次活动的日期)、<code class="du lr ls lt lu b">LAST_SPIN_DATE_TABLE</code>(用户的最后一次旋转)可以类似地计算。</p><ul class=""><li id="7bdc" class="kr ks hh ir b is it iw ix ja kt je ku ji kv jm kw kx ky kz bi translated">使用上面的数据表，可以计算出这些特征。例如，要找到注册和<code class="du lr ls lt lu b">first_rev</code>之间的旋转次数，必须加入<code class="du lr ls lt lu b">RUDDER.spin</code>、<code class="du lr ls lt lu b">SIGNUP_DATE_TABLE</code>和<code class="du lr ls lt lu b">LAST_SPIN_DATE_TABLE</code>。<code class="du lr ls lt lu b">RUDDER.spin</code> table是RudderStack创建的事件专用表。查询如下所示:</li></ul><pre class="ln lo lp lq fd lw lu lx ly aw lz bi"><span id="c6f5" class="ma jp hh lu b fi mb mc l md me">CREATE TABLE NUM_OF_SPINS AS <br/>SELECT anonymous_id<br/>     SUM(RUDDER.spin.no_of_spins) as no_of_spins<br/>FROM <br/>     SIGNUP_DATE_TABLE, <br/>     FIRST_REV_DATE_TABLE,<br/>     RUDDER.spin table<br/>WHERE<br/>     SIGNUP_DATE_TABLE.anonymous_id = RUDDER.spin_table.anonymous_id<br/>     AND SIGNUP_DATE_TABLE.anonymous_id = RUDDER.spin_table.anonymous_id<br/>     AND FIRST_REV_DATE.first_rev_date &gt;= RUDDER.spin_table.sent_at<br/>GROUP BY anonymous_id</span></pre><ul class=""><li id="d924" class="kr ks hh ir b is it iw ix ja kt je ku ji kv jm kw kx ky kz bi translated">下一步是计算标签列。如果<code class="du lr ls lt lu b">LAST_SPIN_DATE</code>和<code class="du lr ls lt lu b">FIRST_PAY_DATE</code>之间的差值为<strong class="ir hi"> &lt; = 3天</strong>和<strong class="ir hi"> 7天</strong>(流失阈值)，则用户已经流失了3天。这也是一个连接<code class="du lr ls lt lu b">FIRST_REV_DATE</code>和<code class="du lr ls lt lu b">LAST_SPIN_DATE</code>的简单SQL查询。这被添加为另一个表3_day_churn。</li><li id="d88e" class="kr ks hh ir b is la iw lb ja lc je ld ji le jm kw kx ky kz bi translated">最后，所有这些功能可以通过跨越<code class="du lr ls lt lu b">anonymous_id</code>合并成一个巨大的功能。</li></ul><h1 id="6887" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">步骤2:构建模型</h1><p id="e753" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">现在，通过选择和生成我们需要的所有数据特征，我们已经有了最终的数据集，是时候使用BigQuery ML直接从我们的数据仓库中构建模型了。BigQuery ML支持仅使用SQL构建机器学习模型。这大大简化了模型构建迭代和最终部署。</p><p id="a8c6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">目前，BigQuery ML仅支持一些基本模型，如逻辑和线性回归，但不支持NBD/帕累托(通常对流失最有效)。然而，这里的目标是展示如何在数据仓库中使用SQL快速构建和操作ML模型。</p><p id="8c07" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">以下查询显示了如何在BigQueryML中生成模型。</p><pre class="ln lo lp lq fd lw lu lx ly aw lz bi"><span id="06e2" class="ma jp hh lu b fi mb mc l md me">CREATE OR REPLACE MODEL `BigQueryMLModel</span><span id="b8e6" class="ma jp hh lu b fi mf mc l md me">OPTIONS (model_type='LOGISTIC_REG',auto_class_weights=TRUE,data_split_method='NO_SPLIT', input_label_cols=['within_3_days'],max_iterations = 15) </span><span id="c92e" class="ma jp hh lu b fi mf mc l md me">AS SELECT anonymous_id,first_spin_to_first_pay,total_jackpot,total_bet,total_win,total_spins, number_of_distinct_games, event_count,coin_balance,SUM_WIN_BY_BET, within_3_days</span><span id="571d" class="ma jp hh lu b fi mf mc l md me">FROM '3DAY_CHURN_MODEL_ALL_FEATURES'</span><span id="9471" class="ma jp hh lu b fi mf mc l md me">WHERE dataframe = 'training'</span></pre><p id="6659" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">上面的查询使用包含所有用户的所有特征值的表中的数据创建了一个<strong class="ir hi">逻辑回归</strong>模型。该模型自动分配类权重。我们指导训练过程不要将数据分成训练和测试数据集，因为在数据准备阶段已经完成了。此外，我们只选择用于训练的数据作为模型训练过程的输入。<strong class="ir hi">标签</strong>栏的名称也已经指定。根据用户是流失积极还是流失消极，列<code class="du lr ls lt lu b">within_3_days</code>被标记为真或假。还指定了训练迭代或步骤的最大数量。</p><p id="93b3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们运行以下查询来评估我们的模型:</p><pre class="ln lo lp lq fd lw lu lx ly aw lz bi"><span id="9e90" class="ma jp hh lu b fi mb mc l md me">SELECT * FROM ML.EVALUATE (MODEL `BigQueryMLModel`, <br/>   (SELECT Anonymous_id,first_spin_to_first_pay,total_jackpot,total_bet,total_win,total_spins, number_of_distinct_games, event_count,coin_balance,SUM_WIN_BY_BET, within_3_days<br/>    FROM `3DAY_CHURN_MODEL_ALL_FEATURES`<br/>    WHERE dataframe = 'test’<br/>    )<br/> )</span></pre><p id="66f6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">上述查询从包含所有用户的所有功能的数据中获取测试数据集，评估模型性能。基本上，模型将考虑所有其他特征来预测<code class="du lr ls lt lu b">within_3_days</code>列的值。然后，我们将预测值与实际值进行比较，以计算模型性能统计数据。</p><h1 id="8b6c" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">分析流失预测模型的性能</h1><p id="2656" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">我们获得了该模型的以下性能指标:</p><figure class="ln lo lp lq fd ii er es paragraph-image"><div class="er es lv"><img src="../Images/a7bd4b2100404bf8093a4090cf69e21b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/0*H2EjM7tyUNf2dL_I.png"/></div></figure><p id="f101" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">召回率对精确度的ROC曲线如下所示:</p><figure class="ln lo lp lq fd ii er es paragraph-image"><div class="er es lv"><img src="../Images/23115e0bbe2699ff69f34e97d86ee6b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/0*2bxvvHOxTx2eurMn.png"/></div></figure><p id="0b46" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当我们比较模型对用户的预测时，我们的期望是模型应该预测尽可能多的用户可能的流失。换句话说——模型应该能够正确地<strong class="ir hi"/><strong class="ir hi">召回</strong>相关用户的类。该模型实现了84%的召回率，这是值得称赞的。这是因为导出的特征和选择的算法本质上非常简单。</p><p id="dc23" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">重要的是，该模型能够识别实际上会流失的用户。同时，它不会错误地识别出不会流失的用户也很重要。这种错误的影响可能从浪费激励，从而降低投资回报率，到激怒用户。回到我们的用例，这意味着模型为测试数据集中的任一类预测的值应该在尽可能多的情况下与实际值相匹配。这个指标叫做<strong class="ir hi">精度</strong>，也比较高，接近86%。这是相当好的，再次考虑到我们的是一个非常简单的模型。</p><h1 id="cfa4" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">样本外测试</h1><p id="3e8d" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">除上述之外，我们还执行样本外测试。这实质上是对不属于训练或评估过程的记录进行预测。但是，我们知道这些数据的流失状态。换句话说，它是“看不见的”数据。这种情况下的预测准确性给出了模型在生产中表现如何的合理的好主意。</p><p id="3a29" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在我们的例子中，我们检查样本外测试的假阳性/假阴性率。我们将这些数字记录在表格中，如下所示:</p><figure class="ln lo lp lq fd ii er es paragraph-image"><div class="er es mg"><img src="../Images/82dce8456107948cbca6fa0b83e6dcd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:756/format:webp/0*CVQgtghpWCU5parL.png"/></div></figure><p id="77fe" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当一个模型进行预测时，它还会为它预测的每个类别关联一个正确的<strong class="ir hi">概率</strong>或<strong class="ir hi">置信度</strong>。对于0.1%或10%的阈值，以大于或等于10%的置信度预测为特定用户的类别-召回率为70%，假阳性率为10%。这意味着该模型正确地将实际产生了的<strong class="ir hi">用户中的<strong class="ir hi"> 70% </strong>识别为流失候选人。没有流失</strong>的用户<strong class="ir hi">中只有<strong class="ir hi"> 10% </strong>被<strong class="ir hi">错误地分类为流失候选。</strong></strong></p><h1 id="09cb" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">结论</h1><p id="5669" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">根据我们进行的模型构建练习，有几个关键的观察和收获:</p><ul class=""><li id="ecbe" class="kr ks hh ir b is it iw ix ja kt je ku ji kv jm kw kx ky kz bi translated">从性能指标来看，流失预测模型作为一个初始项目表现得相当不错。模型的输出应该让产品经理满意。因此，我们肯定可以通过在生产中部署该模型来运行各种活动。</li><li id="9590" class="kr ks hh ir b is la iw lb ja lc je ld ji le jm kw kx ky kz bi translated">更多的数据积累将需要定期刷新模型。</li><li id="8554" class="kr ks hh ir b is la iw lb ja lc je ld ji le jm kw kx ky kz bi translated">执行<strong class="ir hi">主成分分析</strong>可以产生更好的结果，而不是仅仅依靠领域知识进行特征选择。</li></ul><p id="f1c7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">除了上述观察结果，我们还可以研究支持更复杂的模型构建流程的替代分析平台，包括对<strong class="ir hi">自定义评估函数</strong>的支持。</p><h1 id="4320" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">免费注册并开始发送数据</h1><p id="5db8" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">测试我们的事件流、ELT和反向ETL管道。使用我们的HTTP源在不到5分钟的时间内发送数据，或者在您的网站或应用程序中安装我们12个SDK中的一个。<a class="ae jn" href="https://app.rudderlabs.com/signup?type=freetrial" rel="noopener ugc nofollow" target="_blank">入门</a>。</p><p id="065a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">本博客原载于</strong><a class="ae jn" href="https://rudderstack.com/blog/churn-prediction-using-bigqueryml" rel="noopener ugc nofollow" target="_blank"><strong class="ir hi">https://rudder stack . com/blog/churn-prediction-using-bigqueryml</strong></a><strong class="ir hi">。</strong></p></div></div>    
</body>
</html>