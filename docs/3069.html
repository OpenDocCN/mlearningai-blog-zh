<html>
<head>
<title>Do Data Scientists Need to Learn CICD? Gitlab Python Code on AWS ECS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据科学家需要学习CICD吗？AWS ECS上的Gitlab Python代码</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/do-data-scientists-need-to-learn-cicd-gitlab-python-code-on-aws-ecs-be4cf97db375?source=collection_archive---------9-----------------------#2022-07-15">https://medium.com/mlearning-ai/do-data-scientists-need-to-learn-cicd-gitlab-python-code-on-aws-ecs-be4cf97db375?source=collection_archive---------9-----------------------#2022-07-15</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="7ac4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi jc translated"><span class="l jd je jf bm jg jh ji jj jk di"> F </span>继<a class="ae jl" rel="noopener" href="/@peiyuan67/do-data-scientists-need-to-learn-cicd-gitlab-python-code-on-aws-serverless-lambda-service-13a11f5df4a0">一节最后一条之后<strong class="ig hi">数据科学家需要学习CICD吗？AWS无服务器Lambda服务</strong> </a>上的Gitlab Python代码，这篇文章关注的是在将机器学习模型部署到服务时非常常见的容器化技术。我们将使用AWS ECS(弹性容器服务)来运行我们的docker映像。我们在ECS上运行docker映像的原因包括:</p><ul class=""><li id="bd24" class="jm jn hh ig b ih ii il im ip jo it jp ix jq jb jr js jt ju bi translated">可扩展性:其集群服务支持可扩展的计算资源。</li><li id="6563" class="jm jn hh ig b ih jv il jw ip jx it jy ix jz jb jr js jt ju bi translated">兼容性:容器管理可以清楚地定义我们的运行环境。</li></ul><figure class="kb kc kd ke fd kf er es paragraph-image"><div role="button" tabindex="0" class="kg kh di ki bf kj"><div class="er es ka"><img src="../Images/d3715bdb6ff54cb61e10e1469c80c6c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bUebnlGS7NQdoGNn"/></div></div><figcaption class="km kn et er es ko kp bd b be z dx">Photo by <a class="ae jl" href="https://unsplash.com/@ianjbattaglia?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ian Battaglia</a> on <a class="ae jl" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure></div><div class="ab cl kq kr go ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="ha hb hc hd he"><p id="1fb0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在ECS上运行docker映像的架构如下，我们将其分为4个主要步骤:</p><ul class=""><li id="bb7a" class="jm jn hh ig b ih ii il im ip jo it jp ix jq jb jr js jt ju bi translated"><strong class="ig hi">第一步。编写一个应用程序——Python Flask</strong>:为我们的应用程序构建大脑</li><li id="756c" class="jm jn hh ig b ih jv il jw ip jx it jy ix jz jb jr js jt ju bi translated"><strong class="ig hi">第二步。构建Docker映像并将其推送到ECR </strong>:为我们的应用程序构建运行环境</li><li id="a41c" class="jm jn hh ig b ih jv il jw ip jx it jy ix jz jb jr js jt ju bi translated"><strong class="ig hi">第三步。设置ECS </strong>:让我们的应用程序运行</li><li id="1990" class="jm jn hh ig b ih jv il jw ip jx it jy ix jz jb jr js jt ju bi translated"><strong class="ig hi">第四步。定义。gitlab-ci.yml运行CICD </strong>:自动更新一切</li></ul><figure class="kb kc kd ke fd kf er es paragraph-image"><div role="button" tabindex="0" class="kg kh di ki bf kj"><div class="er es kx"><img src="../Images/56eb7890febbe4e3a1c3cc5bbe233a48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kn0iHnOirl8ZRrS9FRDHVw.png"/></div></div><figcaption class="km kn et er es ko kp bd b be z dx">CICD Workflow</figcaption></figure><h2 id="4d70" class="ky kz hh bd la lb lc ld le lf lg lh li ip lj lk ll it lm ln lo ix lp lq lr ls bi translated">第一步。编写一个应用程序— Python Flask</h2><p id="6969" class="pw-post-body-paragraph ie if hh ig b ih lt ij ik il lu in io ip lv ir is it lw iv iw ix lx iz ja jb ha bi translated">这是我们运行机器学习模型服务的地方，例如在大多数情况下运行模型推理。为了简单起见，我们在这里使用一个flask应用程序(application.py)作为例子。</p><pre class="kb kc kd ke fd ly lz ma mb aw mc bi"><span id="48ac" class="ky kz hh lz b fi md me l mf mg">from flask import Flask<br/>from flask import render_template</span><span id="7676" class="ky kz hh lz b fi mh me l mf mg">application = Flask(__name__)</span><span id="ac76" class="ky kz hh lz b fi mh me l mf mg"><a class="ae jl" href="http://twitter.com/application" rel="noopener ugc nofollow" target="_blank">@application</a>.route('/')<br/>def hello_world():<br/>    return render_template('run_ml_model_inference.html')</span><span id="bebc" class="ky kz hh lz b fi mh me l mf mg">if __name__ == '__main__':<br/>    application.run(host='0.0.0.0')</span></pre><h2 id="468b" class="ky kz hh bd la lb lc ld le lf lg lh li ip lj lk ll it lm ln lo ix lp lq lr ls bi translated">第二步。构建一个Docker映像并将其推送到ECR</h2><p id="a7ba" class="pw-post-body-paragraph ie if hh ig b ih lt ij ik il lu in io ip lv ir is it lw iv iw ix lx iz ja jb ha bi translated">这里，我们需要完成三个小步骤来为我们的应用程序构建一个在ECS上运行的环境。</p><p id="0859" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> 2.1在ECR上创建一个存储库</strong></p><p id="194f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">ECR是一项AWS服务，我们在其中存储我们的docker图像。就像我们在Github上做的一样，我们在ECR上构建一个存储库来保存我们的docker映像并跟踪它的版本。我们通过使用<a class="ae jl" href="https://pypi.org/project/awscli/" rel="noopener ugc nofollow" target="_blank"> aws-cli </a> python包来完成这一步。记住授权IAM用户凭证有权访问ECR。(为简单起见，出于测试目的，附加管理员访问权限。)</p><pre class="kb kc kd ke fd ly lz ma mb aw mc bi"><span id="5d78" class="ky kz hh lz b fi md me l mf mg"># log in to aws ecr service<br/><strong class="lz hi">aws ecr</strong> get-login-password --region us-east-1 | docker login --username AWS --password-stdin <strong class="lz hi">{aws_account_id}</strong>.dkr.ecr.us-east-1.amazonaws.com</span><span id="d7d9" class="ky kz hh lz b fi mh me l mf mg"># create an ecr repository<br/><strong class="lz hi">aws ecr</strong> create-repository --repository-name <strong class="lz hi">mlapp</strong> --region us-east-1</span></pre><p id="1b61" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> 2.2编写Dockerfile </strong></p><p id="25f0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">知道了在哪里可以保存我们的docker形象，是时候建立我们的docker形象了。我们在Dockerfile中定义环境。但是在编写Dockerifle之前，让我们首先定义python requirements.txt，以包含运行机器学习应用程序所需的任何包。在这种情况下，我们只需要烧瓶。因此，在requirements.txt中，添加flask。</p><pre class="kb kc kd ke fd ly lz ma mb aw mc bi"><span id="f7a5" class="ky kz hh lz b fi md me l mf mg">flask</span></pre><p id="f15e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Dockerfile如下:</p><pre class="kb kc kd ke fd ly lz ma mb aw mc bi"><span id="51f2" class="ky kz hh lz b fi md me l mf mg"># define base image: the current image has installed python 3<br/>FROM python:3</span><span id="173c" class="ky kz hh lz b fi mh me l mf mg"># define container working directory: we start our under this directory<br/>WORKDIR /usr/src/app</span><span id="3309" class="ky kz hh lz b fi mh me l mf mg"># copy our requirements.txt to container WORKDIR and then install required pacakges<br/>COPY ./requirements.txt ./<br/>RUN apt-get -y update<br/>RUN pip install --no-cache-dir -r requirements.txt</span><span id="619e" class="ky kz hh lz b fi mh me l mf mg">COPY . .</span><span id="1684" class="ky kz hh lz b fi mh me l mf mg"># define the entrypoint of container and run the commands (to run a python file, we need to set an entry point of python): python applications.py<br/>ENTRYPOINT [ "python" ]<br/>CMD ["application.py"]</span></pre><p id="089d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> 2.3构建映像并将其推送到ECR </strong></p><p id="16a0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一旦定义了Dockerfile，我们就构建一个docker映像，并将其推送到我们在步骤2.1中构建的ECR。</p><pre class="kb kc kd ke fd ly lz ma mb aw mc bi"><span id="95a1" class="ky kz hh lz b fi md me l mf mg"># build an image<br/><strong class="lz hi">docker build</strong> <!-- -->-t local/mlapp <!-- -->.</span><span id="3c93" class="ky kz hh lz b fi mh me l mf mg"># rename the image so that it is same as the repository on ECR<br/><strong class="lz hi">docker tag</strong> local/mlapp <strong class="lz hi">{aws_account_id}</strong>.dkr.ecr.us-east-1.amazonaws.com/mlapp</span><span id="c72b" class="ky kz hh lz b fi mh me l mf mg"># push the docker image to ECR repository<br/><strong class="lz hi">docker push</strong> <strong class="lz hi">{aws_account_id}</strong>.dkr.ecr.us-east-1.amazonaws.com/mlapp</span></pre><h2 id="b355" class="ky kz hh bd la lb lc ld le lf lg lh li ip lj lk ll it lm ln lo ix lp lq lr ls bi translated">第三步。设置ECS</h2><p id="e32e" class="pw-post-body-paragraph ie if hh ig b ih lt ij ik il lu in io ip lv ir is it lw iv iw ix lx iz ja jb ha bi translated">好吧，我们在旅程的中间。我们有六个小步骤来完成第三步。</p><p id="ec9b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> 3.1安装ECS CLI </strong></p><p id="84f0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">按照以下链接安装ecs-cli。这样，我们就可以利用设置ECS服务的优势。</p><div class="mi mj ez fb mk ml"><a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ECS_CLI_installation.html" rel="noopener  ugc nofollow" target="_blank"><div class="mm ab dw"><div class="mn ab mo cl cj mp"><h2 class="bd hi fi z dy mq ea eb mr ed ef hg bi translated">安装Amazon ECS CLI</h2><div class="ms l"><h3 class="bd b fi z dy mq ea eb mr ed ef dx translated">Amazon ECS发布了AWS Copilot，这是一个命令行界面(CLI)工具，可以简化构建、发布和…</h3></div><div class="mt l"><p class="bd b fp z dy mq ea eb mr ed ef dx translated">docs.aws.amazon.com</p></div></div><div class="mu l"><div class="mv l mw mx my mu mz kk ml"/></div></div></a></div><p id="7dc1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> 3.2配置ECS </strong></p><p id="8331" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">从AWS IAM用户处获得凭证(AWS _ ACCESS _ KEY _ ID &amp; AWS _ SECRET _ ACCESS _ KEY)后，我们将其设置为环境变量。接下来，使用<em class="na"> ecs-cli配置文件</em>授权我们的ecs-cli命令使用AWS服务。然后，使用<em class="na"> ecs-cli configure </em>，定义集群的名称、启动计算资源的机制、服务运行的区域及其配置名称。关于launch type中的<em class="na"> FARGATE </em>，它是一个运行我们的应用程序的无服务器服务，这与使用EC2相反。</p><pre class="kb kc kd ke fd ly lz ma mb aw mc bi"><span id="10dd" class="ky kz hh lz b fi md me l mf mg">export AWS_ACCESS_KEY_ID="xxx"<br/>export AWS_SECRET_ACCESS_KEY="xxx"</span><span id="f71f" class="ky kz hh lz b fi mh me l mf mg"><strong class="lz hi">ecs-cli configure</strong> <strong class="lz hi">profile</strong> --profile-name aws_ecs_cli_profile_name --access-key $AWS_ACCESS_KEY_ID --secret-key $AWS_SECRET_ACCESS_KEY</span><span id="254b" class="ky kz hh lz b fi mh me l mf mg"><strong class="lz hi">ecs-cli configure</strong> --cluster MLCluster --default-launch-type FARGATE --region us-east-1 --config-name MLConfigName</span></pre><p id="9596" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> 3.3为ECS创建IAM角色</strong></p><p id="9f80" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当一个AWS服务需要访问另一个AWS服务时，需要IAM角色。让我们使用ecs-trust-policy.json来创建一个角色。</p><pre class="kb kc kd ke fd ly lz ma mb aw mc bi"><span id="8062" class="ky kz hh lz b fi md me l mf mg">{<br/>    "Version": "2012-10-17",<br/>    "Statement": [<br/>        {<br/>            "Effect": "Allow",<br/>            "Principal": {<br/>                "Service": "ecs-tasks.amazonaws.com"<br/>            },<br/>            "Action": "sts:AssumeRole"<br/>        }<br/>    ]<br/>}</span></pre><p id="e556" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">创建一个IAM角色并附加另一个策略来授权ECS。</p><pre class="kb kc kd ke fd ly lz ma mb aw mc bi"><span id="c8f2" class="ky kz hh lz b fi md me l mf mg"><strong class="lz hi">aws iam create-role</strong> \<br/>--role-name <strong class="lz hi">ecsMLTaskExecutionRole</strong> \<br/>--assume-role-policy-document <strong class="lz hi">file://ecs-trust-policy.json</strong></span><span id="e99f" class="ky kz hh lz b fi mh me l mf mg"><strong class="lz hi">aws iam</strong> <strong class="lz hi">attach-role-policy</strong> \<br/>--role-name ecsMLTaskExecutionRole \<br/>--policy-arn arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy</span></pre><p id="add8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> 3.4创建一个ECS集群</strong></p><p id="bff3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">是时候创建ECS集群了。请保留VPC和子网信息，因为我们稍后会用到它们。</p><pre class="kb kc kd ke fd ly lz ma mb aw mc bi"><span id="9b11" class="ky kz hh lz b fi md me l mf mg"><strong class="lz hi">ecs-cli up</strong> \<br/>--cluster MLCluster \<br/>--region us-east-1 \<br/>--launch-type FARGATE</span><span id="f8e3" class="ky kz hh lz b fi mh me l mf mg">output:<br/>VPC created: <strong class="lz hi">vpc-123456789</strong><br/>Subnet created: <strong class="lz hi">subnet-xxxx1</strong><br/>Subnet created: <strong class="lz hi">subnet-xxxx2</strong><br/>Cluster creation succeeded.</span></pre><p id="cbb6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> 3.5根据步骤1，更改安全组入口规则</strong></p><p id="3240" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">出于安全原因，我们只公开运行应用程序所需的端口。通过填充步骤3.4中的VPC值，我们得到了安全组值(GroupId)。</p><pre class="kb kc kd ke fd ly lz ma mb aw mc bi"><span id="958d" class="ky kz hh lz b fi md me l mf mg"><strong class="lz hi">aws ec2 describe-security-groups</strong> \<br/>--filters Name=vpc-id,Values=<strong class="lz hi">vpc-123456789</strong> \<br/>--region us-east-1</span><span id="cfe7" class="ky kz hh lz b fi mh me l mf mg">output:<br/>“GroupId”: “<strong class="lz hi">sg-123</strong>”,<br/>“UserId”: “xxxxxxxx”</span></pre><p id="1558" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后，我们授权公众访问我们的端口5000，这是我们运行flask应用程序的地方。</p><pre class="kb kc kd ke fd ly lz ma mb aw mc bi"><span id="d133" class="ky kz hh lz b fi md me l mf mg"><strong class="lz hi">aws ec2 authorize-security-group-ingress</strong> \<br/>--group-id <strong class="lz hi">sg-123</strong> \<br/>--protocol tcp \<br/><strong class="lz hi">--port 5000 \<br/>--cidr 0.0.0.0/0 \<br/></strong>--region us-east-1</span></pre><p id="fc92" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">3.6</strong>T16】运行服务</p><p id="2c74" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最后一小步是开始在ECS上运行服务。这里要定义两个文件:</p><ol class=""><li id="b889" class="jm jn hh ig b ih ii il im ip jo it jp ix jq jb nb js jt ju bi translated"><strong class="ig hi"> docker-compose.yml: </strong></li></ol><ul class=""><li id="9a9d" class="jm jn hh ig b ih ii il im ip jo it jp ix jq jb jr js jt ju bi translated">图像是我们在步骤2中在ECR上创建的图像。</li><li id="c158" class="jm jn hh ig b ih jv il jw ip jx it jy ix jz jb jr js jt ju bi translated">端口意味着容器端口5000连接到ECS端口5000。还记得我们在步骤3.5中刚刚授权公众访问的端口吗？那是端口5000。</li></ul><pre class="kb kc kd ke fd ly lz ma mb aw mc bi"><span id="cfc4" class="ky kz hh lz b fi md me l mf mg">version: "3"<br/>services:<br/>    web:<br/>        image: <strong class="lz hi">{aws_account_id}</strong>.dkr.ecr.us-east-1.amazonaws.com/mlapp:latest<br/>        ports:<br/>            - 5000:5000</span></pre><p id="82e9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> 2。ecs-params.yml </strong></p><ul class=""><li id="6bd0" class="jm jn hh ig b ih ii il im ip jo it jp ix jq jb jr js jt ju bi translated">对于task_execution_role，为其分配我们创建的IAM角色。</li><li id="ee9b" class="jm jn hh ig b ih jv il jw ip jx it jy ix jz jb jr js jt ju bi translated">根据我们在步骤3.4和3.5中创建的内容替换子网和安全组。</li></ul><pre class="kb kc kd ke fd ly lz ma mb aw mc bi"><span id="e988" class="ky kz hh lz b fi md me l mf mg">version: 1<br/>task_definition:<br/>  task_execution_role: <strong class="lz hi">ecsMLTaskExecutionRole</strong><br/>  ecs_network_mode: awsvpc<br/>  task_size:<br/>    mem_limit: 0.5GB<br/>    cpu_limit: 256<br/>run_params:<br/>  network_configuration:<br/>    awsvpc_configuration:<br/>      subnets:<br/>        - "<strong class="lz hi">subnet-xxxx1</strong>"<br/>        - "<strong class="lz hi">subnet-xxxx2</strong>"<br/>      security_groups:<br/>        - "<strong class="lz hi">sg-123</strong>"<br/>      assign_public_ip: ENABLED</span></pre><p id="d3fc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">完成docker-compose.yml和ecs-params.yml的定义后，让我们启动服务来运行我们的应用程序。</p><pre class="kb kc kd ke fd ly lz ma mb aw mc bi"><span id="8946" class="ky kz hh lz b fi md me l mf mg"><strong class="lz hi">ecs-cli compose</strong> \<br/>--project-name MLService \<br/>--cluster MLCluster \<br/>service up \<br/>--launch-type FARGATE \<br/>--timeout 6.5</span></pre><h2 id="621d" class="ky kz hh bd la lb lc ld le lf lg lh li ip lj lk ll it lm ln lo ix lp lq lr ls bi translated">第四步。定义。gitlab-ci.yml运行CICD</h2><p id="0ca7" class="pw-post-body-paragraph ie if hh ig b ih lt ij ik il lu in io ip lv ir is it lw iv iw ix lx iz ja jb ha bi translated">为了自动更新我们的应用程序，我们必须定义。gitlab-ci.yml，这样下次我们向应用程序推送新的更改时，Gitlab runner可以帮助我们构建和映像，将其推送到ECR并更新ECS服务。</p><pre class="kb kc kd ke fd ly lz ma mb aw mc bi"><span id="8430" class="ky kz hh lz b fi md me l mf mg">docker-build-master:<br/>  image: <strong class="lz hi">docker:latest</strong><br/>  stage: build<br/>  services:<br/>    - docker:dind<br/>  before_script:<br/>    - <strong class="lz hi">apk add py3-pip</strong><br/>    - <strong class="lz hi">pip install awscli</strong><br/>  script:<br/>    - aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin {aws_account_id}.dkr.ecr.us-east-1.amazonaws.com<br/>    - <strong class="lz hi">docker build -t</strong> $CI_REGISTRY_IMAGE .<br/>    - <strong class="lz hi">docker push</strong> "$CI_REGISTRY_IMAGE"<br/>    - <strong class="lz hi">aws ecs update-service</strong> --cluster MLCluster --service MLService --force-new-deployment<br/>  only:<br/>    - master</span></pre><p id="cfe6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在终端中，通过键入以下内容，我们可以获得访问服务的IP地址。例如，我们可以在54.211.152.253:5000看到我们的Flask网页。因为我们在这个架构中没有使用弹性IP，所以每次我们更新服务时，IP地址都会改变。</p><pre class="kb kc kd ke fd ly lz ma mb aw mc bi"><span id="06d9" class="ky kz hh lz b fi md me l mf mg">ecs-cli ps — cluster MLCluster</span></pre><figure class="kb kc kd ke fd kf er es paragraph-image"><div role="button" tabindex="0" class="kg kh di ki bf kj"><div class="er es nc"><img src="../Images/5762a1351917e79a1e39e79d35e985c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sQuzcR62XDVfTsIx5rW45Q.png"/></div></div></figure><p id="cf9e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">通过在浏览器中搜索链接，可以看到下面的页面。</p><figure class="kb kc kd ke fd kf er es paragraph-image"><div class="er es nd"><img src="../Images/cf6126f95de735788adfe22c88b9b44a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/format:webp/1*bdZtJ4q2NdeCdBxeIi8D5g.png"/></div></figure><p id="a9e7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">实现这个架构的示例代码可以在Github上的<a class="ae jl" href="https://gitlab.com/chrissmart/ecs-ci-cd" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><div class="mi mj ez fb mk ml"><a rel="noopener follow" target="_blank" href="/mlearning-ai/mlearning-ai-submission-suggestions-b51e2b130bfb"><div class="mm ab dw"><div class="mn ab mo cl cj mp"><h2 class="bd hi fi z dy mq ea eb mr ed ef hg bi translated">Mlearning.ai提交建议</h2><div class="ms l"><h3 class="bd b fi z dy mq ea eb mr ed ef dx translated">如何成为Mlearning.ai上的作家</h3></div><div class="mt l"><p class="bd b fp z dy mq ea eb mr ed ef dx translated">medium.com</p></div></div><div class="mu l"><div class="ne l mw mx my mu mz kk ml"/></div></div></a></div></div></div>    
</body>
</html>