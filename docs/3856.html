<html>
<head>
<title>Support Vector Machines From Scratch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从头开始支持向量机</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/support-vector-machines-16241417ee6d?source=collection_archive---------6-----------------------#2022-10-31">https://medium.com/mlearning-ai/support-vector-machines-16241417ee6d?source=collection_archive---------6-----------------------#2022-10-31</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="54bd" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">使用感知器算法</h2></div><p id="5624" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在这篇文章中，你将学习如何实现一个简单的算法来从头开始求解SVM。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es jt"><img src="../Images/fd68096b33fac90c04eafdbf38fe54ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*wavqZEbWpFpagjrpM5D5XQ.gif"/></div><figcaption class="kb kc et er es kd ke bd b be z dx">Perceptron algorithm for solving SVM</figcaption></figure><h2 id="c763" class="kf kg hh bd kh ki kj kk kl km kn ko kp jf kq kr ks jj kt ku kv jn kw kx ky kz bi translated">Tldr支持向量机</h2><p id="a175" class="pw-post-body-paragraph iw ix hh iy b iz la ii jb jc lb il je jf lc jh ji jj ld jl jm jn le jp jq jr ha bi translated">目标是找到分隔班级的最宽街道。街道由3条线定义:</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es jt"><img src="../Images/f2c0869bb75afde803d1537b6c38e18a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*Xv_6nq1vwbXPOzJyCsMVzw.png"/></div></figure><p id="af94" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在这个例子中，我们有两个类(<strong class="iy hi">蓝色= +1 </strong>和<strong class="iy hi">绿色= -1 </strong>)。红线是决策边界——使用上述SVM方法对未知点<strong class="iy hi"> u </strong>进行分类:</p><ul class=""><li id="6221" class="lf lg hh iy b iz ja jc jd jf lh jj li jn lj jr lk ll lm ln bi translated"><strong class="iy hi"> w^T u + b ≥ 0 </strong>然后<strong class="iy hi">蓝色</strong></li><li id="7a54" class="lf lg hh iy b iz lo jc lp jf lq jj lr jn ls jr lk ll lm ln bi translated"><strong class="iy hi"> w^T u + b &lt; 0 </strong>然后<strong class="iy hi">绿色</strong></li></ul><p id="982e" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这条街的宽度是</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="er es lt"><img src="../Images/c969f13b123cedf9ecd26e443c08fd23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*16HSSuO7ELpial_f.png"/></div></div></figure><p id="e199" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这意味着街道的宽度与w的大小成反比。</p><div class="ju jv jw jx fd ab cb"><figure class="ly jy lz ma mb mc md paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><img src="../Images/e7893677a66f28878e68322e5280f33d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*onJdMfs2N0Zg-UiiA92wAw.png"/></div></figure><figure class="ly jy lz ma mb mc md paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><img src="../Images/d22f4d62003854347b399ea669d2b69e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*AKh0ZcT9KMSsZwAJ9GXc5w.png"/></div></figure></div><p id="c98a" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">因此，找到最宽的街道意味着我们想要找到一条尽可能小的街道来分隔各个阶层。</p><h2 id="7296" class="kf kg hh bd kh ki kj kk kl km kn ko kp jf kq kr ks jj kt ku kv jn kw kx ky kz bi translated">膨胀/收缩率</h2><p id="7365" class="pw-post-body-paragraph iw ix hh iy b iz la ii jb jc lb il je jf lc jh ji jj ld jl jm jn le jp jq jr ha bi translated">请注意，将<strong class="iy hi"> w </strong>和<strong class="iy hi"> b </strong>乘以相同的常数<strong class="iy hi"> c </strong>不会改变决策边界，但会改变街道的宽度。如果:</p><ul class=""><li id="e055" class="lf lg hh iy b iz ja jc jd jf lh jj li jn lj jr lk ll lm ln bi translated"><strong class="iy hi"> 0 &lt; c &lt; 1 </strong>宽度将<strong class="iy hi">扩大</strong></li><li id="0e5b" class="lf lg hh iy b iz lo jc lp jf lq jj lr jn ls jr lk ll lm ln bi translated"><strong class="iy hi"> c &gt; 1 </strong>宽度将<strong class="iy hi">缩回</strong></li></ul><p id="a277" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">假设我们有一个线性可分的数据集，我们将施加约束，即没有数据点位于街道上。这意味着，如果我们找到一条线来分隔我们的阶级，但有些点位于街道上，我们应该使街道变得更窄。而如果我们发现有一条街把我们的阶级分开，而他们都不在这条街上，我们就应该扩大这条街。</p><p id="9cb0" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">理想情况下，一些特殊点(称为支持向量)正好位于街道边缘。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es jt"><img src="../Images/ba2636cae68736edddc4470d46ef9ade.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*aWepgTJEebypyQY3qw_mpg.png"/></div></figure><h2 id="5135" class="kf kg hh bd kh ki kj kk kl km kn ko kp jf kq kr ks jj kt ku kv jn kw kx ky kz bi translated">感知器算法</h2><p id="064f" class="pw-post-body-paragraph iw ix hh iy b iz la ii jb jc lb il je jf lc jh ji jj ld jl jm jn le jp jq jr ha bi translated">如果当前的<strong class="iy hi"> w </strong>和<strong class="iy hi"> b </strong>导致我们数据集中随机点<strong class="iy hi"> x </strong>的错误分类，我们可以将线向<strong class="iy hi"> x </strong>移动一定量lr，如下所示:</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="er es me"><img src="../Images/3c863c03102bd88526543ae8cba18f78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*cPurzoCVVgsx9-JK.png"/></div></div></figure><p id="79aa" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果那个点<strong class="iy hi"> x </strong>在街道上，我们可能想要收回街道。如果该点不在街道上或分类正确，我们可能需要扩展它。</p><h2 id="a7ea" class="kf kg hh bd kh ki kj kk kl km kn ko kp jf kq kr ks jj kt ku kv jn kw kx ky kz bi translated">把所有的放在一起</h2><p id="e715" class="pw-post-body-paragraph iw ix hh iy b iz la ii jb jc lb il je jf lc jh ji jj ld jl jm jn le jp jq jr ha bi translated">从一个随机的<strong class="iy hi"> w </strong>和<strong class="iy hi"> b </strong>开始(注意:w<strong class="iy hi">w</strong>和<strong class="iy hi"> b </strong>的初始值对通过这个过程学习什么线影响很大)。</p><pre class="ju jv jw jx fd mf mg mh mi aw mj bi"><span id="3657" class="kf kg hh mg b fi mk ml l mm mn">epochs = 100<br/>lr = .05<br/>expanding_rate = .99<br/>retracting_rate = 1.01</span><span id="013d" class="kf kg hh mg b fi mo ml l mm mn">for _ in range(epochs):<br/>    # pick a point from X at random<br/>    i = np.random.randint(0, len(X))<br/>    x, y = X[i], Y[i]<br/>    ypred = w[0] * x[0] + w[1] * x[1] + b<br/>    if (ypred &gt; 0 and y &gt; 0) or (ypred &lt; 0 and y &lt; 0):<br/>        # classified correctly<br/>        if ypred &lt; 1 and ypred &gt; -1:<br/>            # in the street / street is too wide<br/>            w = w + x * y * lr * retracting_rate<br/>            b = b + y * lr * retracting_rate<br/>        else:<br/>            # street is too narrow<br/>            w = w * expanding_rate<br/>            b = b * expanding_rate<br/>    else:<br/>        # misclassified<br/>        w = w + x * y * lr * expanding_rate<br/>        b = b + y * lr * expanding_rate</span></pre><p id="4c5b" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">用红色<strong class="iy hi">圈起来的</strong>是被错误分类的点。用黄色<strong class="iy hi">圈起来的</strong>是被正确分类的点。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es jt"><img src="../Images/fd68096b33fac90c04eafdbf38fe54ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*wavqZEbWpFpagjrpM5D5XQ.gif"/></div><figcaption class="kb kc et er es kd ke bd b be z dx">Perceptron algorithm for solving SVM</figcaption></figure><h2 id="876f" class="kf kg hh bd kh ki kj kk kl km kn ko kp jf kq kr ks jj kt ku kv jn kw kx ky kz bi translated">如果数据不是线性可分的呢</h2><p id="1f44" class="pw-post-body-paragraph iw ix hh iy b iz la ii jb jc lb il je jf lc jh ji jj ld jl jm jn le jp jq jr ha bi translated">再看一遍问题陈述——我们希望在数据集中的点不能位于街道的约束下，最大化街道的宽度。数学上，我们希望找到:</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es mp"><img src="../Images/8785f54154a80648d4274146f4ea15ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:716/0*Br1SFKJa_-F4Kz0R"/></div></figure><p id="ad51" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">根据:</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es mq"><img src="../Images/cfcfe88d347a5c03bc7dcf6e730ae1e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:576/0*YoAogFLnC6UWEGu9"/></div></figure><p id="9cb3" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这相当于最大限度地减少:</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="er es mr"><img src="../Images/83db57a5fa7483c6c74f92779903bc9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TJl6ZMz_BdYdzzrx"/></div></div></figure><p id="c44e" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">取导数wrt<strong class="iy hi">w</strong>:</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es ms"><img src="../Images/d28cd2e859a23d64b19f9284ed929530.png" data-original-src="https://miro.medium.com/v2/resize:fit:1052/0*nrlzKjgOC3HdfSNy"/></div></figure><p id="538c" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">因此，决策边界可以重写为:</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="er es mt"><img src="../Images/3e6295f58b76b15017796c83bcda704d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*EpKAEdqdRr-av7rW.png"/></div></div></figure><p id="fd84" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">更新<strong class="iy hi"> w </strong>意味着更新<strong class="iy hi"> α。</strong></p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="er es me"><img src="../Images/c763729b2684667297e59cfd398b518d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*yEEWsh03XQz_5BtV.png"/></div></div></figure><p id="31ed" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">因此，我们可以这样重写上面的算法:</p><pre class="ju jv jw jx fd mf mg mh mi aw mj bi"><span id="a31d" class="kf kg hh mg b fi mk ml l mm mn">epochs = 100<br/>lr = .05<br/>expanding_rate = .99<br/>retracting_rate = 1.01</span><span id="67a0" class="kf kg hh mg b fi mo ml l mm mn">def <strong class="mg hi">predict</strong>(alpha_i, b, x):<br/>    wx = 0<br/>    for j in range(len(X)):<br/>        wx += alpha_i[j] * np.dot(X[j], x)<br/>    return wx + b</span><span id="dab3" class="kf kg hh mg b fi mo ml l mm mn">for _ in range(epochs):<br/>    # pick a point from X at random<br/>    i = np.random.randint(0, len(X))<br/>    x, y = X[i], Y[i]<br/>    ypred = <strong class="mg hi">predict</strong>(alpha_i, b, x)<br/>    if (ypred &gt; 0 and y &gt; 0) or (ypred &lt; 0 and y &lt; 0):<br/>        # classified correctly<br/>        if ypred &lt; 1 and ypred &gt; -1:<br/>            # in the street / street is too wide<br/>            alpha_i[i] += y * lr<br/>            alpha_i = alpha_i * retracting_rate           <br/>            b += y * lr * retracting_rate<br/>        else:<br/>            # street is too narrow<br/>            alpha_i = alpha_i * expanding_rate<br/>            b *= expanding_rate<br/>    else:<br/>        # misclassified<br/>        alpha_i[i] += y * lr<br/>        alpha_i = alpha_i * expanding_rate<br/>        b += y * lr * expanding_rate</span></pre><h2 id="a93c" class="kf kg hh bd kh ki kj kk kl km kn ko kp jf kq kr ks jj kt ku kv jn kw kx ky kz bi translated">内核技巧</h2><p id="e123" class="pw-post-body-paragraph iw ix hh iy b iz la ii jb jc lb il je jf lc jh ji jj ld jl jm jn le jp jq jr ha bi translated">为了找到非线性决策边界，我们可以使用“核技巧”。也就是说，我们只需要定义转换后的空间中的内积，而不是定义一个到新的特征空间的显式映射，其中数据集是线性可分的。该<strong class="iy hi">核</strong> <strong class="iy hi">函数</strong>定义了该内积，可以代替<strong class="iy hi">预测</strong>函数中的点积:</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="er es mu"><img src="../Images/855b9b8ff7661f0f002439d4d2632d8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*iwucbXvoKYe2WNQf.png"/></div></div></figure><p id="9df9" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">例如，我们可以使用多项式核</p><pre class="ju jv jw jx fd mf mg mh mi aw mj bi"><span id="59a1" class="kf kg hh mg b fi mk ml l mm mn">def <strong class="mg hi">polynomial</strong>(x_i, x_j, c, n):<br/>    return (np.dot(x_i, x_j) + c) ** n</span><span id="9428" class="kf kg hh mg b fi mo ml l mm mn">def <strong class="mg hi">predict</strong>(alpha_i, b, x):<br/>    wx = 0<br/>    for j in range(len(X)):<br/>        wx += alpha_i[j] * <strong class="mg hi">polynomial</strong>(X[j], x, C, N)<br/>    return wx + b</span></pre><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es jt"><img src="../Images/1dab0670f66f4c352519dc03328ed9ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*jWjzrfDLV1HSrNjVGE8TnA.gif"/></div></figure><p id="c889" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">或者使用径向基函数核</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es jt"><img src="../Images/977c9f92b7f3fb701f33dd2d20d5aee9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*SlHfGzRgwYJXoSTofFiFnA.gif"/></div></figure><h2 id="3e87" class="kf kg hh bd kh ki kj kk kl km kn ko kp jf kq kr ks jj kt ku kv jn kw kx ky kz bi translated">结论</h2><p id="239c" class="pw-post-body-paragraph iw ix hh iy b iz la ii jb jc lb il je jf lc jh ji jj ld jl jm jn le jp jq jr ha bi translated">虽然其他方法可以更有效地解决这个问题，但我希望这个简单的算法能帮助你更好地理解支持向量机！</p><div class="mv mw ez fb mx my"><a rel="noopener follow" target="_blank" href="/mlearning-ai/mlearning-ai-submission-suggestions-b51e2b130bfb"><div class="mz ab dw"><div class="na ab nb cl cj nc"><h2 class="bd hi fi z dy nd ea eb ne ed ef hg bi translated">Mlearning.ai提交建议</h2><div class="nf l"><h3 class="bd b fi z dy nd ea eb ne ed ef dx translated">如何成为移动人工智能的作者</h3></div><div class="ng l"><p class="bd b fp z dy nd ea eb ne ed ef dx translated">medium.com</p></div></div><div class="nh l"><div class="ni l nj nk nl nh nm jz my"/></div></div></a></div></div></div>    
</body>
</html>