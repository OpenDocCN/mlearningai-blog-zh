<html>
<head>
<title>Pytorch for Beginners 💫</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Pytorch适合初学者💫</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/pytorch-for-beginners-d759cb85ff1a?source=collection_archive---------4-----------------------#2022-02-02">https://medium.com/mlearning-ai/pytorch-for-beginners-d759cb85ff1a?source=collection_archive---------4-----------------------#2022-02-02</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="46ec" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">第2部分:神经网络基础及其从头实现</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/fc16b8232b6f558b37d89dcb1aff7263.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3G90f7g9YfnJl0Haif-s5w.png"/></div></div></figure><p id="6ffc" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">本文将向您展示如何使用Pytorch从头开始创建一个简单的神经网络。如果您对如何在Pytorch中执行一些基本操作没有任何概念，我希望您查看本系列的第一部分。</p><div class="ke kf ez fb kg kh"><a rel="noopener follow" target="_blank" href="/@akashjoshirm.aj/pytorch-for-beginners-62c3fcd75f69"><div class="ki ab dw"><div class="kj ab kk cl cj kl"><h2 class="bd hi fi z dy km ea eb kn ed ef hg bi translated">Pytorch适合初学者💫</h2><div class="ko l"><h3 class="bd b fi z dy km ea eb kn ed ef dx translated">第一部分:张量的基本运算</h3></div><div class="kp l"><p class="bd b fp z dy km ea eb kn ed ef dx translated">medium.com</p></div></div><div class="kq l"><div class="kr l ks kt ku kq kv jg kh"/></div></div></a></div><p id="ad22" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在从头开始实现神经网络之前，你应该有关于自动升级的知识。</p><h2 id="cbe8" class="kw kx hh bd ky kz la lb lc ld le lf lg jr lh li lj jv lk ll lm jz ln lo lp lq bi translated">什么是汽车毕业生？</h2><p id="7048" class="pw-post-body-paragraph ji jj hh jk b jl lr ii jn jo ls il jq jr lt jt ju jv lu jx jy jz lv kb kc kd ha bi translated">torch.autograd是PyTorch的自动微分引擎，为神经网络训练提供动力</p><p id="ad31" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">训练神经网络(NN)分两步进行:</p><p id="25d1" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">正向传播:在正向传播中，神经网络对正确的输出做出最佳猜测。它通过每个函数运行输入数据来进行猜测。</p><p id="5e35" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">反向传播:在反向传播中，神经网络根据其猜测的误差成比例地调整其参数。这是通过从输出向后遍历，收集误差 相对于函数(梯度)参数的<strong class="jk hi"> <em class="lw">导数，并使用梯度下降优化参数来实现的。</em></strong></p><pre class="ix iy iz ja fd lx ly lz ma aw mb bi"><span id="492f" class="kw kx hh ly b fi mc md l me mf">import torch<br/>from torch.autograd import grad<br/>import torch.nn.functional as F</span></pre><p id="1617" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">创建两个分别值为5和6的张量。在创建张量时，我们将给出一个额外的参数<strong class="jk hi"> requires_grad </strong>。该参数告诉Pytorch跟踪并创建变量的微分图。简单地说，如果你想进行微分，你必须在创建张量时传递这个参数。</p><pre class="ix iy iz ja fd lx ly lz ma aw mb bi"><span id="b86e" class="kw kx hh ly b fi mc md l me mf">a = torch.tensor([5.0] , requires_grad = True)<br/>b = torch.tensor([6.0] , requires_grad = True)</span><span id="9e79" class="kw kx hh ly b fi mg md l me mf">print(a , b)</span></pre><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mh"><img src="../Images/2a030a875cbbbecb8501f91e9521e179.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BGUynsavTMM-_qEk0fV9xw.png"/></div></div></figure><pre class="ix iy iz ja fd lx ly lz ma aw mb bi"><span id="2fe3" class="kw kx hh ly b fi mc md l me mf">y = a**3 - b**2<br/>y</span></pre><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mi"><img src="../Images/e409de2708f35f6e1111c99588d41c11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZYKVGKV0ySgQhkuwBEn0_A.png"/></div></div></figure><p id="e2f5" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">为了找出差别，你必须调用<strong class="jk hi"> variable_name.grad </strong>方法。但是一开始，输出将是零。要计算微分，您必须调用<strong class="jk hi"> variable_name.backward() </strong>方法。</p><pre class="ix iy iz ja fd lx ly lz ma aw mb bi"><span id="d4b2" class="kw kx hh ly b fi mc md l me mf">print(a.grad) , print(b.grad)</span></pre><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mj"><img src="../Images/4fbf00e74e13015bd2776970e1cb4e72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kwS1762-BlgWfgG1j3hYhg.png"/></div></div></figure><pre class="ix iy iz ja fd lx ly lz ma aw mb bi"><span id="778c" class="kw kx hh ly b fi mc md l me mf">y.backward()</span></pre><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mk"><img src="../Images/ef25209f6479c96d329792eab96844e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GDztwy6S2luQBk0dROH9Kw.png"/></div></div></figure><pre class="ix iy iz ja fd lx ly lz ma aw mb bi"><span id="60a7" class="kw kx hh ly b fi mc md l me mf">a.grad , b.grad</span></pre><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es ml"><img src="../Images/08e104ccf7d9f96117dd83be7099faa8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wsU5g3dWlAX-kjxYLmzaQw.png"/></div></div></figure><p id="4c0e" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们在这里使用了<strong class="jk hi"> y.backward </strong>，因为我们想计算y相对于a和b的微分。</p><p id="9b40" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">现在，您对Auto-grad已经很熟悉了，但为了让事情更清楚，我想再举一个例子:</p><pre class="ix iy iz ja fd lx ly lz ma aw mb bi"><span id="e391" class="kw kx hh ly b fi mc md l me mf">x = torch.tensor([3. ])<br/>w = torch.tensor([2. ] , requires_grad= True)<br/>b= torch.tensor([1. ] , requires_grad = True)</span></pre><p id="5c44" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这里，我们创建了一个<strong class="jk hi"> x </strong>张量，我们将把它作为输入。w代表权重，b代表偏差，我们希望跟踪w和b，因为我们希望使用这两个变量来计算梯度。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mm"><img src="../Images/ef69ec7498aef650384b598c1e55b790.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fFkIXTCQEsu3znuzj--6_g.png"/></div></div></figure><pre class="ix iy iz ja fd lx ly lz ma aw mb bi"><span id="81a6" class="kw kx hh ly b fi mc md l me mf">import torch.nn.functional as F<br/>out = F.relu(w*x + b)<br/>out</span></pre><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mn"><img src="../Images/a8a8289c9d89ebb6ea278d53e7113b4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RsBMCCT9PzZAtKaQDQ8FRg.png"/></div></div></figure><p id="cb05" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">如果你不知道什么是热卢。不要担心，我们将来会看到什么是relu，但现在，relu代表<strong class="jk hi">整流线性激活函数</strong>或简称<strong class="jk hi"> ReLU </strong>是一个分段线性函数，如果它是正的，它将直接输出输入，否则，它将输出零。</p><p id="6e55" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">用简单的语言来说，如果值大于零，它将给出一个正值，如果值小于零，它将给出输出0。</p><pre class="ix iy iz ja fd lx ly lz ma aw mb bi"><span id="c90a" class="kw kx hh ly b fi mc md l me mf">grad(out , w , retain_graph = True)</span></pre><p id="0920" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这也是计算梯度的一种方法。这仅仅意味着计算out相对于w的梯度。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mo"><img src="../Images/68680632a7dc6cefb2b45c48fe2aa358.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t7lvhdfkphIyDMNAM-pouw.png"/></div></div></figure><pre class="ix iy iz ja fd lx ly lz ma aw mb bi"><span id="44d2" class="kw kx hh ly b fi mc md l me mf">grad(out , b )</span></pre><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mp"><img src="../Images/574b811c8242fb097ecb2bb403b58b70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wqgRYSJFNn6852TYW4MPSQ.png"/></div></div></figure><p id="71fd" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我希望现在汽车毕业生对你来说是清楚的，如果不感到自由在评论部分询问问题。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es mq"><img src="../Images/aa4183c90ad13bfc7e1e4cc81160797d.png" data-original-src="https://miro.medium.com/v2/resize:fit:802/format:webp/0*Fo5MXE1Jz0pjAnrY.jpg"/></div></figure><p id="0f65" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">现在你已经准备好了！</p><p id="bd48" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">让我们从头开始实现神经网络。我会试着向你解释所有这些概念，就好像你是一个完全的初学者，但是如果你已经知道这些概念，直接跳到编码部分。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es mr"><img src="../Images/24d81e0bd02df0983a8c4e8814723fc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/format:webp/0*I36T5KDG27VuCHZO.jpeg"/></div><figcaption class="ms mt et er es mu mv bd b be z dx">fig 1</figcaption></figure><p id="8711" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">图1显示了神经网络的单个神经元中实际发生的情况。这里我们有多个输入x1，x2 …xn，则这些输入分别与被称为突触权重w1、w2 … wn的一些权重相关联。然后，这些值被传递给加法器函数(σ),所有这些值相乘，最后一项加上偏差。</p><p id="52e2" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">因此，如果我们用向量表示所有这些操作，那么它将被写成(权重(转置)x输入+偏差)</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mw"><img src="../Images/e311e3000fd1dcec732bef9233598406.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Utu3AvJPt4CXTwOd6WGr6A.png"/></div></div></figure><p id="4e09" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">为了找到偏差和权重的值，我们将首先取一些随机值，然后在每次迭代中，我们将通过用(<strong class="jk hi">学习速率</strong> ) x ( <strong class="jk hi">关于w和b的损失梯度</strong>)减去当前偏差或权重来找到新值。然后这些值被传递给某个激活函数，然后我们得到输出。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="mx my l"/></div></figure><p id="bf59" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们将使用torch.manual_seed在每次运行中复制相同的输出</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="mx my l"/></div></figure><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="mx my l"/></div></figure><p id="0eae" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在这里，我们刚刚使用sklearn.make_classification方法在目标中创建了具有1000个样本、4个特征和2个类的分类数据，并将X和y从简单数组转换为张量</p><p id="f07a" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">看，现在我们将把数据分成训练和测试数据。您可以使用以下工具轻松执行此步骤:</p><p id="b6f7" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><em class="lw">sk learn . model _ selection . train _ test _ train _ split():</em></p><div class="ke kf ez fb kg kh"><a href="https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.train_test_split.html" rel="noopener  ugc nofollow" target="_blank"><div class="ki ab dw"><div class="kj ab kk cl cj kl"><h2 class="bd hi fi z dy km ea eb kn ed ef hg bi translated">sk learn . model _ selection . train _ test _ split</h2><div class="ko l"><h3 class="bd b fi z dy km ea eb kn ed ef dx translated">使用sk learn . model _ selection . train _ test _ split的示例:scikit的发布亮点-learn 0.23发布亮点…</h3></div><div class="kp l"><p class="bd b fp z dy km ea eb kn ed ef dx translated">scikit-learn.org</p></div></div><div class="kq l"><div class="mz l ks kt ku kq kv jg kh"/></div></div></a></div><p id="eef3" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">但是我想当我们从零开始做每件事的时候，为什么不这样做呢？</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="mx my l"/></div></figure><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="mx my l"/></div></figure><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="mx my l"/></div></figure><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="mx my l"/></div></figure><p id="8bf9" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">现在，我们将把数据集中数值列的值更改为一个通用的标度，而不会扭曲值范围的差异，这就是通常所说的规范化</p><p id="96db" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">现在，您可以使用sklearn标准缩放器来缩放您的值，但我们将从头开始编写代码。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es na"><img src="../Images/ef7707cb9e39c7ca07c7c8d7554f2733.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*GvZ7_VAvksVgdIh9.png"/></div></div></figure><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="mx my l"/></div></figure><p id="deb3" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">现在，我们将实现一个NN类，在该类中，我们将执行一个前向传递，其中我们将乘以输入和权重，然后我们将添加偏差(图1)。我们从头开始实现所有的东西，但是对于向后传球，我们将会得到亲笔签名的帮助，因为从头实现自动升级可能会让我头疼，所以我们将简单地使用内置的自动升级🙂。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="mx my l"/></div></figure><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="mx my l"/></div></figure><p id="489b" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这里，我们创建了一个简单的类，在构造函数中，我们给出了一些输入作为参数，而不是用一些随机数初始化偏差和权重，我们用零初始化它们。</p><blockquote class="nb nc nd"><p id="e211" class="ji jj lw jk b jl jm ii jn jo jp il jq ne js jt ju nf jw jx jy ng ka kb kc kd ha bi translated">注意:损失函数是在类外定义的</p></blockquote><p id="f311" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">为了计算损失，我们使用均方差。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es nh"><img src="../Images/e9fb5b71d7404e476f6bda6a034872c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/0*lJXPqX-GrlwWpAy3"/></div></figure><p id="8c89" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">如果你不知道什么是损失，那么损失只是一种计算预测和实际产量之间误差的方法。简而言之，我们必须降低这种损失的值，以获得更好的准确性，但不要担心神经网络(NN)会通过调整权重和偏差来自动为您完成这项工作。</p><p id="30c9" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">现在是时候定义一个模型⌚了</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="mx my l"/></div></figure><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es ni"><img src="../Images/052390c393a2efb8141e431def718ac9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/0*xycLUrKrV6lV-wqL.jpg"/></div></figure><p id="b418" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">冷静点。</p><p id="83e0" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我会试着一行一行地解释一切。在这里，我们定义了一个功能训练，它采用模型、X(输入)、Y(目标)、时期(时期是指我们希望向模型显示整个数据集的次数)、lr是学习率，种子是手动种子，bsz是批量大小(批量只是整个数据集的小块，这里50是指我们希望将整个数据集分成大小为50的小块)。</p><p id="170f" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">Look 1st for循环针对的是epochs (epochs指的是我们希望向模型显示整个数据集的次数),在该循环下，对于不同的混洗索引，我们将整个数据集划分为多个批次，对于单个批次，我们执行正向传递并计算损失。然后我们计算偏差和权重的损失导数。我们需要这个推导来更新权重和偏差。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es nj"><img src="../Images/4c0cb84b0fa8e92727f23a9ae7515944.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/0*BbHgjecAs757bu1y"/></div></figure><p id="5260" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">使用这个公式，我们可以更新权重和偏差。然后我们计算yhat( Y预测)并打印特定时期的当前损失。</p><p id="f184" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">让我们训练神经网络模型</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="mx my l"/></div></figure><p id="b810" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">让我们绘制图表</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="mx my l"/></div></figure><p id="dbef" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">为了检查准确性</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="mx my l"/></div></figure><p id="b915" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">现在，如果你还记得，我告诉过你，在增加权重和偏差输入后，我们将输出发送到一些激活函数，但这里我没有实现任何函数。但这是另一篇文章的主题。但是现在，在这种情况下，激活功能是不需要的。</p><p id="af82" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">如果您有疑问或疑问，请提出来！</p><p id="0a81" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">喜欢、分享和关注❤</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es nk"><img src="../Images/13fdeae0f117fdfc25da3eade98d98fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/0*NK0qyeS-EhMsaZmH.gif"/></div></figure><div class="ke kf ez fb kg kh"><a rel="noopener follow" target="_blank" href="/mlearning-ai/mlearning-ai-submission-suggestions-b51e2b130bfb"><div class="ki ab dw"><div class="kj ab kk cl cj kl"><h2 class="bd hi fi z dy km ea eb kn ed ef hg bi translated">Mlearning.ai提交建议</h2><div class="ko l"><h3 class="bd b fi z dy km ea eb kn ed ef dx translated">如何成为Mlearning.ai上的作家</h3></div><div class="kp l"><p class="bd b fp z dy km ea eb kn ed ef dx translated">medium.com</p></div></div><div class="kq l"><div class="nl l ks kt ku kq kv jg kh"/></div></div></a></div><p id="bbd4" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">🟠 <a class="ae nm" rel="noopener" href="/mlearning-ai/mlearning-ai-submission-suggestions-b51e2b130bfb"> <strong class="jk hi">成为作家</strong> </a></p></div></div>    
</body>
</html>