<html>
<head>
<title>Mastering Unsupervised</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">无人监督的掌握</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/mastering-unsupervised-9df6adc35555?source=collection_archive---------11-----------------------#2022-07-10">https://medium.com/mlearning-ai/mastering-unsupervised-9df6adc35555?source=collection_archive---------11-----------------------#2022-07-10</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="f63c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Kaggle上2022年7月的新表格游乐场系列正在为98000 x 29大小的X特征矩阵估计y_label。乍一看，我认为kmeans可以解决这个问题，因为根据我的经验，kmeans是在一个大的X矩阵中寻找特征之间的相似性的最佳聚类方法之一。然而，这个问题更具挑战性，仅仅对X矩阵执行kmeans或高斯混合估计不会产生可靠的y_label来正确地对每一行进行分类。</p><p id="7136" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下面是我学会的一些步骤，来尝试解决一个困难的无监督分类问题。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es jc"><img src="../Images/f9e11305ac03304ca667aa184dc07722.png" data-original-src="https://miro.medium.com/v2/resize:fit:1116/format:webp/1*-diwG5kHZT4N78q2-Tf1rA.png"/></div></figure><h1 id="24f4" class="jk jl hh bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">子功能</h1><p id="6eb2" class="pw-post-body-paragraph ie if hh ig b ih ki ij ik il kj in io ip kk ir is it kl iv iw ix km iz ja jb ha bi translated">随便看看我在Kaggle笔记本里做的一些子功能:<a class="ae kn" href="https://www.kaggle.com/code/jamilahfoucher/tabular-playground-series-july-2022/edit/run/100273114" rel="noopener ugc nofollow" target="_blank">https://www . ka ggle . com/code/jamilahfoucher/tabular-playground-series-July-2022/</a>。</p><h1 id="8075" class="jk jl hh bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">加载和缩放数据</h1><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ko kp l"/></div></figure><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="er es kq"><img src="../Images/cf17cfb05ef9d6b7ddebd6ac84a470e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yNWmrY0sY81bbxWOKCo4Lw.png"/></div></div></figure><h1 id="7f2b" class="jk jl hh bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">确定集群的最佳数量</h1><p id="cd63" class="pw-post-body-paragraph ie if hh ig b ih ki ij ik il kj in io ip kk ir is it kl iv iw ix km iz ja jb ha bi translated">在我们对数据进行聚类之前，确定多少个聚类对于数据集的可变性是理想的是一个好主意。为了确定理想的聚类数，我们对一系列聚类值运行聚类模型(kmeans、高斯混合等)。</p><p id="7138" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用每个聚类模型的标签，我们可以根据每个数据点到其各自聚类的质心的距离，计算出几个度量来告诉我们标签是否描述了数据。这些指标包括BIC、剪影得分或同质性得分，以及更多信息，请访问<a class="ae kn" href="https://scikit-learn.org/stable/modules/clustering.html#clustering-performance-evaluation" rel="noopener ugc nofollow" target="_blank">https://sci kit-learn . org/stable/modules/clustering . html # clustering-performance-evaluation</a>。下面我用BIC:</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ko kp l"/></div></figure><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="er es kv"><img src="../Images/b9be913e8ed9c57923150208e8f8673e.png" data-original-src="https://miro.medium.com/v2/resize:fit:692/format:webp/1*tjqnUC0DXRGkjjcoqlhIPg.png"/></div></div></figure><p id="4719" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">理想的聚类数是方差较低或BIC斜率发生变化时的最大聚类数。因此，在这个例子中，对于高斯混合模型，聚类的理想数量看起来是7。理想的群集数量可能会根据您使用的群集模型而变化。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="er es kw"><img src="../Images/f8f023940f83b7aac48c6782483b759f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cZ7yKQhVC-7qRv2Nd0z5RQ.png"/></div></div></figure><h1 id="dcd5" class="jk jl hh bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">确定如何选择X的列进行聚类</h1><p id="471d" class="pw-post-body-paragraph ie if hh ig b ih ki ij ik il kj in io ip kk ir is it kl iv iw ix km iz ja jb ha bi translated">每种聚类方法都可以比其他列更好地区分/标记某些列。确定哪些列被聚类方法描述得好或不好的一种方法是绘制与每个类相关的数据。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ko kp l"/></div></figure><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="er es kx"><img src="../Images/14ddfa22203e28dd376e56f3918d4fcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RakNDGBlubXwwSe7XBefUA.png"/></div></div></figure><p id="9036" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">上面，我使用高斯混合模型来创建一个使用所有数据的初始标签。在上图中，我们根据数据点的数量绘制了每列X数据，因此类标签用颜色表示。这是聚类数据的一个非典型的可视化，但是我们可以只在30个子图中可视化所有数据，而不是一列接一列地绘制来为所有30列创建一个30×30的特征图子图。检查函数plotting_data_featurespace，查看特征空间的可视化。</p><p id="8f9a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果聚类方法能够区分相似的列数据，它也应该能够区分相同的列数据，这在将k均值应用于时间序列信号时是常见的；因此，如果聚类是100%完美的，每个柱形图应该有不重叠的颜色块(即:类分配)。在这个简化的图中，我们可以看到没有多少列具有分离的颜色块，因此这意味着标签没有很好地区分具有重叠颜色的列的数据。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="er es ky"><img src="../Images/eec16b5c1008a4960d290091ad9d35bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7_kxB07EvLo80dDndOCGEg.png"/></div></div></figure><p id="73e4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们可以从上面的小图中进一步看到相同的结果，它显示了每个类(y轴)和每个列(y轴)的X平均值。我们可以看到，高斯混合模型创建的y标签不能很好地区分列[0，1，2，3，4，5，6，14，15，16，17，18，19，20，21，23，24，26，27，28]的数据。</p><p id="bb6a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，我们需要另一个聚类模型来为这些列创建标签，或者单独对每一列进行聚类，以获得每一列的y标签。</p><p id="51ef" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">同时，让我们使用高斯混合模型可以很好地区分的列([7，8，9，10，11，12，13，22，25])，看看这个标签对于这些列来说到底有多好。让我们只为这些列获取一个ylabel，然后使用silhoutte_score来看看高斯混合模型在识别最容易识别的列方面有多好。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ko kp l"/></div></figure><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ko kp l"/></div></figure><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="er es kz"><img src="../Images/9a8fdd421a70483ccfd133d845ffa074.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pCQdWm07hlD7_nN7KVkEzw.png"/></div></div></figure><p id="121e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">轮廓分数是从-1到1的值，其中接近1的正分数表示密集且分离良好的聚类，负分数表示不正确的聚类；接近0的分数表示重叠的聚类。因此，我们的分数0.067意味着高斯混合模型导致重叠的聚类，即使对于最明显的列也是如此。kmeans表现稍好，得分0.11。</p><p id="6349" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这意味着这个问题真的很难。我们可以用更多的聚类方法重新运行相同的过程，但结果可能是相似的。那么，你会怎么做？</p><p id="7c45" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我尝试了两个选项，稍微修改了X的值，使得每个类都有更明显的均值和总体聚类。使用第一个选项，我确实获得了0.253的改进侧影分数。</p><p id="9d3c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后我开始探索集成聚类，这是一种将两个y标签合并成一个y标签的技术。不幸的是，不存在能够很好地区分困难数据的聚类方法。很多人会为相似的数据列或单个列创建标签，然后使用2D平均法将这些标签组合在一起。我是在下面的笔记本里找到这个方法的:<a class="ae kn" href="https://www.kaggle.com/code/thedevastator/how-to-ensemble-clustering-algorithms-updated/notebook" rel="noopener ugc nofollow" target="_blank">https://www . ka ggle . com/code/the desavestator/how-to-ensemble-clustering-algorithms-updated/notebook</a>。</p><p id="961d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">2D平均法需要大量的内存，所以我做了一个初始的批处理方法，我正在研究这个方法。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ko kp l"/></div></figure><p id="5440" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当我让它运行起来，我会让你知道我是如何解决这个问题的，或者至少发生了什么。</p><p id="6991" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">练习愉快！👋</p><div class="la lb ez fb lc ld"><a rel="noopener follow" target="_blank" href="/mlearning-ai/mlearning-ai-submission-suggestions-b51e2b130bfb"><div class="le ab dw"><div class="lf ab lg cl cj lh"><h2 class="bd hi fi z dy li ea eb lj ed ef hg bi translated">Mlearning.ai提交建议</h2><div class="lk l"><h3 class="bd b fi z dy li ea eb lj ed ef dx translated">如何成为Mlearning.ai上的作家</h3></div><div class="ll l"><p class="bd b fp z dy li ea eb lj ed ef dx translated">medium.com</p></div></div><div class="lm l"><div class="ln l lo lp lq lm lr ji ld"/></div></div></a></div></div></div>    
</body>
</html>