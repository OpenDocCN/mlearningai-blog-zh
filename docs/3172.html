<html>
<head>
<title>Natural Language Processing with Julia (Part-1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Julia进行自然语言处理(上)</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/natural-language-processing-with-julia-part-1-422a21902e93?source=collection_archive---------2-----------------------#2022-07-29">https://medium.com/mlearning-ai/natural-language-processing-with-julia-part-1-422a21902e93?source=collection_archive---------2-----------------------#2022-07-29</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/e47953902491a481870f58f527e137cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UFAkemKdsfqwGu_2"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Photo by <a class="ae it" href="https://unsplash.com/@leookubo?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Leonardo Toshiro Okubo</a> on <a class="ae it" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="ed27" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">介绍</h1><p id="cb0d" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">Python无疑是数据科学中使用最多的编程语言。但是城里的一门新语言比Python快多了，非<strong class="ju hi"> Julia </strong>莫属。</p><p id="e7c1" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">Julia是一种高级、高性能、动态编程语言。除了作为一种通用编程语言，它还被明确地设计用于数值分析和计算科学。</p><p id="0049" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">在这个系列中，我将展示使用Julia编程语言进行自然语言处理。据我所知，我找不到任何关于在自然语言处理中使用Julia的演练教程。所以这个系列是献给所有的Julia新手用户(像我一样)，正在考虑过渡到Julia的数据科学家，以及高级的Julia用户。</p><blockquote class="kv kw kx"><p id="64ed" class="js jt ky ju b jv kq jx jy jz kr kb kc kz ks kf kg la kt kj kk lb ku kn ko kp ha bi translated">注意:这是一个关于在NLP中使用Julia的实践系列。如果你对这两者都完全陌生，请查看<a class="ae it" href="https://julialang.org/learning/" rel="noopener ugc nofollow" target="_blank"> Julia课程</a>以详细了解Julia，并查看<a class="ae it" href="https://www.coursera.org/specializations/natural-language-processing" rel="noopener ugc nofollow" target="_blank">自然语言处理专业</a>以掌握NLP领域。在本系列中，我将假设您已经在系统中安装了Julia。</p></blockquote><h1 id="f6ec" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">首先要做的是</h1><p id="85f4" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">你将需要安装一些软件包到你的朱莉娅REPL中，以便在朱莉娅中完成自然语言处理任务。和Python中的<code class="du lc ld le lf b">pip</code>一样，也有针对Julia的包管理器；叫做<code class="du lc ld le lf b">Pkg</code>。现在有两种方法可以在您的Julia环境中安装软件包。</p><p id="93b1" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">一种方法是将<code class="du lc ld le lf b">Pkg</code>导入到你的朱莉娅·REPL中，然后使用<code class="du lc ld le lf b">Pkg.add("&lt;package-name&gt;")</code>来安装包。另一种方法是在你的朱莉娅press中按下<code class="du lc ld le lf b">]</code>，然后在你的朱莉娅press中键入下面的命令<code class="du lc ld le lf b">add &lt;packages-names&gt;</code>来添加包</p><p id="cdda" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">对于我们的自然语言处理的任务，我们将需要在我们的朱莉娅REPL包列表如下:</p><blockquote class="kv kw kx"><p id="950e" class="js jt ky ju b jv kq jx jy jz kr kb kc kz ks kf kg la kt kj kk lb ku kn ko kp ha bi translated">注意:您也可以在Julia中创建一个虚拟环境，方法是按下<code class="du lc ld le lf b">]</code>，然后键入以下命令:</p><p id="90e4" class="js jt ky ju b jv kq jx jy jz kr kb kc kz ks kf kg la kt kj kk lb ku kn ko kp ha bi translated"><code class="du lc ld le lf b">activate .</code></p><p id="beb3" class="js jt ky ju b jv kq jx jy jz kr kb kc kz ks kf kg la kt kj kk lb ku kn ko kp ha bi translated">这将为您当前的项目文件夹创建一个自定义的虚拟环境。</p></blockquote><figure class="lg lh li lj fd ii"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="6fcf" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">安装上面的包需要一点时间。但是一旦完成，您就可以使用下面的代码片段导入代码中的包:</p><figure class="lg lh li lj fd ii"><div class="bz dy l di"><div class="lk ll l"/></div></figure><h1 id="491f" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">使用数据集</h1><p id="4dfe" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">对于本教程，我将使用<a class="ae it" href="https://www.kaggle.com/datasets/team-ai/spam-text-message-classification" rel="noopener ugc nofollow" target="_blank"> Kaggle数据集</a>中的<em class="ky">垃圾短信分类</em>。该数据集的合作者是<em class="ky">AI团队，</em>以<strong class="ju hi"> <em class="ky">知识共享许可(CCO)在公共领域发布，</em> </strong>表示该数据集没有相关的版权。</p><p id="7acd" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">为了在Julia中读取数据集，我们将使用Julia的<code class="du lc ld le lf b">CSV.jl</code>和<code class="du lc ld le lf b">DataFrames.jl</code>包，如下所示:</p><figure class="lg lh li lj fd ii"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="9a55" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">在上面的代码中，<code class="du lc ld le lf b">|&gt;</code>被称为<em class="ky">管道</em>操作符，它是Julia的<code class="du lc ld le lf b">Pipe.jl</code>包的一部分。</p><p id="89f3" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">对于不熟悉这个运算符的人来说，它只是简单地将<em class="ky">第二个函数</em>应用于<em class="ky">第一个函数</em>的<strong class="ju hi">输出</strong>，其用法在R编程语言中可以广泛找到。</p><figure class="lg lh li lj fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lm"><img src="../Images/925dc38c3deb232806b79ad59db93991.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JaKN9tFvh2HO4s004Y4rSQ.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">The Pipe Operator</figcaption></figure><p id="945f" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">这个数据集有5572个记录或样本，其中一个文本列代表<em class="ky">消息</em>，一个标签列代表<em class="ky">目标</em>。</p><h1 id="cf77" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">文本预处理</h1><p id="5ad3" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">像Python一样，Julia也有自己的文本库<code class="du lc ld le lf b">TextAnalysis.jl</code>，其中打包了许多函数，可以用来预处理Julia中的文本数据。一些常用的功能如下:</p><ul class=""><li id="0002" class="ln lo hh ju b jv kq jz kr kd lp kh lq kl lr kp ls lt lu lv bi translated"><code class="du lc ld le lf b">remove_case!(...)</code> —使文本正常化。换句话说，就是将字符串小写。</li><li id="9320" class="ln lo hh ju b jv lw jz lx kd ly kh lz kl ma kp ls lt lu lv bi translated"><code class="du lc ld le lf b">prepare!(..., strip_numbers)</code> —从字符串中删除数字。</li><li id="b302" class="ln lo hh ju b jv lw jz lx kd ly kh lz kl ma kp ls lt lu lv bi translated"><code class="du lc ld le lf b">prepare!(..., strip_punctuation)</code> —删除字符串中的标点符号。</li><li id="c721" class="ln lo hh ju b jv lw jz lx kd ly kh lz kl ma kp ls lt lu lv bi translated"><code class="du lc ld le lf b">prepare!(..., strip_html_tags)</code> —从字符串中删除HTML标签。</li></ul><p id="4c71" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">上面的包提供了一系列其他功能，这些功能可以在文本分析文档中找到。</p><p id="0510" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">但是必须转换字符串数据类型才能使用上述函数。<code class="du lc ld le lf b">TextAnalysis.jl</code>的函数期望字符串数据为以下任一类型:</p><ul class=""><li id="0950" class="ln lo hh ju b jv kq jz kr kd lp kh lq kl lr kp ls lt lu lv bi translated"><code class="du lc ld le lf b">StringDocument</code></li><li id="df6a" class="ln lo hh ju b jv lw jz lx kd ly kh lz kl ma kp ls lt lu lv bi translated"><code class="du lc ld le lf b">FileDocument</code></li><li id="1576" class="ln lo hh ju b jv lw jz lx kd ly kh lz kl ma kp ls lt lu lv bi translated"><code class="du lc ld le lf b">TokenDocument</code></li><li id="ed21" class="ln lo hh ju b jv lw jz lx kd ly kh lz kl ma kp ls lt lu lv bi translated"><code class="du lc ld le lf b">NGramDocument</code></li></ul><p id="dd1c" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">要将Julia数据帧中的数据从一种类型转换成另一种类型，我们可以如下使用<code class="du lc ld le lf b">DataFrame.jl</code>的<code class="du lc ld le lf b">transform(...)</code>模块:</p><figure class="lg lh li lj fd ii"><div class="bz dy l di"><div class="lk ll l"/></div></figure><blockquote class="kv kw kx"><p id="8516" class="js jt ky ju b jv kq jx jy jz kr kb kc kz ks kf kg la kt kj kk lb ku kn ko kp ha bi translated">注意:<code class="du lc ld le lf b">chain</code>命令的工作方式类似于管道操作符。</p></blockquote><p id="8046" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">一旦我们执行了上面的代码，我们就会得到我们的<code class="du lc ld le lf b">TextAnalysis</code>包函数所需格式的文本数据。现在，我们可以使用以下代码将预处理算法应用于文本数据:</p><figure class="lg lh li lj fd ii"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="7d61" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">在上面这段代码中，函数名和括号之间的<code class="du lc ld le lf b">.</code>操作符被称为<em class="ky">广播操作符</em>，用于Julia中的<em class="ky">向量化</em>。更简单地说，<em class="ky">向量化</em>是一种使用for循环的方法，它不需要显式地使用它们来加速计算。在我们执行上面这段代码后，我们将在数据集中的一个新列<code class="du lc ld le lf b">:Message2</code>中有预处理过的文本。</p><h1 id="7794" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">准备语料库和建立Tf-idf矩阵</h1><p id="4b90" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">在为我们的文本数据生成Tf-idf矩阵之前，我们需要为我们的文本数据构建一个<code class="du lc ld le lf b">Corpus</code>对象。<code class="du lc ld le lf b">TextAnalysis.jl</code>的<code class="du lc ld le lf b">Corpus</code>对象代表一组文档。</p><p id="e524" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">我们需要执行下面这段代码来生成文本数据的<code class="du lc ld le lf b">Corpus</code>对象。</p><figure class="lg lh li lj fd ii"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="b22b" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">一旦执行完毕，我们就需要构建文本数据的词汇表并更新它，这可以使用<code class="du lc ld le lf b">TextAnalysis</code>包的<code class="du lc ld le lf b">update_lexicon!(...)</code>快速完成。</p><figure class="lg lh li lj fd ii"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="ce64" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">为了构建我们的文本语料库的tf-idf矩阵，我们需要将我们的文本语料库包装在一个<code class="du lc ld le lf b">DocumentTermMatrix(...)</code>对象中，之后我们可以应用<code class="du lc ld le lf b">tf-idf(...)</code>函数来构建我们的文本数据的Tf-idf矩阵。这方面的代码如下:</p><figure class="lg lh li lj fd ii"><div class="bz dy l di"><div class="lk ll l"/></div></figure><h1 id="54ba" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">茱莉亚ML建模简介</h1><p id="134e" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">就像Python中的<em class="ky"> Scikit-learn </em>一样，我们在Julia中有<em class="ky"> MLJ框架</em>。Julia中的<em class="ky"> MLJ框架</em>具有与Python中的<em class="ky"> Scikit-learn </em>几乎相似的功能，如数据建模、模型堆叠、超参数优化等。最棒的是，它是纯Julia编写的，因此我们可以从这个框架中期待惊人的速度。</p><p id="7eee" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">在系列的这一部分，我们将继续机器学习的相同基本程序，即:</p><ul class=""><li id="6820" class="ln lo hh ju b jv kq jz kr kd lp kh lq kl lr kp ls lt lu lv bi translated">将数据集分为训练集和测试集</li><li id="270f" class="ln lo hh ju b jv lw jz lx kd ly kh lz kl ma kp ls lt lu lv bi translated">在完整的训练集上拟合模型</li><li id="b815" class="ln lo hh ju b jv lw jz lx kd ly kh lz kl ma kp ls lt lu lv bi translated">在测试集上评估性能</li></ul><p id="329b" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">现在在本教程中，我们正在处理一个监督学习问题；因此，第一条经验法则是定义问题的<code class="du lc ld le lf b">X</code>和<code class="du lc ld le lf b">y</code>。为此，我们可以使用下面这段代码:</p><figure class="lg lh li lj fd ii"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="3d8d" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">对于我们的数据建模，我们将使用<em class="ky">决策树</em>算法。让我们从使用下面这段代码定义模型开始:</p><figure class="lg lh li lj fd ii"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="b159" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">在<em class="ky"> MLJ中，</em>一个<strong class="ju hi">模型</strong>是一个作为模型超参数的<em class="ky">容器</em>的对象。为了在<em class="ky"> MLJ中安装一个模型，</em>我们首先需要调用<em class="ky"> MLJ机器</em>一个包装器，将模型和数据包装成一个实例。为此，我们可以运行如下代码:</p><figure class="lg lh li lj fd ii"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="3898" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">在<em class="ky"> MLJ中，</em>数据必须被编码成特定的scitype⁴.否则，模型将与数据不符。在上面这段代码中，我们使用<code class="du lc ld le lf b">coerce(...)</code>函数将<code class="du lc ld le lf b">X</code>和<code class="du lc ld le lf b">y</code>数据编码成特定的scitype。</p><p id="c67c" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">为了将数据划分为训练集和测试集，我们可以使用<em class="ky"> MLJ框架</em>的<code class="du lc ld le lf b">parition(...)</code>如下:</p><figure class="lg lh li lj fd ii"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="27c1" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">现在，必要的步骤已经完成，我们现在可以使用<em class="ky"> MLJ </em>框架的<code class="du lc ld le lf b">fit!(...)</code>来拟合我们的机器学习模型，并通过<code class="du lc ld le lf b">rows=train</code>来拟合我们在训练集中的模型。这方面的代码如下:</p><figure class="lg lh li lj fd ii"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="7ee2" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">一旦模型符合我们的训练数据，我们就可以使用下面的代码在测试集上评估模型的性能。</p><figure class="lg lh li lj fd ii"><div class="bz dy l di"><div class="lk ll l"/></div></figure><h1 id="8938" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">未来作品</h1><p id="365f" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">在本系列的下一部分中，我将尝试发布Julia在NLP领域的更多高级应用。接下来的内容将集中在交叉验证、超参数优化等方面。所以下一部分再见了。</p><h1 id="bb69" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">密码</h1><p id="911f" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">如果你们想看看这篇文章的工作片段，可以在下面的链接中找到我的代码:<a class="ae it" href="https://colab.research.google.com/drive/1m_3ga7RiRjV0Wybnt9KBa4Xrtfg-tVKS?usp=sharing" rel="noopener ugc nofollow" target="_blank">https://colab . research . Google . com/drive/1m _ 3g a7 rir JV 0 wy bnt 9 kb a4 xrtfg-tVKS？usp =分享</a></p><h1 id="ed38" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">参考</h1><p id="41e8" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">[1]Julia Hub撰写的TextAnalysis.jl文档—<a class="ae it" href="https://docs.juliahub.com/TextAnalysis/5Mwet/0.7.3/" rel="noopener ugc nofollow" target="_blank">https://docs.juliahub.com/TextAnalysis/5Mwet/0.7.3/</a></p><p id="5bfd" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">[2]通过<a class="ae it" href="https://niczky12.medium.com/?source=post_page-----ad04a1696944--------------------------------" rel="noopener">Bence Komarniczky</a>—<a class="ae it" href="https://towardsdatascience.com/vectorize-everything-with-julia-ad04a1696944" rel="noopener" target="_blank">https://towards data science . com/Vectorize-everything-with-Julia-ad04a 1696944</a></p><p id="49df" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">[3]茱莉亚的机器学习框架——MLJ框架:<a class="ae it" href="https://alan-turing-institute.github.io/MLJ.jl/dev/" rel="noopener ugc nofollow" target="_blank">https://alan-turing-institute.github.io/MLJ.jl/dev/</a></p><p id="5e16" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">[4] MLJ数据解释和sci types:<a class="ae it" href="https://juliaai.github.io/DataScienceTutorials.jl/data/scitype/" rel="noopener ugc nofollow" target="_blank">https://Julia ai . github . io/datasciencetutorials . JL/Data/scitype/</a></p><div class="mb mc ez fb md me"><a rel="noopener follow" target="_blank" href="/mlearning-ai/mlearning-ai-submission-suggestions-b51e2b130bfb"><div class="mf ab dw"><div class="mg ab mh cl cj mi"><h2 class="bd hi fi z dy mj ea eb mk ed ef hg bi translated">Mlearning.ai提交建议</h2><div class="ml l"><h3 class="bd b fi z dy mj ea eb mk ed ef dx translated">如何成为Mlearning.ai上的作家</h3></div><div class="mm l"><p class="bd b fp z dy mj ea eb mk ed ef dx translated">medium.com</p></div></div><div class="mn l"><div class="mo l mp mq mr mn ms in me"/></div></div></a></div></div></div>    
</body>
</html>