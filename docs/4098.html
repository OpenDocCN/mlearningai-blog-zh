<html>
<head>
<title>Introduction to Regex for Data Scientists</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向数据科学家的正则表达式介绍</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/introduction-to-regex-for-data-scientists-6b4447687655?source=collection_archive---------6-----------------------#2022-12-08">https://medium.com/mlearning-ai/introduction-to-regex-for-data-scientists-6b4447687655?source=collection_archive---------6-----------------------#2022-12-08</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="48c6" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">如何在Python和Pandas中使用正则表达式</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/a0c84585fa0b0412c4bec0301141a65b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FB7a0AJUU0kaPuKk"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx">Photo by <a class="ae jm" href="https://unsplash.com/@cdr6934?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Chris Ried</a> on <a class="ae jm" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure></div><div class="ab cl jn jo go jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ha hb hc hd he"><h1 id="b2f2" class="ju jv hh bd jw jx jy jz ka kb kc kd ke in kf io kg iq kh ir ki it kj iu kk kl bi translated">什么是正则表达式</h1><p id="5bcf" class="pw-post-body-paragraph km kn hh ko b kp kq ii kr ks kt il ku kv kw kx ky kz la lb lc ld le lf lg lh ha bi translated">Regex代表<strong class="ko hi"> <em class="li">正则表达式</em> </strong>，是用于在文本中搜索模式的表达式。简而言之，它将匹配每一个符合模式单词或词组。在Python中，你可以使用正则表达式来搜索单词、替换单词、匹配一个单词或一组单词。你可以使用正则表达式做任何事情，唯一阻止你的是你的想象力。</p><h1 id="f8e3" class="ju jv hh bd jw jx lj jz ka kb lk kd ke in ll io kg iq lm ir ki it ln iu kk kl bi translated">第一个例子</h1><p id="6177" class="pw-post-body-paragraph km kn hh ko b kp kq ii kr ks kt il ku kv kw kx ky kz la lb lc ld le lf lg lh ha bi translated">让我们举一个例子，通过查找电子邮件提供商，这是使用<a class="ae jm" href="https://randommer.io/random-email-address" rel="noopener ugc nofollow" target="_blank"> Randommer.io </a>生成的虚假电子邮件列表；</p><pre class="ix iy iz ja fd lo lp lq bn lr ls bi"><span id="9b79" class="lt jv hh lp b be lu lv l lw lx">email_list = ["rosanna_mayer78@yahoo.com",<br/>"edmund_haley@hotmail.com",<br/>"peyton31@gmail.com",<br/>"garnet.ratke77@hotmail.com",<br/>"shaun_heathcote@hotmail.com",<br/>"andreane68@hotmail.com",<br/>"rudolph9@gmail.com",<br/>"oran43@gmail.com",<br/>"leonel_ferry@gmail.com",<br/>"virgie20@yahoo.com"]</span></pre><p id="b54d" class="pw-post-body-paragraph km kn hh ko b kp ly ii kr ks lz il ku kv ma kx ky kz mb lb lc ld mc lf lg lh ha bi translated">第一步是从标准库导入re包</p><pre class="ix iy iz ja fd lo lp lq bn lr ls bi"><span id="6374" class="lt jv hh lp b be lu lv l lw lx">import re</span></pre><p id="2cfc" class="pw-post-body-paragraph km kn hh ko b kp ly ii kr ks lz il ku kv ma kx ky kz mb lb lc ld mc lf lg lh ha bi translated">然后我们写一些代码来循环遍历列表，并在每个字符串中找到一个电子邮件提供商</p><pre class="ix iy iz ja fd lo lp lq bn lr ls bi"><span id="d21d" class="lt jv hh lp b be lu lv l lw lx"># For each email in our email list<br/>for email in email_list: <br/>    <br/>    # Searching for an email provider<br/>    email_match = re.search('@(\S+)',email)<br/>  <br/>    # If there is a match, print it<br/>    if email_match:<br/>        print(email_match.group(1))</span></pre><p id="95a0" class="pw-post-body-paragraph km kn hh ko b kp ly ii kr ks lz il ku kv ma kx ky kz mb lb lc ld mc lf lg lh ha bi translated">让我们解释这一部分；</p><pre class="ix iy iz ja fd lo lp lq bn lr ls bi"><span id="f1e5" class="lt jv hh lp b be lu lv l lw lx">re.search('@(\S+)',email)</span></pre><p id="3189" class="pw-post-body-paragraph km kn hh ko b kp ly ii kr ks lz il ku kv ma kx ky kz mb lb lc ld mc lf lg lh ha bi translated">re包中的搜索函数扫描输入字符串(email ),查找与我们作为第一个参数提供的模式相匹配的子字符串<strong class="ko hi"> ('@(\S+)') </strong>。我们在这里提供的模式寻找一个基本符号<strong class="ko hi"> (@ ) </strong>并捕获一个组中后面的所有内容，直到遇到一个空格。括号意味着匹配左括号和右括号之间子模式的所有内容都是该组的一部分。这里我们的子模式是<strong class="ko hi"> \S+ </strong>，其中<strong class="ko hi"> \S </strong>表示非空白字符，而<strong class="ko hi"> + </strong>匹配这个标记一次或多次。</p><p id="9ec2" class="pw-post-body-paragraph km kn hh ko b kp ly ii kr ks lz il ku kv ma kx ky kz mb lb lc ld mc lf lg lh ha bi translated">最后我们的输出是:</p><pre class="ix iy iz ja fd lo lp lq bn lr ls bi"><span id="082e" class="lt jv hh lp b be lu lv l lw lx">yahoo.com<br/>hotmail.com<br/>gmail.com<br/>hotmail.com<br/>hotmail.com<br/>hotmail.com<br/>gmail.com<br/>gmail.com<br/>gmail.com<br/>yahoo.com</span></pre><h1 id="7fbe" class="ju jv hh bd jw jx lj jz ka kb lk kd ke in ll io kg iq lm ir ki it ln iu kk kl bi translated"><strong class="ak">基本表征和模式</strong></h1><p id="4893" class="pw-post-body-paragraph km kn hh ko b kp kq ii kr ks kt il ku kv kw kx ky kz la lb lc ld le lf lg lh ha bi translated">在正则表达式的世界中，存在许多不同的记号和模式，但让我们保持简单。</p><ul class=""><li id="84d4" class="md me hh ko b kp ly ks lz kv mf kz mg ld mh lh mi mj mk ml bi translated">所有基本的字母数字字符都是匹配的:“a”、“2”、“Z”</li><li id="b97a" class="md me hh ko b kp mm ks mn kv mo kz mp ld mq lh mi mj mk ml bi translated">特殊元字符及其反义词</li></ul><pre class="ix iy iz ja fd lo lp lq bn lr ls bi"><span id="b285" class="lt jv hh lp b be lu lv l mr lx">\s -&gt; whitespace character<br/>\S -&gt; non whitespace character<br/>\d -&gt; digit character (0,1,2,3,4,5,6,7,8,9)<br/>\D -&gt; non digit character<br/>\w -&gt; any word<br/>\W -&gt; non word<br/>. -&gt; any character<br/>\n -&gt; new line<br/>\r -&gt; carriage return</span></pre><ul class=""><li id="c31e" class="md me hh ko b kp ly ks lz kv mf kz mg ld mh lh mi mj mk ml bi translated">量词</li></ul><pre class="ix iy iz ja fd lo lp lq bn lr ls bi"><span id="5de6" class="lt jv hh lp b be lu lv l lw lx">? -&gt; zero or one of the token in front (eg: \d?)<br/>* -&gt; zero or more of the token in front (eg: z*)<br/>+ -&gt; one or more of the token in front (eg: \S+)<br/>{x} -&gt; match x number of times the token in front (eg: a{5} -&gt; match aaaaa)</span></pre><ul class=""><li id="635c" class="md me hh ko b kp ly ks lz kv mf kz mg ld mh lh mi mj mk ml bi translated">其他人</li></ul><pre class="ix iy iz ja fd lo lp lq bn lr ls bi"><span id="3b2a" class="lt jv hh lp b be lu lv l lw lx">^ -&gt; Start of a string<br/>$ -&gt; End of a string<br/>| -&gt; Boolean or condition  (eg: a|b)<br/>[] -&gt; defining a list of token that could be match <br/>(eg: [A-Za-z] for all letters in both lower and uppercase)</span></pre><p id="d9fa" class="pw-post-body-paragraph km kn hh ko b kp ly ii kr ks lz il ku kv ma kx ky kz mb lb lc ld mc lf lg lh ha bi translated">要像我们在示例中那样创建一个组，您需要使用括号并在它们之间编写子模式。</p><p id="f0a5" class="pw-post-body-paragraph km kn hh ko b kp ly ii kr ks lz il ku kv ma kx ky kz mb lb lc ld mc lf lg lh ha bi translated">您可能已经注意到，在最后一行，我们打印了id为1的组。这是因为re不仅返回我们组的字符串的总匹配:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es ms"><img src="../Images/ba6cd8f5bf5180eb1ae61d6dfd26b3aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/format:webp/1*CJ7wInQC67SMfAg1gAcbPQ.png"/></div></figure><h1 id="5b2d" class="ju jv hh bd jw jx lj jz ka kb lk kd ke in ll io kg iq lm ir ki it ln iu kk kl bi translated">如何在熊猫身上使用正则表达式</h1><p id="6b01" class="pw-post-body-paragraph km kn hh ko b kp kq ii kr ks kt il ku kv kw kx ky kz la lb lc ld le lf lg lh ha bi translated">现在让我们以熊猫为例，通过在句子列表中查找价格来使用正则表达式。</p><pre class="ix iy iz ja fd lo lp lq bn lr ls bi"><span id="95fb" class="lt jv hh lp b be lu lv l lw lx">import pandas as pd<br/><br/>sentence_dict ={"Sentence" : ["I bought it for $100.50",<br/>                              "$50 is not worth it",<br/>                              "Price: $12",<br/>                              "Pricing on demand"]}<br/><br/>df = pd.DataFrame(sentence_dict)</span></pre><p id="d1ef" class="pw-post-body-paragraph km kn hh ko b kp ly ii kr ks lz il ku kv ma kx ky kz mb lb lc ld mc lf lg lh ha bi translated">这给了我们这样的输出:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es mt"><img src="../Images/46872bfde85d30933d309f03693d9295.png" data-original-src="https://miro.medium.com/v2/resize:fit:478/format:webp/1*yCRUaehOTcAYAekXAceUvA.png"/></div><figcaption class="ji jj et er es jk jl bd b be z dx">Dataframe output</figcaption></figure><p id="297a" class="pw-post-body-paragraph km kn hh ko b kp ly ii kr ks lz il ku kv ma kx ky kz mb lb lc ld mc lf lg lh ha bi translated">现在我们来思考如何匹配一个价格？简单:我们需要一个团队来捕捉美元符号后的所有数字！但是我们如何做到呢？就在一条线上。</p><pre class="ix iy iz ja fd lo lp lq bn lr ls bi"><span id="630d" class="lt jv hh lp b be lu lv l lw lx">df['Price']=df['Sentence'].str.extract(r'\$([0-9.]+)')</span></pre><p id="2e6d" class="pw-post-body-paragraph km kn hh ko b kp ly ii kr ks lz il ku kv ma kx ky kz mb lb lc ld mc lf lg lh ha bi translated">这里我们匹配一个美元符号，注意前面有一个反斜杠，这意味着我们想要一个美元符号，而不是一个字符串的开头。然后我们有带括号的组。在里面我们说匹配任何数字(0到9)或点，一次或多次。</p><p id="bac3" class="pw-post-body-paragraph km kn hh ko b kp ly ii kr ks lz il ku kv ma kx ky kz mb lb lc ld mc lf lg lh ha bi translated">我们也可以这样编写正则表达式，其中<strong class="ko hi"> \d </strong>是任意数字:</p><pre class="ix iy iz ja fd lo lp lq bn lr ls bi"><span id="a60d" class="lt jv hh lp b be lu lv l lw lx">df['Price']=df['Sentence'].str.extract(r'\$([\d.]+)')</span></pre><p id="8ad0" class="pw-post-body-paragraph km kn hh ko b kp ly ii kr ks lz il ku kv ma kx ky kz mb lb lc ld mc lf lg lh ha bi translated">最后我们的输出是:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es mu"><img src="../Images/a8f53d3be18b04ee2bd0517ffbd83100.png" data-original-src="https://miro.medium.com/v2/resize:fit:618/format:webp/1*wUUASTpQtAas9l6-Gpavjw.png"/></div><figcaption class="ji jj et er es jk jl bd b be z dx">Final output</figcaption></figure><p id="30e6" class="pw-post-body-paragraph km kn hh ko b kp ly ii kr ks lz il ku kv ma kx ky kz mb lb lc ld mc lf lg lh ha bi translated">我们有一个NaN，因为句子中没有价格。</p><h1 id="72f3" class="ju jv hh bd jw jx lj jz ka kb lk kd ke in ll io kg iq lm ir ki it ln iu kk kl bi translated">额外资源</h1><p id="8b32" class="pw-post-body-paragraph km kn hh ko b kp kq ii kr ks kt il ku kv kw kx ky kz la lb lc ld le lf lg lh ha bi translated">Regex上有很多要说的，我们无法在一篇博客文章中涵盖所有内容，因此这里列出了一些有用的资源:</p><h2 id="c6ce" class="mv jv hh bd jw mw mx my ka mz na nb ke kv nc nd kg kz ne nf ki ld ng nh kk ni bi translated">Python Re模块文档:</h2><div class="nj nk ez fb nl nm"><a href="https://docs.python.org/3/library/re.html" rel="noopener  ugc nofollow" target="_blank"><div class="nn ab dw"><div class="no ab np cl cj nq"><h2 class="bd hi fi z dy nr ea eb ns ed ef hg bi translated">重新正则表达式操作- Python 3.11.1文档</h2><div class="nt l"><h3 class="bd b fi z dy nr ea eb ns ed ef dx translated">这个模块提供了类似于Perl中的正则表达式匹配操作。无论是图案还是字符串…</h3></div><div class="nu l"><p class="bd b fp z dy nr ea eb ns ed ef dx translated">docs.python.org</p></div></div></div></a></div><h2 id="9568" class="mv jv hh bd jw mw mx my ka mz na nb ke kv nc nd kg kz ne nf ki ld ng nh kk ni bi translated">Google对Regex的介绍:</h2><div class="nj nk ez fb nl nm"><a href="https://developers.google.com/edu/python/regular-expressions" rel="noopener  ugc nofollow" target="_blank"><div class="nn ab dw"><div class="no ab np cl cj nq"><h2 class="bd hi fi z dy nr ea eb ns ed ef hg bi translated">Python正则表达式| Python教育| Google开发者</h2><div class="nt l"><h3 class="bd b fi z dy nr ea eb ns ed ef dx translated">正则表达式是匹配文本模式的强大语言。本页给出了常规…的基本介绍</h3></div><div class="nu l"><p class="bd b fp z dy nr ea eb ns ed ef dx translated">developers.google.com</p></div></div><div class="nv l"><div class="nw l nx ny nz nv oa jg nm"/></div></div></a></div><h2 id="fc28" class="mv jv hh bd jw mw mx my ka mz na nb ke kv nc nd kg kz ne nf ki ld ng nh kk ni bi translated">令人敬畏的正则表达式:一个可以帮助你掌握正则表达式的知识库</h2><div class="nj nk ez fb nl nm"><a href="https://github.com/aloisdg/awesome-regex" rel="noopener  ugc nofollow" target="_blank"><div class="nn ab dw"><div class="no ab np cl cj nq"><h2 class="bd hi fi z dy nr ea eb ns ed ef hg bi translated">GitHub-aloisdg/awesome-Regex:awesome Regex库、工具、框架的精选集合…</h2><div class="nt l"><h3 class="bd b fi z dy nr ea eb ns ed ef dx translated">令人敬畏的正则表达式库、工具、框架和软件的精选集合。目标是建立一个分类的…</h3></div><div class="nu l"><p class="bd b fp z dy nr ea eb ns ed ef dx translated">github.com</p></div></div><div class="nv l"><div class="ob l nx ny nz nv oa jg nm"/></div></div></a></div><h2 id="ee30" class="mv jv hh bd jw mw mx my ka mz na nb ke kv nc nd kg kz ne nf ki ld ng nh kk ni bi translated">Regex101:一个强大的Regex编辑器，解释正则表达式术语，并让您编写一些测试用例:</h2><div class="nj nk ez fb nl nm"><a href="https://regex101.com" rel="noopener  ugc nofollow" target="_blank"><div class="nn ab dw"><div class="no ab np cl cj nq"><h2 class="bd hi fi z dy nr ea eb ns ed ef hg bi translated">regex101:构建、测试和调试regex</h2><div class="nt l"><h3 class="bd b fi z dy nr ea eb ns ed ef dx translated">正则表达式测试器，语法高亮，解释，PHP/PCRE，Python，GO，JavaScript的备忘单…</h3></div><div class="nu l"><p class="bd b fp z dy nr ea eb ns ed ef dx translated">regex101.com</p></div></div><div class="nv l"><div class="oc l nx ny nz nv oa jg nm"/></div></div></a></div><p id="1338" class="pw-post-body-paragraph km kn hh ko b kp ly ii kr ks lz il ku kv ma kx ky kz mb lb lc ld mc lf lg lh ha bi translated">最后，感谢阅读！让我知道它在这里是否有用👇</p><div class="nj nk ez fb nl nm"><a rel="noopener follow" target="_blank" href="/mlearning-ai/mlearning-ai-submission-suggestions-b51e2b130bfb"><div class="nn ab dw"><div class="no ab np cl cj nq"><h2 class="bd hi fi z dy nr ea eb ns ed ef hg bi translated">Mlearning.ai提交建议</h2><div class="nt l"><h3 class="bd b fi z dy nr ea eb ns ed ef dx translated">如何成为Mlearning.ai上的作家</h3></div><div class="nu l"><p class="bd b fp z dy nr ea eb ns ed ef dx translated">medium.com</p></div></div><div class="nv l"><div class="od l nx ny nz nv oa jg nm"/></div></div></a></div></div></div>    
</body>
</html>