<html>
<head>
<title>YOLOX Explanation — How Does YOLOX Work?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">YOLOX解释——YOLOX是如何工作的？</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/yolox-explanation-how-does-yolox-work-3e5c89f2bf78?source=collection_archive---------0-----------------------#2022-05-17">https://medium.com/mlearning-ai/yolox-explanation-how-does-yolox-work-3e5c89f2bf78?source=collection_archive---------0-----------------------#2022-05-17</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="dd5c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">本文是我全面解释YOLOX(你只看一次X)模型如何工作的系列文章的第二篇。如果您对该代码感兴趣，可以在下面找到它的链接:</p><div class="jc jd ez fb je jf"><a href="https://github.com/gmongaras/YOLOX_From_Scratch/tree/main" rel="noopener  ugc nofollow" target="_blank"><div class="jg ab dw"><div class="jh ab ji cl cj jj"><h2 class="bd hi fi z dy jk ea eb jl ed ef hg bi translated">GitHub-gmongaras/YOLOX _从头开始</h2><div class="jm l"><h3 class="bd b fi z dy jk ea eb jl ed ef dx translated">试图从头开始构建YOLOX算法。</h3></div><div class="jn l"><p class="bd b fp z dy jk ea eb jl ed ef dx translated">github.com</p></div></div><div class="jo l"><div class="jp l jq jr js jo jt ju jf"/></div></div></a></div><p id="4cf1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">本系列有4个部分来全面介绍YOLOX算法:</p><ul class=""><li id="0a38" class="jv jw hh ig b ih ii il im ip jx it jy ix jz jb ka kb kc kd bi translated">什么是YOLO，它有什么特别之处？</li><li id="9c09" class="jv jw hh ig b ih kf il kg ip kh it ki ix kj jb ka kb kc kd bi translated">【YOLOX是怎么工作的？ ( <a class="ae ke" rel="noopener" href="/p/3e5c89f2bf78">自我</a>)</li><li id="4ce7" class="jv jw hh ig b ih kf il kg ip kh it ki ix kj jb ka kb kc kd bi translated"><a class="ae ke" href="https://gmongaras.medium.com/yolox-explanation-simota-for-dynamic-label-assignment-8fa5ae397f76" rel="noopener">用于动态标签分配的SimOTA</a></li><li id="5459" class="jv jw hh ig b ih kf il kg ip kh it ki ix kj jb ka kb kc kd bi translated"><a class="ae ke" href="https://gmongaras.medium.com/yolox-explanation-mosaic-and-mixup-for-data-augmentation-3839465a3adf" rel="noopener">用于数据增强的镶嵌和混合</a></li></ul><h1 id="d2f8" class="kk kl hh bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">暗网-53——YOLOX的主干</h1><p id="0e89" class="pw-post-body-paragraph ie if hh ig b ih li ij ik il lj in io ip lk ir is it ll iv iw ix lm iz ja jb ha bi translated">YOLOv3算法是许多对象检测算法的基础，也是YOLOX使用的算法。在进入YOLOv3之前，我假设你已经知道YOLOv1是如何工作的，在上一篇文章中<a class="ae ke" rel="noopener" href="/p/c01f6a8a0830">对此有简要的解释。</a></p><p id="0783" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">YOLOv3算法与最初的YOLO算法非常相似，但是它做了一些小的改变，这些改变产生了重大的影响。</p><p id="311c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">YOLOv3的一个主要变化是它使用了一个叫做<strong class="ig hi"> Darknet-53 </strong>的大型主干。(主干只是一个非常不专业的结构，数据最初是通过它发送的)。主干的架构使用1×1卷积、剩余连接和3×3卷积来构成非常强大的特征提取器。这个主干也是YOLOX使用的，它有以下架构。</p><figure class="lo lp lq lr fd ls er es paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="er es ln"><img src="../Images/33afd3a1e489428b6822a181365824cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*MSlPfBYOWPVkWVj0.png"/></div></div><figcaption class="ly lz et er es ma mb bd b be z dx">Darknet-53 architecture from the YOLOv3 paper: <a class="ae ke" href="https://paperswithcode.com/method/darknet-53" rel="noopener ugc nofollow" target="_blank">https://paperswithcode.com/method/darknet-53</a></figcaption></figure><p id="8858" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">从YOLOv3获得预测的第一步是通过这个主干发送图像，然后对数据进行编码，这样YOLOv3头就可以进行最终预测。(与主干不同，头是一种用于进行预测的专门架构)。</p><p id="26a6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">YOLOv3车型的车头和YOLOv1车型基本一致。在我们的例子中，两者之间的差异并不重要，因为YOLOX完全改变了模型的头部。请记住，YOLOv1模型的最终预测基本上是一个巨大的三维张量，其中长度和宽度是不同的预测，深度是预测的不同特征。</p><p id="acce" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我在阅读YOLOv3论文时遇到的一个问题是，既然输出要通过softmax层，我如何从Darknet主干网获得特性？这个模型使用了一种叫做<strong class="ig hi">特征金字塔网络(FPN) </strong>的东西。特征金字塔网络从具有不同方面(不同宽度和高度)的图像中提取信息。为了用暗网做到这一点，我们从模型中取出转换状态，并把它们作为几个输出，而不是来自网络末端的单个输出。下面是如何工作的示意图。</p><figure class="lo lp lq lr fd ls er es paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="er es mc"><img src="../Images/3a6dba76f5007877c90b43d525589c3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b7mno28O_wN6OaJD5gsDfg.png"/></div></div><figcaption class="ly lz et er es ma mb bd b be z dx">The Darknet backbone and its three outputs</figcaption></figure><p id="c48b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">本质上，Darknet-53主干(从现在开始我可以称之为FPN)在不同的尺度上输出三种不同的预测:</p><ol class=""><li id="d538" class="jv jw hh ig b ih ii il im ip jx it jy ix jz jb md kb kc kd bi translated">256通道(第一转换输出)</li><li id="961b" class="jv jw hh ig b ih kf il kg ip kh it ki ix kj jb md kb kc kd bi translated">512通道(第二转换输出)</li><li id="592f" class="jv jw hh ig b ih kf il kg ip kh it ki ix kj jb md kb kc kd bi translated">1024通道(第三转换输出)</li></ol><p id="54bd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这些输出中的每一个都以不同的尺度提取信息。请注意，随着通道数量的增加，图像的长度和宽度会减小。因此，256通道过渡输出以较小的比例提取特征，而1024通道输出以较大的比例提取特征，因为1024通道输出具有较少的来自原始图像的信息来处理。</p><h1 id="4d1f" class="kk kl hh bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">YOLOv3头与YOLOX头</h1><p id="81da" class="pw-post-body-paragraph ie if hh ig b ih li ij ik il lj in io ip lk ir is it ll iv iw ix lm iz ja jb ha bi translated">虽然YOLOv3脊梁和YOLOX脊梁是一样的，但是模型从头部开始不同。下图显示了两个头的区别。</p><figure class="lo lp lq lr fd ls er es paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="er es me"><img src="../Images/2b51aaec13855c9af62113acda3a10f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*YzEfhoVjXEQyL1Th.png"/></div></div><figcaption class="ly lz et er es ma mb bd b be z dx">YOLOv3 vs. YOLOX head from the original YOLOX: <a class="ae ke" href="https://paperswithcode.com/method/yolox" rel="noopener ugc nofollow" target="_blank">https://paperswithcode.com/method/yolox</a></figcaption></figure><p id="d57c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当我第一次看到这个图表时，我发现它有点混乱，所以下面是我的图表的标记版本，我希望它能更容易理解。</p><figure class="lo lp lq lr fd ls er es paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="er es mf"><img src="../Images/cf065929907b09dadf739176fb634b9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MwCDxfGvRbsJU0Bvei6KMQ.png"/></div></div></figure><p id="e883" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">该图说明了YOLOv3头和YOLOX头的输入是来自FPN(暗网)主干的三个不同规模的输出，即1024、512、256个通道。</p><p id="15ef" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">两个头的输出在尺寸(高×宽×特征)上基本上完全相同，就像原始的YOLO一样。两个头的区别在于YOLOv3采用耦合头，YOLOX采用解耦头。因此，YOLOX的输出实际上是3个张量，每个张量包含不同的信息，而不是1个包含所有信息的大质量张量。</p><p id="cb11" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">三个张量YOLOX输出包含与大质量张量YOLOv3输出相同的信息:</p><ol class=""><li id="a0e5" class="jv jw hh ig b ih ii il im ip jx it jy ix jz jb md kb kc kd bi translated">Cls:每个边界框的类</li><li id="2ce2" class="jv jw hh ig b ih kf il kg ip kh it ki ix kj jb md kb kc kd bi translated">Reg:边界框的4个部分(x，y，w，h)</li><li id="e66c" class="jv jw hh ig b ih kf il kg ip kh it ki ix kj jb md kb kc kd bi translated">IoU (Obj):出于某种原因，作者使用IoU而不是Obj，但这个输出只是网络对边界框中有一个对象有多确信(objectness)</li></ol><p id="8672" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">就像原始输出一样，输出的高度和宽度中的每个“像素”都是不同的边界框预测。所以，有H*W种不同的预测。</p><p id="d624" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">上面列出的输出仅针对FPN的单个输出。记住，FPN有三个输出，分别馈入YOLOv3和YOLOX的头部。这意味着实际上每个磁头有三个不同的输出，而不是一个。因此，YOLOv3的输出实际上是(3×h×w×features ), YOLOX的输出实际上是Cls、Reg和IoU (obj)输出的3倍，总共9个输出。</p><h1 id="3cd9" class="kk kl hh bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">切换到无锚点模式</h1><p id="429a" class="pw-post-body-paragraph ie if hh ig b ih li ij ik il lj in io ip lk ir is it ll iv iw ix lm iz ja jb ha bi translated">YOLOX做出的最重要的改变之一是不使用锚点，而YOLOv3严重依赖锚点。</p><p id="eb07" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">什么是主播？</strong></p><p id="f1a2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">锚点基本上是一个预定义的边界框形状，有助于网络。先前的YOLO算法不是预测直接边界框，而是预测从预定义锚框的偏移。假设锚盒的长度和宽度分别为100和50，而模型预测的长度和宽度分别为10和15。最终的边界框预测将是从锚框的偏移，长度和宽度分别为110和65。更多关于锚箱的信息可以在对话中<a class="ae ke" href="https://github.com/pjreddie/darknet/issues/568" rel="noopener ugc nofollow" target="_blank">找到。</a></p><p id="747f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">基本上，锚框是帮助模型的一种方式，因此它不必直接预测边界框。</p><p id="cac7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">锚箱的问题</strong></p><p id="4778" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">锚盒基本上是额外的参数。模特要用几个主播？锚的尺寸应该是多少？这些问题导致模型中更多的超参数调整和更少的多样性。</p><p id="da03" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">【YOLOX如何修复锚箱问题？</p><p id="6c3f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">YOLOX只是让模型直接预测边界框的尺寸，而不是预测锚框的偏移量。为了直接预测一个边界框，YOLOX使用了一个上面解释过的解耦头。此外，它使用了一种叫做大步走的东西。</p><p id="37f1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">大步流星</strong></p><p id="e196" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">YOLOX不仅仅基于YOLOv3，它还基于FCOS，这是另一个边界框模型，但它不是YOLO系列的一部分，这使得它不是很酷。</p><p id="6b1c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">FCOS用大步来帮助模型。想象一下，模型必须学会预测从0，0处的图像的左上角到1024，1024处的图像的右下角的任何地方的边界框。在离散空间中，模型有1048576个可能的预测位置，由于预测范围如此之广，它可能无法了解任何信息。</p><p id="df15" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">跨越解决了这个问题，并允许模型从偏移而不是从图像的左上角进行预测。基本上，我们可以根据模型进行预测的三种不同尺度将图像分割成网格。例如，网格可能如下所示:</p><figure class="lo lp lq lr fd ls er es paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="er es mg"><img src="../Images/b8d71932e8925db2876777bbc3bbe3b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V1EQb5O-4CXChRDpO4Ewiw.png"/></div></div><figcaption class="ly lz et er es ma mb bd b be z dx">Cat Grids</figcaption></figure><p id="2822" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用这些网格，我们可以将每个预测分配给网格上的每个交叉点。YOLOX模型预测的好处在于它们已经是长×宽的格式了。因此，我们可以将每个输出直接映射到网格上的一个唯一点，然后使用该网格点作为偏移来缩放边界框。</p><p id="c64b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">上面的网格可以通过定义某一步距来创建，该步距是网格上每个交叉点之间的距离。在YOLOX算法中，每个FPN级别分别使用32、16和8的步长。如果在256×256的图像上使用32的跨距，那么在每个维度上将有总共256/32 = 8个交点，总共64个交点。</p><p id="9be6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">例如，我将使用上面定义的YOLOX FPN步幅在下面的图像上添加网格:</p><figure class="lo lp lq lr fd ls er es paragraph-image"><div class="er es mh"><img src="../Images/50f194d5b16e0e0af26a5d178b75a894.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/format:webp/1*WboGYycNdm6jqmwpH0nC9w.png"/></div><figcaption class="ly lz et er es ma mb bd b be z dx">Bear</figcaption></figure><p id="de59" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下图显示了熊图像的网格覆盖:</p><figure class="lo lp lq lr fd ls er es paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="er es mi"><img src="../Images/0f17b8e6f8b29f9bb5ff6e5f003ee48e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IAIus4y2drsOYqUUp_lkqw.png"/></div></div><figcaption class="ly lz et er es ma mb bd b be z dx">Bear Grids</figcaption></figure><p id="cd97" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">图像上的每个交点被称为<strong class="ig hi">锚点</strong>。不要把这个和前面解释的锚混淆，因为这种类型的锚略有不同。锚点是移动预测的x，y位置的偏移量，而之前解释的锚点(这是YOLOX去掉的)是一个预定义的框，用作预测的w，h部分的偏移量。锚盒不好，因为它们是需要调整的额外超参数，而锚点很好，因为它们不涉及我们需要调整的额外参数。</p><p id="698b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">注意:从现在开始，当我说anchor时，我指的是YOLOX使用的网格上的位置，而不是YOLOv3使用的预定义边界框。</p><p id="7b27" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">图像上的锚位置可通过以下公式获得:</p><pre class="lo lp lq lr fd mj mk ml mm aw mn bi"><span id="caae" class="mo kl hh mk b fi mp mq l mr ms">x = s/2 + s*i<br/>y = s/2 + s*j</span></pre><p id="492b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">其中<em class="mt"> s </em>为步幅，<em class="mt"> i </em>为<em class="mt"> x </em>轴上的<em class="mt"> i </em>交点，<em class="mt"> j </em>为<em class="mt"> y </em>轴上的<em class="mt"> j </em>交点</p><p id="5aba" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对于YOLOX，我们使用网格点作为边界框的左上角偏移量。以下公式用于将预测的边界框(p_x，p_y，p_w，p_h)映射到图像上的实际位置(l_x，l_y，l_w，l_h ),如果(x，y)是预测所属的网格上的交点，并且<em class="mt"> s </em>是当前FPN级别的步幅:</p><pre class="lo lp lq lr fd mj mk ml mm aw mn bi"><span id="3435" class="mo kl hh mk b fi mp mq l mr ms">l_x = p_x + x<br/>l_y = p_y + y<br/>l_w = s*e^(p_w)<br/>l_h = s*e^(p_h)</span></pre><p id="fab4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们通过将预测添加到锚点(分配给该预测的x，y点)来移动预测点。我们还通过确保宽度和高度不是负的指数函数，并根据图像的步幅来移动它，来反规格化宽度和高度。</p><p id="8804" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">例如，让我们回到熊的形象，步幅为32。如果这个预测的定位点是(<em class="mt"> i </em>，<em class="mt"> j </em> ) = (2，1)，意味着交点2在<em class="mt">x</em>-轴上，交点1在<em class="mt">y</em>-轴上，我将看到图像上的以下点:</p><figure class="lo lp lq lr fd ls er es paragraph-image"><div class="er es mu"><img src="../Images/328a17636e0d4ee0d05865ecc73d70c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:738/format:webp/1*m-sxEXwHJ_RLLO2SPhNaLA.png"/></div><figcaption class="ly lz et er es ma mb bd b be z dx">Bear Grid with a point at (2, 1) assuming index starts at 0 and (0, 0) is the top left corner</figcaption></figure><p id="50b0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">注意:该点位于网格上的(2，1)处，但就像素而言，它位于:</p><pre class="lo lp lq lr fd mj mk ml mm aw mn bi"><span id="0bf4" class="mo kl hh mk b fi mp mq l mr ms">x = 32/2 + 32*2 = 16 + 64 = 80<br/>y = 32/2 + 32*1 = 16 + 32 = 48</span></pre><p id="ac1e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果模型给我的预测值是(20，15，0.2，0.3)，那么我们可以将盒子计算为:</p><pre class="lo lp lq lr fd mj mk ml mm aw mn bi"><span id="3a9a" class="mo kl hh mk b fi mp mq l mr ms">l_x = 20 + 80 = 100<br/>l_y = 15 + 48 = 63<br/>l_w = 32*e^(0.2) = 39<br/>l_h = 32*e^(0.3) = 43</span></pre><p id="c5c5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，最终图像可能如下所示:</p><figure class="lo lp lq lr fd ls er es paragraph-image"><div class="er es mh"><img src="../Images/a9a504c16aa3a41e975799bbf39ee31a.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/format:webp/1*ji58fBKc9ZY3bAQKpAtASg.png"/></div><figcaption class="ly lz et er es ma mb bd b be z dx">Bear Grid with bounding box</figcaption></figure><h1 id="aaac" class="kk kl hh bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">标签分配</h1><p id="1461" class="pw-post-body-paragraph ie if hh ig b ih li ij ik il lj in io ip lk ir is it ll iv iw ix lm iz ja jb ha bi translated">不是所有的预测都是相等的。有些显然是垃圾，我们甚至不希望我们的模型优化它们。为了区分好的和坏的预测，YOLOX使用了一种叫做<strong class="ig hi"> SimOTA </strong>的东西，用于动态标签分配。</p><p id="b37c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> SimOTA </strong>将在下一篇文章中解释，但现在，你需要知道的是，被认为是“好的”(限制了一个地面真理对象)的预测被标记为正面，而那些“坏的”(限制了背景)的预测被标记为负面。</p><p id="9aa2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当损失函数之一使用它们时，负标签的预测不仅仅被丢弃。</p><p id="0003" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">另一方面，正面的标签真的很重要。我们如何知道我们希望每个锚点优化哪个地面真实边界框？(注:ground truth是指我们希望模型预测的边界框)SimOTA不只是分配正/负标签，它还会将ground truth边界框分配给图像中每个正标签的锚点。这个基本事实包围盒对于优化模型非常重要。</p><h1 id="2ef5" class="kk kl hh bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">损失函数—评估YOLOX</h1><p id="df99" class="pw-post-body-paragraph ie if hh ig b ih li ij ik il lj in io ip lk ir is it ll iv iw ix lm iz ja jb ha bi translated">YOLOX模型有三个输出，每个输出都有自己的损失函数，因为它们需要以不同的方式进行优化。</p><p id="35ec" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">班级优化</strong></p><p id="1a44" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">正如YOLOX模型所述，类输出具有以下形状:H×W× <em class="mt"> C </em>。因此，对于每个预测，模型都预测一个包含<em class="mt"> C </em>个元素的向量。</p><p id="b070" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="mt"> C </em>是可供选择的类别数。因此，每个元素代表该类的概率，或者模型认为该类是边界框中的一个类的置信度。</p><p id="d3c3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了优化这一点，我们可以使用一个<a class="ae ke" href="https://machinelearningmastery.com/why-one-hot-encode-data-in-machine-learning/" rel="noopener ugc nofollow" target="_blank">独热编码向量</a>，它为每个锚/预测编码地面真实边界框的类。对于每个预测，独热向量具有<em class="mt"> C </em>个元素。独热向量中的1位于我们希望模型预测的类的位置，而0位于所有其他位置。例如，如果我有四个类，并且我希望模型预测第二个类，则向量可能如下所示</p><pre class="lo lp lq lr fd mj mk ml mm aw mn bi"><span id="335e" class="mo kl hh mk b fi mp mq l mr ms">pred1: [0.45, 0.25, 0.05, 0.25] # The model is most confident in the 1st class<br/>pred2: [0.25, 0.25, 0.25, 0.25] # The model is not confident in any class<br/>pred3: [0.1, 0.7, 0.1, 0.1] # The model is very confident in the second class<br/>labels: [0, 1, 0, 0] # 1 in the second location which is what we want the model to predict</span></pre><p id="fff6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了优化这些预测，我们可以通过<a class="ae ke" href="https://towardsdatascience.com/understanding-binary-cross-entropy-log-loss-a-visual-explanation-a3ac6025181a" rel="noopener" target="_blank"><strong class="ig hi">【BCE】</strong></a>二进制交叉熵损失函数来放置预测(形状为H×W×C)和基本事实标签(形状也为H×W×C)。具体来说，我们将<strong class="ig hi">所有正面预测</strong>通过BCE和logits，这是一种有趣的说法，即通过sigmoid进行预测，然后通过BCE函数进行预测。</p><p id="2283" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">注:在这一损失中不使用负标预测</p><p id="3c4d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用独热编码向量而不是仅使用正确的类的原因是为了帮助模型了解正确的类应该具有权重1，而其他类应该具有权重0。请注意模型的类输出如何具有与一键向量相同的维数。该模型不是预测单个值，而是预测所有可能类别的分布。所以，我们不应该针对单个值进行优化，相反，我们希望针对它预测的所有值进行优化。</p><p id="3709" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">回归优化</strong></p><p id="1ebe" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">优化回归(边界框预测)输出比类输出稍微复杂一些。请记住，回归输出的形状是H×W×4，其中每个预测是(x，y，w，h)。</p><p id="e873" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">有人可能认为使用<a class="ae ke" href="https://www.freecodecamp.org/news/machine-learning-mean-squared-error-regression-line-c7dde9a26b93/" rel="noopener ugc nofollow" target="_blank"><strong class="ig hi">【MSE】</strong></a>是一个很好的评估指标，因为它是一个回归任务。YOLOv3实际上使用了一种类似的度量标准，称为误差平方和(SSE)。这些指标的问题是，它会导致模型过度适应训练样本中的回归目标。</p><p id="2c58" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">并集上的交集(IOU) </strong></p><p id="e1ed" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了克服这个问题，YOLOX使用了一个名为<strong class="ig hi"> IoU </strong>的评估指标。</p><p id="6753" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">IoU的计算方法是取一个预测的边界框，并将其与实际边界框进行比较。IoU首先计算两个边界框之间的交集，然后是并集。最终结果是由盒子的并集划分的盒子之间的交集。</p><p id="739a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们仔细看看欠条。首先，交集永远不能大于并集，最小交集是0，这给了我们以下约束:</p><p id="74cf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">0 ≤ I ≤ U</p><p id="82c8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当没有交集时，并集将是两个框组合的面积(A₁+A₂),当两个框有100%交集时，并集将是其中一个框的面积(A₁),给我们以下约束:</p><p id="9dfd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">A₁ ≤ U ≤ A₁+A₂</p><p id="aac1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，随着交集的增长，IoU趋向于1，因为交集和并集收敛到相同的值。随着交集的减少，IoU趋向于0，因为并集增大，分子变小，分母变大。因此，IoU具有以下值:</p><p id="25cc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">0 ≤ IoU ≤ 1</p><p id="bea0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们实际上想要最大化IoU值，因为我们想要交集包含两个框的整体。问题是梯度下降会将损耗降至最低，因此IoU的损耗等于1-IoU，值相同，但方向相反。因此，当交点接近0%时，损耗值较高，当交点接近100%时，损耗值较低。</p><p id="4721" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">评估回归输出</strong></p><p id="5ca4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了评估回归输出，我们实际上使用<a class="ae ke" href="https://giou.stanford.edu/" rel="noopener ugc nofollow" target="_blank"> <strong class="ig hi">泛交集超过并集【GIoU】</strong></a>。GIoU类似于IoU，只是它的值介于-1和1之间。IoU(值，而不是损失)的问题是IoU为0的盒子没有任何额外的信息。有很多借据的值都是0，所以GIoU解决了这个问题。这种想法是相同的，只是它编码了更多的信息，并允许在IoU为0时具有非零值的更平滑的函数。</p><p id="cd4a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了优化模型，我们通过对所有正面预测求和并最小化该和来直接最小化GIoU损失。</p><p id="fc4a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">注:在这一损失中不使用负标预测</p><p id="0e50" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">借据/实物</strong> <strong class="ig hi">损失</strong></p><p id="a121" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果模型认为盒子里有物体，我们希望它的客观分数接近1，如果它不认为盒子里有东西，它的客观分数大约为0，如果它不确定，它的客观分数介于两者之间(希望在0.5左右)。</p><p id="44ab" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，我们想要一个介于0和1之间的函数，当边界框完全覆盖对象时，它更接近于1，当对象完全不覆盖对象时，它更接近于0。一个完美的功能就是IoU。具体来说，我们希望使用IoU，而不是GIoU，因为GIoU的范围是2，而IoU的范围是1。</p><p id="7af5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">类似于类损失函数，我们将使用<strong class="ig hi"> BCE </strong>来优化对象预测。要优化单个预测，有两种可能性:</p><ol class=""><li id="dd7a" class="jv jw hh ig b ih ii il im ip jx it jy ix jz jb md kb kc kd bi translated">容易考虑的预测是那些被标记为积极的预测。</li><li id="e6fd" class="jv jw hh ig b ih kf il kg ip kh it ki ix kj jb md kb kc kd bi translated">我们必须考虑的第二组预测是那些被标记为负面的预测。</li></ol><p id="ee19" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">由于SimOTA将基本事实边界框分配给正预测，我们可以采用预测边界框和基本事实边界框之间的IoU来获得我们希望模型预测的值。然后，我们可以将预测的对象和IoU值放入BCE损失函数中，以获得该预测的损失。</p><p id="12f8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">负面预测的问题是，我们希望对象损失优化坏预测，以便它了解坏预测和好预测的区别。SimOTA不会为负标签预测分配边界框。那么，我们如何获得负面预测的基本事实边界框呢？</p><p id="fb03" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为每个负面预测分配对象标签的一种方法是为所有负面预测分配值0。这个策略的一个问题是有更好的负面标签和更坏的负面标签。并非所有的负面标签都一样糟糕。</p><p id="1b2f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">获得负面预测的基本事实的更好方法是查看图像中的所有基本事实边界框。我们可以计算预测的负标签边界框和所有地面事实之间的IoU。然后，我们取最大的IoU值(意味着预测边界框比所有其他地面事实更多地覆盖该地面事实),并将该IoU值分配给预测边界框。然后，我们可以采用BCE和预测对象与分配的IoU值之间的逻辑值来获得该负标签的损失。</p><p id="4fee" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">注意:所有的预测，包括负面标记的预测，都被用在这个损失中。</p><p id="561b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">最终损失函数</strong></p><p id="e6ce" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最终损失函数是上述三种损失的组合，定义如下:</p><figure class="lo lp lq lr fd ls er es paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="er es mv"><img src="../Images/3349b7bd69d9152a210fec58a8b75a03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E52a8VBYRtYVLHy4HHgmvQ.png"/></div></div><figcaption class="ly lz et er es ma mb bd b be z dx">Final Loss function for YOLOX</figcaption></figure><p id="6703" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">损失函数基本上是所有损失的总和，这些损失是阳性标签数的平均值。请记住，我们使用SimOTA为每个预测分配标签。</p><p id="f40c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="mt"> reg_weight </em>是一个平衡术语，用于权衡回归损失与其他损失，因为这是最重要的优化。作者使用的权重为5.0。</p><h1 id="6a56" class="kk kl hh bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">做出推论</h1><p id="4cb8" class="pw-post-body-paragraph ie if hh ig b ih li ij ik il lj in io ip lk ir is it ll iv iw ix lm iz ja jb ha bi translated">YOLOX模型像大多数其他机器学习模型一样进行推理，但有一个主要问题需要处理。和往常一样，为了做出推断，我们应该像平常一样通过模型发送数据。</p><p id="7155" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在对输出做任何事情之前，记住我们使用BCE和logits，而不是BCE来优化类和对象预测。带有logits的BCE正在优化输出的sigmoid，而不是默认输出。因此，要获得正确形式的数据，首先要做的是获取class和objectness值的sigmoid。此外，请记住，模型预测的是每个类预测的分布，而不是类值。因此，我们希望获取每个类预测的argmax，以获得该类的最终预测:</p><pre class="lo lp lq lr fd mj mk ml mm aw mn bi"><span id="93a0" class="mo kl hh mk b fi mp mq l mr ms">final_cls = argmax(sigmoid(cls), axis=-1)<br/>final_obj = sigmoid(obj)</span></pre><p id="59fc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">至于回归目标，我们必须将它们移动到正确的位置，就像本文前面定义的跨越一样。</p><p id="70ad" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们在进行推理时面临的一个问题是，YOLOX输出了许多边界框，而这些边界框中的大多数都不是好的预测。为了处理这个问题，模型的输出经过两个修剪步骤:</p><ol class=""><li id="811e" class="jv jw hh ig b ih ii il im ip jx it jy ix jz jb md kb kc kd bi translated">移除置信度得分(客观)低于某个阈值的所有输出。当我编写YOLOX模型时，我删除了所有置信度低于0.5的预测。</li><li id="9f36" class="jv jw hh ig b ih kf il kg ip kh it ki ix kj jb md kb kc kd bi translated">使用软非最大抑制来进一步修剪预测。</li></ol><p id="c88b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在通过这两个步骤进行预测之后，应该留下少量的预测，这些预测就是模型的最终预测。</p><p id="fb4e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">非最大抑制</strong></p><p id="dd61" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">非最大值抑制是一种非常好的修剪边界框的方法，不需要知道图像中的基本事实在哪里。为此，该算法基本上删除了高度重叠的预测，如下图所示:</p><figure class="lo lp lq lr fd ls er es paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="er es mw"><img src="../Images/cbc68e714c9973fd4b8d169f2601a476.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*G1ZZZcasOJaWLbPv.png"/></div></div></figure><p id="f948" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">非最大值抑制移除高重叠边界框的方法是使用重叠边界框之间的IoU分数。具有高IoU的那些被移除，以便保留单个边界框。</p><p id="164b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下面是我用来实现软NMS(非最大抑制)的伪代码:</p><pre class="lo lp lq lr fd mj mk ml mm aw mn bi"><span id="f266" class="mo kl hh mk b fi mp mq l mr ms">Definitions:<br/>B - The predicted bounding boxes with shape (x, y, w, h)<br/>S - The confidence score for each bounding box (objectness)<br/>C - The class for each boudning box<br/>score_thresh - The score threshold to remove boxes<br/>IoU_thresh - The IoU threshold to update scores</span><span id="cd12" class="mo kl hh mk b fi mx mq l mr ms">softNMS(B, S, C, score_thresh, IoU_thresh):<br/>  D = []   &lt;- Boudning boxes we want to keep for all images</span><span id="e070" class="mo kl hh mk b fi mx mq l mr ms">  for img in imgs:<br/>    b = B[img]<br/>    s = S[img]<br/>    d = []</span><span id="5f86" class="mo kl hh mk b fi mx mq l mr ms">    while b not empty:<br/>      Get the bounding box with the highest score and save it<br/>      m = argmax(s)<br/>      M = b[m]<br/>      d.append(M)<br/>    <br/>      Remove the bounding box with the highest score from the lists<br/>    <br/>      Get the mean of all confidence scores<br/>      mean_scores = mean(s)</span><span id="b4cb" class="mo kl hh mk b fi mx mq l mr ms">      Get the IoU between M and all b<br/>      IoU = IoU_funct(M, b)<br/>    <br/>      Update all scores, s, where the IoU &gt; IoU_thresh<br/>      idx = argwhere(IoU &gt; IoU_thresh)<br/>      s[idx] = s[idx]*e^(-(IoU[idx]**2)/mean_scores)</span><span id="9d77" class="mo kl hh mk b fi mx mq l mr ms">      Remove the bounding boxes from b where s &lt; score_thresh<br/>      b = b[s &gt;= score_thresh]</span><span id="7f7a" class="mo kl hh mk b fi mx mq l mr ms">    Save the bounding boxes for this image<br/>    D.append(d)</span><span id="222d" class="mo kl hh mk b fi mx mq l mr ms">return D</span></pre><p id="9dc5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">以下是不同格式的步骤:</p><ol class=""><li id="3288" class="jv jw hh ig b ih ii il im ip jx it jy ix jz jb md kb kc kd bi translated">获取具有最高客观性分数的边界框</li><li id="3bf2" class="jv jw hh ig b ih kf il kg ip kh it ki ix kj jb md kb kc kd bi translated">从列表中删除所选预测</li><li id="909e" class="jv jw hh ig b ih kf il kg ip kh it ki ix kj jb md kb kc kd bi translated">获取所有剩余客观性分数的平均值</li><li id="fe36" class="jv jw hh ig b ih kf il kg ip kh it ki ix kj jb md kb kc kd bi translated">获取所选边框<em class="mt"> M </em>和所有其他边框<em class="mt"> b </em>之间的借据</li><li id="159f" class="jv jw hh ig b ih kf il kg ip kh it ki ix kj jb md kb kc kd bi translated">用高IoU更新边界框的分数</li><li id="47db" class="jv jw hh ig b ih kf il kg ip kh it ki ix kj jb md kb kc kd bi translated">从分数小于分数阈值的<em class="mt"> b </em>中移除所有边界框</li><li id="0af1" class="jv jw hh ig b ih kf il kg ip kh it ki ix kj jb md kb kc kd bi translated">重复步骤1-7，直到<em class="mt"> b </em>为空</li></ol><p id="423e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">用于更新分数的公式可以在<a class="ae ke" href="https://arxiv.org/abs/1704.04503" rel="noopener ugc nofollow" target="_blank">原始软非最大值抑制论文</a>(第4页)中找到。这是该论文建议的公式之一，可以与其他几个公式一起用于创建软非最大抑制。</p><p id="5bfa" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我不打算深入研究非最大值抑制的实现，但是如果您想查看<a class="ae ke" href="https://github.com/gmongaras/YOLOX_From_Scratch/blob/main/src/nonmaxSupression.py" rel="noopener ugc nofollow" target="_blank">一个有效的编码示例</a>，或者在本文中阅读关于它的更多信息<a class="ae ke" href="https://towardsdatascience.com/non-maximum-suppression-nms-93ce178e177c" rel="noopener" target="_blank">，您可以查看我的代码。</a></p><p id="29a1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这基本上就是YOLOX的全部内容。在下一篇文章中，我们将讨论SimOTA如何为动态标签分配工作。</p><h1 id="97fb" class="kk kl hh bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">来源</h1><p id="6ba8" class="pw-post-body-paragraph ie if hh ig b ih li ij ik il lj in io ip lk ir is it ll iv iw ix lm iz ja jb ha bi translated">约洛克斯:<a class="ae ke" href="https://arxiv.org/abs/2107.08430" rel="noopener ugc nofollow" target="_blank">https://arxiv.org/abs/2107.08430</a></p><p id="4ded" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">https://arxiv.org/abs/1804.02767</p><p id="886c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">https://arxiv.org/abs/1904.01355</p><p id="9f85" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">https://arxiv.org/abs/1704.04503<a class="ae ke" href="https://arxiv.org/abs/1704.04503" rel="noopener ugc nofollow" target="_blank">NMS</a></p><div class="jc jd ez fb je jf"><a rel="noopener follow" target="_blank" href="/mlearning-ai/mlearning-ai-submission-suggestions-b51e2b130bfb"><div class="jg ab dw"><div class="jh ab ji cl cj jj"><h2 class="bd hi fi z dy jk ea eb jl ed ef hg bi translated">Mlearning.ai提交建议</h2><div class="jm l"><h3 class="bd b fi z dy jk ea eb jl ed ef dx translated">如何成为Mlearning.ai上的作家</h3></div><div class="jn l"><p class="bd b fp z dy jk ea eb jl ed ef dx translated">medium.com</p></div></div><div class="jo l"><div class="my l jq jr js jo jt ju jf"/></div></div></a></div></div></div>    
</body>
</html>