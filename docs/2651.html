<html>
<head>
<title>Add custom transformation &amp; Find the best machine learning model with a machine learning pipeline</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">添加自定义转换&amp;通过机器学习管道找到最佳的机器学习模型</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/add-custom-transformation-find-the-best-machine-learning-model-3d1c40a97639?source=collection_archive---------7-----------------------#2022-05-26">https://medium.com/mlearning-ai/add-custom-transformation-find-the-best-machine-learning-model-3d1c40a97639?source=collection_archive---------7-----------------------#2022-05-26</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/3160258fb0fe29020f4e9cc06b1b592e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l0wD0JafgCU74o5V3k0zeQ.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Photo by <a class="ae it" href="https://unsplash.com/@possessedphotography?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Possessed Photography</a> on <a class="ae it" href="https://unsplash.com/s/photos/robot-finger?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="aedd" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">搜索最佳的机器学习模型可能是一项耗时的任务。管道可以使这项任务更加方便，这样您就可以缩短模型训练和评估循环。</p><h1 id="00b0" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">📖先决条件</h1><p id="376c" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">要理解这篇文章，你应该知道管道和网格搜索的概念。你可以阅读下面两篇文章的内容。如果你也熟悉Python中的类，那就太好了。</p><p id="4bc0" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">基本管线</strong></p><div class="kv kw ez fb kx ky"><a rel="noopener follow" target="_blank" href="/mlearning-ai/neat-data-preprocessing-with-pipeline-and-columntransformer-2a0468865b6b"><div class="kz ab dw"><div class="la ab lb cl cj lc"><h2 class="bd hi fi z dy ld ea eb le ed ef hg bi translated">使用管道和ColumnTransformer进行整洁的数据预处理</h2><div class="lf l"><h3 class="bd b fi z dy ld ea eb le ed ef dx translated">创建一个管道，您可以在其中输入任何数据，这些数据将在训练机器学习之前进行转换…</h3></div><div class="lg l"><p class="bd b fp z dy ld ea eb le ed ef dx translated">medium.com</p></div></div><div class="lh l"><div class="li l lj lk ll lh lm in ky"/></div></div></a></div><p id="3deb" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">网格搜索</strong></p><div class="kv kw ez fb kx ky"><a rel="noopener follow" target="_blank" href="/mlearning-ai/find-the-best-data-preparation-method-and-model-using-a-pipeline-9677f68c35e9"><div class="kz ab dw"><div class="la ab lb cl cj lc"><h2 class="bd hi fi z dy ld ea eb le ed ef hg bi translated">使用管道找到最佳的数据准备方法和模型</h2><div class="lf l"><h3 class="bd b fi z dy ld ea eb le ed ef dx translated">管道不仅使你的代码更整洁，它还可以帮助超参数调优和数据准备…</h3></div><div class="lg l"><p class="bd b fp z dy ld ea eb le ed ef dx translated">medium.com</p></div></div><div class="lh l"><div class="ln l lj lk ll lh lm in ky"/></div></div></a></div><h1 id="271b" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">📔本文内容</h1><ul class=""><li id="9e13" class="lo lp hh iw b ix kq jb kr jf lq jj lr jn ls jr lt lu lv lw bi translated">向机器学习管道添加自定义转换</li><li id="d078" class="lo lp hh iw b ix lx jb ly jf lz jj ma jn mb jr lt lu lv lw bi translated">找到最好的机器学习模型</li></ul><h1 id="893b" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">🔨向机器学习管道添加自定义转换</h1><p id="ead8" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">除了标准的数据转换函数(如sklearn的MinMaxScaler)之外，您还可以为您的数据创建转换。</p><p id="2ee7" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在这个例子中，我将创建一个类方法，使用映射将分类特征转换成数字特征，从而对顺序特征进行编码。<br/>(简单的词:从文字变成数字)</p><p id="4a48" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这是回归模型训练前所需的数据处理。</p><pre class="mc md me mf fd mg mh mi mj aw mk bi"><span id="a732" class="ml jt hh mh b fi mm mn l mo mp">from sklearn.base import TransformerMixin</span><span id="3a82" class="ml jt hh mh b fi mq mn l mo mp">class Encode(TransformerMixin):<br/>    <br/>    def __init__(self):<br/>        # Making Dictionaries of ordinal features<br/>        self.rel_exp_map = {<br/>            'Has relevent experience': 1,<br/>            'No relevent experience': 0}</span><span id="f63b" class="ml jt hh mh b fi mq mn l mo mp">def fit(self, df, y = None):<br/>        return self<br/>        <br/>    def transform(self, df, y = None):<br/>        df_pre = df.copy()<br/>        df_pre.loc[:,'rel_exp'] = df_pre['rel_exp']\<br/>                               .map(self.rel_exp_map)<br/>        return df_pre</span></pre><p id="bf23" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">代码解释:</strong></p><ul class=""><li id="7f36" class="lo lp hh iw b ix iy jb jc jf mr jj ms jn mt jr lt lu lv lw bi translated">创建一个名为Encode的类，它继承了sklearn中名为TransformerMixin的基类。</li><li id="defb" class="lo lp hh iw b ix lx jb ly jf lz jj ma jn mb jr lt lu lv lw bi translated">在该类中，有3个必要的方法:__init__、fit和transform</li><li id="0e97" class="lo lp hh iw b ix lx jb ly jf lz jj ma jn mb jr lt lu lv lw bi translated">创建管道时将调用<strong class="iw hi"> __init__ </strong>。这是我们在类中定义变量的地方。我创建了一个变量“rel_exp_map ”,这是一个将类别映射到数字的字典。</li><li id="1325" class="lo lp hh iw b ix lx jb ly jf lz jj ma jn mb jr lt lu lv lw bi translated"><strong class="iw hi">装配</strong>将在装配管道时被调用。这个案子我留了空白。</li><li id="2d32" class="lo lp hh iw b ix lx jb ly jf lz jj ma jn mb jr lt lu lv lw bi translated">使用管道转换时，将调用<strong class="iw hi">转换</strong>。这个方法需要一个dataframe (df)作为输入，而y默认设置为None(它被强制使用y参数，但我无论如何也不会使用它)。</li><li id="50ee" class="lo lp hh iw b ix lx jb ly jf lz jj ma jn mb jr lt lu lv lw bi translated">在<strong class="iw hi">转换</strong>中，数据帧列‘rel _ exp’将与rel_exp_map进行映射。</li></ul><p id="451d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">注意:</strong> \只是将代码继续到新的一行。</p><p id="034d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">接下来，添加这个编码类作为管道步骤。</p><pre class="mc md me mf fd mg mh mi mj aw mk bi"><span id="941e" class="ml jt hh mh b fi mm mn l mo mp">pipeline = Pipeline(steps=[<br/>    ('Encode', Encode()),<br/>    ('col_trans', col_trans),<br/>    ('model', LogisticRegression())<br/>])</span></pre><p id="cef8" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">然后，您可以像普通管道一样拟合、转换或网格化搜索管道。</p><h1 id="ca65" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">🤖找到最好的机器学习模型</h1><p id="fe90" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">我想到的第一个解决方案是在管道中添加许多模型步骤，并通过在网格搜索中将步骤值更改为“通过”来跳过一个步骤，就像在寻找最佳数据准备方法时一样(在上面的网格搜索文章链接中阅读更多信息)。</p><pre class="mc md me mf fd mg mh mi mj aw mk bi"><span id="4fe4" class="ml jt hh mh b fi mm mn l mo mp">temp_pipeline = Pipeline(steps=[<br/>    ('model1', LogisticRegression()),<br/>    ('model2',SVC(gamma='auto'))<br/>])</span></pre><p id="ce44" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">但是，我看到了这样的错误。</p><figure class="mc md me mf fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mu"><img src="../Images/76aa01304e4d84160b32da709d8e8c58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2CGj8aBvcPbxDw_p9tpijg.png"/></div></div></figure><blockquote class="mv mw mx"><p id="a8c7" class="iu iv my iw b ix iy iz ja jb jc jd je mz jg jh ji na jk jl jm nb jo jp jq jr ha bi translated">管道中不能有两个分类模型！！</p></blockquote><p id="225b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这个问题的解决方案是创建一个定制的转换，它接收一个模型作为输入，并通过网格搜索来找到最佳的模型。</p><h2 id="0a03" class="ml jt hh bd ju nc nd ne jy nf ng nh kc jf ni nj kg jj nk nl kk jn nm nn ko no bi translated"><strong class="ak"> 1。创建一个接收模型作为输入的类</strong></h2><pre class="mc md me mf fd mg mh mi mj aw mk bi"><span id="aca1" class="ml jt hh mh b fi mm mn l mo mp">from sklearn.base import BaseEstimator<br/>from sklearn.linear_model import LogisticRegression<br/>from sklearn.svm import SVC</span><span id="37b9" class="ml jt hh mh b fi mq mn l mo mp">class ClfSwitcher(BaseEstimator):</span><span id="1f4c" class="ml jt hh mh b fi mq mn l mo mp">def __init__(self, estimator = LogisticRegression()):<br/>        self.estimator = estimator</span><span id="b3cf" class="ml jt hh mh b fi mq mn l mo mp">def fit(self, X, y=None, **kwargs):<br/>        self.estimator.fit(X, y)<br/>        return self</span><span id="1492" class="ml jt hh mh b fi mq mn l mo mp">def predict(self, X, y=None):<br/>        return self.estimator.predict(X)</span><span id="6dae" class="ml jt hh mh b fi mq mn l mo mp">def predict_proba(self, X):<br/>        return self.estimator.predict_proba(X)</span><span id="dcac" class="ml jt hh mh b fi mq mn l mo mp">def score(self, X, y):<br/>        return self.estimator.score(X, y)</span></pre><p id="0325" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">代码解释:</strong></p><ul class=""><li id="d376" class="lo lp hh iw b ix iy jb jc jf mr jj ms jn mt jr lt lu lv lw bi translated">创建一个名为ClfSwitcher的类，它继承了sklearn中名为BaseEstimator的基类。</li><li id="f647" class="lo lp hh iw b ix lx jb ly jf lz jj ma jn mb jr lt lu lv lw bi translated">在类中，有5个必要的方法，如分类模型:_init__、fit、predict、predict_proba和score</li><li id="ab1a" class="lo lp hh iw b ix lx jb ly jf lz jj ma jn mb jr lt lu lv lw bi translated"><strong class="iw hi"> __init__ </strong>接收评估者(模型)作为输入。我将LogisticRegression()声明为默认模型。</li><li id="bdfc" class="lo lp hh iw b ix lx jb ly jf lz jj ma jn mb jr lt lu lv lw bi translated"><strong class="iw hi">拟合</strong>用于模型拟合。没有返回值。</li><li id="dd41" class="lo lp hh iw b ix lx jb ly jf lz jj ma jn mb jr lt lu lv lw bi translated">其他方法是模拟模型。它会像模型本身一样返回结果。</li></ul><h2 id="60a5" class="ml jt hh bd ju nc nd ne jy nf ng nh kc jf ni nj kg jj nk nl kk jn nm nn ko no bi translated"><strong class="ak"> 2。将1号中的类添加到管道</strong></h2><pre class="mc md me mf fd mg mh mi mj aw mk bi"><span id="00b8" class="ml jt hh mh b fi mm mn l mo mp">clf_pipeline = Pipeline(steps=[<br/>    ('Encode', Encode()),<br/>    ('col_trans', col_trans),<br/>    ('model', ClfSwitcher())<br/>])</span></pre><h2 id="6e34" class="ml jt hh bd ju nc nd ne jy nf ng nh kc jf ni nj kg jj nk nl kk jn nm nn ko no bi translated"><strong class="ak"> 3。网格搜索</strong></h2><p id="102f" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">在网格搜索参数中有两种情况使用不同的分类模型，包括逻辑回归和支持向量机。</p><pre class="mc md me mf fd mg mh mi mj aw mk bi"><span id="a93b" class="ml jt hh mh b fi mm mn l mo mp">from sklearn.model_selection import GridSearchCV</span><span id="8092" class="ml jt hh mh b fi mq mn l mo mp">grid_params = [<br/>    {'model__estimator': [LogisticRegression()]},<br/>    {'model__estimator': [SVC(gamma='auto')]}<br/>]</span><span id="e316" class="ml jt hh mh b fi mq mn l mo mp">gs = GridSearchCV(clf_pipeline, grid_params, scoring='accuracy')<br/>gs.fit(X_train, y_train)</span><span id="605a" class="ml jt hh mh b fi mq mn l mo mp">print("Best Score of train set: "+str(gs.best_score_))<br/>print("Best parameter set: "+str(gs.best_params_))<br/>print("Test Score: "+str(gs.score(X_test,y_test)))</span></pre><figure class="mc md me mf fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es np"><img src="../Images/e0fa29e203611a7a15c5887eea933e5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4rxzC3Wv0y9QOw0G4iHxog.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Grid Search Result</figcaption></figure><p id="5394" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">结果表明，逻辑回归的结果最好。</p><h2 id="17e8" class="ml jt hh bd ju nc nd ne jy nf ng nh kc jf ni nj kg jj nk nl kk jn nm nn ko no bi translated"><strong class="ak"> 4。将网格搜索结果打印成表格</strong></h2><pre class="mc md me mf fd mg mh mi mj aw mk bi"><span id="732f" class="ml jt hh mh b fi mm mn l mo mp">pd.DataFrame(gs.cv_results_)</span></pre><figure class="mc md me mf fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nq"><img src="../Images/131776af8df0aeb644b90d82b0668164.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bzCWW5AJ3Jb2c5fdIR78LA.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Grid Search Result Table</figcaption></figure><p id="9719" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">逻辑回归比SVC的精度稍高，但速度更快(拟合时间更短)</p><p id="67d3" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">另外，你也可以为每个模型应用不同的数据准备方法。</p><h1 id="2159" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">结论</h1><p id="b358" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">在本文中，您将学习如何通过从TransformerMixin创建一个类来将自定义转换添加到机器学习管道中。然后，您将学习应用这个自定义转换来执行网格搜索，以获得最佳分类模型。</p><p id="b2db" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果您觉得这篇文章有用，请关注我以获取更多数据科学文章。如果你有任何反馈，请在下面评论。</p><h2 id="1167" class="ml jt hh bd ju nc nd ne jy nf ng nh kc jf ni nj kg jj nk nl kk jn nm nn ko no bi translated">参考</h2><div class="kv kw ez fb kx ky"><a href="https://stackoverflow.com/questions/50285973/pipeline-multiple-classifiers" rel="noopener  ugc nofollow" target="_blank"><div class="kz ab dw"><div class="la ab lb cl cj lc"><h2 class="bd hi fi z dy ld ea eb le ed ef hg bi translated">管道:多分类器？</h2><div class="lf l"><h3 class="bd b fi z dy ld ea eb le ed ef dx translated">这里有一个简单的方法来优化任何分类器和每个分类器的任何参数设置。来自…</h3></div><div class="lg l"><p class="bd b fp z dy ld ea eb le ed ef dx translated">stackoverflow.com</p></div></div><div class="lh l"><div class="nr l lj lk ll lh lm in ky"/></div></div></a></div><div class="kv kw ez fb kx ky"><a rel="noopener follow" target="_blank" href="/mlearning-ai/mlearning-ai-submission-suggestions-b51e2b130bfb"><div class="kz ab dw"><div class="la ab lb cl cj lc"><h2 class="bd hi fi z dy ld ea eb le ed ef hg bi translated">Mlearning.ai提交建议</h2><div class="lf l"><h3 class="bd b fi z dy ld ea eb le ed ef dx translated">如何成为Mlearning.ai上的作家</h3></div><div class="lg l"><p class="bd b fp z dy ld ea eb le ed ef dx translated">medium.com</p></div></div><div class="lh l"><div class="ns l lj lk ll lh lm in ky"/></div></div></a></div></div></div>    
</body>
</html>