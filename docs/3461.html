<html>
<head>
<title>Cointegration of Time-Series in R</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">R中时间序列的协整</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/cointegration-of-time-series-in-r-a6543dacf66e?source=collection_archive---------2-----------------------#2022-09-06">https://medium.com/mlearning-ai/cointegration-of-time-series-in-r-a6543dacf66e?source=collection_archive---------2-----------------------#2022-09-06</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="3427" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">使用疫苗接种率和超额死亡率之间的可能关系作为展示案例。</h2></div><p id="0643" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这篇文章不是为了证明新冠肺炎疫苗(加强系列)和超额死亡率之间的因果关系。它将展示如何使用时间序列方法(如协整)来分析这些数据。尽管这个话题很沉重，但这不是我第一次，也不会是我最后一次发布关于<a class="ae js" href="https://blog.devgenius.io/causal-inference-on-time-series-covid-19-data-3cbba9ec35f3" rel="noopener ugc nofollow" target="_blank">疫苗和超额死亡率</a>、<a class="ae js" rel="noopener" href="/@marc.jacobs012/predicting-covid-19-mortality-using-logistic-regression-in-sas-5453d3532cd7">新冠肺炎和死亡率</a>、<a class="ae js" rel="noopener" href="/mlearning-ai/ivermectin-covid-19-and-death-355114059c41">伊维菌素和死亡率</a>、<a class="ae js" rel="noopener" href="/mlearning-ai/confidence-vs-prediction-intervals-576d3047f4c">疫苗和死产</a>、<a class="ae js" href="https://pub.towardsai.net/animating-covid-19-progress-and-variants-over-time-2250b9ef1a87" rel="noopener ugc nofollow" target="_blank">变异</a>和<a class="ae js" href="https://blog.devgenius.io/the-effect-of-covid-measures-on-covid-outcomes-a-vector-autoregressive-moving-average-exogenous-dd7fa6c3774f" rel="noopener ugc nofollow" target="_blank">封锁措施和重要流行病学结果</a>的分析。我确信我不是唯一的一个。</p><p id="3ba9" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">此外，这不是我第一篇关于时间序列的文章，也不是关于协整的文章，但我会更深入地研究这个特殊的案例，因为这是一个具有挑战性的案例。因为有很多好的和好的案例，给你一些好的技巧的例子，如果也有足够多的脏案例是最好的。数据科学、建模和统计并不总是做它应该做的事情。</p><p id="682f" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">因此，让我们来看看如何通过协整方法将两个时间序列，疫苗接种率和超额死亡率联系起来。</p><p id="0578" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">首先，我们加载库。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="eda3" class="kc kd hh jy b fi ke kf l kg kh">rm(list = ls())<br/>library(readxl)<br/>library(ggplot2)<br/>library(lattice)<br/>library(tidyverse)<br/>library(lubridate)<br/>library(stringr)<br/>library(xts)<br/>library(urca)<br/>library(dynlm)<br/>library(tseries)<br/>library(quantmod)<br/>library(lmtest)<br/>library(sandwich)<br/>library(vars)</span></pre><p id="8d40" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">然后我们加载数据，就像这样。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="e810" class="kc kd hh jy b fi ke kf l kg kh">oversterfte &lt;- read_excel("OVERSTERFTE MARC JACOBS AUG 2022.xlsx")<br/>oversterfte%&gt;%print(n=40)</span><span id="5168" class="kc kd hh jy b fi ki kf l kg kh"># A tibble: 27 x 4<br/>    Year  Week    VAX Death<br/>   &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;<br/> 1  2022     7      0   -81<br/> 2  2022     8      0   -86<br/> 3  2022     9  20880  -168<br/> 4  2022    10 104770    23<br/> 5  2022    11 196340   302<br/> 6  2022    12 250430   411<br/> 7  2022    13 271740   416<br/> 8  2022    14 251170   505<br/> 9  2022    15 174670   515<br/>10  2022    16 138460   279<br/>11  2022    17  81470   231<br/>12  2022    18  53040   245<br/>13  2022    19  42050   262<br/>14  2022    20  45300   218<br/>15  2022    21  42050   112<br/>16  2022    22  12820   169<br/>17  2022    23  29230   166<br/>18  2022    24  39390   230<br/>19  2022    25  71770   370<br/>20  2022    26  66660   330<br/>21  2022    27  51750   204<br/>22  2022    28  81440   326<br/>23  2022    29  71770   408<br/>24  2022    30  42050   365<br/>25  2022    31  58220   199<br/>26  2022    32   4520   218<br/>27  2022    33  37530   441</span></pre><p id="7d62" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了使它成为一个成熟的时间序列，我们需要添加一个日期变量，所以让我们这样做。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="4567" class="kc kd hh jy b fi ke kf l kg kh">oversterfte_tbl &lt;- oversterfte %&gt;% <br/>  mutate(beg = ymd(str_c(Year, "-01-01")),<br/>         date_var = beg + weeks(Week))</span></pre><figure class="jt ju jv jw fd kk er es paragraph-image"><div class="er es kj"><img src="../Images/4fab9687400cc675f39e363cff448a46.png" data-original-src="https://miro.medium.com/v2/resize:fit:890/format:webp/1*jKxHa53ibd7bKPOwbYDXDA.png"/></div><figcaption class="kn ko et er es kp kq bd b be z dx">Now we have a time-series.</figcaption></figure><p id="5b29" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">由于数据在不同的尺度上运行，而GGplot以一种荒谬的方式展示了两个y尺度，我将转向<a class="ae js" href="https://www.statmethods.net/advgraphs/trellis.html" rel="noopener ugc nofollow" target="_blank">点阵包</a>并在一个中绘制两个时间序列。接下来，我将绘制两个系列之间的简单相关图。现在，对已经相关的数据做简单的关联有很多批评，但它确实提供了一些帮助。最后，你可以在x轴和y轴上绘制数据点。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="d358" class="kc kd hh jy b fi ke kf l kg kh">VAX &lt;- xyplot(VAX~ date_var,<br/>               data = oversterfte_tbl, type = "l")<br/>Death&lt;- xyplot(Death~ date_var,<br/>              data = oversterfte_tbl, type = "l")<br/>latticeExtra::doubleYScale(VAX,Death,style1 = 0, style2 = 3, add.ylab2 = TRUE)</span><span id="89b0" class="kc kd hh jy b fi ki kf l kg kh">ggplot(oversterfte, <br/>       aes(x=VAX, <br/>           y=Death))+<br/>  geom_point()+<br/>  geom_smooth(fill="blue", alpha=0.1)+<br/>  geom_smooth(method='lm', formula= y~x, se=FALSE, col="red",lty=2)+<br/>  theme_bw()</span></pre><div class="jt ju jv jw fd ab cb"><figure class="kr kk ks kt ku kv kw paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><img src="../Images/ffdae4e23be759756f09da3f9764bcfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/format:webp/1*Q4xE0SohEYH3qAeG07LArg.png"/></div></figure><figure class="kr kk lb kt ku kv kw paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><img src="../Images/6295db984b37a8e9c8f6386c69add2df.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*9LJtI9_WEawsVsHCFWW3Zw.png"/></div><figcaption class="kn ko et er es kp kq bd b be z dx lc di ld le">The left plot is the most informative and it does show some heavy mirroring, which seems to disintegrate at the end. We will later see why the end is making this analysis so difficult, and thus also so interesting.</figcaption></figure></div><p id="3132" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在，时间序列是所有关于发现模式和解开数据。这一切都是为了确保数据是稳定的，这意味着数据的平均值不依赖于时间。</p><blockquote class="lf"><p id="6cfc" class="lg lh hh bd li lj lk ll lm ln lo jr dx translated"><a class="ae js" href="https://otexts.com/fpp2/stationarity.html" rel="noopener ugc nofollow" target="_blank"> <em class="lp">平稳时间序列是指其性质不依赖于观察时间的序列</em> </a>。</p></blockquote><p id="e09f" class="pw-post-body-paragraph iw ix hh iy b iz lq ii jb jc lr il je jf ls jh ji jj lt jl jm jn lu jp jq jr ha bi translated">它的基本意思是，你的数据没有显示趋势，或季节性(但周期是可以的)。就我个人而言，我从来没有真正喜欢过这个，但是我也不喜欢正常化、居中、缩放和任何形式的转换。然而，在时间序列中，平稳性的假设真的不能被忽略，因为它会影响你的预测，尽管你看到越来越多的机器学习算法被部署在不关心假设的时间序列数据上。</p><p id="5287" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">因此，我们需要检查的第一件事是数据是否平稳，这也与<a class="ae js" href="https://en.wikipedia.org/wiki/Cointegration" rel="noopener ugc nofollow" target="_blank">协整</a>的定义有关。协整意味着时间序列基本上是相关的。如果一个上升，另一个也会上升，就像两条小船在海浪中航行，但有一条看不见的绳子将它们连接在一起。</p><p id="1aa1" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">正式地说，如果两个数列A和B之间的差是固定的，那么它们就是协整的。也就是说每个系列都不是，它表现出一种趋势。如果序列不是协整的，差异是非平稳的(因此显示趋势或季节性)。这是一个可以用单位根检验来检验的假设，我们将在下面进行检验。</p><p id="b0ab" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在，有不止一种方法来测试协同集成，我们将探索这些方法，但首先让我们使用上面使用的定义。因此，我们寻找的是两个非平稳序列，它们的差是平稳的。</p><p id="2d7a" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">检查非平稳数据的最简单方法是检查自相关，这意味着一个时间值取决于前一个时间值。通常，删除这种自相关的方法是求差，所以我会这样做，并添加自相关图。<strong class="iy hi">请注意，平稳并不意味着没有自相关</strong>。<a class="ae js" href="https://statisticsbyjim.com/time-series/autocorrelation-partial-autocorrelation/#:~:text=data%20are%20random.-,Stationarity,a%20non%2Dstationary%20time%20series." rel="noopener ugc nofollow" target="_blank">对于平稳序列，自相关下降很快，对于非平稳序列下降很慢。</a></p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="242d" class="kc kd hh jy b fi ke kf l kg kh">par(mfrow = c(3, 4))<br/>VAXts&lt;-oversterfte_tbl%&gt;%<br/>  dplyr::select(VAX)%&gt;%<br/>  ts(., start=c(2022, 7), <br/>     end=c(2022, 33), frequency=52)<br/>plot(VAXts)<br/>acf(VAXts)<br/>plot(diff(VAXts))<br/>acf(diff(VAXts))<br/>Deathts&lt;-oversterfte_tbl%&gt;%<br/>  dplyr::select(Death)%&gt;%<br/>  ts(., start=c(2022, 7), <br/>     end=c(2022, 33), frequency=52)<br/>plot(Deathts)<br/>acf(Deathts)<br/>plot(diff(Deathts))<br/>acf(diff(Deathts))<br/>VECM_ECT &lt;- Deathts - VAXts<br/>plot(VECM_ECT)<br/>acf(VECM_ECT)<br/>plot(diff(VECM_ECT))<br/>acf(diff(VECM_ECT))</span></pre><figure class="jt ju jv jw fd kk er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es lv"><img src="../Images/cc4390566a3cf82aec2c9ce44fb5ad1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uS5JJlK_QZZHKK-W8dvHMA.png"/></div></div><figcaption class="kn ko et er es kp kq bd b be z dx">First column shows the original time-series of the death, vax, and difference(death-vax). Second column shows the auto-correlation for each of the time-series. Third and fourth column of graphics shows the differenced time-series and the auto-correlation plot that goes with it.</figcaption></figure><p id="5148" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">从上面已经可以看出，协整的第一个定义在这里是不够的。虽然两者都明确显示了一种趋势，但它们的差异也是如此。这种类型的自相关性甚至在差分之后仍然存在，这实际上是因为奇怪的第一次凸起和随后的衰减，这将导致稍后的分析相当困难。我可以做的另一件事是，我之前用图形表示过，看看相关性和互相关函数。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="0ee5" class="kc kd hh jy b fi ke kf l kg kh">cor(VAXts, Deathts)<br/>ccfvalues&lt;-ccf(as.numeric(VAXts), as.numeric(Deathts)); ccfvalues</span></pre><p id="2c1f" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如你所见，相关性不是很高，<a class="ae js" href="https://www.rdocumentation.org/packages/tseries/versions/0.1-2/topics/ccf" rel="noopener ugc nofollow" target="_blank"> ccf </a>值由lag完成。它们在非常近的地方最强，但也很快消失，如果你再次看原始图形，你可能会想到这一点。最后，通过回顾多步来预测一步是非常困难的。</p><figure class="jt ju jv jw fd kk er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es lw"><img src="../Images/db8afc31678533731a900457ee314264.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xBYLhEVZ_svrCpG3TkSkHA.png"/></div></div></figure><figure class="jt ju jv jw fd kk er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es lx"><img src="../Images/861adf5afbc71832fe40dbb3c525aa70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vksc9diyx-ITSaHRUWHEXQ.png"/></div></div><figcaption class="kn ko et er es kp kq bd b be z dx">Clearly shows that the majority of the auto-correlation happens in the vicinity of the value itself. Then, there are some things happening 5 lags apart, but that does not really show from the graph. It would mean that a value now is dependent on five values back.</figcaption></figure><p id="266d" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当然，绘制互相关数据有多种方法，在<a class="ae js" href="https://cran.r-project.org/web/packages/astsa/index.html" rel="noopener ugc nofollow" target="_blank"> astsa </a>包中，我们找到了另一种方法。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="7123" class="kc kd hh jy b fi ke kf l kg kh">astsa::lag2.plot (as.numeric(VAXts), <br/>                  as.numeric(Deathts), 10)<br/>astsa::lag2.plot (as.numeric(Deathts), <br/>                  as.numeric(VAXts), 10)</span></pre><p id="2869" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">下面你可以看到，在死亡或VAX时间序列中的一个值和另一个序列中的一个滞后值之间的两种相互关系。</p><div class="jt ju jv jw fd ab cb"><figure class="kr kk ly kt ku kv kw paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><img src="../Images/fddf35ab5d64419af412688e0239cff7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1034/format:webp/1*Ze7WHBSNbtb0Mjxus9tR7w.png"/></div></figure><figure class="kr kk lz kt ku kv kw paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><img src="../Images/3a71541ed6b942f64548f19a0e3a8f19.png" data-original-src="https://miro.medium.com/v2/resize:fit:968/format:webp/1*LgOiTkgfhV9XrHyqg-M05g.png"/></div><figcaption class="kn ko et er es kp kq bd b be z dx ma di mb le">Correlation is highest the closed the lag value is. Further away, it does not really amount to anything.</figcaption></figure></div><p id="a2f0" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在是时候使用臭名昭著的Dickey-Fuller测试和许多其他测试来寻找<a class="ae js" href="https://en.wikipedia.org/wiki/Unit_root" rel="noopener ugc nofollow" target="_blank">单位根</a>了。单位根的意思是，如果一个时间序列有这样一个东西，它就不是平稳的，需要差分。迪基-富勒测试，或这里的<a class="ae js" href="https://en.wikipedia.org/wiki/Augmented_Dickey%E2%80%93Fuller_test" rel="noopener ugc nofollow" target="_blank">增强迪基-富勒测试</a>，是检验这一点的首选测试。零假设是存在单位根，这意味着如果p值低于给定的阈值，比如0.05，则数据是平稳的或趋势平稳的。后者意味着一旦趋势被移除，一个序列就变得稳定。因此，可以用多种方式进行测试，不删除任何东西，不删除一个常数，也不删除一个趋势。我们将移除趋势以测试平稳性。</p><p id="10cf" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">使用了<a class="ae js" href="https://kevinkotze.github.io/ts-6-tut/" rel="noopener ugc nofollow" target="_blank"> <em class="mc"> ur.df </em> </a>函数，我将基于之前的acf图计算滞后数，尽管自动选择功能也是可用的。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="1607" class="kc kd hh jy b fi ke kf l kg kh">ADF_VAXts&lt;-ur.df(VAXts, <br/>      lags = 2, <br/>      selectlags = "AIC", <br/>      type = "trend")      <br/>summary(ADF_VAXts)<br/>plot.ts(ADF_VAXts@res, ylab = "Residuals")<br/>abline(h = 0, col = "red")<br/>tsm::ac(ADF_VAXts@res, max.lag = 20)</span></pre><figure class="jt ju jv jw fd kk er es paragraph-image"><div class="er es md"><img src="../Images/42bf428293591d491e937a257a6c4258.png" data-original-src="https://miro.medium.com/v2/resize:fit:1166/format:webp/1*fTzDb3SzN13i419qTj6q5g.png"/></div><figcaption class="kn ko et er es kp kq bd b be z dx">The summary coming from the <strong class="bd me">ur.df</strong> function.</figcaption></figure><p id="ac8e" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在，上面显示的，是对单位根的扩展的Dickey Fuller测试。三个测试统计值分别是-5.28、9.37和14.06。这些是tau3、phi2和phi3各自的测试统计，它们是<em class="mc">趋势</em>、<em class="mc">漂移</em>和<em class="mc">无</em>的各自值。你能看到的是，三者都与临界值有显著差异，这意味着数据是平稳的(记住，我们假设的是非平稳数据)。观察到这三个都很重要意味着我们有正确的测试，并且我们有一个固定的数据集。这与早先的观察结果一致，即VAX时间序列的自相关性迅速下降。</p><figure class="jt ju jv jw fd kk er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es mf"><img src="../Images/7afcae3371b74a932834d57e39b9cc14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lGD6JNa5i8IhHExw8_fMow.png"/></div></div><figcaption class="kn ko et er es kp kq bd b be z dx">The residuals coming from the test.</figcaption></figure><figure class="jt ju jv jw fd kk er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es mg"><img src="../Images/a889e3aa333a03b1945382f06a42c4b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OHMPyg9SoCN7vgnw_e1Ivw.png"/></div></div><figcaption class="kn ko et er es kp kq bd b be z dx">Autocorrelation of residuals coming from the test. No remaining auto-correlation to be detected.</figcaption></figure><p id="4751" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当然，有多种方法来测试单位根，我们也将应用这种方法。这里，临界值低于1%水平的检验统计量，所以这里的检验也暗示了平稳数据。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="7de7" class="kc kd hh jy b fi ke kf l kg kh">summary(ur.ers(VAXts,<br/>       model = "trend", <br/>       lag.max = 2))         </span></pre><figure class="jt ju jv jw fd kk er es paragraph-image"><div class="er es mh"><img src="../Images/790004861218868592744f3b00e2bb62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1104/format:webp/1*HT75pYQDMt4g5TTbswOLiw.png"/></div></figure><p id="a5f6" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当然，还有很多测试可以应用。因为这是R，所以您可以测试和做很多事情。就我个人而言，我更喜欢图形而不是统计测试，但是因为这应该是一个信息丰富的博客，所以我将向你们展示两者。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="6dad" class="kc kd hh jy b fi ke kf l kg kh">tseries::adf.test(VAXts)     <br/>tseries::kpss.test(VAXts, null="Trend")<br/>Box.test(VAXts, lag=2, <br/>         type="Ljung-Box")</span></pre><figure class="jt ju jv jw fd kk er es paragraph-image"><div class="er es mi"><img src="../Images/bab7d9eece15758feb81f87ad7e68a59.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/1*8U2W9wzlrxD6odO_rW4jwg.png"/></div><figcaption class="kn ko et er es kp kq bd b be z dx">The null-hypothesis of a unit-root at lag 2 has been beaten.</figcaption></figure><figure class="jt ju jv jw fd kk er es paragraph-image"><div class="er es mj"><img src="../Images/7065ff073d6da8dd01a643f90bf87f29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1174/format:webp/1*0F_wPZ00hRgC8Q9vliO45g.png"/></div><figcaption class="kn ko et er es kp kq bd b be z dx"><a class="ae js" href="https://www.statology.org/kpss-test-in-r/" rel="noopener ugc nofollow" target="_blank"><strong class="bd me">KPSS</strong></a>: using this test statistic, the p value is greater than 0.1, which is in agreement with the rest, because the null-hypothesis assumes a stationary series. So, here, H0 means trend stationary. Using the ADF, H0 means unit root and so non-stationary. They do not make this easy on you.</figcaption></figure><figure class="jt ju jv jw fd kk er es paragraph-image"><div class="er es mk"><img src="../Images/ad13616f1346a8c169165f55c2fe7862.png" data-original-src="https://miro.medium.com/v2/resize:fit:914/format:webp/1*vYQ7j0RyocnY8uslcHrIcw.png"/></div><figcaption class="kn ko et er es kp kq bd b be z dx"><a class="ae js" href="https://en.wikipedia.org/wiki/Ljung%E2%80%93Box_test" rel="noopener ugc nofollow" target="_blank"><strong class="bd me">Box-L jung</strong></a>: This test statistic looks at the presence of auto-correlation. A low p-value means that the data are not idd — not independently distributed. There is serial correlation.</figcaption></figure><p id="4c78" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">所以，现在我们知道如何做了，让我们把它也应用到其他地方。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="b477" class="kc kd hh jy b fi ke kf l kg kh">ADF_Deathts&lt;-ur.df(Deathts, <br/>                 lags = 2, <br/>                 selectlags = "AIC", <br/>                 type = "trend")      <br/>summary(ADF_Deathts)<br/>plot(ADF_Deathts)<br/>tsm::ac(ADF_Deathts@res, max.lag = 20)<br/>tsm::gts_ur(ADF_Deathts)<br/>summary(ur.ers(Deathts,<br/>               model = "trend", <br/>               lag.max = 2))         # lag at 2<br/>tseries::adf.test(Deathts)     <br/>tseries::kpss.test(Deathts, null="Trend")<br/>Box.test(Deathts, lag=2, <br/>         type="Ljung-Box")</span></pre><figure class="jt ju jv jw fd kk er es paragraph-image"><div class="er es ml"><img src="../Images/dbf7a08c457f536bc36afbff20d67b94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1110/format:webp/1*Y1SRz0mNaGOY0sF9AnXjpw.png"/></div><figcaption class="kn ko et er es kp kq bd b be z dx">Test statistic exceed critical values at the 5% at least.</figcaption></figure><div class="jt ju jv jw fd ab cb"><figure class="kr kk mm kt ku kv kw paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><img src="../Images/dd3bc4f02da90bbda6c2967c54b9d430.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/format:webp/1*FRBVlpyFivtbPzJE8pyL0w.png"/></div></figure><figure class="kr kk mn kt ku kv kw paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><img src="../Images/fdc2eda8a7886da4064859f13b201e02.png" data-original-src="https://miro.medium.com/v2/resize:fit:910/format:webp/1*UPaeuOG9EOKkFaISDPIwuw.png"/></div><figcaption class="kn ko et er es kp kq bd b be z dx mo di mp le">Residuals show no auto-or partial auto-correlation. `</figcaption></figure></div><figure class="jt ju jv jw fd kk er es paragraph-image"><div class="er es mq"><img src="../Images/63875de262e57881c4b62c2925d6223c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1078/format:webp/1*jDSqE8iM71GS7waT6WL7jg.png"/></div><figcaption class="kn ko et er es kp kq bd b be z dx">Test statistic not exceed at the 5% level meaning that the data is non-stationary.</figcaption></figure><figure class="jt ju jv jw fd kk er es paragraph-image"><div class="er es mr"><img src="../Images/971a343de7ed5059ef944bdaf27eaa85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1026/format:webp/1*VQhFqfyyL3g8_jbC6jK6yg.png"/></div><figcaption class="kn ko et er es kp kq bd b be z dx">The null-hypothesis is not rejected, so non-stationary.</figcaption></figure><figure class="jt ju jv jw fd kk er es paragraph-image"><div class="er es ms"><img src="../Images/64724cc20c5ba5946713b849c2fce111.png" data-original-src="https://miro.medium.com/v2/resize:fit:1094/format:webp/1*IgzHoEwVUqgwtz6ZmynEcw.png"/></div><figcaption class="kn ko et er es kp kq bd b be z dx">The null hypothesis is not rejected, so stationary.</figcaption></figure><figure class="jt ju jv jw fd kk er es paragraph-image"><div class="er es mt"><img src="../Images/7b36755650cf5e16f9fa96466cff76d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:920/format:webp/1*66X4WkugXNcND6iADjlDUw.png"/></div><figcaption class="kn ko et er es kp kq bd b be z dx">And there is serial correlation.</figcaption></figure><p id="3708" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在，这个时间序列，死亡是很难解释的。自相关是肯定存在的，它下降得很快，差分抵消了任何自相关。因此，有人会说数据是不稳定的，必须差分才能如此，但不是所有的测试都同意。当然，统计测试依赖于样本大小，这个时间序列真的不是很长，而且很奇怪。</p><p id="4e7b" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">因此，接下来要做的是检查和评估两个单变量时间序列之间的差异。现在，我确实知道它们在规模上有很大的不同，但这不一定有关系。重要的是差异。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="4645" class="kc kd hh jy b fi ke kf l kg kh">VECM_ECT&lt;-Deathts - VAXts<br/>ADF_DeathtsVAX&lt;-ur.df(VECM_ECT, <br/>      lags = 2, <br/>      selectlags = "AIC", <br/>      type = "trend")<br/>summary(ADF_DeathtsVAX)<br/>plot(ADF_DeathtsVAX)<br/>tsm::ac(ADF_DeathtsVAX@res, max.lag = 20)<br/>tsm::gts_ur(ADF_DeathtsVAX)<br/>summary(ur.ers(Deathts - VAXts, <br/>       type="DF-GLS",<br/>       model = "trend", <br/>       lag.max=2))         <br/>adf.test(VECM_ECT, k=6)  <br/>adf.test(VECM_ECT, k=2)   <br/>Box.test(VECM_ECT, lag=6, <br/>         type="Ljung-Box")</span></pre><figure class="jt ju jv jw fd kk er es paragraph-image"><div class="er es mu"><img src="../Images/b1388426e588a22cb0edf89c484f39a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1016/format:webp/1*vEw4_SgovAsnFKh-afHjbQ.png"/></div><figcaption class="kn ko et er es kp kq bd b be z dx">Test statistics beat all the critical values — this is a time-series which is stationary with a constant and a trend.</figcaption></figure><div class="jt ju jv jw fd ab cb"><figure class="kr kk mv kt ku kv kw paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><img src="../Images/f368d5675e320f478203674e9775c119.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*BSmLmIHGlSrHfzsyEudB0g.png"/></div></figure><figure class="kr kk mv kt ku kv kw paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><img src="../Images/bb5f43b20aee5a5ff4dde3bb2650aeb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*KNV5jpZ0opfuq6UJ8IXwpw.png"/></div><figcaption class="kn ko et er es kp kq bd b be z dx mw di mx le">No auto-correlation anymore with such a model, meaning it is stationary after including the constant and the trend.</figcaption></figure></div><figure class="jt ju jv jw fd kk er es paragraph-image"><div class="er es my"><img src="../Images/a1db486dc1f1831add4edc13c949c661.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/format:webp/1*B088vgXKBrMGelTst-YQXQ.png"/></div><figcaption class="kn ko et er es kp kq bd b be z dx">Time-series is stationary.</figcaption></figure><figure class="jt ju jv jw fd kk er es paragraph-image"><div class="er es mz"><img src="../Images/c126ff1fefb45f4de97a2612b8446f79.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/format:webp/1*PPZHwr_J-4FExF69_cX8IQ.png"/></div><figcaption class="kn ko et er es kp kq bd b be z dx">At lag six non-stationary.</figcaption></figure><figure class="jt ju jv jw fd kk er es paragraph-image"><div class="er es na"><img src="../Images/46e9af6e1ff32776e6d1241197d91569.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/1*XyxkratVnbtaLthq-G9s-A.png"/></div><figcaption class="kn ko et er es kp kq bd b be z dx">However, at lag 2 it is. So, it really depends on what kind of lags you test on and I chose my lags based on the acf plots shown way above, the ones of the raw time-series.</figcaption></figure><figure class="jt ju jv jw fd kk er es paragraph-image"><div class="er es nb"><img src="../Images/73bf4c100be6b47a2f20c4ee519d3464.png" data-original-src="https://miro.medium.com/v2/resize:fit:940/format:webp/1*tTJoVMle1Yb5A-0zpRmICw.png"/></div><figcaption class="kn ko et er es kp kq bd b be z dx">The data is serial correlated, which is to be expected looking at the plots.</figcaption></figure><p id="d073" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">因此，协整的第一个检验表明，如果两个非平稳数据进行协整，它们会有一个平稳的差异。这并没有发生。然而，看这个图，在开始时肯定有一些共同整合，在结束时也有一些，但是很快就变得模糊了。幸运的是，有多种方法来测试协整，其中之一是动态回归。如果你想了解更多关于协整的内容，请看看这本<a class="ae js" href="https://www.pearson.com/en-us/subject-catalog/p/introduction-to-econometrics/P200000006421?view=educator" rel="noopener ugc nofollow" target="_blank">优秀的书</a>。它谈到了三种共同整合的方法，第一种我们刚刚做了。另一个博客谈论同样的三种方式，实际上使用了书中的数据，可以在这里找到<a class="ae js" href="https://www.econometrics-with-r.org/16-3-cointegration.html" rel="noopener ugc nofollow" target="_blank"/>。快速比较一下就会发现，我确实借用了这个博客的代码。</p><p id="f833" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在，我们来看第二种方法，它涉及到动态线性回归。如果两个单变量时间序列是协整的，那么协整回归中系数的OLS估计是一致的。由于时间序列的固有属性，OLS是不够的，人们必须回到动态OLS，其中滞后和领先可以被纳入。</p><p id="e734" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">因此，让我们回到<a class="ae js" href="https://cran.r-project.org/web/packages/dynlm/dynlm.pdf" rel="noopener ugc nofollow" target="_blank"> <strong class="iy hi"> dynlm </strong> </a> <strong class="iy hi"> </strong>包，并尝试共同整合VAX和死亡时间序列。下面你可以看到一个简单的动态回归的例子，不包括滞后和误差。误差本身是特别令人感兴趣的，尤其是如果它们符合平稳过程的特性，这正是我们所期望的。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="8499" class="kc kd hh jy b fi ke kf l kg kh">VAX_Death &lt;- dynlm(Deathts ~ VAXts)<br/>summary(VAX_Death)<br/>par(mfrow = c(2, 2))<br/>plot(VAX_Death)<br/>z_hat &lt;- resid(VAX_Death)<br/>dev.off();plot(z_hat)<br/>acf(z_hat)</span></pre><figure class="jt ju jv jw fd kk er es paragraph-image"><div class="er es nc"><img src="../Images/b64182d74e0ef45da0b6682e81ebcfd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1102/format:webp/1*PdAqRzZQzXYRwqWSG4Esmw.png"/></div><figcaption class="kn ko et er es kp kq bd b be z dx">The summary coming from the time-series regression.</figcaption></figure><figure class="jt ju jv jw fd kk er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es nd"><img src="../Images/af2809417daf228966c0d56a3d071a76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nxSQVFnytYWQvPlFeHsrQg.png"/></div></div><figcaption class="kn ko et er es kp kq bd b be z dx">Evaluation of the model shows the same attributes that one might expect from a normal linear regression.</figcaption></figure><div class="jt ju jv jw fd ab cb"><figure class="kr kk ne kt ku kv kw paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><img src="../Images/9c121b13c1e0d2d80c63f12de531c73b.png" data-original-src="https://miro.medium.com/v2/resize:fit:902/format:webp/1*sH9xI5vc4nJg9IeK-_daEQ.png"/></div></figure><figure class="kr kk nf kt ku kv kw paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><img src="../Images/d396ffe6f8646d15367f845d381c539b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*Kc5gTRm-G5Y4gJWNUr5fOg.png"/></div><figcaption class="kn ko et er es kp kq bd b be z dx ng di nh le">The residuals, plotted.</figcaption></figure></div><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="68e9" class="kc kd hh jy b fi ke kf l kg kh">tsm::gts_ur(z_hat)</span></pre><figure class="jt ju jv jw fd kk er es paragraph-image"><div class="er es ni"><img src="../Images/332cf7af2d6e2d81a63225b9bd454451.png" data-original-src="https://miro.medium.com/v2/resize:fit:1098/format:webp/1*DiWSZ2U2GxDKHk_9EYIPfQ.png"/></div><figcaption class="kn ko et er es kp kq bd b be z dx">The residuals are only stationary if we include a constant and a trend, else they are not.</figcaption></figure><p id="14b6" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">从aTSA软件包中，我们还可以要求进行一个协整检验，其中进行了Engle-Granger(或EG)检验。这里的零假设是两个或两个以上的时间序列，每个都是I(1)，不协整。因此，为了进行这个测试，我们需要首先通过<em class="mc"> d=1 </em>对时间序列进行积分，然后查看结果。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="dfe3" class="kc kd hh jy b fi ke kf l kg kh">aTSA::coint.test(Deathts, VAXts, d = 1, nlag = 2, output = TRUE)</span></pre><figure class="jt ju jv jw fd kk er es paragraph-image"><div class="er es nj"><img src="../Images/90fe931b4e6cc08829fb9e499abccbbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:778/format:webp/1*TdQWY0gO_y3vXO0j6Xv65A.png"/></div><figcaption class="kn ko et er es kp kq bd b be z dx">It seems that, at lag 2, the data are cointegrated at the 1% level at no trend.</figcaption></figure><p id="b1e2" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果我们想将这些结果与之前的程序进行比较，我们需要通过包含差异和包含滞后来扩充该程序，分别设置为<em class="mc"> d=1 </em>和<em class="mc"> lag=2 </em>。为了让at更有趣，我们可以用两种方式来做这个分析:</p><ol class=""><li id="7bdc" class="nk nl hh iy b iz ja jc jd jf nm jj nn jn no jr np nq nr ns bi translated">VAX的死亡回归</li><li id="d9dd" class="nk nl hh iy b iz nt jc nu jf nv jj nw jn nx jr np nq nr ns bi translated">回归死亡中的VAX</li></ol><p id="1d86" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当然，第一个是我们最感兴趣的。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="b794" class="kc kd hh jy b fi ke kf l kg kh">VECM_EQ1&lt;-dynlm(d(Deathts)~L(d(VAXts),1:2)+L(d(Deathts),1:2)+ L(VECM_ECT))</span><span id="9128" class="kc kd hh jy b fi ki kf l kg kh">VECM_EQ2&lt;-dynlm(d(VAXts)~L(d(VAXts),1:2)+L(d(Deathts),1:2) + L(VECM_ECT))</span></pre><figure class="jt ju jv jw fd kk er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es ny"><img src="../Images/ed1e9e4fc9dbf2297de17a81077c1444.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gBteLIKPrsZq4GngCv6n-g.png"/></div></div><figcaption class="kn ko et er es kp kq bd b be z dx">The results for regressing Death on VAX</figcaption></figure><figure class="jt ju jv jw fd kk er es paragraph-image"><div class="er es nz"><img src="../Images/99cd5e2d7ba3c64e4593a43497dfc03d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/1*V_aYotLh_5xDXWmD1hvXqQ.png"/></div><figcaption class="kn ko et er es kp kq bd b be z dx">The results for regressing VAX on Death</figcaption></figure><p id="cd3a" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在，这两个模型的主要兴趣是，并将永远是，剩余部分。到目前为止，我们所做的一切每次都集中在错误部分，这就是我们将用<a class="ae js" href="https://www.rdocumentation.org/packages/lmtest/versions/0.9-40/topics/coeftest" rel="noopener ugc nofollow" target="_blank"><em class="mc">coeftest</em></a><em class="mc"/>函数再次做的事情。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="68ee" class="kc kd hh jy b fi ke kf l kg kh">names(VECM_EQ1$coefficients) &lt;- c("Intercept", "D_VAXts_l1", "D_VAXts_l2", "D_Deathts_l1", "D_Deathts_l2", "ect_l1")</span><span id="0370" class="kc kd hh jy b fi ki kf l kg kh">names(VECM_EQ2$coefficients) &lt;- names(VECM_EQ1$coefficients)</span><span id="7423" class="kc kd hh jy b fi ki kf l kg kh">coeftest(VECM_EQ1,vcov.=NeweyWest(VECM_EQ1,prewhite=F,adjust=T))<br/>coeftest(VECM_EQ2,vcov.=NeweyWest(VECM_EQ2,prewhite=F,adjust=T))</span></pre><p id="6cf4" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">从输出中可以看出，VAX的第一滞后和死亡的第二滞后影响死亡。至少，在第一个模型中。在第二个模型中，我们还可以看到，VAX的第一和第二个滞后影响了VAX，死亡几乎影响了VAX，错误也有影响。从这里看，VAX和死亡是否结合在一起还不是很清楚，当然VAX的变化也不会导致死亡的变化。</p><figure class="jt ju jv jw fd kk er es paragraph-image"><div class="er es oa"><img src="../Images/132424cfbe2ddb9aa92e0264bf941421.png" data-original-src="https://miro.medium.com/v2/resize:fit:1370/format:webp/1*IbP3_yxvxI1tat0SCnfI6g.png"/></div><figcaption class="kn ko et er es kp kq bd b be z dx">In the first model, the error is not significant from zero, but in the second it is. Not sure yet how to best interpret this, besides perhaps that the relationship is not per se of VAX on Death but vice versa. Biologically, that could make sense, as well as sociologically, although that would mean that the death rate as communicated would directly influence the tendency to vaccinate, and the ability to do so.</figcaption></figure><p id="b25c" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">另一个要进行协整评估的是通过<a class="ae js" href="https://cran.r-project.org/web/packages/car/index.html" rel="noopener ugc nofollow" target="_blank"><strong class="iy hi"/></a><strong class="iy hi"/>包，其中有一个<a class="ae js" href="https://www.rdocumentation.org/packages/car/versions/3.1-0/topics/linearHypothesis" rel="noopener ugc nofollow" target="_blank"><em class="mc"/></a><em class="mc"/>函数。在这种形式中，可以根据frequentist统计测试来测试滞后值是否相关。所以，在第一部分，我通过建立一个限制模型并去掉它们，来测试VAX的滞后值是否对死亡有影响。在下一个模型中，我们做了同样的事情，但是是关于死亡和VAX之间的关系。记住，每次我构建一个受限模型。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="24c0" class="kc kd hh jy b fi ke kf l kg kh">car::linearHypothesis(VECM_EQ1, <br/>                 hypothesis.matrix=c("D_VAXts_l1", <br/>                 "D_VAXts_l2"),<br/>                 vcov. = sandwich)</span><span id="3912" class="kc kd hh jy b fi ki kf l kg kh">car::linearHypothesis(VECM_EQ2, <br/>                      hypothesis.matrix=c("D_Deathts_l1",<br/>                      "D_Deathts_l2"),<br/>                      vcov. = sandwich)</span></pre><figure class="jt ju jv jw fd kk er es paragraph-image"><div class="er es ob"><img src="../Images/6db63dcef551b21eac6fe3be7e49be3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1194/format:webp/1*TmjKn3OLTmQqjw19G9vToA.png"/></div><figcaption class="kn ko et er es kp kq bd b be z dx">The restricted model is not better, meaning that the lags of VAX should be included.</figcaption></figure><figure class="jt ju jv jw fd kk er es paragraph-image"><div class="er es oc"><img src="../Images/a003e355b268526ca98c2a9b5f190e6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1270/format:webp/1*M9kEO4CzKaJWUmhDV1nf7w.png"/></div><figcaption class="kn ko et er es kp kq bd b be z dx">The restricted model is better, meaning that the lags of Death on VAX do not add much. One could already see that from the previous model summary</figcaption></figure><p id="c02c" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们也可以测试误差是否为零，但最后一步是<a class="ae js" href="https://www.rdocumentation.org/packages/lmtest/versions/0.9-40/topics/grangertest" rel="noopener ugc nofollow" target="_blank"> <em class="mc">格兰杰</em> </a>测试，这通常被称为<a class="ae js" href="https://en.wikipedia.org/wiki/Granger_causality" rel="noopener ugc nofollow" target="_blank">格兰杰因果关系测试</a>。如果以前在<a class="ae js" href="https://blog.devgenius.io/the-effect-of-covid-measures-on-covid-outcomes-a-vector-autoregressive-moving-average-exogenous-dd7fa6c3774f" rel="noopener ugc nofollow" target="_blank">尝试将锁定措施与重要的Covid KPI</a>连接时使用过该测试。这里，我将加上lag=2，因为我们一直都是这么做的。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="270f" class="kc kd hh jy b fi ke kf l kg kh">grangertest(Deathts~VAXts, order = 2)<br/>grangertest(VAXts~Deathts, order = 2)</span></pre><p id="ab6c" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">第一个测试试图比较包含和不包含VAX滞后的模型。好像型号2(也就是缩小版的型号)也不是更好。所以，VAX的滞后对死亡的滞后是有影响的。在第二个测试中，我们再次建立了一个滞后和重复模型，并看到死亡的滞后并没有给VAX增加多少。这意味着简化的模型，只包含VAX的滞后来预测VAX是足够的。这一发现有利于VAX水平影响死亡水平。</p><figure class="jt ju jv jw fd kk er es paragraph-image"><div class="er es od"><img src="../Images/b117491364f517cd42fdcca2302b62bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1114/format:webp/1*wDlmJhVmGzjWOBaFmWw9zA.png"/></div><figcaption class="kn ko et er es kp kq bd b be z dx">You see we have two test, looking at two models each.</figcaption></figure><p id="cf7c" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">另一个协整检验是通过<a class="ae js" href="https://www.rdocumentation.org/packages/urca/versions/1.2-9/topics/ca.jo" rel="noopener ugc nofollow" target="_blank"> <em class="mc"> ca.jo </em> </a>对VAR的<a class="ae js" href="https://en.wikipedia.org/wiki/Johansen_test" rel="noopener ugc nofollow" target="_blank"> Johansen过程</a>。这不是一个简单的测试，涉及到等级。由于我们只有两个单变量时间序列，我们只能有两个等级:<em class="mc"> r=0 </em>或<em class="mc"> r≤1 </em>。这意味着要么不存在协整(<em class="mc"> r=0 </em>)，要么存在(<em class="mc"> R≤1 </em>)。让我们指定这样一个模型，使用和以前一样的滞后数。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="51e3" class="kc kd hh jy b fi ke kf l kg kh">jotest=ca.jo(data.frame(VAXts,Deathts), <br/>             type="trace", <br/>             K=2, <br/>             ecdet="none", <br/>             spec="longrun")<br/>summary(jotest) <br/>plot(jotest)</span></pre><figure class="jt ju jv jw fd kk er es paragraph-image"><div class="er es oe"><img src="../Images/bca0151d0acff9af4abc2f76fd55dbe5.png" data-original-src="https://miro.medium.com/v2/resize:fit:902/format:webp/1*oC3UCuguO9mjcfYemuoTtQ.png"/></div><figcaption class="kn ko et er es kp kq bd b be z dx">The model clearly shows that there is no cointegration present.</figcaption></figure><div class="jt ju jv jw fd ab cb"><figure class="kr kk of kt ku kv kw paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><img src="../Images/862fd6f97f33cb8cb32a6a9088c83f23.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/1*4dYId16qI7gL7bwgiDEKcw.png"/></div></figure><figure class="kr kk og kt ku kv kw paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><img src="../Images/ede2fffb403248a7c95602a81bbee305.png" data-original-src="https://miro.medium.com/v2/resize:fit:1150/format:webp/1*V-8uWO9AMSYqouUyOKxLlA.png"/></div></figure></div><p id="e6d7" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">最后，同样重要的是，我们可以使用<a class="ae js" href="https://www.rdocumentation.org/packages/vars/versions/1.5-6/topics/VAR" rel="noopener ugc nofollow" target="_blank"> <em class="mc"> VAR </em> </a> <em class="mc"> </em>函数，构建一个VAR，或<a class="ae js" href="https://www.r-bloggers.com/2021/11/vector-autoregressive-model-var-using-r/#:~:text=For%20a%20vector%20times%20series,model%20and%20error%20correction%20equations." rel="noopener ugc nofollow" target="_blank"> <strong class="iy hi">向量自回归模型</strong> </a>。为此，我们需要构建一个多元时间序列对象，对其求差，并在lag=2时运行它。VAR模型没有回归VAX死亡或VAX死亡的偏好。不，它是同时进行的，您将在接下来的总结中看到。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="25e0" class="kc kd hh jy b fi ke kf l kg kh">combined&lt;-ts.union(diff(VAXts), diff(Deathts))<br/>plot(combined)<br/>VAR_est &lt;- VAR(y = combined, p = 2)<br/>summary(VAR_est)</span></pre><figure class="jt ju jv jw fd kk er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es oh"><img src="../Images/bff7c8470b6315927844b433df21821d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CRpTkpFWgzm0q33-bw091Q.png"/></div></div><figcaption class="kn ko et er es kp kq bd b be z dx">The multivariate ts object created.</figcaption></figure><p id="30d9" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">和VAR模型的总结，把VAX的死亡和VAX的死亡放在一起看，它们是包含双重滞后的不同时间序列。VAX模型没有提供太多，但是死亡模型提供了，其中VAX的第一个滞后再次是显著的，但是强度非常小。当然，时间序列有不同的数量级，但与常数相比，外生变量的影响很小。实际上，最大的影响来自于常数，因此也来自于死亡本身。</p><figure class="jt ju jv jw fd kk er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es oi"><img src="../Images/2f0bb8eeb1c6b99137d4c0b92afa0900.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UT9UP6VhYpztScnfSRr2SQ.png"/></div></div></figure><p id="82a5" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">好了，博客到此结束。现在，主要的目的并不是一定要把VAX和死亡联系起来，而是要表明协整分析是多么困难。我们使用了多种方法，我找不到一个稳定的协整模式，这意味着两个序列的差异显示了一个稳定的形式。此外，应用的许多指标和矢量建模并没有显示出有吸引力的联系，这一点从一开始看图表时就非常清楚。第一条曲线很奇怪，但其余的逐渐消失。</p><figure class="jt ju jv jw fd kk er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es oj"><img src="../Images/95d1e3105910fb0bec573cbbb673eeeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q4xE0SohEYH3qAeG07LArg.png"/></div></div></figure><p id="cc72" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果真的有联系，下一轮的疫苗应该会导致另一次冲击。</p><p id="92c2" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">希望你喜欢这篇文章，如果有什么不对的地方，请告诉我！</p><div class="ok ol ez fb om on"><a rel="noopener follow" target="_blank" href="/mlearning-ai/mlearning-ai-submission-suggestions-b51e2b130bfb"><div class="oo ab dw"><div class="op ab oq cl cj or"><h2 class="bd hi fi z dy os ea eb ot ed ef hg bi translated">Mlearning.ai提交建议</h2><div class="ou l"><h3 class="bd b fi z dy os ea eb ot ed ef dx translated">如何成为Mlearning.ai上的作家</h3></div><div class="ov l"><p class="bd b fp z dy os ea eb ot ed ef dx translated">medium.com</p></div></div><div class="ow l"><div class="ox l oy oz pa ow pb kl on"/></div></div></a></div></div></div>    
</body>
</html>