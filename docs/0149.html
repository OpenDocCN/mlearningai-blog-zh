<html>
<head>
<title>Heuristic Search: A* Search</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">启发式搜索:A*搜索</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/heuristic-search-a-search-1e3e41d1802?source=collection_archive---------0-----------------------#2021-02-22">https://medium.com/mlearning-ai/heuristic-search-a-search-1e3e41d1802?source=collection_archive---------0-----------------------#2021-02-22</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="793a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在不知情的搜索中，我们不会朝目标前进。换句话说，我们不会问“达到目标的成本是多少？”。</p><p id="c89b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了猜测从搜索中的一个状态到达目标的成本，我们需要一个<strong class="ig hi">启发式函数h(n)</strong>，它是特定于领域的。这样，搜索将比盲目搜索更加智能。</p><h1 id="7e83" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">A*搜索</h1><p id="99b1" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">我们考虑启发式函数和到达目标的估计，而不是到达节点的真实成本函数。因此，A*搜索被定义为实际成本和启发式函数的总和。该算法考虑了到达一个节点的成本和从该节点到达目标的成本估计。</p><p id="5fe1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">该搜索基于以下公式</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div class="er es kf"><img src="../Images/ab12b3ea82d1e79205fa59cdd6d4b970.png" data-original-src="https://miro.medium.com/v2/resize:fit:596/format:webp/1*4U3vuYw2UsiIOwDFG0jCqQ.png"/></div></figure><p id="ce35" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在哪里，</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="er es kn"><img src="../Images/396418f0df1f532a88da6a96d5e97909.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eN2xa6QUra5wfBlncKsZnw.png"/></div></div></figure><p id="a753" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们使用f(n)作为优先级队列中节点的优先级，frontier。</p><h1 id="bc5f" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">例子</h1><figure class="kg kh ki kj fd kk er es paragraph-image"><div class="er es ks"><img src="../Images/f5f48ca88d776eeae8cc45b8453d7ef3.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/format:webp/1*CKpAcA6Wr8dADzNrLuYE6Q.png"/></div></figure><figure class="kg kh ki kj fd kk er es paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="er es et"><img src="../Images/d07048af66a52b87ced0f4785fee03a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gUOothJEPu1w6ZhJN6ib-w.png"/></div></div></figure><pre class="kg kh ki kj fd kt ku kv kw aw kx bi"><span id="5eb6" class="ky jd hh ku b fi kz la l lb lc"><strong class="ku hi"><em class="ld">         We always pick the lowest f(n) from the frontier</em></strong></span></pre><figure class="kg kh ki kj fd kk er es paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="er es le"><img src="../Images/d51e7595c8fc7f07073479add0a3d0e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BjmKLA0Fdf3Fp6ZVE0rPjg.png"/></div></div></figure><p id="b483" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，让我们考虑一下启发函数的估计有多好。</p><p id="bfe3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">好的启发式函数提供最优性，这意味着没有高估。如果存在对启发式函数的过高估计，那么我们可能会在更晚的时间探索搜索空间。因为我们总是从前沿选取最低的f(n)值。在这种情况下，A*搜索无法找到最佳路径。与此相反，如果存在对启发式函数的低估，则搜索空间有机会被早期探索。</p><h1 id="0642" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">容许性</h1><p id="888d" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">一个可接受的启发永远不会高估真正的成本。因为它小于或等于真实成本，所以A*搜索保证找到最优解。</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div class="er es lf"><img src="../Images/23c7806b2651edf0cb182b90a10c18fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*j2MDMeMRHSDh_w4nbSWAQQ.png"/></div></figure><h1 id="b262" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">检查可接受性</h1><figure class="kg kh ki kj fd kk er es paragraph-image"><div class="er es lg"><img src="../Images/2bc249939450bcf2e1ec4d3dec2a4891.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/format:webp/1*wVG3dNEIhvQ_W7ZyCEgZ_A.png"/></div></figure><figure class="kg kh ki kj fd kk er es paragraph-image"><div class="er es lh"><img src="../Images/28fe34c5b91ba444d3eb07d44fb21c41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*6rtwoZQRYgcld_wTky4WSA.png"/></div></figure><p id="1344" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">每个方程必须满足它的条件，才能有一个可接受的启发。如果其中一个是不可接受的，那么我们说它不是一个可接受的启发。</p><p id="45d0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们考虑这样一个问题“如果搜索不止一次访问这些州会怎么样？”</p><h1 id="34c4" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">单调性</h1><figure class="kg kh ki kj fd kk er es paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="er es li"><img src="../Images/5cc7672125dd83edee2b2d7dbb3d2715.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1HjGg4JgcZ8JDzvH-FncUA.png"/></div></div></figure><p id="7b9d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">单调试探法具有针对所有节点n1和n2的条件</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div class="er es lj"><img src="../Images/7c124b5a392769b31246358e7b3471a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:784/format:webp/1*hQ0WbPwuC7GBKyeq9tsaig.png"/></div></figure><p id="0d6a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果一个启发式函数是一致的，A*搜索就不会被分散注意力。因此，单调性保证了一个状态被探索一次。</p><p id="802b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">此外，f(n)值沿任何路径都不会减少。</p><p id="03eb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">作为单调性的结果，</p><blockquote class="lk ll lm"><p id="10c6" class="ie if ld ig b ih ii ij ik il im in io ln iq ir is lo iu iv iw lp iy iz ja jb ha bi translated"><strong class="ig hi">用一个单调的试探法，A*第一次扩展一个州，它就找到了到那个州的最小成本路径。</strong></p></blockquote><h1 id="d2d5" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">检查单调性</h1><figure class="kg kh ki kj fd kk er es paragraph-image"><div class="er es lq"><img src="../Images/ffc3aa45441277bb555da2cd2af00a8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1176/format:webp/1*PteAb-Fny80G4G0l7iWnqA.png"/></div></figure><figure class="kg kh ki kj fd kk er es paragraph-image"><div class="er es lr"><img src="../Images/5e257511f6c6fbc95f65674d41a7ae3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:576/format:webp/1*aRQhPreugCwCIpTtIFkEDA.png"/></div></figure><p id="2a8b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果其中一个方程不满足，那么启发式算法就不是单调的。</p><h1 id="ca65" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">*搜索的属性</h1><p id="40ac" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">随着f值的增加，A*搜索会扩展节点。</p><p id="8cc5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">搜索完毕<strong class="ig hi">。</strong></p><p id="f257" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">A*搜索是<strong class="ig hi">最优的，如果启发式搜索是可接受的，则为</strong>。</p><p id="f2b0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">A*搜索具有指数级<strong class="ig hi">时间复杂度</strong>。</p><p id="524f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">A*搜索将所有节点保存在内存中。</p><p id="2291" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">理想的启发式函数接近于成本函数。</p><pre class="kg kh ki kj fd kt ku kv kw aw kx bi"><span id="0f8b" class="ky jd hh ku b fi kz la l lb lc"><strong class="ku hi"><em class="ld">          If h(n)=0, the search will be the Uniform Cost Search</em></strong></span></pre><h1 id="a004" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">迭代深化A* (IDA*)</h1><p id="3632" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">当扩展指数数量的节点时，A*搜索可能会遇到一些空间问题。为了解决空间问题，我们可以使用迭代深化A*搜索。迭代深化也是如此。在这种情况下，“截止值”是f值，IDA*在每次迭代时增加截止值。就空间而言，IDA*比A*更有效。而且，IDA*是完全最优的。</p><h1 id="7353" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">履行</h1><p id="c11e" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">这是一个GitHub存储库，其中包括用Python实现的A*搜索和统一成本搜索算法。在这个项目中，我尝试用这些搜索算法来解决Bloxorz游戏。</p><div class="ls lt ez fb lu lv"><a href="https://github.com/ecealptekin/Solving-Bloxorz-using-UCS-and-A-Search" rel="noopener  ugc nofollow" target="_blank"><div class="lw ab dw"><div class="lx ab ly cl cj lz"><h2 class="bd hi fi z dy ma ea eb mb ed ef hg bi translated">ecealptekin/Solving-Bloxorz-using-UCS-and-A-Search</h2><div class="mc l"><h3 class="bd b fi z dy ma ea eb mb ed ef dx translated">通过在GitHub上创建帐户，为ecealptekin/Solving-Bloxorz-using-UCS-and-A-Search开发做出贡献。</h3></div><div class="md l"><p class="bd b fp z dy ma ea eb mb ed ef dx translated">github.com</p></div></div><div class="me l"><div class="mf l mg mh mi me mj kl lv"/></div></div></a></div><p id="2540" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">你可以在这里玩游戏来了解一下。</p><div class="ls lt ez fb lu lv"><a href="https://www.coolmathgames.com/0-bloxorz" rel="noopener  ugc nofollow" target="_blank"><div class="lw ab dw"><div class="lx ab ly cl cj lz"><h2 class="bd hi fi z dy ma ea eb mb ed ef hg bi translated">Bloxorz</h2><div class="mc l"><h3 class="bd b fi z dy ma ea eb mb ed ef dx translated">1)游戏的目的是在每个阶段结束时让积木落入方孔中。有33个阶段…</h3></div><div class="md l"><p class="bd b fp z dy ma ea eb mb ed ef dx translated">www.coolmathgames.com</p></div></div><div class="me l"><div class="mk l mg mh mi me mj kl lv"/></div></div></a></div><p id="0bb9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我将这个难题建模为一个搜索问题:指定状态、后继状态函数、初始状态、目标状态和步骤成本。之后，我用Python实现了一个统一成本搜索算法和一个A*搜索算法，其中包含一个启发式函数来解决这个难题。</p><p id="2137" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">根据我的实现，我创建了Bloxorz游戏的五个示例阶段，并将它们用作输入。最后，我比较了均匀代价搜索和A*搜索算法在这些样本难题上的性能。此外，表格显示了两种算法的时间和内存消耗。</p><h1 id="a5f4" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">参考</h1><figure class="kg kh ki kj fd kk"><div class="bz dy l di"><div class="ml mm l"/></div></figure><p id="18bb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae mn" href="https://web.cs.hacettepe.edu.tr/~pinar/courses/BBM405/lectures/informed_search.pdf" rel="noopener ugc nofollow" target="_blank">https://web . cs . hacettepe . edu . tr/~ pinar/courses/bbm 405/lessons/informed _ search . pdf</a></p></div></div>    
</body>
</html>