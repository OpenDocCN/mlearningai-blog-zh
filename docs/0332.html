<html>
<head>
<title>Distribution-Free Graph Kernels and Spatial Graph Neural Networks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">无分布图核和空间图神经网络</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/distribution-free-graph-kernels-and-spatial-graph-neural-networks-350ea434ad06?source=collection_archive---------9-----------------------#2021-03-23">https://medium.com/mlearning-ai/distribution-free-graph-kernels-and-spatial-graph-neural-networks-350ea434ad06?source=collection_archive---------9-----------------------#2021-03-23</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="6e45" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">图表的真正力量在于其灵活的结构，可以随着时间的推移而调整。然而，为了适应节点和边，必须有一些原则性的机制来决定图形的未来版本。通过评估适应性拟合优度。</p><p id="8666" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">通常，图同构测试用于挑选具有近似甚至精确结构属性的相似图，这些图最终具有近似嵌入。这种测试在计算机视觉检测和识别应用中具有各种应用。基于机器学习的时间过程建模和状态预测系统。</p><p id="5a04" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">任何任意结构都可以被建模为一组节点和边。这些可以代表任何粒度级别的任何概念建模。例如，节点可以表示系统中任何可识别的实体及其特征。这种实体可以处于任何模块化水平，从单个人类细胞及其与邻近细胞的生理相互作用到细胞本身内部的分子相互作用。然后，我们可以看到基于图形的复杂世界的表现是多么普遍。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es jc"><img src="../Images/56c789f9eeb0fa657715ed514f911bfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:304/format:webp/1*Soaqb6qbAarWeI4cV-2Obw.png"/></div></figure><p id="c2f4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这种情况下，概率评估作为传达所有未来选项的工具出现，作为评估适应有效性的一种方式。因此，存在符合概率模型的可接受的(即，似是而非的)结构适应，并且那些是应该由预测模型生成的结构适应。提及行人关系推理系统，并将图形内核引入基于图形的表示。</p><p id="8a11" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">给定动态系统中的<em class="jk"> G </em> = <em class="jk"> (V，E) </em>是具有<em class="jk"> V </em>个节点和<em class="jk"> E </em>条加权边的无向图，在节点的属性随时间变化的动态复杂系统中，寻找最优边集来建模节点之间的交互(即关系)的问题是NP-Hard问题。节点描述了系统的对象或主要组件，而边表示了涉及相同类别或具有共享属性的对象的关系。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es jl"><img src="../Images/9dd7f71fdea5d0d65df67868d9a79582.png" data-original-src="https://miro.medium.com/v2/resize:fit:774/format:webp/1*ISVacNMR-Y3bWMV_LdJ3Xg.png"/></div></figure><p id="9f4d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们将把建议的问题先验地归结为'<strong class="ig hi">寻找最佳邻接矩阵</strong>'，并且因为我们正在处理加权边，所以解空间<strong class="ig hi">ω</strong>是无限的；因此，可能存在多个最优解，而在有生之年找到它们是不可行的。作为问题的放松，我们将依赖于寻找次优的解决方案，其中邻接矩阵的估计是合理的和现实的，以反映节点之间的相互作用。</p><p id="dccf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们定义邻接矩阵(<em class="jk"> A </em>)使得<em class="jk">A</em>∈<strong class="ig hi">ω</strong><em class="jk"/>并且大小为<em class="jk">n×n</em>，描绘了对应于图中节点之间所有可能边对的方阵。寻找次优矩阵的目标与误差最小化和期望的结果相关联。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es jm"><img src="../Images/bbd750d76d07393523deafb79f8495da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6sawKUwENMIlDZO3KOJxIQ.png"/></div></div></figure><p id="609e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在深度学习中，图可以形成许多建模应用的底层结构。使得深度网络变成深度图，而不是规则形状的层。这被称为<em class="jk">图形神经网络(GNN)，</em>可以直接利用任意形状的输入作为图形结构数据(即节点和边)。GNN可以最终产生预测或分类输出，并且在给定的时间实例增强空间建模将反映动力系统的更好的表示，从而产生更高精度的结果。</p><p id="2ff5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了达到这样的结果，GNN依靠聚集和更新操作来替代图遍历作为测试解决方案空间的手段。在我们的例子中，GNN需要添加新的边或指定边集，以便在真实场景中相互交互的节点之间生成合理的关联。对节点和边的访问时间可以在O(1)中完成，然而，GNN本地函数并不清楚地支持遍历图和分配似是而非的关联的机制，所以这里我们建议两种可能的方式来呈现该机制:</p><p id="f757" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">(1)使用<em class="jk"> n x n </em>遍历来检查每一个一对一关联的回归问题，这种方法是GNN及其内部函数所固有的。</p><p id="03f9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">(2)图核方法，将整个图的边映射到邻接矩阵(a ),并将多个矩阵同时分解为一组建议Aᴾ。在本文中，我们考虑第二种方法，并介绍了非负矩阵分解(NMF)。NMF执行推荐系统部分，该部分立即推荐<em class="jk"> P </em>邻接提议，并在现有图上逐一部署它们以验证准确性。此外，我们提出了基于无监督核方法的边集部分搜索，以可行的时间方式估计边集权重，而不是强制所有可能的边集。</p><p id="e495" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">作为对NMF的放松，我们假设初始矩阵都是1<em class="jk">n×n</em>，这意味着所有节点都有相互关联。</p><p id="8519" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">后来，NMF将估计渗透关系，使得<em class="jk"> w </em> (i，j)和<em class="jk"> w </em> (j，I)可以具有不同的估计，并且结果A不一定是对称的。其中A = { <em class="jk"> w </em> (1，2)，<em class="jk"> w </em> (1，3)，… <em class="jk"> w </em> (i，j)}，这样有N个节点，w(n，m)是图中的最后一对，i∈n和j∈m，|n| = |m|和{n，m}∈ <em class="jk"> V </em>。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es jr"><img src="../Images/207fb5ab3fe85cf2813afbe9ea8f768e.png" data-original-src="https://miro.medium.com/v2/resize:fit:440/format:webp/1*EMohmEOlkVcTaDHMRmoq8Q.png"/></div></figure><p id="bfca" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">NMF现在将重构传入的深度特征，并且基于特征矩阵<em class="jk"> W </em>和分量矩阵<em class="jk"> H，s.t. W </em>被分配了边缘嵌入表示向量<strong class="ig hi">(</strong>)并且<em class="jk"> H </em>被分配了整个图H的隐藏状态:</p><p id="f208" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jk"> A </em> = <em class="jk"> NMF </em> (W，H)</p><p id="c1dc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">基于NMF的估计不依赖于先验分布假设，但是，从统计角度来看，超过400次运行后，结果似乎大多是稀疏矩阵，其中大多数估计权重接近于零，黄色条覆盖的估计范围反映了较高的权重。从下图的密度图来看，这种表示可以很好地符合标准高斯分布<strong class="ig hi"> μ = 0 </strong>和<strong class="ig hi"> σ = 1 </strong>。这使我们可以开发在设计和性能上更少定制的自治模型，这样该模型可以扩展到各种动态系统，而不是在某些条件或环境下使用。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es js"><img src="../Images/10f6c75927421fdf5983682296b93281.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D6zl6bQhO3Z7L3GjrnLGeQ.png"/></div></div></figure><p id="b29f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">总之，本文讨论了寻找最佳邻接矩阵的实际应用。为此，本文提出了一种无监督图核，它依靠非负矩阵分解(NMF)来分解加权有向图的边，以取代穷举的经典搜索方法，并且仍然可以在搜索空间中找到次优解。内核可以被扩展到多种目的，其中图是底层建模架构，并且不需要太多的统计表征工作，内核可以从断开的图开始，并且以无分布的方式运行，这使得方法不太倾向于上下文定制，并且在建模中给出更高的自由度。</p><p id="6f11" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">来源和相关参考资料:</p><p id="8c3b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">图形神经网络综述:</strong><a class="ae jt" href="https://arxiv.org/pdf/1901.00596.pdf" rel="noopener ugc nofollow" target="_blank">https://arxiv.org/pdf/1901.00596.pdf</a></p><p id="6e54" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">上下文感知行人轨迹预测的自生长空间图网络:【https://arxiv.org/pdf/2012.06320.pdf】T22</strong>T23】</p><p id="b479" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">用图形神经网络进行组合优化和推理:</strong><a class="ae jt" href="https://arxiv.org/pdf/2102.09544.pdf" rel="noopener ugc nofollow" target="_blank">https://arxiv.org/pdf/2102.09544.pdf</a></p></div></div>    
</body>
</html>