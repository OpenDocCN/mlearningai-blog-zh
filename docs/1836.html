<html>
<head>
<title>Classification algorithms 1: Logistic Regression Part-1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">分类算法1:逻辑回归第一部分</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/classification-algorithms-1-logistic-regression-part-1-a2b0dab31b5a?source=collection_archive---------9-----------------------#2022-02-02">https://medium.com/mlearning-ai/classification-algorithms-1-logistic-regression-part-1-a2b0dab31b5a?source=collection_archive---------9-----------------------#2022-02-02</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="2109" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">萨提亚·克里希南·苏雷什</p><p id="1ea2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">简介:</strong> <br/>逻辑回归是一种监督机器学习分类算法，它很简单，在分类问题上表现得非常好。它已被用于天气、疾病预测、自然语言处理中的情感分析等。这里我们试着理解一下逻辑回归。</p><p id="86c5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">定义:</strong> <br/>在我开始谈论逻辑回归之前，理解构成逻辑回归基础的某些术语是很重要的。<br/> <strong class="ig hi"> Logit函数:</strong><br/>Logit函数是赔率的对数。让我们假设‘p’是事件发生的概率。那么有利于事件发生的几率就是“p”与“1-p”的比值。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/e947baf42d1690a68264b455add70507.png" data-original-src="https://miro.medium.com/v2/resize:fit:602/format:webp/1*LjpXZTlxWOI00QAbuiGGcA.png"/></div><figcaption class="jl jm et er es jn jo bd b be z dx">Logit function</figcaption></figure><p id="6d3c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">logit函数接受0–1范围内的值，并输出一个实数值。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jp"><img src="../Images/aee9d718805a785c11f4d77745d010d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*7BK3JcC6SZ7QUR4qc9b2jQ.png"/></div></figure><p id="5692" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> Sigmoid函数:<br/></strong>Sigmoid函数，也叫logistic sigmoid函数，是构成logistic回归核心的函数。与其定义它，我来展示一下sigmoid函数的方程。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jq"><img src="../Images/593eb25e4a5392425b307294283e1e8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:494/format:webp/1*ujl2--x_csSkqjS9kC8uIA.png"/></div><figcaption class="jl jm et er es jn jo bd b be z dx">sigmoid function</figcaption></figure><p id="dae5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">sigmoid函数接受一个实数值，并将其压缩到0到1之间。这个函数非常重要，因为它是逻辑回归的激活函数，并且它还赋予算法预测事件概率的能力，这是我们用Adaline或感知器无法做到的。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jp"><img src="../Images/b8014219204251ac912397c6a306dee4.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*7FTWSdGSCrflI2xCbxYM9A.png"/></div></figure><p id="929c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">从上图可以看出，sigmoid函数将输入压缩到0到1之间。</p><p id="eb0d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">最大似然函数:<br/> </strong>最大似然函数是逻辑回归的代价函数。这个函数的定义是高度统计性的，理解这个定义对有效地实现逻辑回归模型没有影响。让我们看看函数的方程，然后进入逻辑回归。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jr"><img src="../Images/bcf913f43adea4108417134f4d9ac744.png" data-original-src="https://miro.medium.com/v2/resize:fit:850/format:webp/1*WGyxDpxNQgmSY-CdL_etrw.png"/></div><figcaption class="jl jm et er es jn jo bd b be z dx">Likelihood function</figcaption></figure><p id="63d3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">逻辑回归:<br/> </strong>首先让我来定义一下逻辑回归——逻辑回归是一种分类算法，它可以通过对净输入函数产生的输出应用sigmoid函数来预测属于某个类的概率(我在以前的文章中已经谈到过净输入函数)。</p><p id="3177" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">上面的定义以及本文前面给出的函数定义是实现逻辑回归所需要的。我们来一个一个的过逻辑回归的算法。</p><p id="664b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">起点是净输入函数。网络输入函数接收样本向量并给出一个实数值，我们可以<strong class="ig hi">将其与logit函数</strong>等同，因为logit函数也输出一个实数值。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es js"><img src="../Images/57a2b42e120d50251c0f0cb47523deb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:478/format:webp/1*NyotU0UdQC6fC7DGbyTFDQ.png"/></div></figure><p id="177c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">既然我们已经使logit函数与净输入相等，我们可以得到概率‘p’。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jt"><img src="../Images/155449b9dc7d62afec3a5a7b9c4dfb1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:662/format:webp/1*EMIdcoLuGLV5G1LtzRnCHQ.png"/></div></figure><p id="f5d7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">从上面的推导中，我们推断概率“p”就是净输入的sigmoid函数。但是p是什么的概率呢？“p”是类别1的概率。该等式通常如下所示，但为了简单起见，我省略了这一部分。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ju"><img src="../Images/e3afe4c21432a1dec2a8b97cb4b7efcd.png" data-original-src="https://miro.medium.com/v2/resize:fit:456/format:webp/1*oHtqiZBB_MWNqsrODD4ezQ.png"/></div><figcaption class="jl jm et er es jn jo bd b be z dx">;</figcaption></figure><p id="0d80" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对于给定的“x”特征，上述等式被解读为样本向量“x”属于样本类1(y = 1)的概率。在此基础上，我们建立了逻辑回归模型的激活函数模型。</p><p id="2250" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在我们来谈谈成本函数。成本函数是最大似然函数，但是以其原始形式使用它将在计算上是昂贵的。通过简单地对方程应用自然对数，降低了计算复杂度。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jv"><img src="../Images/3332f2e26fb32722b180633ead17d6c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1186/format:webp/1*nd3G0l1Te6MaNfThVcLTmA.png"/></div><figcaption class="jl jm et er es jn jo bd b be z dx">Log likelihood</figcaption></figure><p id="c041" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">上述方程被称为对数似然函数，逻辑回归模型将试图使用梯度上升优化技术使其最大化。但是因为我们已经熟悉了梯度下降，我们想在这里应用同样的技术。通过简单地将等式乘以负号，可以将上述等式修改为使用梯度下降。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jw"><img src="../Images/9152f7be4ccde6dee36d3076aca493db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1070/format:webp/1*gCp3z_Kqzgdtf9ESLFGVcg.png"/></div><figcaption class="jl jm et er es jn jo bd b be z dx">Negative log likelihood</figcaption></figure><p id="038f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">上面给出的是逻辑回归成本函数的最终形式。现在让我们试着插入y的值。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jx"><img src="../Images/de7bf7fe74da83c35629e5de680f65d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:778/format:webp/1*qJZxnKaq__PY2Eq2IrhY5A.png"/></div></figure><p id="d6e0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了更清楚地理解上面的等式，让我们把它画出来。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jy"><img src="../Images/a81ca9ae4a448bab203594653005cadf.png" data-original-src="https://miro.medium.com/v2/resize:fit:998/format:webp/1*i4-8SGtR-xLLoe8DI9t6Ig.png"/></div></figure><p id="2e8f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">从上面的图中，需要注意的重要事情是，当属于一个类别的概率被正确预测时，成本函数具有非常低的值，但是当它被错误预测时，成本函数呈指数增长。这就是为什么逻辑回归是如此有效的算法，因为它允许你打开引擎盖，看看它的工作机制。</p><p id="ddd1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">逻辑回归的实现:</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es jz"><img src="../Images/4e380e84b8b9e724953fba9af9a5bf27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gcHdnDVjt1cOuCFZ9SmWCQ.png"/></div></div></figure><p id="1b83" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">上面的逻辑回归实现包含了我在本文中讨论的所有内容。该代码与Adaline实现的代码非常相似，因为Adaline和逻辑回归仅在激活和成本函数上有所不同。上面代码中的激活函数是sigmoid函数，代价函数是负对数似然函数。另一个需要注意的重要事情是predict函数，每当激活函数的值大于或等于0.5时，它都返回1。这可以从本文前面给出的sigmoid函数图中理解。您可以将0.5视为阈值，超过该阈值，特征向量将属于我们预测概率的类别。</p><p id="4c2f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">结论:</strong></p><p id="9b68" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在第一部分中，我们已经讨论了逻辑回归背后的理论。在第2部分中，我将展示逻辑回归的scikit-learn实现以及超参数调优。但是下一篇文章将是关于“ML在定制网站设计中的应用”。我希望你在写这篇文章的时候和我一样开心。鼓掌，订阅，留言评论。</p><div class="ke kf ez fb kg kh"><a rel="noopener follow" target="_blank" href="/mlearning-ai/mlearning-ai-submission-suggestions-b51e2b130bfb"><div class="ki ab dw"><div class="kj ab kk cl cj kl"><h2 class="bd hi fi z dy km ea eb kn ed ef hg bi translated">Mlearning.ai提交建议</h2><div class="ko l"><h3 class="bd b fi z dy km ea eb kn ed ef dx translated">如何成为Mlearning.ai上的作家</h3></div><div class="kp l"><p class="bd b fp z dy km ea eb kn ed ef dx translated">medium.com</p></div></div><div class="kq l"><div class="kr l ks kt ku kq kv jj kh"/></div></div></a></div></div></div>    
</body>
</html>