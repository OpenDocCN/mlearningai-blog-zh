<html>
<head>
<title>Load Json.gz files to Azure ML dataset</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将Json.gz文件加载到Azure ML数据集</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/load-json-gz-files-to-azure-ml-dataset-b7039ec9da34?source=collection_archive---------0-----------------------#2021-04-15">https://medium.com/mlearning-ai/load-json-gz-files-to-azure-ml-dataset-b7039ec9da34?source=collection_archive---------0-----------------------#2021-04-15</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="38bb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一旦我们有了从Azure Data Explorer (ADX)加载数据到Azure ML的需求，因为我们没有Azure ML和ADX之间的直接集成，我们面临一些挑战。我们在ADX中使用了连续导出功能，并将所有数据从ADX导出到blob，以用于ADX的灾难发现目的。所以我们决定对Azure ML使用同样的方法。我们按照以下步骤来完成相同的，这将有助于只有当你的文件是在json.gz格式。你可以直接使用json是它的非压缩结构。</p><p id="bb9d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">创建数据集</strong></p><p id="2cc0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们可以使用Azure ML上的创建数据集选项，并通过指定包含所有json.gz文件的存储容器的详细信息来创建新的数据集。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es jc"><img src="../Images/2dd26a1f85602452af2ac058c04c82e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:832/format:webp/1*sq517DqcCcrJj9FFxWVTYg.png"/></div><figcaption class="jk jl et er es jm jn bd b be z dx">Create dataset</figcaption></figure><p id="87a9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">创建解压缩数据集</strong></p><p id="6f00" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">重复上述步骤，选择数据集到不同的容器保存解压缩文件。</p><p id="d3f0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">创建笔记本</strong></p><p id="8d3d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一旦数据集准备就绪，我们就可以用python创建一个新的笔记本，并开始编写代码来从blob存储中提取文件，并将其加载到数据集</p><p id="9230" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在让我们导入所需的库</p><pre class="jd je jf jg fd jo jp jq jr aw js bi"><span id="39ae" class="jt ju hh jp b fi jv jw l jx jy">from azureml.core import Workspace, Dataset, Datastorefrom azureml.data.dataset_factory import DataType<br/>import gzip<br/>import os</span></pre><p id="b9c1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在准备工作区对象，这将根据提供的详细信息创建工作区对象，这可用于从数据集创建数据集</p><pre class="jd je jf jg fd jo jp jq jr aw js bi"><span id="5dff" class="jt ju hh jp b fi jv jw l jx jy">subscription_id = ‘your-subscription-id’<br/>resource_group = ‘your-resourcegroup-name’<br/>workspace_name = ‘your-workspace-name’<br/>workspace = Workspace(subscription_id, resource_group, workspace_name)</span></pre><p id="82d7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在让我们创建用于处理的数据集</p><pre class="jd je jf jg fd jo jp jq jr aw js bi"><span id="cd6b" class="jt ju hh jp b fi jv jw l jx jy">datastore = Datastore.get(workspace, ‘datastore’)<br/>dest_datastore = Datastore.get(workspace, ‘datastore_unzip’)</span></pre><p id="c748" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在我们想从blob存储中准备文件列表，为此我们使用通配符表达式从存储中获取文件。这里我们从blob容器中过滤所有的json.gz文件</p><pre class="jd je jf jg fd jo jp jq jr aw js bi"><span id="e899" class="jt ju hh jp b fi jv jw l jx jy">datastore_paths = [(datastore, ‘/**.json.gz’)]</span></pre><p id="d03a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，我们使用上面步骤中的列表创建一个临时文件数据集，并将文件下载到集群中</p><pre class="jd je jf jg fd jo jp jq jr aw js bi"><span id="5d12" class="jt ju hh jp b fi jv jw l jx jy">qc_ds = Dataset.File.from_files(path=datastore_paths)<br/>qc_ds.download(target_path=’.’, overwrite=True)</span></pre><p id="bf72" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在我们有了文件列表和所有下载的要处理的文件，现在我们将遍历文件列表并解压缩每个文件，然后文件名将被保存到单独的列表中。Azure ML接受”。jsonl”文件。由于提取的文件已经在jsonl文件结构中，我们只需用“.”重命名该文件。jsonl”而不是“json.gz”</p><pre class="jd je jf jg fd jo jp jq jr aw js bi"><span id="48fe" class="jt ju hh jp b fi jv jw l jx jy">filelist = []<br/>for singlePath in qc_ds.to_path():<br/>  with gzip.open(“.” + singlePath, “r”) as f:<br/>    data = f.read()<br/>    fn = (“.” + singlePath.replace(“json.gz”, “jsonl”))<br/>    tf = open(fn, “w”)<br/>    tf.write(data.decode())<br/>    tf.close()<br/>filelist.append(os.path.abspath(fn))</span></pre><p id="663d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在我们已经有了提取的文件及其列表，所以让我们将这些文件上传到我们在第二步中创建的数据存储中。</p><pre class="jd je jf jg fd jo jp jq jr aw js bi"><span id="ee08" class="jt ju hh jp b fi jv jw l jx jy">dest_datastore.upload_files(filelist, overwrite=True)</span></pre><p id="6f19" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一旦数据被提取并在数据存储中可用，数据集就可以使用这些数据进行进一步处理。</p><p id="0f62" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了从数据存储区创建数据集，我们将通过筛选“*”来创建新的表格数据集。' jsonl '</p><pre class="jd je jf jg fd jo jp jq jr aw js bi"><span id="f8ad" class="jt ju hh jp b fi jv jw l jx jy">tabl_ds = Dataset.Tabular.from_json_lines_files(path=(dest_datastore,’*.jsonl’))<br/>tabl_ds = tabl_ds.register(workspace = workspace,name=’DS_Unzip’,description=’Decompressed Data’,create_new_version = True)</span></pre><p id="91d9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在我们可以看到新的数据集，其中包含了从json中提取的所有数据</p></div></div>    
</body>
</html>