<html>
<head>
<title>Understanding Perceptron</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解感知器</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/understanding-perceptron-8e82a5a97ea?source=collection_archive---------6-----------------------#2022-01-04">https://medium.com/mlearning-ai/understanding-perceptron-8e82a5a97ea?source=collection_archive---------6-----------------------#2022-01-04</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="c819" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在本文中，我们来看看机器学习中最古老的分类算法之一——感知器。</p><p id="683c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">贡献者:Sathya Krishnan Suresh，<a class="ae jc" href="http://Priya Suresh on Medium https://medium.com/@pshunmugapriya" rel="noopener ugc nofollow"> Shunmugapriya </a> P</p><p id="ff55" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">git hub Link:<a class="ae jc" href="https://github.com/SathyaKrishnan1211/understanding_perceptron" rel="noopener ugc nofollow" target="_blank">https://git hub . com/sathyakrishnan 1211/undermination _感知器</a></p><p id="893f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">感知器算法</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/af8f5875a01815061964319211b58bc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*HGGEHpDX4HfEZ8xY_0dxVQ.jpeg"/></div></figure><p id="9f20" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们假设有一组50名学生参加一次体检。根据每个人在各种项目中的体检分数，他们被分配到第一组(线下)或第二组(线上)。考试的及格分数是50分，这是所有考试的累积分数。因此，如果一个人的分数低于50分，他将被分配到第二组或第一组。<br/>这正是我们体内神经元的工作方式。对于发送信号的神经元，应达到阈值(在上述示例中为50)。如果不符合阈值，信号将不会被触发。感知器算法的工作方式也与模仿神经元的<strong class="ig hi">相同。</strong>它可以预测一个学生属于二元分类中的第一组或第二组。当涉及到多个类别时，感知器使用一对其余(Ovr)方法对样本进行分类。</p><p id="09de" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">感知器后面的数学</strong></p><p id="95fd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当您用一定数量的特征拟合数据集时，感知器模型会尝试为每个特征找到r <strong class="ig hi">权重或影响</strong>。这就像找到直线的斜率。每个特征的权重决定了相应特征对分类的<strong class="ig hi">影响程度</strong>。</p><p id="75d4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">假设“x”是一个样本数据集，目标标签是y。w是每个要素的权重向量。每当xi大于“c”时，yi就是1。这里c是阈值。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jl"><img src="../Images/fa2e7c5f80d0779d56a2ba099b1c2aea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VKQVOQ0IByG2ZwSwZNJC-w.jpeg"/></div></div></figure><p id="8363" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们可以将公式左侧的“c”设为0。在大多数机器学习模型中，这个“c”被称为“偏差单位”，表示为w0。</p><p id="a9b9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">您可能想知道权重是如何获得或初始化的。嗯，当您开始培训模型时，它们并不容易获得。最初，我们<br/>给权向量取任意值。但是任意值以0 为中心，标准偏差为0.01(标准偏差为0.01)，因为我们不希望权重在不知道数据集中值的范围的情况下取大值。).每当感知器模型错误地对样本行进行错误分类时，通过重复迭代通过数据集和<strong class="ig hi">惩罚权重</strong>获得<strong class="ig hi">权重。</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jq"><img src="../Images/feb43bce84e013ab04e33c89d6cf3da8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WS707xNFtT8ygKv2Hxl9IQ.jpeg"/></div></div></figure><p id="eded" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这是在我们的模型每次预测一个结果之后将被添加到权重中的更新函数。这里lr是学习率，它是一个重要的参数，决定了我们希望我们的模型多快达到误差函数的全局最小值。yi是xi的目标标签，而“yi cap”是我们的模型的类别预测。如果预测是正确的,“更新”函数将为零，我们不会更新我们的权重，但如果预测是错误的，我们将更新权重。在这里，样本行“xi”被相乘，因为我们想要根据错误的程度来惩罚我们的模型<strong class="ig hi">。</strong></p><p id="2e64" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">感知器模型的最终工作流程如下所示</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jr"><img src="../Images/f0001833b31609b288f7f6b6c88baaa6.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/format:webp/1*S47YVCfzfoi-HjEefANt5g.jpeg"/></div></figure><p id="3da4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">建立感知机模型</strong></p><p id="6bf4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这一节中，让我们尝试基于上一节中讨论的数学来构建一个感知器模型。</p><p id="5c3f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这里给出的是1v1感知器模型的python实现。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es js"><img src="../Images/95dd1a381def31a564d54889695cdeaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gND3s_3j8SfKT_QmsO5Kng.png"/></div></div></figure><p id="c1e1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们先讨论“适合”功能。“拟合”函数接受特征向量和目标标签。前两行函数初始化权重向量，其值以0为中心，标准偏差为0.01。这里需要注意的重要一点是矢量的<strong class="ig hi">形状。它比列数多一个值。这个<strong class="ig hi">额外值就是偏置单位。</strong>‘fit’函数有一个误差变量，用于查看在多次迭代后误差是增加还是减少。现在我们只是在感知器工作流程中反复循环<strong class="ig hi"> n_iter </strong>次，这是在使用模型时必须指定的。内部for循环中的前三行构成感知器算法的核心。这些线的数学形式在上一节已经讨论过了。另一个需要注意的重要事项是，<strong class="ig hi">偏差项不与任何东西</strong>相乘，或者概括一下等式，我们可以假设它与x0相乘，其中x0始终为1。</strong></p><p id="49df" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">“net_input”函数执行权重向量的转置和样本向量之间的点积。“预测”函数根据“net_input”函数的输出预测类。</p><p id="1fc5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">测试模型</strong></p><p id="533d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们用人工准备的数据集来测试这个模型。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jt"><img src="../Images/313eed23c55f80c0e640ac7cc43aea7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:742/format:webp/1*mhVeEyEwPv5JYUwTKycq1A.png"/></div></figure><p id="006a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">上面人工准备的数据集有两个要素和一个目标标注，该标注有两个值- 1和-1。‘x1’的系数是2，而‘x2’的系数是-2。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ju"><img src="../Images/244da833a57833078914f91915e431a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*3325mu0uktFc34cNuY6-7A.png"/></div></figure><p id="88be" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">观察权重向量的第二个和第三个值<strong class="ig hi">。它们的绝对值几乎相等。原始系数也遵循该模式。现在我们来看看偏置单元。<strong class="ig hi">偏差单位非常接近零</strong>，因为该数据集的阈值为0。这就是为什么偏置单位非常接近于零。权重向量的所有值都遵循我们在数学部分讨论过的数学公式。</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/471e0255c4641477f1a6ae0a0f9b39c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*-AuV3iA3crn1pQvIKEfKgQ.png"/></div></figure><p id="2b5e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">感知器模型就是这样划分训练行的。感知器的缺点之一是它的<strong class="ig hi">只对线性可分的</strong>数据有效。当训练数据不是线性可分的感知器时<strong class="ig hi">将不能</strong>收敛到特征的适当权重。</p><p id="def7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">结论</strong></p><p id="2f70" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在本文中，我们看到了感知器算法的数学和代码实现。这里的代码是针对1v1分类的，但是同样的概念也适用于对多个类问题进行分类。尽管该算法看起来很简单，但是多年来已经构建了该算法的许多高级版本，并且已经构建了许多基于该模型的高级模型。感知器算法只是起点。</p><div class="jv jw ez fb jx jy"><a rel="noopener follow" target="_blank" href="/mlearning-ai/mlearning-ai-submission-suggestions-b51e2b130bfb"><div class="jz ab dw"><div class="ka ab kb cl cj kc"><h2 class="bd hi fi z dy kd ea eb ke ed ef hg bi translated">Mlearning.ai提交建议</h2><div class="kf l"><h3 class="bd b fi z dy kd ea eb ke ed ef dx translated">如何成为Mlearning.ai上的作家</h3></div><div class="kg l"><p class="bd b fp z dy kd ea eb ke ed ef dx translated">medium.com</p></div></div><div class="kh l"><div class="ki l kj kk kl kh km jj jy"/></div></div></a></div></div></div>    
</body>
</html>