<html>
<head>
<title>Hazelcast + Kibana: best buddies for exploring and visualizing data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Hazelcast + Kibana:探索和可视化数据的最佳伙伴</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/hazelcast-kibana-best-buddies-for-exploring-and-visualizing-data-7e4577669c28?source=collection_archive---------1-----------------------#2021-10-28">https://medium.com/mlearning-ai/hazelcast-kibana-best-buddies-for-exploring-and-visualizing-data-7e4577669c28?source=collection_archive---------1-----------------------#2021-10-28</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/dced10d306701701edff3f2ad0f4a71e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R5cc9mQpjAxes7OBAbZSdg.jpeg"/></div></div></figure><p id="167f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">许多(如果不是全部的话)数据科学项目需要一些数据可视化前端来显示结果供人类分析。Python似乎拥有最强大的库，但是如果您是Java开发人员(或者如果您精通另一种语言)，请不要失去希望。在这篇文章中，我将描述如何在不编写任何代码的情况下从这样的数据可视化前端中获益。</p><h1 id="43ef" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">用例:维基百科的变化</h1><p id="a74b" class="pw-post-body-paragraph ip iq hh ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">我推断你已经很熟悉<a class="ae kq" href="https://wikipedia.org/" rel="noopener ugc nofollow" target="_blank">维基百科</a>。如果你不知道，维基百科是由社区管理的在线百科全书。用他们自己的话说:</p><blockquote class="kr ks kt"><p id="9815" class="ip iq ku ir b is it iu iv iw ix iy iz kv jb jc jd kw jf jg jh kx jj jk jl jm ha bi translated">维基百科是一个内容免费、多语言的在线百科全书，由志愿贡献者社区通过开放协作模式使用基于维基的编辑系统编写和维护。</p></blockquote><p id="9ffb" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">以上实际上是维基百科上的<a class="ae kq" href="https://en.wikipedia.org/wiki/Wikipedia" rel="noopener ugc nofollow" target="_blank">条目</a>的摘录。很meta。</p><p id="e199" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这个想法是让任何人就任何主题写任何东西，让社区决定这个作品是否提高了知识体系。你可以把这个系统想象成一个世界范围的Git评论。</p><p id="3e1f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">即使有了这些，通过发送大量的变更，也很容易超出社区的审查能力。为了防止这种滥用，潜在的贡献者需要首先创建一个帐户。但是，它增加了一层摩擦。如果我想通过修改一个打字错误、添加一张图片或任何其他微小的任务来做出贡献，创建我的帐户将比贡献更耗时。为了允许一次性贡献，维基百科允许匿名修改。然而，关于滥用，我们又回到了起点。为了掩盖这一点，维基百科会记录你的IP地址。IP将出现在更改历史记录中，而不是帐户的名称。</p><p id="1c99" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，我的用例是关于可视化世界范围的匿名贡献。我先从维基百科上读取数据，通过认证账号过滤掉改动，推断改动的位置，推断改动的语言，然后在世界范围的地图上显示出来。从这一点来看，我会探索视觉上的变化，并说语言和位置以某种方式匹配。</p><p id="2ce9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们将通过循序渐进的过程来实现这一目标。</p><h1 id="3878" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">等待世界改变</h1><p id="9cb8" class="pw-post-body-paragraph ip iq hh ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">我们要做的第一步实际上是获取数据，<em class="ku">也就是</em>，将维基百科中的更改获取到我们的数据存储中。这非常简单，因为维基百科本身在一个专门的最近变化页面上提供了它的变化。如果你按下“实时更新”按钮，你可以看到列表是实时更新的(或非常接近)。下面是写这篇文章时的变化截图:</p><figure class="kz la lb lc fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ky"><img src="../Images/a23296a81c5210e22e10df06863840b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-WR8u1WSsuVp8fE8.png"/></div></div></figure><p id="72e3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在是时候创建一个数据管道来获取Hazelcast中的数据了。注意，如果您想继续学习，<a class="ae kq" href="https://github.com/hazelcast-demos/wikipedia-changes" rel="noopener ugc nofollow" target="_blank">这个项目在GitHub </a>上很容易找到。</p><p id="d67f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">维基百科通过<a class="ae kq" href="https://fr.wikipedia.org/wiki/Server-sent_events" rel="noopener ugc nofollow" target="_blank">服务器发送的事件</a>提供变化。简而言之，使用SSE，您向端点注册一个客户机，每次有新数据进来时，您都会得到通知，并可以相应地采取行动。在JVM上，有几个SSE兼容的客户端可用，包括Spring WebClient。相反，我选择使用<a class="ae kq" href="https://github.com/launchdarkly/okhttp-eventsource" rel="noopener ugc nofollow" target="_blank"> OkHttp EventSource </a>，因为它是轻量级的——它只依赖于OkHttp，并且它的用法相对简单。</p><p id="c148" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">以下是POM的摘录:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="eec3" class="li jo hh le b fi lj lk l ll lm">&lt;dependency&gt;<br/>    &lt;groupId&gt;com.hazelcast&lt;/groupId&gt;<br/>    &lt;artifactId&gt;hazelcast&lt;/artifactId&gt;<br/>    &lt;version&gt;${hazelcast.version}&lt;/version&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>    &lt;groupId&gt;com.launchdarkly&lt;/groupId&gt;<br/>    &lt;artifactId&gt;okhttp-eventsource&lt;/artifactId&gt;<br/>    &lt;version&gt;2.3.2&lt;/version&gt;<br/>&lt;/dependency&gt;</span></pre><h1 id="ebe6" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">获取数据</h1><p id="12f7" class="pw-post-body-paragraph ip iq hh ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">Hazelcast数据管道通过定期轮询数据源来工作。对于HTTP端点，这很简单，但是对于SSE，SSE不那么依赖订阅。因此，我们需要实现一个定制的<code class="du ln lo lp le b">Source</code>并围绕一个内部队列来设计它，以便在更改到达时存储它们，而轮询将使它们出列并进一步发送到管道中。</p><p id="2924" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们围绕以下组件设计代码:</p><figure class="kz la lb lc fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lq"><img src="../Images/c5d95fcb55a22e370cf51716c31e8f80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZqSY1O5zB--yCibSeDxSkQ.png"/></div></div></figure><ul class=""><li id="9bc7" class="lr ls hh ir b is it iw ix ja lt je lu ji lv jm lw lx ly lz bi translated"><code class="du ln lo lp le b">Context</code>管理订阅。它创建一个新的<code class="du ln lo lp le b">WikipediaChangeEventHandler</code>实例，并将其注册为SSE流的观察者。</li><li id="5913" class="lr ls hh ir b is ma iw mb ja mc je md ji me jm lw lx ly lz bi translated"><code class="du ln lo lp le b">WikipediaChangeEventHandler</code>是认购部分。每次发生更改时，它都会得到通知，并在其内部队列中对更改负载进行排队。</li><li id="b3ac" class="lr ls hh ir b is ma iw mb ja mc je md ji me jm lw lx ly lz bi translated">Hazelcast引擎定期调用<code class="du ln lo lp le b">Call</code>。当发生这种情况时，它从<code class="du ln lo lp le b">WikipediaChangeEventHandler</code>中取出项目，将普通字符串转换为<code class="du ln lo lp le b">JSONObject</code>，并将后者放入数据管道缓冲区。</li></ul><p id="29b1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">从动态角度来看，系统可以建模为:</p><figure class="kz la lb lc fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mf"><img src="../Images/66a0b2e732c891b4ea51536d0e8b891b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*msM0f5P4bUHQcr6u3k-VDg.png"/></div></div></figure><p id="8a84" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">运行代码输出如下所示:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="e120" class="li jo hh le b fi lj lk l ll lm">{"server_script_path":"/w","server_name":"en.wikipedia.org","$schema":"/mediawiki/recentchange/1.0.0","bot":false,"wiki":"enwiki","type":"categorize","title":"Category:Biography articles without listas parameter","meta":{"dt":"2021-07-28T04:07:40Z","partition":0,"offset":363427323,"stream":"mediawiki.recentchange","domain":"en.wikipedia.org","topic":"codfw.mediawiki.recentchange","id":"01592c7a-03f1-46cd-9472-3bbe63aff0ec","uri":"https://en.wikipedia.org/wiki/Category:Biography_articles_without_listas_parameter","request_id":"b49c3b98-2064-44da-aab4-ab7b3bf65bdd"},"namespace":14,"comment":"[[:Talk:Jeff S. Klotz]] removed from category","id":1406951122,"server_url":"https://en.wikipedia.org","user":"Lepricavark","parsedcomment":"&lt;a href=\"/wiki/Talk:Jeff_S._Klotz\" title=\"Talk:Jeff S. Klotz\"&gt;Talk:Jeff S. Klotz&lt;\/a&gt; removed from category","timestamp":1627445260}<br/>{"server_script_path":"/w","server_name":"commons.wikimedia.org","$schema":"/mediawiki/recentchange/1.0.0","bot":true,"wiki":"commonswiki","type":"categorize","title":"Category:Flickr images reviewed by FlickreviewR 2","meta":{"dt":"2021-07-28T04:07:42Z","partition":0,"offset":363427324,"stream":"mediawiki.recentchange","domain":"commons.wikimedia.org","topic":"codfw.mediawiki.recentchange","id":"68f3a372-112d-4dae-af8f-25d88984f1d8","uri":"https://commons.wikimedia.org/wiki/Category:Flickr_images_reviewed_by_FlickreviewR_2","request_id":"1a132610-85e0-4954-9329-9e44691970aa"},"namespace":14,"comment":"[[:File:Red squirrel (51205279267).jpg]] added to category","id":1729953358,"server_url":"https://commons.wikimedia.org","user":"FlickreviewR 2","parsedcomment":"&lt;a href=\"/wiki/File:Red_squirrel_(51205279267).jpg\" title=\"File:Red squirrel (51205279267).jpg\"&gt;File:Red squirrel (51205279267).jpg&lt;\/a&gt; added to category","timestamp":1627445262}<br/>{"server_script_path":"/w","server_name":"commons.wikimedia.org","$schema":"/mediawiki/recentchange/1.0.0","bot":true,"wiki":"commonswiki","type":"categorize","title":"Category:Flickr review needed","meta":{"dt":"2021-07-28T04:07:42Z","partition":0,"offset":363427325,"stream":"mediawiki.recentchange","domain":"commons.wikimedia.org","topic":"codfw.mediawiki.recentchange","id":"b4563ed9-a6f2-40de-9e71-c053f5352846","uri":"https://commons.wikimedia.org/wiki/Category:Flickr_review_needed","request_id":"1a132610-85e0-4954-9329-9e44691970aa"},"namespace":14,"comment":"[[:File:Red squirrel (51205279267).jpg]] removed from category","id":1729953359,"server_url":"https://commons.wikimedia.org","user":"FlickreviewR 2","parsedcomment":"&lt;a href=\"/wiki/File:Red_squirrel_(51205279267).jpg\" title=\"File:Red squirrel (51205279267).jpg\"&gt;File:Red squirrel (51205279267).jpg&lt;\/a&gt; removed from category","timestamp":1627445262}<br/>{"server_script_path":"/w","server_name":"www.wikidata.org","$schema":"/mediawiki/recentchange/1.0.0","minor":false,"bot":true,"wiki":"wikidatawiki","length":{"new":31968,"old":31909},"type":"edit","title":"Q40652","revision":{"new":1468164253,"old":1446892882},"patrolled":true,"meta":{"dt":"2021-07-28T04:07:43Z","partition":0,"offset":363427326,"stream":"mediawiki.recentchange","domain":"www.wikidata.org","topic":"codfw.mediawiki.recentchange","id":"70784dde-0360-4292-9f62-81323ced9aa7","uri":"https://www.wikidata.org/wiki/Q40652","request_id":"f9686303-ffed-4c62-8532-bf870288ff55"},"namespace":0,"comment":"/* wbsetaliases-add:1|zh */ 蒂托, [[User:Cewbot#Import labels/aliases|import label/alias]] from [[zh:巴西國家足球隊]], [[zh:何塞·保罗·贝塞拉·马希尔·儒尼奥尔]], [[zh:2018年國際足協世界盃參賽球員名單]], [[zh:埃德爾·米利唐]], [[zh:加布里埃爾·馬丁內利]], [[zh:2019年南美超级德比杯]], [[zh:2019年美洲杯决赛]], [[zh:2019年美洲杯参赛名单]], [[zh:2021年美洲杯B组]], [[zh:2021年美洲國家盃決賽]]","id":1514670479,"server_url":"https://www.wikidata.org","user":"Cewbot","parsedcomment":"\u200e&lt;span dir=\"auto\"&gt;&lt;span class=\"autocomment\"&gt;Added Chinese alias: &lt;\/span&gt;&lt;\/span&gt; 蒂托, &lt;a href=\"/wiki/User:Cewbot#Import_labels/aliases\" title=\"User:Cewbot\"&gt;import label/alias&lt;\/a&gt; from &lt;a href=\"https://zh.wikipedia.org/wiki/%E5%B7%B4%E8%A5%BF%E5%9C%8B%E5%AE%B6%E8%B6%B3%E7%90%83%E9%9A%8A\" class=\"extiw\" title=\"zh:巴西國家足球隊\"&gt;zh:巴西國家足球隊&lt;\/a&gt;, &lt;a href=\"https://zh.wikipedia.org/wiki/%E4%BD%95%E5%A1%9E%C2%B7%E4%BF%9D%E7%BD%97%C2%B7%E8%B4%9D%E5%A1%9E%E6%8B%89%C2%B7%E9%A9%AC%E5%B8%8C%E5%B0%94%C2%B7%E5%84%92%E5%B0%BC%E5%A5%A5%E5%B0%94\" class=\"extiw\" title=\"zh:何塞·保罗·贝塞拉·马希尔·儒尼奥尔\"&gt;zh:何塞·保罗·贝塞拉·马希尔·儒尼奥尔&lt;\/a&gt;, &lt;a href=\"https://zh.wikipedia.org/wiki/2018%E5%B9%B4%E5%9C%8B%E9%9A%9B%E8%B6%B3%E5%8D%94%E4%B8%96%E7%95%8C%E7%9B%83%E5%8F%83%E8%B3%BD%E7%90%83%E5%93%A1%E5%90%8D%E5%96%AE\" class=\"extiw\" title=\"zh:2018年國際足協世界盃參賽球員名單\"&gt;zh:2018年國際足協世界盃參賽球員名單&lt;\/a&gt;, &lt;a href=\"https://zh.wikipedia.org/wiki/%E5%9F%83%E5%BE%B7%E7%88%BE%C2%B7%E7%B1%B3%E5%88%A9%E5%94%90\" class=\"extiw\" title=\"zh:埃德爾·米利唐\"&gt;zh:埃德爾·米利唐&lt;\/a&gt;, &lt;a href=\"https://zh.wikipedia.org/wiki/%E5%8A%A0%E5%B8%83%E9%87%8C%E5%9F%83%E7%88%BE%C2%B7%E9%A6%AC%E4%B8%81%E5%85%A7%E5%88%A9\" class=\"extiw\" title=\"zh:加布里埃爾·馬丁內利\"&gt;zh:加布里埃爾·馬丁內利&lt;\/a&gt;, &lt;a href=\"https://zh.wikipedia.org/wiki/2019%E5%B9%B4%E5%8D%97%E7%BE%8E%E8%B6%85%E7%BA%A7%E5%BE%B7%E6%AF%94%E6%9D%AF\" class=\"extiw\" title=\"zh:2019年南美超级德比杯\"&gt;zh:2019年南美超级德比杯&lt;\/a&gt;, &lt;a href=\"https://zh.wikipedia.org/wiki/2019%E5%B9%B4%E7%BE%8E%E6%B4%B2%E6%9D%AF%E5%86%B3%E8%B5%9B\" class=\"extiw\" title=\"zh:2019年美洲杯决赛\"&gt;zh:2019年美洲杯决赛&lt;\/a&gt;, &lt;a href=\"https://zh.wikipedia.org/wiki/2019%E5%B9%B4%E7%BE%8E%E6%B4%B2%E6%9D%AF%E5%8F%82%E8%B5%9B%E5%90%8D%E5%8D%95\" class=\"extiw\" title=\"zh:2019年美洲杯参赛名单\"&gt;zh:2019年美洲杯参赛名单&lt;\/a&gt;, &lt;a href=\"https://zh.wikipedia.org/wiki/2021%E5%B9%B4%E7%BE%8E%E6%B4%B2%E6%9D%AFB%E7%BB%84\" class=\"extiw\" title=\"zh:2021年美洲杯B组\"&gt;zh:2021年美洲杯B组&lt;\/a&gt;, &lt;a href=\"https://zh.wikipedia.org/wiki/2021%E5%B9%B4%E7%BE%8E%E6%B4%B2%E5%9C%8B%E5%AE%B6%E7%9B%83%E6%B1%BA%E8%B3%BD\" class=\"extiw\" title=\"zh:2021年美洲國家盃決賽\"&gt;zh:2021年美洲國家盃決賽&lt;\/a&gt;","timestamp":1627445263}<br/>{"server_script_path":"/w","server_name":"www.wikidata.org","$schema":"/mediawiki/recentchange/1.0.0","minor":false,"bot":true,"wiki":"wikidatawiki","length":{"new":239,"old":161},"type":"edit","title":"Q107674623","revision":{"new":1468164250,"old":1468164243},"patrolled":true,"meta":{"dt":"2021-07-28T04:07:43Z","partition":0,"offset":363427327,"stream":"mediawiki.recentchange","domain":"www.wikidata.org","topic":"codfw.mediawiki.recentchange","id":"40260137-ee52-4a67-b024-22d3cf86907a","uri":"https://www.wikidata.org/wiki/Q107674623","request_id":"db6e073a-19f6-4658-9425-7992b34b4208"},"namespace":0,"comment":"/* wbsetlabel-add:1|de */ Favolaschia filopes","id":1514670480,"server_url":"https://www.wikidata.org","user":"SuccuBot","parsedcomment":"\u200e&lt;span dir=\"auto\"&gt;&lt;span class=\"autocomment\"&gt;Bezeichnung für [de] hinzugefügt: &lt;\/span&gt;&lt;\/span&gt; Favolaschia filopes","timestamp":1627445263}<br/>{"server_script_path":"/w","server_name":"ko.wikipedia.org","$schema":"/mediawiki/recentchange/1.0.0","minor":true,"bot":true,"wiki":"kowiki","length":{"new":1158,"old":1161},"type":"edit","title":"이시다테 야스키","revision":{"new":29895993,"old":26098259},"meta":{"dt":"2021-07-28T04:07:43Z","partition":0,"offset":363427328,"stream":"mediawiki.recentchange","domain":"ko.wikipedia.org","topic":"codfw.mediawiki.recentchange","id":"c23bdb77-e88c-48d3-9d24-3c4dd8ef1dbf","uri":"https://ko.wikipedia.org/wiki/%EC%9D%B4%EC%8B%9C%EB%8B%A4%ED%85%8C_%EC%95%BC%EC%8A%A4%ED%82%A4","request_id":"0010e77b-fbcd-4de8-a5ad-4616adbbd6d4"},"namespace":0,"comment":"봇: 분류 이름 변경 (분류:1984년 태어남 → [[분류:1984년 출생]])","id":56333828,"server_url":"https://ko.wikipedia.org","user":"TedBot","parsedcomment":"봇: 분류 이름 변경 (분류:1984년 태어남 → &lt;a href=\"/wiki/%EB%B6%84%EB%A5%98:1984%EB%85%84_%EC%B6%9C%EC%83%9D\" title=\"분류:1984년 출생\"&gt;분류:1984년 출생&lt;\/a&gt;)","timestamp":1627445263}<br/>{"server_script_path":"/w","server_name":"commons.wikimedia.org","$schema":"/mediawiki/recentchange/1.0.0","minor":false,"bot":true,"wiki":"commonswiki","length":{"new":3864,"old":527},"type":"edit","title":"File:Albizia kalkora 06.jpg","revision":{"new":577195372,"old":577193453},"patrolled":true,"meta":{"dt":"2021-07-28T04:07:44Z","partition":0,"offset":363427329,"stream":"mediawiki.recentchange","domain":"commons.wikimedia.org","topic":"codfw.mediawiki.recentchange","id":"1a7fcb55-dec7-4303-b757-19f6a6a4dcdd","uri":"https://commons.wikimedia.org/wiki/File:Albizia_kalkora_06.jpg","request_id":"7f841b4a-ac70-4c2b-a148-bc07696ccf7a"},"namespace":6,"comment":"/* wbeditentity-update:0| */ Adding structured data: date, camera, author, copyright &amp; source","id":1729953360,"server_url":"https://commons.wikimedia.org","user":"BotMultichillT","parsedcomment":"\u200e&lt;span dir=\"auto\"&gt;&lt;span class=\"autocomment\"&gt;Changed an entity: &lt;\/span&gt;&lt;\/span&gt; Adding structured data: date, camera, author, copyright &amp;amp; source","timestamp":1627445264}<br/>{"server_script_path":"/w","server_name":"id.wikipedia.org","$schema":"/mediawiki/recentchange/1.0.0","minor":true,"bot":true,"wiki":"idwiki","length":{"new":977,"old":962},"type":"edit","title":"Euporus linearis","revision":{"new":18801346,"old":16068468},"patrolled":true,"meta":{"dt":"2021-07-28T04:07:43Z","partition":0,"offset":363427330,"stream":"mediawiki.recentchange","domain":"id.wikipedia.org","topic":"codfw.mediawiki.recentchange","id":"6c3882f9-9fd0-4f43-ab69-e538762c7981","uri":"https://id.wikipedia.org/wiki/Euporus_linearis","request_id":"dea59b42-7c97-4cbc-9384-5d8836a981ec"},"namespace":0,"comment":"[[Wikipedia:Bot|Bot]]: fixed → [[Kategori:Taxonbar tanpa parameter from|taxonbar tanpa parameter from]]","id":42309169,"server_url":"https://id.wikipedia.org","user":"HsfBot","parsedcomment":"&lt;a href=\"/wiki/Wikipedia:Bot\" title=\"Wikipedia:Bot\"&gt;Bot&lt;\/a&gt;: fixed → &lt;a href=\"/wiki/Kategori:Taxonbar_tanpa_parameter_from\" title=\"Kategori:Taxonbar tanpa parameter from\"&gt;taxonbar tanpa parameter from&lt;\/a&gt;","timestamp":1627445263}<br/>{"server_script_path":"/w","server_name":"www.wikidata.org","$schema":"/mediawiki/recentchange/1.0.0","minor":false,"bot":false,"wiki":"wikidatawiki","length":{"new":25025,"old":24908},"type":"edit","title":"Q80075231","revision":{"new":1468164255,"old":1467697536},"patrolled":true,"meta":{"dt":"2021-07-28T04:07:44Z","partition":0,"offset":363427331,"stream":"mediawiki.recentchange","domain":"www.wikidata.org","topic":"codfw.mediawiki.recentchange","id":"720f6507-1ea1-4665-b1b9-1665c97450a9","uri":"https://www.wikidata.org/wiki/Q80075231","request_id":"43b7d511-007f-4005-a562-5002c7e0aff4"},"namespace":0,"comment":"/* wbsetdescription-add:1|dv */ އަކުއިލާ ނަކަތުގައިވާ ތަރިއެއް, [[:toollabs:quickstatements/#/batch/60416|batch #60416]]","id":1514670481,"server_url":"https://www.wikidata.org","user":"EN-Jungwon","parsedcomment":"\u200e&lt;span dir=\"auto\"&gt;&lt;span class=\"autocomment\"&gt;Added [dv] description: &lt;\/span&gt;&lt;\/span&gt; އަކުއިލާ ނަކަތުގައިވާ ތަރިއެއް, &lt;a href=\"https://iw.toolforge.org/quickstatements/#.2Fbatch.2F60416\" class=\"extiw\" title=\"toollabs:quickstatements/\"&gt;batch #60416&lt;\/a&gt;","timestamp":1627445264}<br/>{"server_script_path":"/w","server_name":"www.wikidata.org","$schema":"/mediawiki/recentchange/1.0.0","minor":false,"bot":false,"wiki":"wikidatawiki","length":{"new":5312,"old":4884},"type":"edit","title":"Q85766437","revision":{"new":1468164246,"old":1342535335},"patrolled":true,"meta":{"dt":"2021-07-28T04:07:42Z","partition":0,"offset":363427332,"stream":"mediawiki.recentchange","domain":"www.wikidata.org","topic":"codfw.mediawiki.recentchange","id":"ad173600-09b7-4ccd-9490-4a60f6a432ea","uri":"https://www.wikidata.org/wiki/Q85766437","request_id":"1228a17e-2baa-46cc-a3bc-2049a62982c9"},"namespace":0,"comment":"/* wbcreateclaim-create:1| */ [[Property:P7937]]: [[Q7366]], [[:toollabs:quickstatements/#/batch/60404|batch #60404]]","id":1514670483,"server_url":"https://www.wikidata.org","user":"Moebeus","parsedcomment":"\u200e&lt;span dir=\"auto\"&gt;&lt;span class=\"autocomment\"&gt;Created claim: &lt;\/span&gt;&lt;\/span&gt; &lt;a href=\"/wiki/Property:P7937\" title=\"Property:P7937\"&gt;Property:P7937&lt;\/a&gt;: &lt;a href=\"/wiki/Q7366\" title=\"Q7366\"&gt;Q7366&lt;\/a&gt;, &lt;a href=\"https://iw.toolforge.org/quickstatements/#.2Fbatch.2F60404\" class=\"extiw\" title=\"toollabs:quickstatements/\"&gt;batch #60404&lt;\/a&gt;","timestamp":1627445262}<br/>{"server_script_path":"/w","server_name":"www.wikidata.org","$schema":"/mediawiki/recentchange/1.0.0","minor":false,"bot":false,"wiki":"wikidatawiki","length":{"new":5134,"old":5126},"type":"edit","title":"Q12444793","revision":{"new":1468164254,"old":1413396080},"patrolled":false,"meta":{"dt":"2021-07-28T04:07:43Z","partition":0,"offset":363427333,"stream":"mediawiki.recentchange","domain":"www.wikidata.org","topic":"codfw.mediawiki.recentchange","id":"c01d52c5-c476-4554-814d-513342e04686","uri":"https://www.wikidata.org/wiki/Q12444793","request_id":"6d0a32b9-1234-4c8e-a02a-d92608f06d33"},"namespace":0,"comment":"/* wbsetdescription-set:1|hi */ भारत के उत्तराखण्ड राज्य का एक गाँव bikash","id":1514670482,"server_url":"https://www.wikidata.org","user":"2409:4061:219C:613E:DFD9:6BD4:F234:E7E0","parsedcomment":"\u200e&lt;span dir=\"auto\"&gt;&lt;span class=\"autocomment\"&gt;बदला [hi] विवरण: &lt;\/span&gt;&lt;\/span&gt; भारत के उत्तराखण्ड राज्य का एक गाँव bikash","timestamp":1627445263}<br/>{"server_script_path":"/w","server_name":"www.wikidata.org","$schema":"/mediawiki/recentchange/1.0.0","minor":false,"bot":false,"wiki":"wikidatawiki","length":{"new":22936,"old":22819},"type":"edit","title":"Q80075234","revision":{"new":1468164258,"old":1467697544},"patrolled":true,"meta":{"dt":"2021-07-28T04:07:44Z","partition":0,"offset":363427334,"stream":"mediawiki.recentchange","domain":"www.wikidata.org","topic":"codfw.mediawiki.recentchange","id":"7016afae-6691-4dca-bfaf-a5a3363edf31","uri":"https://www.wikidata.org/wiki/Q80075234","request_id":"aa4f6828-149d-4feb-a3cf-cd39902773fe"},"namespace":0,"comment":"/* wbsetdescription-add:1|dv */ އަކުއިލާ ނަކަތުގައިވާ ތަރިއެއް, [[:toollabs:quickstatements/#/batch/60416|batch #60416]]","id":1514670484,"server_url":"https://www.wikidata.org","user":"EN-Jungwon","parsedcomment":"\u200e&lt;span dir=\"auto\"&gt;&lt;span class=\"autocomment\"&gt;Added [dv] description: &lt;\/span&gt;&lt;\/span&gt; އަކުއިލާ ނަކަތުގައިވާ ތަރިއެއް, &lt;a href=\"https://iw.toolforge.org/quickstatements/#.2Fbatch.2F60416\" class=\"extiw\" title=\"toollabs:quickstatements/\"&gt;batch #60416&lt;\/a&gt;","timestamp":1627445264}<br/>{"server_script_path":"/w","server_name":"de.wikipedia.org","$schema":"/mediawiki/recentchange/1.0.0","minor":false,"bot":true,"wiki":"dewiki","length":{"new":17069,"old":17075},"type":"edit","title":"Liste der Biografien/Caro","revision":{"new":214271460,"old":213857611},"meta":{"dt":"2021-07-28T04:07:43Z","partition":0,"offset":363427335,"stream":"mediawiki.recentchange","domain":"de.wikipedia.org","topic":"codfw.mediawiki.recentchange","id":"6618b0ab-eadf-405a-a474-ec2ad9fef8bb","uri":"https://de.wikipedia.org/wiki/Liste_der_Biografien/Caro","request_id":"23181b86-03de-4153-ad99-e7e20e611ed6"},"namespace":0,"comment":"Bot: Automatische Aktualisierung, siehe [[Benutzer:APPERbot/LdB]]","id":309672385,"server_url":"https://de.wikipedia.org","user":"APPERbot","parsedcomment":"Bot: Automatische Aktualisierung, siehe &lt;a href=\"/wiki/Benutzer:APPERbot/LdB\" title=\"Benutzer:APPERbot/LdB\"&gt;Benutzer:APPERbot/LdB&lt;\/a&gt;","timestamp":1627445263}</span></pre><p id="fcc6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这是最后一个条目，但为了更好地理解进行了格式化:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="e7ba" class="li jo hh le b fi lj lk l ll lm">{<br/>  "$schema": "/mediawiki/recentchange/1.0.0",<br/>  "bot": true,<br/>  "comment": "Bot: Automatische Aktualisierung, siehe [[Benutzer:APPERbot/LdB]]",<br/>  "id": 309672385,<br/>  "length": {<br/>    "new": 17069,<br/>    "old": 17075<br/>  },<br/>  "meta": {<br/>    "domain": "de.wikipedia.org",<br/>    "dt": "2021-07-28T04:07:43Z",<br/>    "id": "6618b0ab-eadf-405a-a474-ec2ad9fef8bb",<br/>    "offset": 363427335,<br/>    "partition": 0,<br/>    "request_id": "23181b86-03de-4153-ad99-e7e20e611ed6",<br/>    "stream": "mediawiki.recentchange",<br/>    "topic": "codfw.mediawiki.recentchange",<br/>    "uri": "https://de.wikipedia.org/wiki/Liste_der_Biografien/Caro"<br/>  },<br/>  "minor": false,<br/>  "namespace": 0,<br/>  "parsedcomment": "Bot: Automatische Aktualisierung, siehe Benutzer:APPERbot/LdB",<br/>  "revision": {<br/>    "new": 214271460,<br/>    "old": 213857611<br/>  },<br/>  "server_name": "de.wikipedia.org",<br/>  "server_script_path": "/w",<br/>  "server_url": "https://de.wikipedia.org",<br/>  "timestamp": 1627445263,<br/>  "title": "Liste der Biografien/Caro",<br/>  "type": "edit",<br/>  "user": "APPERbot",<br/>  "wiki": "dewiki"<br/>}</span></pre><h1 id="8181" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">数据可视化的基巴纳</h1><p id="2290" class="pw-post-body-paragraph ip iq hh ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">正如我在介绍中提到的，我们有一个不需要编写代码的神奇的数据可视化工具，这个工具就是Kibana。基巴纳是所谓的麋鹿群的一部分:</p><ul class=""><li id="a94e" class="lr ls hh ir b is it iw ix ja lt je lu ji lv jm lw lx ly lz bi translated">Elasticsearch提供存储和索引部分</li><li id="91f2" class="lr ls hh ir b is ma iw mb ja mc je md ji me jm lw lx ly lz bi translated">最后，Kibana提供了仪表盘和小部件来浏览和可视化存储在Elasticsearch中的数据</li></ul><figure class="kz la lb lc fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mg"><img src="../Images/c4e2d378830702ff0480dd8f01d4aa9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yUXWYAiyufh81QWxkLiqoQ.jpeg"/></div></div></figure><p id="2ca7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们将写入一个Elasticsearch实例，而不是写入标准输出。为此，我们需要创建<code class="du ln lo lp le b">Sink</code>。虽然您可以直接使用Elasticsearch API，但Hazelcast提供了一个扩展来简化您的工作。只需将<code class="du ln lo lp le b">com.hazelcast.jet:hazelcast-jet-elasticsearch-7</code> JAR添加到类路径中，就可以编写如下代码:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="9cdd" class="li jo hh le b fi lj lk l ll lm">private val clientBuilder = {<br/>  val env = System.getenv()<br/>  val user = env.getOrDefault("ELASTICSEARCH_USERNAME", "elastic")   // 1<br/>  val password = env.getOrDefault("ELASTICSEARCH_PASSWORD", "changeme") // 1<br/>  val host = env.getOrDefault("ELASTICSEARCH_HOST", "localhost")        // 1<br/>  val port = env.getOrDefault("ELASTICSEARCH_PORT", "9200").toInt()     // 1<br/>  ElasticClients.client(user, password, host, port)                     // 2<br/>}</span><span id="aa1e" class="li jo hh le b fi mh lk l ll lm">val elasticsearch = ElasticSinks.elastic(clientBuilder) {<br/>  IndexRequest("wikipedia").source(it.toString(), XContentType.JSON)    // 3<br/>}</span></pre><ol class=""><li id="a007" class="lr ls hh ir b is it iw ix ja lt je lu ji lv jm mi lx ly lz bi translated">提供一些参数化以允许在不同的环境中运行</li><li id="3142" class="lr ls hh ir b is ma iw mb ja mc je md ji me jm mi lx ly lz bi translated">连接到已配置的Elasticsearch实例</li><li id="2899" class="lr ls hh ir b is ma iw mb ja mc je md ji me jm mi lx ly lz bi translated">有效地将数据发送到ES。在幕后，Hazelcast将批量处理这些请求。</li></ol><p id="8ba4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，管道可以改进了:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="e6bf" class="li jo hh le b fi lj lk l ll lm">val pipeline = Pipeline.create().apply {<br/>  readFrom(wikipedia)<br/>    .withTimestamps({ it.getLong("timestamp") }, 100)<br/>    .writeTo(elasticsearch)<br/>}<br/>Hazelcast.bootstrappedInstance().jet.newJob(pipeline)</span></pre><p id="915b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">锦上添花的是，通过良好的命名，Hazelcast API允许不是开发人员的人遵循逻辑。</p><p id="0b81" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">运行上面的管道，我们已经可以在Kibana中看到结果。如果您没有可用的实例，GitHub库会提供一个<code class="du ln lo lp le b">docker-compose.yml</code>文件。你只需要用<code class="du ln lo lp le b">docker compose up</code>启动基础设施。</p><ol class=""><li id="5e42" class="lr ls hh ir b is it iw ix ja lt je lu ji lv jm mi lx ly lz bi translated">使用您最喜欢的浏览器导航到<a class="ae kq" href="http://localhost:5601" rel="noopener ugc nofollow" target="_blank"> http://localhost:5601 </a></li><li id="ceca" class="lr ls hh ir b is ma iw mb ja mc je md ji me jm mi lx ly lz bi translated">使用登录名<code class="du ln lo lp le b">elastic</code>和密码<code class="du ln lo lp le b">changeme</code>进行验证</li><li id="e105" class="lr ls hh ir b is ma iw mb ja mc je md ji me jm mi lx ly lz bi translated">单击“创建索引模式”按钮</li><li id="e3cb" class="lr ls hh ir b is ma iw mb ja mc je md ji me jm mi lx ly lz bi translated">输入<code class="du ln lo lp le b">wikipedia</code>作为索引名称</li><li id="efe4" class="lr ls hh ir b is ma iw mb ja mc je md ji me jm mi lx ly lz bi translated">点击“下一步”按钮</li><li id="7d96" class="lr ls hh ir b is ma iw mb ja mc je md ji me jm mi lx ly lz bi translated">选择字段为<code class="du ln lo lp le b">meta.dt</code>为时间字段</li><li id="3b12" class="lr ls hh ir b is ma iw mb ja mc je md ji me jm mi lx ly lz bi translated">点击“创建索引模式”按钮完成</li><li id="499d" class="lr ls hh ir b is ma iw mb ja mc je md ji me jm mi lx ly lz bi translated">在左侧菜单中，选择分析→发现</li></ol><p id="0555" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您应该会看到类似这样的内容:</p><figure class="kz la lb lc fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mj"><img src="../Images/e25f32a4222e536faf56d5415e0d1120.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*EqQjVzXFb5Dj1qX_.png"/></div></div></figure><p id="8fe4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这个视图中，您可以看到所有摄取的文档。要进一步探索，您可以选择您想要查看的字段(在右侧)并根据其结构过滤掉文档(在上面的搜索栏中)。</p><h1 id="0902" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">管理“错误”数据</h1><p id="8ec3" class="pw-post-body-paragraph ip iq hh ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">如果您尝试用这一步的代码执行作业，您可能会注意到，一段时间后，Elasticsearch停止接收数据。查看Hazelcast日志，您可能会注意到类似的堆栈跟踪:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="998f" class="li jo hh le b fi lj lk l ll lm">15:02:34.898 [ WARN] [c.h.j.i.e.TaskletExecutionService] [192.168.1.62]:5701 [dev] [5.0-BETA-1] Exception in ProcessorTasklet{068f-8bfa-4080-0001/elasticSink#0}<br/>com.hazelcast.jet.JetException: failure in bulk execution:<br/>[0]: index [wikipedia], type [_doc], id [PD017XoBfeUJ26i8qT-H], message [ElasticsearchException[Elasticsearch exception [type=mapper_parsing_exception, reason=object mapping for [log_params] tried to parse field [null] as object, but found a concrete value]]]<br/>  at com.hazelcast.jet.elastic.ElasticSinkBuilder$BulkContext.lambda$flush$0(ElasticSinkBuilder.java:248)<br/>  at com.hazelcast.jet.elastic.impl.RetryUtils.withRetry(RetryUtils.java:57)<br/>  at com.hazelcast.jet.elastic.ElasticSinkBuilder$BulkContext.flush(ElasticSinkBuilder.java:244)<br/>  at com.hazelcast.function.ConsumerEx.accept(ConsumerEx.java:47)<br/>  at com.hazelcast.jet.impl.connector.WriteBufferedP.process(WriteBufferedP.java:73)<br/>  at com.hazelcast.jet.impl.processor.ProcessorWrapper.process(ProcessorWrapper.java:97)<br/>  at com.hazelcast.jet.impl.pipeline.FunctionAdapter$AdaptingProcessor.process(FunctionAdapter.java:226)<br/>  at com.hazelcast.jet.impl.execution.ProcessorTasklet.lambda$processInbox$2f647568$2(ProcessorTasklet.java:439)<br/>  at com.hazelcast.jet.function.RunnableEx.run(RunnableEx.java:31)<br/>  at com.hazelcast.jet.impl.util.Util.doWithClassLoader(Util.java:498)<br/>  at com.hazelcast.jet.impl.execution.ProcessorTasklet.processInbox(ProcessorTasklet.java:439)<br/>  at com.hazelcast.jet.impl.execution.ProcessorTasklet.stateMachineStep(ProcessorTasklet.java:305)<br/>  at com.hazelcast.jet.impl.execution.ProcessorTasklet.stateMachineStep(ProcessorTasklet.java:300)<br/>  at com.hazelcast.jet.impl.execution.ProcessorTasklet.stateMachineStep(ProcessorTasklet.java:281)<br/>  at com.hazelcast.jet.impl.execution.ProcessorTasklet.call(ProcessorTasklet.java:255)<br/>  at com.hazelcast.jet.impl.execution.TaskletExecutionService$BlockingWorker.run(TaskletExecutionService.java:298)<br/>  at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)<br/>  at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)<br/>  at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)<br/>  at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)<br/>  at java.base/java.lang.Thread.run(Thread.java:829)</span></pre><p id="05b3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这是因为Elasticsearch的工作方式。由于我们没有提供任何显式的索引模式，Elasticsearch从它收到的第一个数据负载中为我们推断出一个。在这种情况下，<code class="du ln lo lp le b">log_params</code>属性主要具有以下结构:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="ae4b" class="li jo hh le b fi lj lk l ll lm">"log_params": {<br/>  "userid": 108038<br/>}</span></pre><p id="5519" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">因此，Elasticsearch将它识别为一个带有<code class="du ln lo lp le b">userid</code>属性的JSON对象。然而，有时，流包含<code class="du ln lo lp le b">"log_params":[]</code>，它是JSON数组。Elasticsearch无法在这两者之间进行调和，并抛出上述异常。</p><p id="ae8e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">要解决这个问题，我们可以过滤掉这样的数据，或者将空数组属性转换为空对象属性。因为我们希望保留尽可能多的数据，所以让我们选择第二个选项。到目前为止，我们还不知道我们是否需要为另一个领域这样做，所以让它通用化可能是个好主意:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="bdb9" class="li jo hh le b fi lj lk l ll lm">class MakeFieldObjectIfArray(private val fieldName: String) : FunctionEx&lt;JSONObject, JSONObject&gt; { // 1<br/>  override fun applyEx(json: JSONObject) = json.apply {         // 2<br/>    if (json.has(fieldName) &amp;&amp; json.get(fieldName) is JSONArray)  // 3<br/>      put(fieldName, JSONObject())                               // 4<br/>  }<br/>}</span><span id="5858" class="li jo hh le b fi mh lk l ll lm">val pipeline = Pipeline.create().apply {<br/>  readFrom(wikipedia)<br/>    .withTimestamps({ it.getLong("timestamp") }, 100)<br/>    .map(MakeFieldObjectIfArray("log_params"))                  // 5<br/>    .writeTo(elasticsearch)<br/>}</span></pre><ol class=""><li id="c0ce" class="lr ls hh ir b is it iw ix ja lt je lu ji lv jm mi lx ly lz bi translated">定义一个将<code class="du ln lo lp le b">JSONObject</code>作为参数并返回<code class="du ln lo lp le b">JSONObject</code>的<code class="du ln lo lp le b">FunctionEx</code></li><li id="70bc" class="lr ls hh ir b is ma iw mb ja mc je md ji me jm mi lx ly lz bi translated">应用以下更改，返回相同的<code class="du ln lo lp le b">JSONObject</code></li><li id="22f7" class="lr ls hh ir b is ma iw mb ja mc je md ji me jm mi lx ly lz bi translated">如果对象具有特定字段，并且该字段是一个<code class="du ln lo lp le b">JSONArray</code></li><li id="5b4b" class="lr ls hh ir b is ma iw mb ja mc je md ji me jm mi lx ly lz bi translated">然后用空的<code class="du ln lo lp le b">JSONObject</code>替换数组</li><li id="3d0f" class="lr ls hh ir b is ma iw mb ja mc je md ji me jm mi lx ly lz bi translated">使用之前定义的<code class="du ln lo lp le b">FunctionEx</code>映射管道中的每个项目</li></ol><p id="1d32" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">重新运行管道现在没有任何故障！</p><h1 id="437d" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">使其更具可读性和“可操作性”</h1><p id="9014" class="pw-post-body-paragraph ip iq hh ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">因为管道是稳定的，所以是时候进行重构以构建坚实的基础了。重构沿着两条轴线进行:</p><ul class=""><li id="2bb2" class="lr ls hh ir b is it iw ix ja lt je lu ji lv jm lw lx ly lz bi translated">代码可读性，面向开发人员</li><li id="2d3f" class="lr ls hh ir b is ma iw mb ja mc je md ji me jm lw lx ly lz bi translated">“可操作性”，面向运营</li></ul><p id="70d1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在开发人员方面，我们可以通过利用Hazelcast的API来改善体验。<code class="du ln lo lp le b">GeneralStage</code>提供了常用的管道原语:<code class="du ln lo lp le b">map()</code>、<code class="du ln lo lp le b">flatMap()</code>、<code class="du ln lo lp le b">filter()</code>以及一些更特殊的管道原语。然而，在这个粒度级别，我们更愿意关注<em class="ku">什么</em>而不是<em class="ku">如何</em>。为此，<code class="du ln lo lp le b">StreamStage</code>还提供了一个<code class="du ln lo lp le b">apply()</code>函数，将一个<code class="du ln lo lp le b">StreamStage</code>转换成另一个<code class="du ln lo lp le b">StreamStage</code>。让我们使用它:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="ce7e" class="li jo hh le b fi lj lk l ll lm">class MakeFieldObjectIfArray(private val fieldName: String) : FunctionEx&lt;StreamStage&lt;JSONObject&gt;, StreamStage&lt;JSONObject&gt;&gt; {<br/>  override fun applyEx(stage: StreamStage&lt;JSONObject&gt;) = stage .map { json -&gt;<br/>    json.apply {<br/>      if (json.has(fieldName) &amp;&amp; json.get(fieldName) is JSONArray)<br/>        put(fieldName, JSONObject())<br/>    }<br/>  }<br/>}</span></pre><p id="bbc9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">要使用它:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="6da6" class="li jo hh le b fi lj lk l ll lm">val pipeline = Pipeline.create().apply {<br/>  readFrom(wikipedia)<br/>    .withTimestamps({ it.getLong("timestamp") }, 100)<br/>    .apply(MakeFieldObjectIfArray("log_params"))       // 1<br/>    .writeTo(elasticsearch)<br/>}</span></pre><ol class=""><li id="bc97" class="lr ls hh ir b is it iw ix ja lt je lu ji lv jm mi lx ly lz bi translated">专注于什么</li></ol><p id="5399" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">接下来就是提高“可操作性”了。检查发生了什么的唯一方法是检查Elasticsearch。如果中间发生了什么事情(如上)，很难准确指出问题是什么。因此，我们应该添加日志记录:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="4a25" class="li jo hh le b fi lj lk l ll lm">val pipeline = Pipeline.create().apply {<br/>  readFrom(wikipedia)<br/>    .withTimestamps({ it.getLong("timestamp") }, 100)<br/>    .apply(MakeFieldObjectIfArray("log_params"))<br/>    .peek()                                           // 1<br/>    .writeTo(elasticsearch)<br/>}</span></pre><ol class=""><li id="08e5" class="lr ls hh ir b is it iw ix ja lt je lu ji lv jm mi lx ly lz bi translated">我们将每个项目记录到标准输出中</li></ol><p id="4ef3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">对于大量的数据，这可能是太多的噪音。一个样本就足够了:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="2400" class="li jo hh le b fi lj lk l ll lm">fun sampleEvery(frequency: Int) = PredicateEx {<br/>  Random.nextInt(frequency) == 0                      // 1<br/>}</span><span id="efe1" class="li jo hh le b fi mh lk l ll lm">val toStringFn = FunctionEx&lt;Any?, String&gt; {<br/>  it?.toString()                                      // 2<br/>}</span></pre><ol class=""><li id="212f" class="lr ls hh ir b is it iw ix ja lt je lu ji lv jm mi lx ly lz bi translated">如果<code class="du ln lo lp le b">0</code>和<code class="du ln lo lp le b">frequency</code>之间的随机值为<code class="du ln lo lp le b">0</code>，则返回<code class="du ln lo lp le b">true</code></li><li id="06de" class="lr ls hh ir b is ma iw mb ja mc je md ji me jm mi lx ly lz bi translated">零安全<code class="du ln lo lp le b">toString()</code></li></ol><p id="2345" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们现在可以很好地利用这段代码了:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="7f6d" class="li jo hh le b fi lj lk l ll lm">val pipeline = Pipeline.create().apply {<br/>  readFrom(wikipedia)<br/>    .withTimestamps({ it.getLong("timestamp") }, 100)<br/>    .apply(MakeFieldObjectIfArray("log_params"))<br/>    .peek(sampleEvery(50), toStringFn)                // 1<br/>    .writeTo(elasticsearch)<br/>}</span></pre><ol class=""><li id="94c7" class="lr ls hh ir b is it iw ix ja lt je lu ji lv jm mi lx ly lz bi translated">平均每50个<strong class="ir hi">抽样一件</strong></li></ol><p id="b963" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">此外，Hazelcast提供了一个API来命名每个管道步骤。</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="0772" class="li jo hh le b fi lj lk l ll lm">class MakeFieldObjectIfArray(private val fieldName: String) : FunctionEx&lt;StreamStage, StreamStage&gt; {<br/>  override fun applyEx(stage: StreamStage) = stage<br/>    .setName("remove-log-params-if-array")            // 1<br/>    .map { json -&gt;<br/>      json.apply {<br/>        if (json.has(fieldName) &amp;&amp; json.get(fieldName) is JSONArray)<br/>          put(fieldName, JSONObject())<br/>      }<br/>    }<br/>}</span></pre><p id="9370" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这样，启动管道会输出以下DAG日志:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="0dfc" class="li jo hh le b fi lj lk l ll lm">digraph DAG {<br/>  "replace-log-params-if-array" [localParallelism=1];<br/>  "replace-log-params-if-array-add-timestamps" [localParallelism=1];<br/>  "map" [localParallelism=16];<br/>  "elasticSink" [localParallelism=2];<br/>  "replace-log-params-if-array" -&gt; "replace-log-params-if-array-add-timestamps" [label="isolated", queueSize=1024];<br/>  "replace-log-params-if-array-add-timestamps" -&gt; "map" [queueSize=1024];<br/>  "map" -&gt; "elasticSink" [queueSize=1024];<br/>}</span></pre><h1 id="9301" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">地理定位数据</h1><p id="9113" class="pw-post-body-paragraph ip iq hh ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">查看现有数据，我们可以注意到两种类型的贡献:</p><ol class=""><li id="27d5" class="lr ls hh ir b is it iw ix ja lt je lu ji lv jm mi lx ly lz bi translated">认证用户的贡献，<em class="ku">，例如</em>，<code class="du ln lo lp le b">GeographBot</code></li><li id="4c6d" class="lr ls hh ir b is ma iw mb ja mc je md ji me jm mi lx ly lz bi translated">匿名投稿，<em class="ku">例如，</em> <code class="du ln lo lp le b">84.243.214.62</code>针对IP v4，<code class="du ln lo lp le b">240D:2:A605:7600:A1DF:B7CA:5AF8:D971</code>针对IP v6</li></ol><p id="9856" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">使用前者没有简单的地理定位方法，但是可以利用后者的库和在线API。在这篇文章中，我选择使用<a class="ae kq" href="https://www.maxmind.com/en/solutions/geoip2-enterprise-product-suite/anonymous-ip-database" rel="noopener ugc nofollow" target="_blank"> MaxMind GeoIP数据库</a>。它提供了一个本地文件和一个库来利用它。</p><p id="cc9b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们添加必要的依赖项:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="6803" class="li jo hh le b fi lj lk l ll lm">&lt;dependency&gt;<br/>    &lt;groupId&gt;commons-validator&lt;/groupId&gt;<br/>    &lt;artifactId&gt;commons-validator&lt;/artifactId&gt;<br/>    &lt;version&gt;1.7&lt;/version&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>    &lt;groupId&gt;com.maxmind.geoip2&lt;/groupId&gt;<br/>    &lt;artifactId&gt;geoip2&lt;/artifactId&gt;<br/>    &lt;version&gt;2.15.0&lt;/version&gt;<br/>&lt;/dependency&gt;</span></pre><p id="e5dd" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然后，我们可以在处理管道中添加一个额外的步骤来检查用户是否是IP，如果是，则添加信息:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="8692" class="li jo hh le b fi lj lk l ll lm">val enrichWithLocation = { stage: StreamStage&lt;JSONObject&gt; -&gt;<br/>  stage.setName("enrich-with-location")                         // 1<br/>    .mapUsingService(ServiceFactories.sharedService(databaseReaderSupplier)) { reader: DatabaseReader, json: JSONObject -&gt;<br/>       json.apply {<br/>         if (!json.optBoolean("bot") &amp;&amp; json.has("user")) {    // 2<br/>           val user = json.getString("user")<br/>           if (InetAddressValidator.getInstance().isValid(user)) {  // 3<br/>             reader.tryCity(InetAddress.getByName(user))       // 4<br/>                   .ifPresent { json.withLocationFrom(it) }    // 5<br/>           }<br/>         }<br/>      }<br/>    }<br/>}</span><span id="1a83" class="li jo hh le b fi mh lk l ll lm">val pipeline = Pipeline.create().apply {<br/>  readFrom(wikipedia)<br/>    .withTimestamps({ it.getLong("timestamp") }, 100)<br/>    .apply(MakeFieldObjectIfArray("log_params"))<br/>    .apply(enrichWithLocation)                                  // 6<br/>    .peek(sampleEvery(50), toStringFn)<br/>    .writeTo(elasticsearch)<br/>}</span></pre><ol class=""><li id="5654" class="lr ls hh ir b is it iw ix ja lt je lu ji lv jm mi lx ly lz bi translated">设置描述性名称</li><li id="ff19" class="lr ls hh ir b is ma iw mb ja mc je md ji me jm mi lx ly lz bi translated">如果bot属性为假并且用户属性存在</li><li id="e97f" class="lr ls hh ir b is ma iw mb ja mc je md ji me jm mi lx ly lz bi translated">验证用户是IP、v4还是v6</li><li id="32d7" class="lr ls hh ir b is ma iw mb ja mc je md ji me jm mi lx ly lz bi translated">地理定位IP</li><li id="2ed7" class="lr ls hh ir b is ma iw mb ja mc je md ji me jm mi lx ly lz bi translated">将数据添加到JSON中</li><li id="0a75" class="lr ls hh ir b is ma iw mb ja mc je md ji me jm mi lx ly lz bi translated">将步骤添加到管道中</li></ol><h1 id="37ac" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">我们的第一次数据可视化</h1><p id="c86d" class="pw-post-body-paragraph ip iq hh ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">有了地理定位数据，我们希望在世界地图上显示变化。好消息是，Kibana提供了这样一个开箱即用的小部件。</p><ol class=""><li id="af54" class="lr ls hh ir b is it iw ix ja lt je lu ji lv jm mi lx ly lz bi translated">转到分析|地图</li><li id="5387" class="lr ls hh ir b is ma iw mb ja mc je md ji me jm mi lx ly lz bi translated">点击添加层按钮</li><li id="a82d" class="lr ls hh ir b is ma iw mb ja mc je md ji me jm mi lx ly lz bi translated">选择文档</li><li id="bdd0" class="lr ls hh ir b is ma iw mb ja mc je md ji me jm mi lx ly lz bi translated">对于索引，选择<code class="du ln lo lp le b">wikipedia</code></li></ol><p id="7e96" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">不幸的是，Kibana抱怨索引不包含任何地理空间字段！</p><p id="3b09" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">事实上，虽然我们对数据进行了格式化，以创建一个具有纬度和经度的数据字段，但Elasticsearch并不将其识别为地理点类型。我们需要明确地映射它。更糟糕的是，我们不能改变现有字段的类型。因此，我们需要停止管道，删除当前索引，并丢失所有数据。</p><ol class=""><li id="a35f" class="lr ls hh ir b is it iw ix ja lt je lu ji lv jm mi lx ly lz bi translated">转到管理|堆栈管理</li><li id="21dc" class="lr ls hh ir b is ma iw mb ja mc je md ji me jm mi lx ly lz bi translated">选择数据|索引管理</li><li id="ec11" class="lr ls hh ir b is ma iw mb ja mc je md ji me jm mi lx ly lz bi translated">检查<code class="du ln lo lp le b">wikipedia</code></li><li id="3497" class="lr ls hh ir b is ma iw mb ja mc je md ji me jm mi lx ly lz bi translated">单击管理索引按钮</li><li id="19ac" class="lr ls hh ir b is ma iw mb ja mc je md ji me jm mi lx ly lz bi translated">选择删除索引</li><li id="7822" class="lr ls hh ir b is ma iw mb ja mc je md ji me jm mi lx ly lz bi translated">确认删除</li></ol><p id="14af" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们现在准备绘制场地地图。</p><ol class=""><li id="313b" class="lr ls hh ir b is it iw ix ja lt je lu ji lv jm mi lx ly lz bi translated">转到管理|堆栈管理</li><li id="2fb0" class="lr ls hh ir b is ma iw mb ja mc je md ji me jm mi lx ly lz bi translated">选择数据|索引管理</li><li id="d643" class="lr ls hh ir b is ma iw mb ja mc je md ji me jm mi lx ly lz bi translated">单击索引模板选项卡(第三个)</li><li id="55c9" class="lr ls hh ir b is ma iw mb ja mc je md ji me jm mi lx ly lz bi translated">点击创建模板按钮</li><li id="7f3a" class="lr ls hh ir b is ma iw mb ja mc je md ji me jm mi lx ly lz bi translated">给它起一个相关的名字，<em class="ku">，例如</em>，<code class="du ln lo lp le b">geo-locate</code></li><li id="8dd5" class="lr ls hh ir b is ma iw mb ja mc je md ji me jm mi lx ly lz bi translated">设置与<code class="du ln lo lp le b">wikipedia</code>、<em class="ku">匹配的索引模式，例如</em>、<code class="du ln lo lp le b">wikipedia</code></li><li id="bf2a" class="lr ls hh ir b is ma iw mb ja mc je md ji me jm mi lx ly lz bi translated">单击“下一步”保留默认设置，直到到达第4步—映射</li><li id="a86c" class="lr ls hh ir b is ma iw mb ja mc je md ji me jm mi lx ly lz bi translated">添加一个名为<code class="du ln lo lp le b">location.coordinates</code>的新字段，类型为Geo-point</li><li id="6366" class="lr ls hh ir b is ma iw mb ja mc je md ji me jm mi lx ly lz bi translated">再次点击下一步，直到最后一步。预览选项卡应该显示以下JSON:</li></ol><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="b51b" class="li jo hh le b fi lj lk l ll lm">{<br/>  "template": {<br/>    "settings": {},<br/>    "mappings": {<br/>      "properties": {<br/>        "location": {<br/>          "properties": {<br/>            "coordinates": {<br/>              "type": "geo_point"<br/>            }<br/>          }<br/>        }<br/>      }<br/>    },<br/>    "aliases": {}<br/>  }<br/>}</span></pre><p id="0a11" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">点击创建模板按钮</p><p id="2a9e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在<code class="du ln lo lp le b">wikipedia</code>索引中，Elasticsearch会将名为<code class="du ln lo lp le b">location</code>的字段内名为<code class="du ln lo lp le b">coordinates</code>的每个字段映射到一个地理点。因此，我们需要稍微修改一下映射代码。</p><p id="0aaf" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们创建这样一个专用的映射函数:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="0cc1" class="li jo hh le b fi lj lk l ll lm">private fun JSONObject.withLocationFrom(response: CityResponse) {<br/>    val country = JSONObject()<br/>        .put("iso", response.country.isoCode)<br/>        .put("name", response.country.name)<br/>    val coordinates = JSONArray()<br/>        .put(response.location.longitude)<br/>        .put(response.location.latitude)<br/>    val location = JSONObject()<br/>        .put("country", country)<br/>        .put("coordinates", coordinates)<br/>        .put("city", response.city.name)<br/>        .put("timezone", response.location.timeZone)<br/>        .put("accuracy-radius", response.location.accuracyRadius)<br/>    put("location", location)<br/>}</span></pre><p id="af33" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们现在可以在管道中使用它:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="5769" class="li jo hh le b fi lj lk l ll lm">reader.tryCity(InetAddress.getByName(user))<br/>    .ifPresent { json.withLocationFrom(it) }</span></pre><p id="c110" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们再次启动管道。现在，我们可以尝试重复这些步骤来创建地图。这一次，它将我们映射的字段识别为地理点，并让我们更进一步。</p><p id="6903" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">点击右下角的添加图层按钮。你已经可以欣赏地图上显示的一些数据点了。</p><h1 id="9903" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">探索数据</h1><p id="6f46" class="pw-post-body-paragraph ip iq hh ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">数据点很优秀，但还不够。假设我们想通过条目的位置来理解它们。为此，我们需要添加字段，<em class="ku">，即</em>、<code class="du ln lo lp le b">meta.uri</code>和<code class="du ln lo lp le b">comment</code>。不要忘记命名层，并保存它。现在可以点击数据点来显示相关数据:</p><figure class="kz la lb lc fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mk"><img src="../Images/52c09a655def84e757872b568e30dcfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ZuUzIhMKVeb3Z5Oi.png"/></div></div></figure><p id="bb14" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">维基百科是全世界数百万用户的信息来源。因为贡献可以是匿名的(记住那些是地理定位的)，恶意用户可以更新一篇文章，而不是为了社区的利益，而是为了进一步的地缘政治议程。我们可以询问数据，文章-语言-位置三元组是否看起来没问题，是否会引发一些危险信号。我们已经有了通过<code class="du ln lo lp le b">meta.uri</code>和位置的文章，我们需要添加语言。</p><h1 id="d5a2" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">添加派生数据</h1><p id="9fe6" class="pw-post-body-paragraph ip iq hh ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">获得该语言有两个主要选项:</p><ol class=""><li id="a7fd" class="lr ls hh ir b is it iw ix ja lt je lu ji lv jm mi lx ly lz bi translated">从服务器的URL，例如，it.wikipedia.org意味着意大利语，而fr.wikipedia.org意味着法语</li><li id="89ac" class="lr ls hh ir b is ma iw mb ja mc je md ji me jm mi lx ly lz bi translated">来自注释(如果它不为空)</li></ol><p id="ce56" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">出于教育目的，我决定选择第二种。每个事件已经包含一个<code class="du ln lo lp le b">comment</code>字段。这里有一个例子:</p><ul class=""><li id="2eca" class="lr ls hh ir b is it iw ix ja lt je lu ji lv jm lw lx ly lz bi translated">Anagrames [[esgota]]，[[esgota]]，més canvis cosmètics</li><li id="a613" class="lr ls hh ir b is ma iw mb ja mc je md ji me jm lw lx ly lz bi translated">"已添加位置模板"</li><li id="2825" class="lr ls hh ir b is ma iw mb ja mc je md ji me jm lw lx ly lz bi">“[[:傑克·威爾許]]已添加至分类，[[Special:WhatLinksHere/傑克·威爾許|此页面包含在其他页面之内]]”</li><li id="0944" class="lr ls hh ir b is ma iw mb ja mc je md ji me jm lw lx ly lz bi translated">"/* wbset description-add:1 | ru */провинцияалжира"</li><li id="8ea9" class="lr ls hh ir b is ma iw mb ja mc je md ji me jm lw lx ly lz bi translated">"/* Treindiensten */"</li><li id="645b" class="lr ls hh ir b is ma iw mb ja mc je md ji me jm lw lx ly lz bi">“יצירת דף עם התוכן \”אסף \”בובי\” מרוז, יליד חיפה, הינו מוזיקאי, מתופף, חבר בלהקות אבטיפוס, קילר ואיפה הילד == הרכבים == === קילר הלוהטת === בשנת 1980 — שימש מתופף של הלהקה קילר הלוהטת. === אבטיפוס === הלהקה הוקמה ב[[קריות]] באמצע [[שנות השמונים]] ועברה גלגולי הרכב שונים. בגלגולה הראשון בשנת…\”</li><li id="a8e4" class="lr ls hh ir b is ma iw mb ja mc je md ji me jm lw lx ly lz bi translated">" { {坦姆·khảo|2}} →{ {坦姆·khảo|30em}} "</li><li id="a7db" class="lr ls hh ir b is ma iw mb ja mc je md ji me jm lw lx ly lz bi translated">"摩尔说他不是货车."</li><li id="0dd6" class="lr ls hh ir b is ma iw mb ja mc je md ji me jm lw lx ly lz bi">“[[:Конуклар (Джиде)]] категори чу тоьхна”</li><li id="e407" class="lr ls hh ir b is ma iw mb ja mc je md ji me jm lw lx ly lz bi translated">等等。</li></ul><p id="5e76" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">语言学家可以推断该领域的语言。还可以在管道中使用自动化流程。JVM生态系统中有几个NLP库，但是我把目光放在了专注于语言识别的<a class="ae kq" href="https://github.com/pemistahl/lingua" rel="noopener ugc nofollow" target="_blank"> Lingua </a>上。</p><p id="44bd" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们需要创建一个额外的阶段转换函数:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="2adc" class="li jo hh le b fi lj lk l ll lm">val languageDetectorSupplier = { _: ProcessorSupplier.Context -&gt;<br/>    LanguageDetectorBuilder<br/>        .fromAllSpokenLanguages()<br/>        .build()<br/>}                                                               // 1</span><span id="aaa4" class="li jo hh le b fi mh lk l ll lm">val enrichWithLanguage = { stage: StreamStage&lt;JSONObject&gt; -&gt;<br/>    stage.setName("enrich-with-language")<br/>        .mapUsingService(ServiceFactories.sharedService(languageDetectorSupplier)) { detector: LanguageDetector, json: JSONObject -&gt;<br/>            json.apply {<br/>                val comment = json.optString("comment")<br/>                if (comment.isNotEmpty()) {<br/>                    val language = detector.detectLanguageOf(comment)                              // 2<br/>                    if (language != Language.UNKNOWN) {<br/>                        json.put(<br/>                            "language", JSONObject()            // 3<br/>                                .put("code2", language.isoCode639_1)<br/>                                .put("code3", language.isoCode639_3)<br/>                                .put("name", language.name)<br/>                        )<br/>                    }<br/>                }<br/>            }<br/>        }<br/>}</span></pre><ol class=""><li id="bf6d" class="lr ls hh ir b is it iw ix ja lt je lu ji lv jm mi lx ly lz bi translated">创建提供语言检测器的函数</li><li id="a8bf" class="lr ls hh ir b is ma iw mb ja mc je md ji me jm mi lx ly lz bi translated">神奇就发生在这里</li><li id="7976" class="lr ls hh ir b is ma iw mb ja mc je md ji me jm mi lx ly lz bi translated">将语言相关的数据添加到JSON中</li></ol><p id="29a1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们现在可以在管道中使用新定义的函数:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="815d" class="li jo hh le b fi lj lk l ll lm">val pipeline = Pipeline.create().apply {<br/>        readFrom(wikipedia)<br/>            .withTimestamps({ it.getLong("timestamp") }, 100)<br/>            .apply(MakeFieldObjectIfArray("log_params"))<br/>            .apply(enrichWithLocation)<br/>            .apply(enrichWithLanguage)<br/>            .peek(sampleEvery(50), toStringFn)<br/>            .writeTo(elasticsearch)<br/>    }</span></pre><p id="7306" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在Kibana地图上，您现在可以添加任何与语言相关的字段，例如,<code class="du ln lo lp le b">language.name</code>,以便与其余数据点一起显示。然而，它们中的一些有一个空的<code class="du ln lo lp le b">comment</code>字段，所以语言没有显示。一种选择是相应地更新数据管道，但是也可以在Kibana接口上过滤掉不需要的数据点。总的来说，就是这样:无论如何都要推送数据，把他们想要显示的数据留给最终用户。</p><p id="2ce4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在地图上，转到过滤部分，添加一个KQL过滤器，过滤掉没有值的数据点:<code class="du ln lo lp le b">language.name : *</code>。结果如下所示:</p><figure class="kz la lb lc fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ml"><img src="../Images/a779da09f70b87331ef513e2fc9a84a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Z5kSaVBDXenTvP5B.png"/></div></div></figure><h1 id="984d" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">提炼数据</h1><p id="48c7" class="pw-post-body-paragraph ip iq hh ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">它已经更好了，尽管我们可以注意到一些差异:</p><ul class=""><li id="c710" class="lr ls hh ir b is it iw ix ja lt je lu ji lv jm lw lx ly lz bi translated">“Ngfn”不是如此，但更像是有人没有找到一个好的评论</li><li id="74cd" class="lr ls hh ir b is ma iw mb ja mc je md ji me jm lw lx ly lz bi translated">“сюжет”可以是<a class="ae kq" href="https://en.wiktionary.org/wiki/%D1%81%D1%8E%D0%B6%D0%B5%D1%82" rel="noopener ugc nofollow" target="_blank">保加利亚语、哈萨克语或俄语</a>，绝对不是蒙古语</li></ul><p id="59a9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">尽管Lingua有很好的结果，但它也容易出错。幸运的是，Lingua可以从一个文本片段和一个语言地图中返回一种语言，并给出可信度等级。第一种语言的置信度为1.0；其他的可信度在0.0到1.0之间。</p><p id="ca85" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">例如，注释“Nufüs”返回以下映射:</p><ul class=""><li id="8894" class="lr ls hh ir b is it iw ix ja lt je lu ji lv jm lw lx ly lz bi translated">1.0:土耳其语</li><li id="4992" class="lr ls hh ir b is ma iw mb ja mc je md ji me jm lw lx ly lz bi translated">0.762256422055537:德语</li><li id="8c4c" class="lr ls hh ir b is ma iw mb ja mc je md ji me jm lw lx ly lz bi translated">0.6951232183399704:阿塞拜疆</li><li id="1172" class="lr ls hh ir b is ma iw mb ja mc je md ji me jm lw lx ly lz bi translated">0.667947340824422:爱沙尼亚语</li><li id="20d1" class="lr ls hh ir b is ma iw mb ja mc je md ji me jm lw lx ly lz bi translated">0.5291088632328994:匈牙利语</li><li id="75f6" class="lr ls hh ir b is ma iw mb ja mc je md ji me jm lw lx ly lz bi translated">0.3674326772623783:加泰罗尼亚语</li></ul><p id="d905" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">因此，第二语言的置信度等级越接近1，第一语言的置信度就越低。为了反映这一点，我们可以将1.0和第二语言的信心评级之间的差异添加到数据点中。上述代码更新为:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="ffb2" class="li jo hh le b fi lj lk l ll lm">val languagesWithConfidence = detector.computeLanguageConfidenceValues(comment)               // 1<br/>if (languagesWithConfidence.isNotEmpty()) {<br/>    val mostLikelyLanguage = languagesWithConfidence.firstKey()<br/>    val secondMostLikelyConfidence = languagesWithConfidence.filterNot { it.key == mostLikelyLanguage }.maxBy { it.value }?.value ?: 0.0 // 2<br/>    json.put(<br/>        "language", JSONObject()<br/>            .put("code2", mostLikelyLanguage.isoCode639_1)<br/>            .put("code3", mostLikelyLanguage.isoCode639_3)<br/>            .put("name", mostLikelyLanguage.name)<br/>            .put("confidence", 1.0 - secondMostLikelyConfidence) // 3<br/>    )<br/>}</span></pre><ol class=""><li id="a387" class="lr ls hh ir b is it iw ix ja lt je lu ji lv jm mi lx ly lz bi translated">获取语言的排序图</li><li id="8556" class="lr ls hh ir b is ma iw mb ja mc je md ji me jm mi lx ly lz bi translated">获取第二种语言的可信度，如果地图只有一个元素，则为0</li><li id="e5c5" class="lr ls hh ir b is ma iw mb ja mc je md ji me jm mi lx ly lz bi translated">将置信度添加到数据点</li></ol><p id="2e63" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">请注意，根据管道的第一个数据点，您可能会以int、<em class="ku">即</em>、0或1类型的<code class="du ln lo lp le b">language.confidence</code>字段结束。如果发生这种情况，您需要删除索引并创建一个带有<code class="du ln lo lp le b">Double</code>类型的索引模板，就像我们在上面对Geo-point所做的那样。</p><p id="9e32" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">此时，您可以显示语言可信度，并更新过滤器以过滤掉可信度低的数据点，<em class="ku">，例如</em>、<code class="du ln lo lp le b">language.name : * and language.confidence &gt; 0.2</code>。结果如下:</p><figure class="kz la lb lc fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ml"><img src="../Images/06db52ad0a6cece5ea092bd8d785209f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*N-VgnVg58VjZg6oa.png"/></div></div></figure><h1 id="6d68" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">结论</h1><p id="2e2f" class="pw-post-body-paragraph ip iq hh ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">在本文中，我们描述了如何借助Hazelcast平台的流水线部分和Kibana的可视化部分来可视化和探索数据集。后者不需要任何前端编码技能——或者任何编码技能。现在开始研究您的数据集，您不需要成为Pythonista或图形库专家:成为JVM的开发人员就足够了。</p><p id="427a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在就开始探索吧！</p><p id="70bf" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这篇博文的源代码在<a class="ae kq" href="https://github.com/hazelcast-demos/wikipedia-changes" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上。</p></div></div>    
</body>
</html>