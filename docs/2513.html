<html>
<head>
<title/>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1/>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/simplex-method-for-linear-programming-1f88fc981f50?source=collection_archive---------0-----------------------#2022-05-13">https://medium.com/mlearning-ai/simplex-method-for-linear-programming-1f88fc981f50?source=collection_archive---------0-----------------------#2022-05-13</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><h2 id="7ba9" class="hf hg hh bd hi hj hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id bi translated">线性规划问题</h2><p id="cf0a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io hr ip iq ir hv is it iu hz iv iw ix iy ha bi translated">线性规划问题是一类约束和目标函数方程本质上都是线性的问题。解决一个线性规划问题有多种方法，我们既可以用图解法也可以用代数法来解决这些问题。我们不会在这里讨论图形化方法。但是要记住的一个重要的事情是，当以图形方式求解时，线性规划问题的解驻留在图的顶点<strong class="ig iz"><em class="ja"/></strong>。此外，图形方法可用于2个变量(最多3个)的方程，否则可能无法绘制这些点。<br/>LPP的一个例子可以取为:<br/> Z = 4x + 6y</p><p id="ccba" class="pw-post-body-paragraph ie if hh ig b ih jb ij ik il jc in io hr jd iq ir hv je it iu hz jf iw ix iy ha bi translated">这是我们的目标函数，我们需要最大化或最小化这个<br/>-x+y≤11<br/>x+y≤27<br/>2x+5y≤90<br/>每一个都是约束方程。</p><pre class="jg jh ji jj fd jk jl jm jn aw jo bi"><span id="9a11" class="hf hg hh jl b fi jp jq l jr js">import numpy as np<br/>import matplotlib.pyplot as plt<br/>x = np.linspace(0,20,10000) <br/>y1 = 11.0 + x<br/>y2 = 27.0 - x<br/>y3 = (90-2*x)/5.0<br/>plt.plot(x,y1,label = r'$-x+y\leq11$')<br/>plt.plot(x,y2,label = r'$x+y\leq27$')<br/>plt.plot(x,y3,label = r'$2x+5y\leq90$')<br/>#plt.xlim((0, 20))<br/>#plt.ylim((0, 40))<br/>plt.xlabel(r'$x$')<br/>plt.ylabel(r'$y$')<br/>y5 = np.minimum(y1, y2)<br/>plt.fill_between(x, y3, y5, where=y3&lt;y5, color='grey', alpha=0.5)<br/>plt.legend(bbox_to_anchor=(1.05, 1), loc=2, borderaxespad=0.)<br/>plt.show()</span></pre><figure class="jg jh ji jj fd jt er es paragraph-image"><div class="ab fe cl ju"><img src="../Images/ac8836923fada4db625a7aa998893558.png" data-original-src="https://miro.medium.com/v2/format:webp/1*m9PoY1m239mFA9ISVN7a5g.png"/></div></figure><p id="c774" class="pw-post-body-paragraph ie if hh ig b ih jb ij ik il jc in io hr jd iq ir hv je it iu hz jf iw ix iy ha bi translated">现在，我们知道线性规划问题的解位于其中一个顶点。我们可以计算每个顶点的解的z值，并检查哪个是最大值。然而，有一条经验法则:</p><ul class=""><li id="a783" class="jx jy hh ig b ih jb il jc hr jz hv ka hz kb iy kc kd ke kf bi translated">如果问题是最大化，那么离原点最远的点就是最大值</li><li id="6812" class="jx jy hh ig b ih kg il kh hr ki hv kj hz kk iy kc kd ke kf bi translated">如果问题是为了最小化，那么离原点最近的点就是最小值</li></ul><p id="8307" class="pw-post-body-paragraph ie if hh ig b ih jb ij ik il jc in io hr jd iq ir hv je it iu hz jf iw ix iy ha bi translated">如果可行域内有原点或图在负侧，则该规则将发生变化。<br/>此外，该解决方案仅适用于两个以上变量的情况，上帝会帮助我们绘制函数。</p><pre class="jg jh ji jj fd jk jl jm jn aw jo bi"><span id="5541" class="hf hg hh jl b fi jp jq l jr js">import sympy as sp<br/>x,y = sp.symbols('x y')<br/>eqn = [y-x-11,x+y-27]<br/>print(sp.solve(eqn,[x,y]))<br/>eqn = [y-x-11,2*x+5*y-90]<br/>print(sp.solve(eqn,[x,y]))<br/>eqn = [y+x-27,2*x+5*y-90]<br/>print(sp.solve(eqn,[x,y]))</span><span id="761f" class="hf hg hh jl b fi kl jq l jr js">OUTPUT<br/>{x: 8, y: 19}<br/>{x: 5, y: 16}<br/>{x: 15, y: 12}</span></pre><p id="0608" class="pw-post-body-paragraph ie if hh ig b ih jb ij ik il jc in io hr jd iq ir hv je it iu hz jf iw ix iy ha bi translated">你可以检查15，12会给我们目标函数的最大值，因此这就是我们对X，Y和相应目标函数的答案。</p><h2 id="3e19" class="hf hg hh bd hi hj hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id bi translated">单纯形算法</h2><p id="4c86" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io hr ip iq ir hv is it iu hz iv iw ix iy ha bi translated">单纯形算法是在1947年发展起来的，该算法的最初思想是利用乔治·伯纳德·丹齐格的最速下降法来寻找最优解。然而，最初的想法是沿着边缘移动。从上面的例子中可以明显看出，由于$\infty$点，这将是非常低效的。因此，这个想法立即被拒绝。因此，他开始致力于顶点到顶点的优化，因此单纯形算法诞生了。<br/>足够的历史让我们去评价算法:<br/>优化-</p><figure class="jg jh ji jj fd jt er es paragraph-image"><div class="er es km"><img src="../Images/986d69bab249bc584d91514ce5f1013c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/format:webp/1*ulSexiBcBTJ5JzbwnXguhA.png"/></div></figure><p id="fc90" class="pw-post-body-paragraph ie if hh ig b ih jb ij ik il jc in io hr jd iq ir hv je it iu hz jf iw ix iy ha bi translated">受限制:</p><figure class="jg jh ji jj fd jt er es paragraph-image"><div class="er es kn"><img src="../Images/ec68ef9122a84088163df947c2129734.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/format:webp/1*5RGycpgN2uTqyXkC9W20iw.png"/></div></figure><p id="5340" class="pw-post-body-paragraph ie if hh ig b ih jb ij ik il jc in io hr jd iq ir hv je it iu hz jf iw ix iy ha bi translated"><strong class="ig iz">单纯形算法的步骤</strong>使用单纯形问题解决线性规划问题有一些已定义的步骤集。基于我们如何设置单纯形问题，可以设置成不同的格式(最终结果不会改变)。单纯形算法的步骤是:</p><ul class=""><li id="258c" class="jx jy hh ig b ih jb il jc hr jz hv ka hz kb iy kc kd ke kf bi translated">以标准(正确)格式设置问题</li><li id="0b38" class="jx jy hh ig b ih kg il kh hr ki hv kj hz kk iy kc kd ke kf bi translated">将目标函数设置为最大问题(如果你有最小问题，将目标函数乘以-1</li><li id="935d" class="jx jy hh ig b ih kg il kh hr ki hv kj hz kk iy kc kd ke kf bi translated">将所有约束设置为≤格式(如果有≥约束，则将约束乘以-1</li><li id="18a0" class="jx jy hh ig b ih kg il kh hr ki hv kj hz kk iy kc kd ke kf bi translated">所有的变量都应该是正数</li><li id="0d78" class="jx jy hh ig b ih kg il kh hr ki hv kj hz kk iy kc kd ke kf bi translated">添加必要的时差变量(添加这些变量是为了使≥约束成为=类型</li><li id="1012" class="jx jy hh ig b ih kg il kh hr ki hv kj hz kk iy kc kd ke kf bi translated">创建初始单纯形表</li><li id="e87f" class="jx jy hh ig b ih kg il kh hr ki hv kj hz kk iy kc kd ke kf bi translated">识别对应于基本变量的原始基本解</li><li id="4ecb" class="jx jy hh ig b ih kg il kh hr ki hv kj hz kk iy kc kd ke kf bi translated">在最后一行(这将成为我们的枢纽列)中找到最大值-ve—这将是输入变量</li><li id="a310" class="jx jy hh ig b ih kg il kh hr ki hv kj hz kk iy kc kd ke kf bi translated">找到RHS与Pivot列的最小非负比率(这成为现有的基础变量</li><li id="c4d5" class="jx jy hh ig b ih kg il kh hr ki hv kj hz kk iy kc kd ke kf bi translated">使用高斯-乔丹消去法使其他元素(除输入变量外)为零</li><li id="3b1f" class="jx jy hh ig b ih kg il kh hr ki hv kj hz kk iy kc kd ke kf bi translated">在最后一行中找到下一个最大值</li><li id="7793" class="jx jy hh ig b ih kg il kh hr ki hv kj hz kk iy kc kd ke kf bi translated">当最后一行没有-ve值时停止</li></ul><p id="b17a" class="pw-post-body-paragraph ie if hh ig b ih jb ij ik il jc in io hr jd iq ir hv je it iu hz jf iw ix iy ha bi translated">这将通过一个例子变得清楚。让我们用图解法解决同样的问题。</p><p id="8663" class="pw-post-body-paragraph ie if hh ig b ih jb ij ik il jc in io hr jd iq ir hv je it iu hz jf iw ix iy ha bi translated"><em class="ja">例1: </em></p><figure class="jg jh ji jj fd jt er es paragraph-image"><div class="er es ko"><img src="../Images/95c4a29aa0589a69a4074ef3d6baf915.png" data-original-src="https://miro.medium.com/v2/resize:fit:588/format:webp/1*sXt2cevQIYZYTSF3cesZsQ.png"/></div></figure><p id="81db" class="pw-post-body-paragraph ie if hh ig b ih jb ij ik il jc in io hr jd iq ir hv je it iu hz jf iw ix iy ha bi translated"><strong class="ig iz">单纯形算法的实现—手动求解</strong> <br/> <strong class="ig iz"> <em class="ja">求解</em> </strong> <br/> <strong class="ig iz">步骤1 </strong>:以标准形式设置问题<br/>以标准形式设置我们需要做两件事:</p><ul class=""><li id="4881" class="jx jy hh ig b ih jb il jc hr jz hv ka hz kb iy kc kd ke kf bi translated">使目标函数为最大化形式(这里我们已经有了最大化形式的目标函数，所以我们不需要做任何事情</li><li id="3965" class="jx jy hh ig b ih kg il kh hr ki hv kj hz kk iy kc kd ke kf bi translated">将所有约束转换为≤格式这里所有约束已经是≤格式，所以我们不需要做任何事情</li></ul><p id="cfa9" class="pw-post-body-paragraph ie if hh ig b ih jb ij ik il jc in io hr jd iq ir hv je it iu hz jf iw ix iy ha bi translated">我们标准形式的问题变成了:</p><figure class="jg jh ji jj fd jt er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es kp"><img src="../Images/8700707854fd1e776ab338a383e97ba6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b7PMIdvQVNlh5uhclQrOQA.png"/></div></div></figure><p id="89c2" class="pw-post-body-paragraph ie if hh ig b ih jb ij ik il jc in io hr jd iq ir hv je it iu hz jf iw ix iy ha bi translated"><strong class="ig iz">第三步</strong>:设置单纯形表</p><figure class="jg jh ji jj fd jt er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es ku"><img src="../Images/db6623d35b4ec07a9ce0b5118de34867.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*baijg2MKd7tvKk7yRV-E2w.jpeg"/></div></div></figure><p id="7aa1" class="pw-post-body-paragraph ie if hh ig b ih jb ij ik il jc in io hr jd iq ir hv je it iu hz jf iw ix iy ha bi translated">以下是该表的元素:</p><ul class=""><li id="e6d9" class="jx jy hh ig b ih jb il jc hr jz hv ka hz kb iy kc kd ke kf bi translated">顶行是目标函数中变量的系数</li><li id="12af" class="jx jy hh ig b ih kg il kh hr ki hv kj hz kk iy kc kd ke kf bi translated">第二行是所有变量的名称(包括时差变量)</li><li id="3ca6" class="jx jy hh ig b ih kg il kh hr ki hv kj hz kk iy kc kd ke kf bi translated">第三行是第一个约束中变量的系数</li><li id="8ca8" class="jx jy hh ig b ih kg il kh hr ki hv kj hz kk iy kc kd ke kf bi translated">第四行是第二个约束中变量的系数</li><li id="6c3a" class="jx jy hh ig b ih kg il kh hr ki hv kj hz kk iy kc kd ke kf bi translated">第五行是第三个约束中变量的系数</li><li id="450c" class="jx jy hh ig b ih kg il kh hr ki hv kj hz kk iy kc kd ke kf bi translated">第六行是目标函数中各个变量的系数的负值</li></ul><p id="2389" class="pw-post-body-paragraph ie if hh ig b ih jb ij ik il jc in io hr jd iq ir hv je it iu hz jf iw ix iy ha bi translated">如果我们将X1、X2和X3设置为零，我们可以得到s1= 11、s2 = 27和s3 = 90的值，并且目标函数的相应值为零，因为确定目标函数(x1 &amp; x2)的所有变量都为零。</p><p id="7cd1" class="pw-post-body-paragraph ie if hh ig b ih jb ij ik il jc in io hr jd iq ir hv je it iu hz jf iw ix iy ha bi translated">这叫做初始基本可行解(x1，x2，s1，s2，s3) = (0，0，11，27，90)</p><p id="8f23" class="pw-post-body-paragraph ie if hh ig b ih jb ij ik il jc in io hr jd iq ir hv je it iu hz jf iw ix iy ha bi translated"><strong class="ig iz">步骤4 </strong>:从最后一行选择最大负值，确定进入和退出变量</p><figure class="jg jh ji jj fd jt er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es ku"><img src="../Images/1028f02b5f4c5254f02387f86b698872.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wOzq6yTOfE6RAQzCKLUu7Q.jpeg"/></div></div></figure><p id="4340" class="pw-post-body-paragraph ie if hh ig b ih jb ij ik il jc in io hr jd iq ir hv je it iu hz jf iw ix iy ha bi translated">这里我们有-6，因为x2的最大负值成为进入变量，RHS/1是11的最小值，所以s1成为退出变量。现在我们将执行高斯消去法来改变行。</p><p id="ef3f" class="pw-post-body-paragraph ie if hh ig b ih jb ij ik il jc in io hr jd iq ir hv je it iu hz jf iw ix iy ha bi translated"><strong class="ig iz">步骤5 </strong>:高斯消去法，使pivot列中的pivot元素1和其余元素为零</p><figure class="jg jh ji jj fd jt er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es ku"><img src="../Images/82d0991b0efb8a7ed61ccc0953562cdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yooEAQg00nHWS2tJ1iE8CA.jpeg"/></div></div></figure><p id="a32b" class="pw-post-body-paragraph ie if hh ig b ih jb ij ik il jc in io hr jd iq ir hv je it iu hz jf iw ix iy ha bi translated"><strong class="ig iz">步骤6 </strong>:如果最后一行有负值，继续相同的步骤。</p><figure class="jg jh ji jj fd jt er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es ku"><img src="../Images/6668175c98936a2a71f42ad1442cf22b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZQiAOWVbd-g11KFoNqzSZg.jpeg"/></div></div></figure><p id="b7f5" class="pw-post-body-paragraph ie if hh ig b ih jb ij ik il jc in io hr jd iq ir hv je it iu hz jf iw ix iy ha bi translated">在最后一行仍然有一个负值，我们需要重复这一步。(高斯消除和枢轴元素识别)</p><figure class="jg jh ji jj fd jt er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es ku"><img src="../Images/dc04b4debab5393981e030de2763324c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cod-FXtBbGSCFlc7VYKRaw.jpeg"/></div></div></figure><figure class="jg jh ji jj fd jt er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es ku"><img src="../Images/9a70efcb54872c8ab01cfa7db4fcfb06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DKkzFQ2XsDXygkXPMFdiAg.jpeg"/></div></div></figure><p id="2f5a" class="pw-post-body-paragraph ie if hh ig b ih jb ij ik il jc in io hr jd iq ir hv je it iu hz jf iw ix iy ha bi translated">正如我们在最后一个表格中看到的，底部一行中的所有值都是非负的。<br/>此外，已进入表格(未离开)的变量列在第一列x2、s1和x1中。<br/>这些成为基本变量，我们可以将它们中的每一个都等同于RHS，其余值为零。<br/>这也是我们在图解法中找到的解决方案，最后一个值132是该函数可以取的最大值。<br/>最终解变成(x1，x2，s1，s2，s3) = (15，12，14，0，0)</p><p id="5fd9" class="pw-post-body-paragraph ie if hh ig b ih jb ij ik il jc in io hr jd iq ir hv je it iu hz jf iw ix iy ha bi translated"><em class="ja">注1 </em>:忽略边算边算就是粗活<br/> <em class="ja">注2 </em>:我本来可以多解答几道题，但是很难用合适的字迹写这么多！！！</p><p id="dbad" class="pw-post-body-paragraph ie if hh ig b ih jb ij ik il jc in io hr jd iq ir hv je it iu hz jf iw ix iy ha bi translated">我们将使用<code class="du kv kw kx jl b">scipy</code>包解决一些问题(它不会给出单独的步骤),但会很快为我们解决问题。<br/>只需记住单纯形中标准格式的解被最大化。然而，在<code class="du kv kw kx jl b">scipy</code>中，标准格式是<strong class="ig iz">最小化</strong> <br/>我们的目标函数4x1 + 6x2到-4x1 + -6x2对于<code class="du kv kw kx jl b">SCIPY STANDARDIZATION</code> <br/>剩余的标准化与单纯形相同，因此我们的约束不需要改变。</p><pre class="jg jh ji jj fd jk jl jm jn aw jo bi"><span id="1d30" class="hf hg hh jl b fi jp jq l jr js">import numpy as np<br/>from scipy.optimize import linprog<br/>obj = [-4,-6] #These are coefficients of our objective function<br/>lhs = [[-1,1],[1,1],[2,5]] #LHS Inequalities<br/>rhs = [11,27,90]<br/>#lhs_eq = [[x1,x2],[y1,y2]] This will be required if there is an equality constraint not required here<br/>#rhs_eq = [[a1,a2]] This will be required if there is an equality constraint RHS value of the same<br/>bnd = [(0,float('inf')),(0,float('inf'))] #This is boundary of our decision variables used because positive</span><span id="8ab1" class="hf hg hh jl b fi kl jq l jr js">#optimization = linprog(c = obj,<br/>#                       A_ub = lhs,<br/>#                      b_ub = rhs,<br/>#                      bounds = bnd,<br/>#                      A_eq = lhs_eq,<br/>#                      b_eq = rhs_eq<br/>#                      method = 'simplex')<br/><br/>#If we had equality constraints we would've used the A_eq and b_eq variables. <br/><br/>optimization = linprog(c = obj,<br/>                       A_ub = lhs,<br/>                      b_ub = rhs,<br/>                      bounds = bnd,<br/>                      method = 'simplex')</span><span id="fc29" class="hf hg hh jl b fi kl jq l jr js">optimization</span><span id="e1cb" class="hf hg hh jl b fi kl jq l jr js">OUTPUT<br/>con: array([], dtype=float64)<br/>     fun: -132.0<br/> message: 'Optimization terminated successfully.'<br/>     nit: 4<br/>   slack: array([14.,  0.,  0.])<br/>  status: 0<br/> success: True<br/>       x: array([15., 12.])</span></pre><p id="5503" class="pw-post-body-paragraph ie if hh ig b ih jb ij ik il jc in io hr jd iq ir hv je it iu hz jf iw ix iy ha bi translated">正如我们所看到的，我们得到了与上述两种方法相同的解决方案(意外惊喜),否则我们不会有所期待。这就完成了单纯形法。</p></div><div class="ab cl ky kz go la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ha hb hc hd he"><p id="2fe5" class="pw-post-body-paragraph ie if hh ig b ih jb ij ik il jc in io hr jd iq ir hv je it iu hz jf iw ix iy ha bi translated"><strong class="ig iz">练习</strong>:</p><figure class="jg jh ji jj fd jt er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es lf"><img src="../Images/c25d95fd49fb275bae2563f311443e30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aE-fwlk4PVfd5QkCmyTGjQ.png"/></div></div></figure><ul class=""><li id="9244" class="jx jy hh ig b ih jb il jc hr jz hv ka hz kb iy kc kd ke kf bi translated">“内点”,这也是默认选项</li><li id="358e" class="jx jy hh ig b ih kg il kh hr ki hv kj hz kk iy kc kd ke kf bi translated">“修正单纯形”选择修正的两阶段单纯形法</li></ul><pre class="jg jh ji jj fd jk jl jm jn aw jo bi"><span id="9d85" class="hf hg hh jl b fi jp jq l jr js">import numpy as np<br/>from scipy.optimize import linprog<br/>obj = [-5,3,4,-7]<br/>lhs = [[1,1,1,1],<br/>      [1,0,1,0],<br/>      [2,1,1,0]]<br/>rhs = [14,7,13]<br/>bnd = [(0,float('inf')),(0,float('inf')),(0,float('inf')),(0,float('inf'))] #There are 4 bounds because 4 variables<br/><br/>optimize = linprog(c = obj,<br/>                  A_ub = lhs,<br/>                  b_ub = rhs,<br/>                  bounds = bnd,<br/>                  method = 'simplex')<br/>optimize</span><span id="c692" class="hf hg hh jl b fi kl jq l jr js"><br/>OUTPUT<br/>con: array([], dtype=float64)<br/>     fun: -98.0<br/> message: 'Optimization terminated successfully.'<br/>     nit: 7<br/>   slack: array([ 0.,  7., 13.])<br/>  status: 0<br/> success: True<br/>       x: array([ 0.,  0.,  0., 14.])</span></pre><p id="65db" class="pw-post-body-paragraph ie if hh ig b ih jb ij ik il jc in io hr jd iq ir hv je it iu hz jf iw ix iy ha bi translated">这给出了最佳基为(x1，x2，x3，x4) = (0，0，0，14)。</p><p id="8d6a" class="pw-post-body-paragraph ie if hh ig b ih jb ij ik il jc in io hr jd iq ir hv je it iu hz jf iw ix iy ha bi translated">希望这本笔记本能帮助你理解使用单纯形法的线性优化。</p><p id="46a2" class="pw-post-body-paragraph ie if hh ig b ih jb ij ik il jc in io hr jd iq ir hv je it iu hz jf iw ix iy ha bi translated">我刚刚开始在这个平台上写作，任何形式的反馈都有助于提高我的写作水平。</p><div class="lg lh ez fb li lj"><a rel="noopener follow" target="_blank" href="/mlearning-ai/mlearning-ai-submission-suggestions-b51e2b130bfb"><div class="lk ab dw"><div class="ll ab lm cl cj ln"><h2 class="bd iz fi z dy lo ea eb lp ed ef lq bi translated">Mlearning.ai提交建议</h2><div class="lr l"><h3 class="bd b fi z dy lo ea eb lp ed ef dx translated">如何成为Mlearning.ai上的作家</h3></div><div class="ls l"><p class="bd b fp z dy lo ea eb lp ed ef dx translated">medium.com</p></div></div><div class="lt l"><div class="lu l lv lw lx lt ly jv lj"/></div></div></a></div></div></div>    
</body>
</html>