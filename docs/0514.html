<html>
<head>
<title>Meta Ensemble Self-Learning Model with Optimization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">优化的元集成自学习模型</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/meta-ensemble-self-learning-model-with-optimization-9fa17d8764fa?source=collection_archive---------1-----------------------#2021-05-06">https://medium.com/mlearning-ai/meta-ensemble-self-learning-model-with-optimization-9fa17d8764fa?source=collection_archive---------1-----------------------#2021-05-06</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="201d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">元自我集成学习器包(pip安装元自我学习器)——<a class="ae jc" href="https://github.com/ajayarunachalam/meta-self-learner" rel="noopener ugc nofollow" target="_blank">https://github.com/ajayarunachalam/meta-self-learner</a></p><p id="cd40" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">你好，朋友们。在这篇博文中，提出了一个元学习者集合设计。元集成学习模型旨在更好地拟合任何复杂的数据，降低估计的不确定性。这两种自学习算法旨在找到最小化目标函数的最优权重。</p><p id="2e6d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">本设计集成为包<a class="ae jc" href="https://pypi.org/project/meta-self-learner/" rel="noopener ugc nofollow" target="_blank"> <strong class="ig hi">元自学者</strong> </a>的一部分。更多细节可以在GitHub页面<a class="ae jc" href="https://github.com/ajayarunachalam/meta-self-learner" rel="noopener ugc nofollow" target="_blank">这里</a>找到。这篇博文的所有代码都可以在这里找到<a class="ae jc" href="https://github.com/ajayarunachalam/meta-self-learner/blob/main/Full_Demo_Tested.ipynb" rel="noopener ugc nofollow" target="_blank"/></p><p id="d666" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">该包装的USP:-</strong></p><p id="8c5b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">"<strong class="ig hi">元自学习</strong>"为快速预测建模原型提供了几个集成学习器功能。通常，当输入样本超出训练分布、偏向于数据分布或易于出现噪声等错误时，预测会变得不可靠。当前的方法总的来说需要改变网络架构、模型微调、平衡数据的需要、增加模型大小等。此外，主要是算法的选择起着至关重要的作用，而可扩展性和学习能力随着复杂数据集而下降。在这个包中，我开发了一个集成框架，用于最小化学习算法中的泛化错误，而不管数据分布、类的数量、算法的选择、模型的数量、数据集的复杂性等。因此，总而言之，有了这个框架，人们可以更好地推断和概括。该软件包的另一个关键点是直观的管道，它以更稳定的方式构建模型，同时最大限度地减少对整体结果非常关键的欠拟合/过拟合。</p><p id="73ce" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">快速安装包:- </strong></p><p id="5f2a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">从</strong> <a class="ae jc" href="https://github.com/ajayarunachalam/meta-self-learner/blob/main/setup.sh" rel="noopener ugc nofollow" target="_blank"> <strong class="ig hi">这里</strong> </a>下载自动化脚本</p><blockquote class="jd je jf"><p id="bb19" class="ie if jg ig b ih ii ij ik il im in io jh iq ir is ji iu iv iw jj iy iz ja jb ha bi translated">在终端上运行以下命令</p></blockquote><p id="3cf0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">sudo bash setup.sh</p><p id="6d48" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">安装:- </strong></p><blockquote class="jd je jf"><p id="c1a2" class="ie if jg ig b ih ii ij ik il im in io jh iq ir is ji iu iv iw jj iy iz ja jb ha bi translated">使用画中画:</p></blockquote><p id="93d3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">pip安装元自学者</p><blockquote class="jd je jf"><p id="aff3" class="ie if jg ig b ih ii ij ik il im in io jh iq ir is ji iu iv iw jj iy iz ja jb ha bi translated">使用笔记本:</p></blockquote><p id="703d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">！pip安装元自学者</p><p id="4c2f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">元自学者工作流程:- </strong></p><p id="411a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">设计的框架流水线工作流程如图所示。</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div class="er es jk"><img src="../Images/5be885155da6ca2bd003a678d1a41863.png" data-original-src="https://miro.medium.com/v2/resize:fit:696/0*u3eIaniCAmhToTgu"/></div><figcaption class="js jt et er es ju jv bd b be z dx">Meta-Self-Learner Ensemble Pipeline</figcaption></figure><p id="38dc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第一层包括几个单独的分类器。我们使用了基本分类器，即逻辑回归(LR)、K-最近邻(KNN)、随机森林(RF)、支持向量机(SVM)、额外树分类器(ETC)和梯度推进机(GBM)。两个自学者(即，集成1和集成2)旨在找到最小化目标函数(即，对数损失函数)的最佳系数。利用在前一层中获得的一组给定的预测，两个元学习器定义两个不同的线性问题，并且旨在优化目标函数以找到降低损失的最佳系数。</p><p id="eb58" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">预处理的数据被输入到模型的第1层。“t”和“P”分别代表训练数据和预测。在第1层中，使用了许多独立的基础学习。第二层的输入包括先前第一层的预测。</p><p id="b70e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用了两种元自学习器集成方案。第三层将第二层预测的结果组合成一个简单的加权平均值(WA)。模型评估和结果解释最终在流水线的最后阶段完成。</p><p id="fbd3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">元自学习架构的细节如下</p><h1 id="2167" class="jw jx hh bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">第一层:-</h1><p id="4e41" class="pw-post-body-paragraph ie if hh ig b ih ku ij ik il kv in io ip kw ir is it kx iv iw ix ky iz ja jb ha bi translated">使用了六个分类器(LR、SVM、RF、ETC、GBM和KNN)。在这里，人们可以使用他们选择的任何机器学习算法。并且，建立任意数量的模型。所有分类器被应用两次:1)分类器在(X_train，y_train)上被训练，并被用于预测(X_valid)的类概率。2)在(X = (X_train + X_valid)，y= (y_train + y_valid)上训练分类器，并用于预测(X_test)的类概率。</p><h1 id="8cb6" class="jw jx hh bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">第二层:-</h1><p id="78e0" class="pw-post-body-paragraph ie if hh ig b ih ku ij ik il kv in io ip kw ir is it kx iv iw ix ky iz ja jb ha bi translated">来自X_valid上的前一层的预测被连接，并用于创建新的训练集(XV，y_valid)。X_test上的预测被连接以创建新的测试集(XT，y_test)。所提出的两种集成方法及其校准版本在(XV，y_valid)上训练，并用于预测(XT)的类概率。</p><h1 id="89e1" class="jw jx hh bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">第三层:-</h1><p id="7d00" class="pw-post-body-paragraph ie if hh ig b ih ku ij ik il kv in io ip kw ir is it kx iv iw ix ky iz ja jb ha bi translated">然后使用加权平均线性组合来自先前第2层的预测。</p><p id="12a8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">以这种方式，设计和部署了混合架构，其中独立分类器的预测通过元自学习器方法来组合，从而降低欠拟合/过拟合的风险。</p><p id="8ccf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们通过一个例子来动手操作一下。</p><p id="6630" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jg">入门</em></p><ol class=""><li id="3fd2" class="kz la hh ig b ih ii il im ip lb it lc ix ld jb le lf lg lh bi translated">导入并加载已安装的软件包元自学者</li></ol><figure class="jl jm jn jo fd jp"><div class="bz dy l di"><div class="li lj l"/></div></figure><p id="6c45" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">2.加载数据集</p><figure class="jl jm jn jo fd jp"><div class="bz dy l di"><div class="li lj l"/></div></figure><p id="b87d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">3.在训练、验证和测试集中拆分数据</p><figure class="jl jm jn jo fd jp"><div class="bz dy l di"><div class="li lj l"/></div></figure><p id="7dbf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">4.设置元自集成器的类配置。这里，我们从total digits数据集类中选取了四个类作为快速示例。</p><figure class="jl jm jn jo fd jp"><div class="bz dy l di"><div class="li lj l"/></div></figure><p id="9d8b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">5.在流水线中逐层构建元自学习架构</p><p id="dacc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">a.创建第一层</p><figure class="jl jm jn jo fd jp"><div class="bz dy l di"><div class="li lj l"/></div></figure><p id="7b55" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">b.创建第二层</p><figure class="jl jm jn jo fd jp"><div class="bz dy l di"><div class="li lj l"/></div></figure><p id="1f26" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">c.创建第三层/最终层</p><figure class="jl jm jn jo fd jp"><div class="bz dy l di"><div class="li lj l"/></div></figure><p id="ec78" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">6.性能评估&amp;为测井损失指标创建图表</p><figure class="jl jm jn jo fd jp"><div class="bz dy l di"><div class="li lj l"/></div></figure><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es lk"><img src="../Images/d5f97edcdcead6618959db8154d3f546.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*khwumURRQT4v1DmQ"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx">Log-loss evaluation metrics for different ensemble algorithms with meta-self-learner model</figcaption></figure><p id="168d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">7.绘制ROC、混淆矩阵和显示分类报告</p><figure class="jl jm jn jo fd jp"><div class="bz dy l di"><div class="li lj l"/></div></figure><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es lp"><img src="../Images/2a4e85a33a6099ecbf4a3966ac5e98b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QiBJSyv44C3DjhYx"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx">ROC, Confusion Matrix, and classification report</figcaption></figure><h1 id="43f9" class="jw jx hh bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">重要链接</h1><h2 id="bcd2" class="lq jx hh bd jy lr ls lt kc lu lv lw kg ip lx ly kk it lz ma ko ix mb mc ks md bi translated">完整的演示笔记本:-</h2><p id="fb61" class="pw-post-body-paragraph ie if hh ig b ih ku ij ik il kv in io ip kw ir is it kx iv iw ix ky iz ja jb ha bi translated"><a class="ae jc" href="https://github.com/ajayarunachalam/meta-self-learner/blob/main/Full_Demo_Tested.ipynb" rel="noopener ugc nofollow" target="_blank">https://github . com/ajayarunachalam/meta-self-learner/blob/main/Full _ Demo _ tested . ipynb</a></p><h2 id="05f6" class="lq jx hh bd jy lr ls lt kc lu lv lw kg ip lx ly kk it lz ma ko ix mb mc ks md bi translated">终端启动:</h2><p id="8b3b" class="pw-post-body-paragraph ie if hh ig b ih ku ij ik il kv in io ip kw ir is it kx iv iw ix ky iz ja jb ha bi translated">下载<a class="ae jc" href="https://github.com/ajayarunachalam/meta-self-learner/blob/main/tested_example.py" rel="noopener ugc nofollow" target="_blank">文件</a> &amp;在终端上运行以下命令</p><p id="3358" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> python tested_example.py </strong></p><h1 id="51ac" class="jw jx hh bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">连接</h1><p id="c290" class="pw-post-body-paragraph ie if hh ig b ih ku ij ik il kv in io ip kw ir is it kx iv iw ix ky iz ja jb ha bi translated">你可以打<a class="ae jc" href="mailto:ajay.arunachalam08@gmail.com" rel="noopener ugc nofollow" target="_blank">ajay.arunachalam08@gmail.com</a>找到我</p><p id="f265" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">感谢阅读。希望这篇文章有用:)</p><h1 id="651f" class="jw jx hh bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">参考资料:-</h1><p id="6ec3" class="pw-post-body-paragraph ie if hh ig b ih ku ij ik il kv in io ip kw ir is it kx iv iw ix ky iz ja jb ha bi translated"><a class="ae jc" href="https://www.spotintelligence.com/blog/how-to-implement-self-learning-systems/" rel="noopener ugc nofollow" target="_blank">https://www . spot intelligence . com/blog/how-to-implementation-self-learning-systems/</a></p><p id="9eb8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae jc" href="https://en.wikipedia.org/wiki/Ensemble_learning" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Ensemble_learning</a></p><p id="3362" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae jc" href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.log_loss.html" rel="noopener ugc nofollow" target="_blank">https://sci kit-learn . org/stable/modules/generated/sk learn . metrics . log _ loss . html</a></p></div></div>    
</body>
</html>