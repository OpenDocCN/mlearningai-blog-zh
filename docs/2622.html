<html>
<head>
<title>Get column name after fitting the machine learning pipeline</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">拟合机器学习管道后获取列名</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/get-column-name-after-fitting-the-machine-learning-pipeline-145a2a8051cc?source=collection_archive---------1-----------------------#2022-05-24">https://medium.com/mlearning-ai/get-column-name-after-fitting-the-machine-learning-pipeline-145a2a8051cc?source=collection_archive---------1-----------------------#2022-05-24</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/62761858495e0bdb532788d06fc6ea17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HPqHGs1CqClyrs9cPdJGHQ.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Picture by <a class="ae it" href="https://www.pexels.com/th-th/@hngstrm?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Henry &amp; Co.</a> from <a class="ae it" href="https://www.pexels.com/th-th/photo/2420294/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Pexels</a></figcaption></figure><p id="c3f8" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在上一篇文章中，我写了机器学习模型训练管道的简单实现，它可以使您的代码更加整洁。你可以通过下面的链接阅读。</p><div class="js jt ez fb ju jv"><a href="https://yannawut.medium.com/neat-data-preprocessing-with-pipeline-and-columntransformer-2a0468865b6b" rel="noopener follow" target="_blank"><div class="jw ab dw"><div class="jx ab jy cl cj jz"><h2 class="bd hi fi z dy ka ea eb kb ed ef hg bi translated">使用管道和ColumnTransformer进行整洁的数据预处理</h2><div class="kc l"><h3 class="bd b fi z dy ka ea eb kb ed ef dx translated">创建一个管道，您可以在其中输入任何数据，这些数据将在训练机器学习之前进行转换…</h3></div><div class="kd l"><p class="bd b fp z dy ka ea eb kb ed ef dx translated">yannawut.medium.com</p></div></div><div class="ke l"><div class="kf l kg kh ki ke kj in jv"/></div></div></a></div><p id="32c2" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">实现管道时的问题是，管道返回没有列标题的数组，因此很难解释模型并改进模型。</p><p id="b6b2" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在本文中，我将分享我的解决方案，并展示一个模型系数的示例图表。</p><h1 id="0f25" class="kk kl hh bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">📔<strong class="ak">本文内容</strong></h1><ol class=""><li id="46e3" class="li lj hh iw b ix lk jb ll jf lm jj ln jn lo jr lp lq lr ls bi translated">称之为管道中的一步</li><li id="ca70" class="li lj hh iw b ix lt jb lu jf lv jj lw jn lx jr lp lq lr ls bi translated">获取列名</li><li id="aafe" class="li lj hh iw b ix lt jb lu jf lv jj lw jn lx jr lp lq lr ls bi translated">绘制特征系数</li></ol><h1 id="e848" class="kk kl hh bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">🛣️管道</h1><p id="36db" class="pw-post-body-paragraph iu iv hh iw b ix lk iz ja jb ll jd je jf ly jh ji jj lz jl jm jn ma jp jq jr ha bi translated">参考上一篇文章，这是管道。</p><pre class="mb mc md me fd mf mg mh mi aw mj bi"><span id="74bf" class="mk kl hh mg b fi ml mm l mn mo"># sets of columns to be transformed in different ways</span><span id="09c8" class="mk kl hh mg b fi mp mm l mn mo">num_cols = ['city_development_index','relevent_experience', 'experience','last_new_job', 'training_hours']<br/>cat_cols = ['gender', 'enrolled_university', 'education_level', 'major_discipline', 'company_size', 'company_type']</span><span id="66be" class="mk kl hh mg b fi mp mm l mn mo"># Create pipelines for numerical and categorical features</span><span id="3c2a" class="mk kl hh mg b fi mp mm l mn mo">from sklearn.impute import SimpleImputer<br/>from sklearn.preprocessing import OneHotEncoder, MinMaxScaler<br/>from sklearn.pipeline import Pipeline</span><span id="a0cd" class="mk kl hh mg b fi mp mm l mn mo">num_pipeline = Pipeline(steps=[<br/>    ('impute', SimpleImputer(strategy='mean')),<br/>    ('scale',MinMaxScaler())<br/>])</span><span id="3723" class="mk kl hh mg b fi mp mm l mn mo">cat_pipeline = Pipeline(steps=[<br/>    ('impute', SimpleImputer(strategy='most_frequent')),<br/>    ('one-hot',OneHotEncoder(handle_unknown='ignore', sparse=False))<br/>])</span><span id="dcac" class="mk kl hh mg b fi mp mm l mn mo"># Create ColumnTransformer to apply pipeline for each column type</span><span id="3945" class="mk kl hh mg b fi mp mm l mn mo">from sklearn.compose import ColumnTransformer</span><span id="5abb" class="mk kl hh mg b fi mp mm l mn mo">col_trans = ColumnTransformer(transformers=[<br/>    ('num_pipeline',num_pipeline,num_cols),<br/>    ('cat_pipeline',cat_pipeline,cat_cols)<br/>    ],<br/>    remainder='drop',<br/>    n_jobs=-1)</span><span id="ac37" class="mk kl hh mg b fi mp mm l mn mo"># Add a model to a final pipeline, clf_pipeline</span><span id="5f6d" class="mk kl hh mg b fi mp mm l mn mo">from sklearn.linear_model import LogisticRegression</span><span id="3c1a" class="mk kl hh mg b fi mp mm l mn mo">clf = LogisticRegression(random_state=0)</span><span id="b1ab" class="mk kl hh mg b fi mp mm l mn mo">clf_pipeline = Pipeline(steps=[<br/>    ('col_trans', col_trans),<br/>    ('model', clf)<br/>])</span></pre><figure class="mb mc md me fd ii er es paragraph-image"><div class="er es mq"><img src="../Images/5295b0d933747e054f477ae9c7060376.png" data-original-src="https://miro.medium.com/v2/resize:fit:560/format:webp/0*HXfm8Upd1eFSZaLa.png"/></div></figure><p id="bede" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在此管道中，clf_pipeline(最终管道)包含col_trans (ColumnTransformer)和一个逻辑回归模型。</p><p id="1991" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在col_tran中，有num_pipeline和cat_pipeline。这些管道将分别转换数字特征和分类特征。</p><h1 id="d7d1" class="kk kl hh bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">🌲 1.称之为管道中的一步</h1><p id="6507" class="pw-post-body-paragraph iu iv hh iw b ix lk iz ja jb ll jd je jf ly jh ji jj lz jl jm jn ma jp jq jr ha bi translated">调用管道中的一个步骤可能很棘手。这就像你一步一步地爬树。</p><p id="63d9" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">从你应该记住的两个属性开始:</p><p id="1c1a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi"> named_steps </strong>:调用管道中的一个步骤</p><p id="e1f1" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi"> named_transformers_ </strong>:调用ColumnTransformer中的一步</p><p id="375e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果您不知道pipeline和ColumnTransformer之间的区别，请花5分钟时间回顾我以前的文章(上面的链接)。</p><p id="f347" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">例子</strong></p><p id="9fc1" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我想访问名为<strong class="iw hi">‘one-hot’</strong>的OneHotEncoder，以使用函数get_feature_names并在执行OneHotEncoder后获取功能名称</p><figure class="mb mc md me fd ii er es paragraph-image"><div class="er es mr"><img src="../Images/d660e55438cbb44d3ba9777a3d2865b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/format:webp/1*G-_cLC6NUmT9hOCeOEl1dA.png"/></div></figure><p id="19ff" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这是代码。</p><pre class="mb mc md me fd mf mg mh mi aw mj bi"><span id="a39b" class="mk kl hh mg b fi ml mm l mn mo">clf_pipeline.named_steps[“col_trans”].named_transformers_[“cat_pipeline”].named_steps[“one-hot”].get_feature_names(cat_cols)</span></pre><p id="e0aa" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">代码解释:</strong></p><ul class=""><li id="08f2" class="li lj hh iw b ix iy jb jc jf ms jj mt jn mu jr mv lq lr ls bi translated">从clf_pipeline(最终的管道)开始</li><li id="63ed" class="li lj hh iw b ix lt jb lu jf lv jj lw jn lx jr mv lq lr ls bi translated">。name_steps将调用“cal_trans ”,这是一个列转换器</li><li id="2246" class="li lj hh iw b ix lt jb lu jf lv jj lw jn lx jr mv lq lr ls bi translated">。name_transformer_将调用“cat_pipeline ”,它是“col_trans”内部的管道</li><li id="0865" class="li lj hh iw b ix lt jb lu jf lv jj lw jn lx jr mv lq lr ls bi translated">第二个。named_steps将调用所需的“one-hot”步骤。</li><li id="ed0a" class="li lj hh iw b ix lt jb lu jf lv jj lw jn lx jr mv lq lr ls bi translated">。get_feature_names类似于直接从OneHotEncoder中调用该函数</li></ul><h1 id="6b1d" class="kk kl hh bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">🤏 2.获取列名</h1><p id="0b39" class="pw-post-body-paragraph iu iv hh iw b ix lk iz ja jb ll jd je jf ly jh ji jj lz jl jm jn ma jp jq jr ha bi translated">管道实现的困难任务是获取列名，因为管道将返回没有列标题的数组。</p><p id="e3ee" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">解决方案是跟踪管道和列转换器流程。</p><p id="7381" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">P <strong class="iw hi"> ipeline </strong>:逐步转换数据，作为steps参数中的输入。<strong class="iw hi"> ColumnTransformer </strong>:并行转换数据，并按顺序连接结果，作为transformers参数中的输入。</p><p id="c038" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">大多数数据转换函数不改变列名(或列数)。因此，您只需关注几个改变列数的函数，如OneHotEncoder。</p><pre class="mb mc md me fd mf mg mh mi aw mj bi"><span id="1a3a" class="mk kl hh mg b fi ml mm l mn mo"># numerical columns not change, categorical columns change from one-hot encoder</span><span id="7834" class="mk kl hh mg b fi mp mm l mn mo">new_cat_cols = clf_pipeline.named_steps["col_trans"]\<br/>.named_transformers_["cat_pipeline"]\               .named_steps["one-hot"].get_feature_names(cat_cols)</span><span id="2e86" class="mk kl hh mg b fi mp mm l mn mo"># concatenate categorical columns with numerical columns to get all columns<br/>all_cols = np.concatenate([num_cols, new_cat_cols])</span></pre><p id="8398" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">代码解释:</strong></p><ul class=""><li id="9389" class="li lj hh iw b ix iy jb jc jf ms jj mt jn mu jr mv lq lr ls bi translated">使用get_feature_names获取新的分类列。(数字列不会改变。)</li><li id="b894" class="li lj hh iw b ix lt jb lu jf lv jj lw jn lx jr mv lq lr ls bi translated">get_feature_names函数内部的(cat_cols)会以“列名_类别值”的格式返回列名。<br/>如果没有自变量cat_cols，它将返回该列的索引。</li></ul><figure class="mb mc md me fd ii er es paragraph-image"><div class="er es mw"><img src="../Images/52a88d46335bc3cea0b661fd1647f644.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*0F64oNdZo06Fm1zE-vT0Cw.png"/></div><figcaption class="ip iq et er es ir is bd b be z dx">Compare get_feature_name with and without argument</figcaption></figure><ul class=""><li id="7a0d" class="li lj hh iw b ix iy jb jc jf ms jj mt jn mu jr mv lq lr ls bi translated">由于col_trans(一个ColumnTransformer)在cat_pipeline之前执行步骤num_pipeline，所以管道的结果将是分类列之前的数字列。所有列都是通过连接num_col和new_cat_col获得的。</li></ul><p id="c4de" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">注意:</strong> \只是将代码继续到新的一行。</p><h1 id="fdcc" class="kk kl hh bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">📊 3.绘制特征系数</h1><p id="b6f1" class="pw-post-body-paragraph iu iv hh iw b ix lk iz ja jb ll jd je jf ly jh ji jj lz jl jm jn ma jp jq jr ha bi translated">这个管道中的模型是逻辑回归，因此我们可以通过查看每个特性/列的系数来快速了解特性的重要性。</p><p id="d910" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">可以通过转到步骤“模型”并调用属性coef_</p><pre class="mb mc md me fd mf mg mh mi aw mj bi"><span id="7679" class="mk kl hh mg b fi ml mm l mn mo">coefs = clf_pipeline.named_steps["model"].coef_.flatten()<br/>coef = pd.DataFrame(zip(all_cols, coefs), columns=["feature", "coef"])<br/>coef["abs_coef"] = coef["coef"].apply(lambda x: abs(x))<br/>coef["colors"] = coef["coef"].apply(lambda x: "green" if x &gt; 0 else "red")<br/>coef = coef.sort_values("abs_coef", ascending=False)</span></pre><p id="aa35" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">代码解释:</strong></p><ul class=""><li id="87f8" class="li lj hh iw b ix iy jb jc jf ms jj mt jn mu jr mv lq lr ls bi translated">访问“模型”步骤以获取系数_</li><li id="ec7c" class="li lj hh iw b ix lt jb lu jf lv jj lw jn lx jr mv lq lr ls bi translated">将array coefs更改为dataframe coef，以便可以添加更多列。</li><li id="3652" class="li lj hh iw b ix lt jb lu jf lv jj lw jn lx jr mv lq lr ls bi translated">添加列“abs_coef ”,它是系数的绝对值</li><li id="580f" class="li lj hh iw b ix lt jb lu jf lv jj lw jn lx jr mv lq lr ls bi translated">添加列“颜色”,当coef为正时返回绿色，如果coef为负时返回红色。</li><li id="05f7" class="li lj hh iw b ix lt jb lu jf lv jj lw jn lx jr mv lq lr ls bi translated">按abs_coef列对数据帧进行排序，这样最重要的特性就在数据帧的顶部。</li></ul><p id="a6b0" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">使用seaborn库的柱状图绘制系数。数据是数据帧的核心。</p><pre class="mb mc md me fd mf mg mh mi aw mj bi"><span id="0a4f" class="mk kl hh mg b fi ml mm l mn mo"># Plot coef<br/>import matplotlib.pyplot as plt<br/>import seaborn as sns</span><span id="ff88" class="mk kl hh mg b fi mp mm l mn mo">%matplotlib inline</span><span id="21ab" class="mk kl hh mg b fi mp mm l mn mo">fig, ax = plt.subplots(1, 1, figsize=(12, 7))<br/>sns.barplot(x="feature",<br/>            y="coef",<br/>            data=coef.head(20),<br/>           palette=coef.head(20)["colors"])<br/>ax.set_xticklabels(ax.get_xticklabels(), rotation=90, fontsize=20)<br/>ax.set_title("Top 20 Features", fontsize=25)<br/>ax.set_ylabel("Coef", fontsize=22)<br/>ax.set_xlabel("Feature Name", fontsize=22)</span></pre><figure class="mb mc md me fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mx"><img src="../Images/3e0fcc4aa0999810ca7dd61420226b64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5CTuPOMfJxamSlc_vhjfqw.png"/></div></div></figure><h1 id="8ae8" class="kk kl hh bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">结论</h1><p id="88bf" class="pw-post-body-paragraph iu iv hh iw b ix lk iz ja jb ll jd je jf ly jh ji jj lz jl jm jn ma jp jq jr ha bi translated">您可以通过使用name_steps和name_transformer_爬上管道树来获得管道之后的列名。然后，您可以使用get_feature_names跟踪已更改的列名。之后，您可以找到模型系数并绘制图表来可视化特征重要性。</p><p id="6706" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果您有更好的方法来获得管道转换后的列名，请在评论中留下您的想法。</p><div class="js jt ez fb ju jv"><a rel="noopener follow" target="_blank" href="/mlearning-ai/mlearning-ai-submission-suggestions-b51e2b130bfb"><div class="jw ab dw"><div class="jx ab jy cl cj jz"><h2 class="bd hi fi z dy ka ea eb kb ed ef hg bi translated">Mlearning.ai提交建议</h2><div class="kc l"><h3 class="bd b fi z dy ka ea eb kb ed ef dx translated">如何成为Mlearning.ai上的作家</h3></div><div class="kd l"><p class="bd b fp z dy ka ea eb kb ed ef dx translated">medium.com</p></div></div><div class="ke l"><div class="my l kg kh ki ke kj in jv"/></div></div></a></div></div></div>    
</body>
</html>