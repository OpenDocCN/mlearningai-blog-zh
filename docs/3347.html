<html>
<head>
<title>Object Oriented Programming and ML Model development in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中面向对象编程和ML模型开发</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/object-oriented-programming-and-ml-model-development-in-python-ada4bf76529b?source=collection_archive---------1-----------------------#2022-08-21">https://medium.com/mlearning-ai/object-oriented-programming-and-ml-model-development-in-python-ada4bf76529b?source=collection_archive---------1-----------------------#2022-08-21</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/19f56c12adc99af2f188d2b085af677b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mGVK5EdCKj9z77uSXfBWUw.jpeg"/></div></div></figure><p id="7090" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">本文的目标是利用面向对象的编程方法，在python中构建可靠的机器学习模型。在详细讨论之前，我们应该先了解一些基础知识。</p><h2 id="6e59" class="jn jo hh bd jp jq jr js jt ju jv jw jx ja jy jz ka je kb kc kd ji ke kf kg kh bi translated">基础</h2><p id="3619" class="pw-post-body-paragraph ip iq hh ir b is ki iu iv iw kj iy iz ja kk jc jd je kl jg jh ji km jk jl jm ha bi translated">在oop范例下，一切都被认为是一个对象。该对象属于特定的类(类的实例)。</p><p id="10ba" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">例如，一个人是人类类的一个实例。</p><p id="4a99" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">所有的类都是由属性和方法定义的。</p><figure class="kp kq kr ks fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ko"><img src="../Images/67ae38907df57c2a039587829beb2399.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FRSr4dPt8ynfXMHutSAk7w.png"/></div></div></figure><p id="9197" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">python实现。</p><figure class="kp kq kr ks fd ii"><div class="bz dy l di"><div class="kt ku l"/></div></figure><h2 id="cb89" class="jn jo hh bd jp jq jr js jt ju jv jw jx ja jy jz ka je kb kc kd ji ke kf kg kh bi translated">一些糟糕的概念</h2><p id="0b25" class="pw-post-body-paragraph ip iq hh ir b is ki iu iv iw kj iy iz ja kk jc jd je kl jg jh ji km jk jl jm ha bi translated">在这一节中，我们将介绍python中一些重要的oops概念。</p><ol class=""><li id="a77c" class="kv kw hh ir b is it iw ix ja kx je ky ji kz jm la lb lc ld bi translated">遗产</li></ol><p id="23f9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">继承是通过继承父类的所有方法和属性来创建子类的能力。例如，学生可以是人类类的子类。</p><figure class="kp kq kr ks fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es le"><img src="../Images/6d76ad71597a4a0a3f2cf3ddf6b7550d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rj4u4o_EILo6Kjsw817-Jw.png"/></div></div><figcaption class="lf lg et er es lh li bd b be z dx">Class Student is created from the parent class human beings. Note that the student class inherited all the methods, and attributes of the parent class and also has an additional method defined.</figcaption></figure><p id="7c8c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">创建子类非常简单，只需将父类名作为输入放入类定义括号中。</p><p id="7e32" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">2.方法重载</p><p id="6190" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果父类和子类共享一个公共的方法名，那么子对象执行只在子类下定义的方法，而不是在父类下定义的方法。这有助于从父类中重新定义一些方法。</p><p id="3791" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">3.抽象类和方法</p><ul class=""><li id="d240" class="kv kw hh ir b is it iw ix ja kx je ky ji kz jm lj lb lc ld bi translated">一个抽象类可以被认为是其他类的蓝图。</li><li id="08ef" class="kv kw hh ir b is lk iw ll ja lm je ln ji lo jm lj lb lc ld bi translated">它充当基类。</li><li id="e37e" class="kv kw hh ir b is lk iw ll ja lm je ln ji lo jm lj lb lc ld bi translated">我们无法创建它的任何实例(对象)。</li><li id="2779" class="kv kw hh ir b is lk iw ll ja lm je ln ji lo jm lj lb lc ld bi translated">它有抽象方法，子类必须覆盖这些方法。(否则，会引发错误)</li></ul><p id="0c40" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">好处:-</p><ol class=""><li id="d572" class="kv kw hh ir b is it iw ix ja kx je ky ji kz jm la lb lc ld bi translated"><em class="kn">我们可以粗略地定义这个结构。(只是蓝图)</em></li><li id="bbb5" class="kv kw hh ir b is lk iw ll ja lm je ln ji lo jm la lb lc ld bi translated"><em class="kn">我们可以检查子类是否保留了某种结构(抽象方法)</em></li></ol><p id="6ddf" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们将在下一节更详细地研究抽象类。</p><h2 id="b645" class="jn jo hh bd jp jq jr js jt ju jv jw jx ja jy jz ka je kb kc kd ji ke kf kg kh bi translated">ML模型</h2><figure class="kp kq kr ks fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lp"><img src="../Images/58050d95f2deebb488ceecf8696eedb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J0WOaRmMzrcKCFljS5Y2ww.png"/></div></div><figcaption class="lf lg et er es lh li bd b be z dx">Supervised learning can be broadly described into two categories. We will look at how to leverage OOPS concepts to create a regression model.</figcaption></figure><p id="cd3a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在创建基本模型类之前。让我们写下模型应该具备的基本方法。</p><figure class="kp kq kr ks fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lq"><img src="../Images/aa7a37f49b00c26bf5c8a7c57faeefc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HzqnwTf_E7ZR33jGwnT6fg.png"/></div></div><figcaption class="lf lg et er es lh li bd b be z dx">A typical model blueprint.</figcaption></figure><p id="885e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在让我们为回归模型创建一个基础(抽象)类。</p><figure class="kp kq kr ks fd ii"><div class="bz dy l di"><div class="kt ku l"/></div></figure><p id="cdcc" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">注意，不需要定义抽象函数。它们应该被子类重载。我已经添加了来自sklearn基本模型类的get_params()方法。抽象函数是使用抽象方法decorator定义的。</p><p id="d39f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">抽象类是通过从标准库中的abc模块继承基类ABC来创建的。</p><p id="34f1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">线性回归模型</strong></p><figure class="kp kq kr ks fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lr"><img src="../Images/11b07ad140d125f2ce8d0abd5ccf3081.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*plJaf0-3o1rOvJ4IICOoCg.png"/></div></div></figure><p id="e51c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们将继承基类，并在它的基础上创建模型类。它将为该类提供一些基本的功能，并确保我们定义了fit和predict等方法(抽象的)。</p><figure class="kp kq kr ks fd ii"><div class="bz dy l di"><div class="kt ku l"/></div></figure><figure class="kp kq kr ks fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ls"><img src="../Images/9ca3401851496dd0152f379c556143bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yNqjkUQVtrPJlpJmUYB9Fw.png"/></div></div><figcaption class="lf lg et er es lh li bd b be z dx">Comparing our model with sklearn linear regression. Both the models give similar mse.</figcaption></figure><p id="29b1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">前馈神经网络</strong></p><p id="0d30" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们将使用TensorFlow、Keras和我们的抽象类来定义模型类。</p><figure class="kp kq kr ks fd ii"><div class="bz dy l di"><div class="kt ku l"/></div></figure><div class="lt lu ez fb lv lw"><a rel="noopener follow" target="_blank" href="/mlearning-ai/mlearning-ai-submission-suggestions-b51e2b130bfb"><div class="lx ab dw"><div class="ly ab lz cl cj ma"><h2 class="bd hi fi z dy mb ea eb mc ed ef hg bi translated">Mlearning.ai提交建议</h2><div class="md l"><h3 class="bd b fi z dy mb ea eb mc ed ef dx translated">如何成为Mlearning.ai上的作家</h3></div><div class="me l"><p class="bd b fp z dy mb ea eb mc ed ef dx translated">medium.com</p></div></div><div class="mf l"><div class="mg l mh mi mj mf mk in lw"/></div></div></a></div></div></div>    
</body>
</html>