<html>
<head>
<title>Object detection ML pipeline with YoloV5, Jenkins, Docker, and Flask</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有YoloV5、Jenkins、Docker和Flask的对象检测ML流水线</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/object-detection-ml-pipeline-with-yolov5-jenkins-docker-and-flask-98b46eb17f71?source=collection_archive---------1-----------------------#2022-08-19">https://medium.com/mlearning-ai/object-detection-ml-pipeline-with-yolov5-jenkins-docker-and-flask-98b46eb17f71?source=collection_archive---------1-----------------------#2022-08-19</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/455028d6e022702619c58623a51128bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*803Zr6QywzBHwlWDfqUboA.png"/></div></div></figure><p id="3f3b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">关于部署ML管道的持续工作，从仅仅训练和优化算法开始，使我分享了另一个基于以前数据集所做工作的设置。</p><p id="8136" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这里的对象检测挑战是识别和计数包含大量或多组非常相似的实例的图片中的实例数量。</p><p id="b4fd" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">第二个挑战是提供一个可以交互使用机器学习算法的平台。这可能意味着要么安装受操作系统限制的用户界面，要么提供可在线访问的web框架。</p><p id="d960" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">最后，在ML管道的环境中，代码的迭代，无论是机器学习优化还是模板格式化，都必须在部署的解决方案上定期更新。这意味着管理更新已部署服务的持续过程。</p><p id="0f81" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">该项目分为4个部分，涵盖了ML管道的不同功能:</p><ul class=""><li id="053f" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated">物体检测:机器学习算法，</li><li id="71b4" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">交互式用户界面:支持使用对象检测算法的框架，</li><li id="9bc2" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">部署:部署算法和接口的方法，</li><li id="56ae" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">CICD:管道根据对存储库的更新改变部署。</li></ul><p id="975c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">那些想要继续前进的人可以访问这个<a class="ae kb" href="https://github.com/Laoban-man/custom_yolo_cicd" rel="noopener ugc nofollow" target="_blank">库</a>上的GitHub代码。</p><h1 id="4ed9" class="kc kd hh bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">堆栈要求</h1><p id="1980" class="pw-post-body-paragraph ip iq hh ir b is la iu iv iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">该项目中使用了两个GCP计算引擎实例:</p><ul class=""><li id="ab41" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated">模型训练和编辑:Ubuntu 20.04，带1个NVDIA T4 GPU，2vCPU，16GB RAM，带有custom_yolo_coco库的克隆，其上安装了CUDA软件的兼容版本(老实说，你是这一个中的一个，有太多的例外…)</li><li id="5f8f" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">部署:Ubuntu 20.04不带GPU，4vCPU和32GB RAM，上面安装了Docker和Jenkins</li></ul><h1 id="bd4d" class="kc kd hh bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">设置堆栈</h1><p id="3f18" class="pw-post-body-paragraph ip iq hh ir b is la iu iv iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">主要编辑是在计算引擎实例上用GPU完成的，这大大加快了训练。迭代完成后，它们被提交并推送到GitHub，GitHub随后触发Jenkins在第二个计算引擎实例上重建并运行Docker容器，在第二个计算引擎实例中，GPU卡并不那么重要。第二个实例将托管Jenkins和Flask应用程序。</p><h2 id="0135" class="lf kd hh bd ke lg lh li ki lj lk ll km ja lm ln kq je lo lp ku ji lq lr ky ls bi translated">目标检测</h2><p id="f546" class="pw-post-body-paragraph ip iq hh ir b is la iu iv iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">训练主要是在GCP实例上用GPU完成的。</p><p id="14fd" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">尽管最近发表的<a class="ae kb" href="https://arxiv.org/abs/2207.02696" rel="noopener ugc nofollow" target="_blank"> Yolov7 </a>结果的结果提供了诱惑，但当不是深度学习的研究专家时，文档和支持是选择框架的一个重要因素。Yolov5已经被尝试了又尝试，以论坛等形式的支持是重要的。这里的安装说明是<a class="ae kb" href="https://docs.ultralytics.com/quick-start/" rel="noopener ugc nofollow" target="_blank"/>。我还特别喜欢脸书的Detectron2，它有更多的记录，覆盖了图像处理的大多数领域，但它需要相当多的资源来训练我正在处理的全分辨率数据集的模型。可靠的安装说明可在<a class="ae kb" rel="noopener" href="/@chengweizhang2012/how-to-train-detectron2-with-custom-coco-datasets-4d5170c9f389">这里</a>获得。</p><p id="100d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">正在讨论的数据集用彩色点标注，表示没有边界框的对象实例。因此，有一个完整的预处理步骤，首先创建边界框注释，然后将这些注释转换成与YOLOv5框架兼容的YOLO格式。尽管转换注释需要有趣的编码，但它不是这篇MLOps文章的核心部分，可以在基于这个<a class="ae kb" href="https://www.kaggle.com/code/yuchunchien/parse-file-with-annotation" rel="noopener ugc nofollow" target="_blank"> Kaggler </a>所做工作的主存储库中找到。对于那些在本地计算机和/或功能较弱的实例上工作的人来说，有一些代码可以对图像进行下采样。虽然这大大加快了处理和训练的速度，但结果却差得多，因为每个实例的信息减少了，而且下采样改变了点的颜色。后一个问题可以通过在下采样之前运行点颜色识别来缓解。</p><p id="146e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一旦数据集的格式正确，第一步就是用自定义数据Yolov5训练模型。下载的Yolov5存储库通过运行它包含的train.py文件使它变得非常简单:</p><pre class="lt lu lv lw fd lx ly lz ma aw mb bi"><span id="a4eb" class="lf kd hh ly b fi mc md l me mf">python train.py --data standard.yaml --weights best.pt --batch-size 32 --img 1408 --rect</span></pre><p id="4666" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">关于这个命令的一些细节:</p><ul class=""><li id="0ef5" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated">data: standard.yaml是一个指定不同参数的文件，例如定位点大小(尽管Yolov5建议使用其自动定位点特性来确定这一点)、用于训练、验证和测试的数据源或数字类:</li><li id="0816" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">weights: best.pt包含在下采样图像上运行500个时期的训练脚本后可用的最佳权重</li><li id="79dd" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">批量大小:参数指示每批训练多少图像，这是一个有用的参数，可以根据您的CPU或GPU RAM进行调整，但越大性能越好</li><li id="2f7a" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">img:指示训练数据的最大和预期图像大小，这也应该是测试和后续数据集的最大和预期图像大小</li><li id="42f1" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">rec:表示图像是矩形的。</li></ul><pre class="lt lu lv lw fd lx ly lz ma aw mb bi"><span id="d9b1" class="lf kd hh ly b fi mc md l me mf">train: ../datasets/images/train/  <br/>val: ../datasets/images/val/  <br/>test: # optional</span><span id="f012" class="lf kd hh ly b fi mg md l me mf"># Classes<br/>nc: 6 # number of classes<br/>names: [ 'None', 'category_1', 'category_2', 'category_3', 'category_4','category_5']</span><span id="3722" class="lf kd hh ly b fi mg md l me mf">anchors:<br/>  - [10,13, 16,30, 33,23] # adapted because of small instance size</span></pre><p id="5a14" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">运行train.py脚本启动培训，这将设置torch深度学习架构以及其他服务，如W&amp;B(用于培训监控)和ClearML(用于记录、编排MLops)，并在指定数量的时期上培训网络，直到完成或挂钩停止培训。在全分辨率5MB图像上运行Yolov5(甚至Detectron2)会占用大量资源，因此存储库中的best.pt是在下采样图像上训练的。</p><p id="2e6c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">得到的训练模型可以用整个数据集来测试:</p><pre class="lt lu lv lw fd lx ly lz ma aw mb bi"><span id="0b9d" class="lf kd hh ly b fi mc md l me mf">python detect.py --source relative-path-to-folder --weights best.pt</span></pre><p id="9593" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">或者在特定的图像上:</p><pre class="lt lu lv lw fd lx ly lz ma aw mb bi"><span id="3e25" class="lf kd hh ly b fi mc md l me mf">python detect.py --source relative-path-to-file --weights best.pt</span></pre><p id="cd3a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">code文件夹中开发并提供的类还包含一个方法，用于预测单个图像并保存包括边界框在内的输出。如果您手动运行它:</p><pre class="lt lu lv lw fd lx ly lz ma aw mb bi"><span id="c697" class="lf kd hh ly b fi mc md l me mf">test=custom_class("./code/data/Downsampled/")<br/>result=test.predict("./test.jpg")</span></pre><p id="11b7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">预测方法将在本地保存一个test.jpg，您可以打开它查看结果(如果有)</p><h2 id="bf2a" class="lf kd hh bd ke lg lh li ki lj lk ll km ja lm ln kq je lo lp ku ji lq lr ky ls bi translated">交互式用户界面</h2><p id="d337" class="pw-post-body-paragraph ip iq hh ir b is la iu iv iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">微型网络框架Flask 仍然是我的最爱，因为它提供了大量功能齐全的模板，并且可以轻松集成网站模板。</p><p id="2070" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">以下代码是Python中的完整Flask脚本:</p><pre class="lt lu lv lw fd lx ly lz ma aw mb bi"><span id="f47e" class="lf kd hh ly b fi mc md l me mf">import pickle<br/>from flask import Flask, render_template, request, flash, redirect, url_for<br/>from werkzeug.utils import secure_filename<br/>import os<br/>import time<br/>import matplotlib.pyplot as plt<br/>import pandas as pd<br/>import numpy as np<br/>from PIL import Image<br/>from PIL.Image import Image as PilImage<br/>import random<br/>import json<br/>import matplotlib.patches as patches<br/>import math<br/>from skimage import io<br/>import skimage.feature<br/>import cv2<br/>from custom_class import custom_class</span><span id="2386" class="lf kd hh ly b fi mg md l me mf">app = Flask(__name__)<br/>upload_folder = "./static/img"<br/>allowed_extensions = {"jpg"}</span><span id="16fe" class="lf kd hh ly b fi mg md l me mf">app = Flask(__name__)<br/>app.config["UPLOAD_FOLDER"] = upload_folder</span><span id="9a22" class="lf kd hh ly b fi mg md l me mf"><a class="ae kb" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route("/", methods=["GET"])<br/>def index():<br/>    """<br/>    Render the main landing page on arrival<br/>    """<br/>    return render_template("index.html")</span><span id="7bdb" class="lf kd hh ly b fi mg md l me mf"><a class="ae kb" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route("/index.html", methods=["GET"])<br/>def main_index():<br/>    """<br/>    Render the main landing page from other pages<br/>    """<br/>    return render_template("index.html")</span><span id="405e" class="lf kd hh ly b fi mg md l me mf"><a class="ae kb" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route("/single-post.html", methods=["GET"])<br/>def single_post():<br/>    """<br/>    Simple page explaining model choice, mostly empty<br/>    """<br/>    return render_template("single-post.html")</span><span id="8780" class="lf kd hh ly b fi mg md l me mf"><a class="ae kb" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route("/data_exploration.html", methods=["GET"])<br/>def data_exploration():<br/>    """<br/>    Simple page going through data exploration, mostly empty<br/>    """<br/>    return render_template("data_exploration.html")</span><span id="f9c0" class="lf kd hh ly b fi mg md l me mf">def allowed_file(filename):<br/>    """<br/>    Function verifying the file extension is within allowed list<br/>    """<br/>    return "." in filename and filename.rsplit(".", 1)[1].lower() in allowed_extensions</span><span id="78ca" class="lf kd hh ly b fi mg md l me mf"><a class="ae kb" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route("/new_test.html", methods=["GET", "POST"])<br/>def upload_file():<br/>    """<br/>    Render page which allows the user to upload a test file<br/>    """<br/>    if request.method == "POST":<br/>        # check if the post request has the file part<br/>        if "file" not in request.files:<br/>            flash("No file part")<br/>            return redirect(request.url)<br/>        file = request.files["file"]<br/>        # If the user does not select a file, the browser submits an<br/>        # empty file without a filename.<br/>        if file.filename == "":<br/>            flash("No selected file")<br/>            return redirect(request.url)<br/>        if file and allowed_file(file.filename):<br/>            filename = secure_filename(file.filename)<br/>            file.save(os.path.join(app.config["UPLOAD_FOLDER"], "test_image.jpg"))<br/>    return render_template("new_test.html")</span><span id="f0fe" class="lf kd hh ly b fi mg md l me mf"><a class="ae kb" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route("/prediction.html", methods=["GET"])<br/>def prediction():<br/>    """<br/>    Function verifying the file extension is within allowed list.<br/>    """<br/>    model = noaa_class()<br/>    result = model.predict()<br/>    return render_template("prediction.html")</span><span id="d95a" class="lf kd hh ly b fi mg md l me mf">if __name__ == "__main__":<br/>    app.run(host="0.0.0.0", port=5000, debug=True)</span></pre><p id="1291" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">注意:重要的边栏在这里，不要使用flask服务器进行生产。</p><p id="179d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">运行web应用程序所需的其余文件，主要是HTML和CSS文件，可以在存储库中找到。除非您特别关注模板化和格式化，否则在MLOps的上下文中浏览这些文件是没有帮助的。</p><p id="0002" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在运行下一步之前，您可以测试web应用程序:</p><pre class="lt lu lv lw fd lx ly lz ma aw mb bi"><span id="4fc5" class="lf kd hh ly b fi mc md l me mf">python main.py</span></pre><p id="725c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">由于debug=True参数，您应该能够访问localhost:5000上的web应用程序，并看到更新和变化。</p><h2 id="f4e0" class="lf kd hh bd ke lg lh li ki lj lk ll km ja lm ln kq je lo lp ku ji lq lr ky ls bi translated">部署</h2><p id="cac4" class="pw-post-body-paragraph ip iq hh ir b is la iu iv iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">确保在不同的服务器/计算机上快速可靠地部署一个设置的最简单的方法之一是将其装箱。构建一个满足运行脚本、包和依赖项的最低要求的映像，只要有合适的引擎运行该映像，它就可以在任何操作系统上运行。很明显，我正在接近<a class="ae kb" href="https://docs.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker </a>，它在实践中很好地提供了这些功能。</p><p id="93bb" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">构建映像的过程非常简单:</p><ul class=""><li id="3c97" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated">编写一个说明如何构建映像的dockerfile文件:</li></ul><pre class="lt lu lv lw fd lx ly lz ma aw mb bi"><span id="9e71" class="lf kd hh ly b fi mc md l me mf"># syntax=docker/dockerfile:1<br/>FROM ubuntu:20.04<br/>WORKDIR /code<br/>RUN apt update<br/>RUN apt-get install -y \<br/>    libpng-dev \<br/>    freetype* \<br/>    libblas-dev \<br/>    liblapack-dev \<br/>    libatlas-base-dev \<br/>    gfortran<br/>RUN apt-get install -y gcc musl-dev python3-pip libgl1<br/>COPY requirements.txt requirements.txt<br/>RUN pip install -r requirements.txt<br/>RUN pip install -U torch torchvision scikit-learn wandb<br/>RUN apt-get install git -y<br/>RUN git clone <a class="ae kb" href="https://github.com/ultralytics/yolov5" rel="noopener ugc nofollow" target="_blank">https://github.com/ultralytics/yolov5</a>  # clone<br/>RUN cd yolov5<br/>RUN pip install -r requirements.txt  # install<br/>COPY ./code /code<br/>ENTRYPOINT [ "python3" ]<br/>CMD [ "main.py" ]</span></pre><p id="5cd0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">无需深入细节，这里的<a class="ae kb" href="https://docs.docker.com/get-started/02_our_app/" rel="noopener ugc nofollow" target="_blank">和<a class="ae kb" href="https://luis-sena.medium.com/creating-the-perfect-python-dockerfile-51bdec41f1c8" rel="noopener">这里的</a>和</a>可以被破译，dockerfile被分成一个接一个的步骤执行的命令。在这里，我们从ubuntu:20.04的基础映像创建一个映像，设置工作目录，安装许多linux包和python库，复制code文件夹中包含的文件，然后运行main.py文件来启动Flask应用程序。</p><ul class=""><li id="e993" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated">建立形象:</li></ul><pre class="lt lu lv lw fd lx ly lz ma aw mb bi"><span id="ebf9" class="lf kd hh ly b fi mc md l me mf">docker image build -t custom_yolo_cicd .</span></pre><ul class=""><li id="d26b" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated">测试图像</li></ul><pre class="lt lu lv lw fd lx ly lz ma aw mb bi"><span id="e385" class="lf kd hh ly b fi mc md l me mf">docker run -p 5000:5000 custom_yolo_cicd</span></pre><p id="f746" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">由于5000:5000端口映射，您还可以看到localhost:5000上的输出，并且如果出现问题，可以很容易地识别运行映像时的潜在问题。如果您希望在运行时看不到终端的输出，请在run命令中添加-d标志，并关闭终端窗口。</p><h2 id="7b7f" class="lf kd hh bd ke lg lh li ki lj lk ll km ja lm ln kq je lo lp ku ji lq lr ky ls bi translated">CICD</h2><p id="0d24" class="pw-post-body-paragraph ip iq hh ir b is la iu iv iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">典型的学术项目会在前面三个步骤中的一个停止。这些文章的目标是展示将它们组合成可复制的设置的方法，其他人可以部署和使用这些设置。因此，最后一步是确保在进行更新和预期部署更新时，设置不需要重复的手动干预。Jenkins促进了ML管道的这一方面。</p><p id="73b8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><a class="ae kb" href="https://www.jenkins.io/" rel="noopener ugc nofollow" target="_blank"> Jenkins </a>是一个自动化服务器，我们将通过提交GitHub服务器来触发它。对于GitHub存储库的每一次更新，Jenkins都会关闭当前运行Flask web应用程序的Docker容器，重新构建映像(这样会更快，除非对库/包进行了重大更改)。另一种方法是，如果不仅仅更新容器参数，而仅仅更新诸如序列化模型或模型权重之类的文件，则确保文件在主机和容器之间共享，即通过绑定安装卷。</p><p id="a233" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为了设置Jenkins，我们将它安装在启动docker容器的同一个卷上。</p><p id="e327" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们创建了一个关于詹金斯的新项目。</p><figure class="lt lu lv lw fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mh"><img src="../Images/625254eaa94574e1064209f3fb56d616.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ynoGG9Ky-NbEIjLybshpSg.png"/></div></div><figcaption class="mi mj et er es mk ml bd b be z dx">Jenkins project creation page</figcaption></figure><p id="206f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在源代码管理中，选择Git并输入一个存储库，然后选择您第一次使用时最有可能需要创建的凭证。</p><figure class="lt lu lv lw fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mm"><img src="../Images/4ae0842bf852be2cb9e487560646f67e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YweraZFZBy66lS0dIYl-fw.png"/></div></div><figcaption class="mi mj et er es mk ml bd b be z dx">Project configuration page</figcaption></figure><p id="eaef" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">清空分支说明符</p><p id="ad01" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">选择GitHub hook trigger for Git SCM polling来触发带有Git提交的构建。</p><p id="42b7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在GitHub上，我们需要创建一个webhook来触发Jenkins。我们可以暴露一个端口。另一种方法是使用NGROK，一个反向代理，这是测试webhooks的理想方法。</p><p id="ed10" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">安装ngrok:</p><pre class="lt lu lv lw fd lx ly lz ma aw mb bi"><span id="edc5" class="lf kd hh ly b fi mc md l me mf">sudo snap install ngrok</span></pre><p id="5988" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">启动ngrok:</p><pre class="lt lu lv lw fd lx ly lz ma aw mb bi"><span id="04e5" class="lf kd hh ly b fi mc md l me mf">ngrok http 8080</span></pre><figure class="lt lu lv lw fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mn"><img src="../Images/17f384ae977d2edeea7b6a614c8dc730.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mqH56hTPjIaQG7EUaKC91Q.png"/></div></div><figcaption class="mi mj et er es mk ml bd b be z dx">Terminal output of running ngrok</figcaption></figure><p id="a4f9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">复制提供给GitHub webhook页面的链接，它位于您的存储库(不是用户)的设置中。</p><p id="2b01" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">回到Jenkins，我们可以在Jenkins项目配置页面的最后部分对构建进行编程，这需要选择“执行shell命令”。</p><figure class="lt lu lv lw fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mo"><img src="../Images/a98bb1aa9ae485c1b77341e690a44d14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yz6MW8-cQa47v4Tnzlo0UQ.png"/></div></div></figure><p id="c8fb" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在出现的文本框中添加以下bash代码。</p><pre class="lt lu lv lw fd lx ly lz ma aw mb bi"><span id="0108" class="lf kd hh ly b fi mc md l me mf">docker stop $(docker ps | grep "custom_yolo_cicd" | cut -d " " -f 1)<br/>cd /var/lib/jenkins/workspace/customer_yolo_cicd <br/>docker image build -t custom_yolo_cicd .<br/>docker run -dp 5000:5000 custom_yolo_cicd</span></pre><p id="7bbb" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">对于那些不太了解bash Shell脚本的人，我们首先识别并停止任何名为custom_yolo_cicd的Docker容器，然后进入Jenkins克隆custom_yolo_cicd的工作区和存储库，最后构建并运行Docker映像。</p><p id="64ae" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">注意:Jenkins使用Docker时可能存在权限问题，修复方法是在终端中使用以下命令:</p><pre class="lt lu lv lw fd lx ly lz ma aw mb bi"><span id="4530" class="lf kd hh ly b fi mc md l me mf">sudo usermod -a -G docker jenkins # requires a restart afterwards</span></pre><p id="e221" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Flask应用程序现在应该可以在您的主机实例地址的端口5000上访问:http:// <external-ip-address> :5000</external-ip-address></p><figure class="lt lu lv lw fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/455028d6e022702619c58623a51128bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*803Zr6QywzBHwlWDfqUboA.png"/></div></div><figcaption class="mi mj et er es mk ml bd b be z dx">Landing page of the Flask app</figcaption></figure><p id="2084" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果在启动Jenkins项目之前没有构建和运行Docker容器，那么最初的构建可能不起作用。</p><h1 id="76a6" class="kc kd hh bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">在实践中</h1><p id="4462" class="pw-post-body-paragraph ip iq hh ir b is la iu iv iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">假设我们将数据添加到训练计算引擎实例，并重新训练Yolov5模型或迭代Flask应用程序，新的权重将被保存并推送到存储库。新的提交将通过webhook触发Jenkins。这将关闭容器的当前版本，获取GitHub项目的最新版本，在本地构建最新的映像，然后运行新版本。</p><p id="df7c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">具体来说，在这种设置中，这采取以下形式:</p><ul class=""><li id="fa84" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated">访问培训GCP实例中克隆的Yolov5存储库</li><li id="d114" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">为模型提供一个包含数据位置和其他参数的standard.yaml(如果需要的话)</li><li id="380a" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">使用新参数或新数据运行训练脚本</li><li id="1c22" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">收集位于Yolov5存储库的runs文件夹中的跑步的best.pt权重</li><li id="7dc9" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">替换位于custom_yolo_cicd/code的部署中使用的现有best.pt版本</li><li id="4897" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">提交并推送custom_yolo_cicd的更改</li><li id="4bf6" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">Jenkins将用这些新数据重建并重新启动Docker容器。</li></ul><figure class="lt lu lv lw fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mp"><img src="../Images/5a7ed432751cdeb5a1e8eba1007a21e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HfcNxwUzvxPwRA8eKh7FKQ.png"/></div></div><figcaption class="mi mj et er es mk ml bd b be z dx">The final validation of all this work (Git-triggered build)</figcaption></figure><h1 id="766a" class="kc kd hh bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">结论</h1><p id="7e57" class="pw-post-body-paragraph ip iq hh ir b is la iu iv iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">尽管训练和超参数优化有限，Yolov5可以快速识别人群中甚至非常小的物体，但良好的性能需要大量的数据和大量的时期。</p><h1 id="c1ab" class="kc kd hh bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">丰富</h1><p id="42ce" class="pw-post-body-paragraph ip iq hh ir b is la iu iv iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">显然，在野生动物保护的背景下，用户界面不如API有用，API可以提交多个图像，而不必麻烦地选择单个文件。我相当偏爱<a class="ae kb" rel="noopener" href="/@bedjango/what-is-hug-da579ae15aad">拥抱</a>框架，尽管它的使用并不广泛，但它标榜高性能。</p><p id="84d9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Jenkins是确保自动化的一种方便的开源方式，但Heroku也可以托管Docker容器，而不必管理Jenkins的烦人的安装和管理。我还没有调查Heroku是否提供显卡。</p><p id="ea59" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">最后，当模型可能需要特别长的时间来优化时，跟进和记录在机器学习中尤为重要。本文中没有明确使用的两个工具是MLFlow和W&amp;B，它们记录训练运行并记录超参数、工件和性能。它们极大地帮助监控模型的进展情况，并建议如何改进它们。</p><p id="346f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">注意:这个设置是一个使用大量开源软件和框架实现的例子，可能不适合您的生产应用程序。</p><p id="78f8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">注意:欢迎在评论中提出与此堆栈改进相关的想法和建议。</p><div class="mq mr ez fb ms mt"><a rel="noopener follow" target="_blank" href="/mlearning-ai/mlearning-ai-submission-suggestions-b51e2b130bfb"><div class="mu ab dw"><div class="mv ab mw cl cj mx"><h2 class="bd hi fi z dy my ea eb mz ed ef hg bi translated">Mlearning.ai提交建议</h2><div class="na l"><h3 class="bd b fi z dy my ea eb mz ed ef dx translated">如何成为Mlearning.ai上的作家</h3></div><div class="nb l"><p class="bd b fp z dy my ea eb mz ed ef dx translated">medium.com</p></div></div><div class="nc l"><div class="nd l ne nf ng nc nh in mt"/></div></div></a></div></div></div>    
</body>
</html>