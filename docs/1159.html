<html>
<head>
<title>Augmented Reality Sudoku Solver: Extracting Sudoku from Image</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">增强现实数独求解器:从图像中提取数独</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/augmented-reality-sudoku-solver-part-ii-cdfc035a415c?source=collection_archive---------1-----------------------#2021-10-14">https://medium.com/mlearning-ai/augmented-reality-sudoku-solver-part-ii-cdfc035a415c?source=collection_archive---------1-----------------------#2021-10-14</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/44eb61b2a99acd78521620f2f58529a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7kh5ciDdZkE9i-ToSS7O2A.png"/></div></div></figure><p id="b22d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi jn translated">这篇文章是增强现实数独解算器的延续，我们将构建一个基于GUI的增强现实数独解算器。在本文中，我们将讨论该项目的图像处理管道，以及如何使用OpenCV在Python中实现我们的方法。我们在不同的步骤中讨论管道，以简化我们对代码的理解。</p><p id="a9f0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们的目标是解决任何N维的数独，其中N是一个非素数。该项目将以两种形式实施-</p><ul class=""><li id="fe0b" class="jw jx hh ir b is it iw ix ja jy je jz ji ka jm kb kc kd ke bi translated">一个选项来加载保存在系统上的图像或使用网络摄像头将图像馈送到程序，然后在系统上玩游戏。</li><li id="9b23" class="jw jx hh ir b is kf iw kg ja kh je ki ji kj jm kb kc kd ke bi translated">一个选项，使用增强现实和解决数独显示的网络摄像头的难题。</li></ul><p id="65a6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">项目以<a class="ae kk" href="https://en.wikipedia.org/wiki/Knuth%27s_Algorithm_X" rel="noopener ugc nofollow" target="_blank"> <em class="kl">算法X </em> </a>的形式使用<a class="ae kk" href="https://en.wikipedia.org/wiki/Dancing_Links" rel="noopener ugc nofollow" target="_blank"> <em class="kl">跳舞环节</em> </a>寻找数独难题的解。数独是一个众所周知的NP完全问题，算法X是实现一种贪婪的深度优先搜索来找到合适的解决方案的一种手段。该项目将分为4个部分</p><ul class=""><li id="c4ad" class="jw jx hh ir b is it iw ix ja jy je jz ji ka jm kb kc kd ke bi translated">第一部分<strong class="ir hi"> <em class="kl"> — </em> </strong> <a class="ae kk" rel="noopener" href="/mlearning-ai/augmented-reality-sudoku-solver-part-i-8e29e59cecab">了解数独解算器，即用于解数独的算法。</a></li><li id="6594" class="jw jx hh ir b is kf iw kg ja kh je ki ji kj jm kb kc kd ke bi translated">第二部分——处理来自相机的图像，以便能够提取数独的网格。</li><li id="9ad4" class="jw jx hh ir b is kf iw kg ja kh je ki ji kj jm kb kc kd ke bi translated">第三部分— <a class="ae kk" href="https://shashank-goyal-blogs.medium.com/augmented-reality-sudoku-solver-part-iii-d2370a9cbace" rel="noopener">处理图像和相应的模型，以检测每个单元中的数值。</a></li><li id="8654" class="jw jx hh ir b is kf iw kg ja kh je ki ji kj jm kb kc kd ke bi translated">第四部分— <a class="ae kk" href="https://shashank-goyal-blogs.medium.com/augmented-reality-sudoku-solver-part-iv-65afe2231e46" rel="noopener">使用PyGame构建GUI。</a></li></ul><h2 id="3c5f" class="km kn hh bd ko kp kq kr ks kt ku kv kw ja kx ky kz je la lb lc ji ld le lf lg bi translated">第二部分:处理来自相机的图像—</h2><p id="67ae" class="pw-post-body-paragraph ip iq hh ir b is lh iu iv iw li iy iz ja lj jc jd je lk jg jh ji ll jk jl jm ha bi translated">为了处理图像，我们使用python OpenCV库。这是一个简单的循序渐进的方法</p><ul class=""><li id="b77a" class="jw jx hh ir b is it iw ix ja jy je jz ji ka jm kb kc kd ke bi translated">检测数独的外部网格，并返回该网格内的面积。</li><li id="f292" class="jw jx hh ir b is kf iw kg ja kh je ki ji kj jm kb kc kd ke bi translated">通过查找轮廓的角来应用扭曲透视变换，以将数独从图像的一部分转换为完整的图像本身。</li><li id="2e17" class="jw jx hh ir b is kf iw kg ja kh je ki ji kj jm kb kc kd ke bi translated">获取数独的尺寸，即提取拼图子框中的行数和列数。</li><li id="d644" class="jw jx hh ir b is kf iw kg ja kh je ki ji kj jm kb kc kd ke bi translated">通过对每个单元应用卷积神经网络模型来提取数字值，得到最终矩阵。</li></ul><p id="03aa" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">数独图像处理课件- </strong></p><figure class="lm ln lo lp fd ii"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="95a0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这里，我们首先用以下变量初始化该类-</p><ul class=""><li id="5024" class="jw jx hh ir b is it iw ix ja jy je jz ji ka jm kb kc kd ke bi translated"><strong class="ir hi"> <em class="kl">图像:</em> </strong> Numpy包含图像数据的N维数组正在从相机加载。</li><li id="f110" class="jw jx hh ir b is kf iw kg ja kh je ki ji kj jm kb kc kd ke bi translated"><strong class="ir hi"> <em class="kl"> Fname: </em> </strong>图像的文件名，如果是从文件加载的话。</li><li id="d226" class="jw jx hh ir b is kf iw kg ja kh je ki ji kj jm kb kc kd ke bi translated"><strong class="ir hi"> <em class="kl"> Game_Size: </em> </strong>这是数独游戏的一行或一列中单元格的总数。</li><li id="a92e" class="jw jx hh ir b is kf iw kg ja kh je ki ji kj jm kb kc kd ke bi translated"><strong class="ir hi"> <em class="kl"> Box_Row: </em> </strong>这是数独一个盒子中的行数。</li><li id="abdc" class="jw jx hh ir b is kf iw kg ja kh je ki ji kj jm kb kc kd ke bi translated"><strong class="ir hi"> <em class="kl"> Box_Col: </em> </strong>这是数独的一个盒子中的列数。</li></ul><figure class="lm ln lo lp fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ls"><img src="../Images/3f0c67fdd59984d17f44c76fe1e45620.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9c9E2WqoMj90GgL5WXSFoA.png"/></div></div></figure><p id="d6a1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">第一步:检测外部数独网格- </strong></p><figure class="lm ln lo lp fd ii"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="6663" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">方法"<strong class="ir hi"> get_grid </strong>"找到最大的轮廓，并用白色像素遮蔽图像周围的区域。在这里，我们做了以下事情-</p><p id="1483" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们首先将图像转换成灰度。然后，我们使用在x轴方向上具有零偏差的(5，5)核来应用高斯模糊。然后，我们应用自适应阈值处理，该阈值处理用于为图像的每个局部区域寻找阈值因子，并相应地应用阈值处理。你可以在这里了解更多关于自适应阈值<a class="ae kk" href="https://www.pyimagesearch.com/2021/05/12/adaptive-thresholding-with-opencv-cv2-adaptivethreshold/" rel="noopener ugc nofollow" target="_blank">的知识。</a></p><p id="f546" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为了找到图像中的外部边缘，我们需要找到图像中的轮廓。轮廓是指物体的轮廓或剪影，在我们的例子中是数独游戏的轮廓。</p><p id="70a4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们使用OpenCV库的findContours方法，这里我们首先传递图像，然后传递cv2。RETR树用于计算图像轮廓之间的层次关系。cv2。CV_CHAIN_APPROX_SIMPLE用于压缩轮廓以节省空间。从这些轮廓中，我们使用cv2.contourArea作为关键字找到具有最大面积的轮廓。</p><p id="78d0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">找到最大轮廓后，我们执行健全性检查，以确保最大轮廓的面积大于250x250像素。接下来，我们生成两个蒙版，一个是黑色蒙版<strong class="ir hi"><em class="kl"/></strong>，白色的<strong class="ir hi"> <em class="kl">作为所选轮廓的内侧</em> </strong>区域，另一个是白色蒙版<strong class="ir hi"><em class="kl"/></strong>，白色的<strong class="ir hi"> <em class="kl">作为所选轮廓的外侧</em> </strong>。然后，我们将原始灰度图像的白色值位置复制到带有外部白色区域的白色蒙版上，得到下面的图像。这个区域是我们的<strong class="ir hi">感兴趣区域</strong>或<strong class="ir hi"> ROI </strong>。</p><figure class="lm ln lo lp fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ls"><img src="../Images/5306ebddc40e1376800d7d0081e20fc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ps6JZcSxnMjpl542GFixlA.png"/></div></div></figure><p id="a808" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们注意到ROI图像稍微有点倾斜，不适合完整的图像框架，即屏幕的视角没有超出平面视角。理想情况下，我们会希望有一个自上而下的，鸟瞰的拼图。</p><p id="dfc9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">第二步:应用扭曲透视变换- </strong></p><figure class="lm ln lo lp fd ii"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="7e9e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">方法“<strong class="ir hi"> get_warped </strong>”利用cv2.getPerspectiveTransform和cv2.warpPerspective来完成这些转换。</p><p id="be0a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们首先执行健全性检查，以确保前面的步骤是成功的，并且我们有一个包含ROI的图像。然后，我们使用cv2.arcLength找到拼图周围轮廓的周长。由于我们知道盒子将是一个矩形，我们知道它将有四个使用cv2.approxPolyDP找到的顶点。为了近似轮廓，我们使用轮廓周长的1.5%近似精度。</p><p id="016d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在找到这个图像的角坐标之后，我们近似输出扭曲图像的角坐标的位置。为了执行透视变换，我们需要一个变换矩阵，它是使用cv2.getPerspective变换计算的，传递来自原始图像的谜题框的坐标，后跟我们为输出图像指定的四个点。然后，我们使用cv2.warpPerspective应用转换。</p><figure class="lm ln lo lp fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lt"><img src="../Images/79f215aae0860a67a338415b5da42367.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a_Aha6GG1QNU-jeAVZ4bmg.png"/></div></div></figure><p id="22ff" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">第三步:获取数独的维度- </strong></p><figure class="lm ln lo lp fd ii"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="cd66" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为了使用“<strong class="ir hi"> get_dimensions </strong>”方法获得尺寸，我们首先使用Otsu的二值化对图像进行阈值处理。二值化后，我们只剩下由0和1组成的图像。现在我们应用简单的矩阵运算来推导子网格维数。</p><figure class="lm ln lo lp fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lt"><img src="../Images/2ae59b32c4d3c25440cfbc8bf87518cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D2ncZ7w4yTm-nF665IzzeA.png"/></div></div></figure><p id="fca2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为了获得尺寸，考虑如下所示的22x22像素的二值化后的图像。<br/>这里，<code class="du lu lv lw lx b">⬛</code>表示值为0的像素，<code class="du lu lv lw lx b">⬜</code>表示值为1的像素。</p><pre class="lm ln lo lp fd ly lx lz ma aw mb bi"><span id="4ce8" class="km kn hh lx b fi mc md l me mf">⬛⬛⬛⬛⬛⬛🔲🔲⬛⬛⬛⬛⬛⬛🔲🔲⬛⬛⬛⬛⬛⬛<br/>⬛🔲⬛⬛🔲⬛🔲🔲⬛🔲⬛⬛⬛⬛⬛🔲⬛⬛⬛⬛⬛⬛<br/>⬛⬛🔲⬛🔲⬛🔲🔲⬛⬛⬛⬛⬛⬛🔲🔲⬛🔲⬛⬛⬛⬛<br/>⬛⬛⬛⬛⬛⬛🔲⬛⬛⬛⬛🔲🔲⬛🔲⬛⬛⬛🔲⬛⬛⬛<br/>🔲⬛🔲⬛⬛🔲🔲🔲⬛🔲⬛⬛⬛⬛🔲🔲⬛⬛⬛⬛⬛⬛<br/>⬛⬛⬛⬛⬛⬛⬛🔲⬛⬛⬛⬛⬛⬛🔲🔲⬛⬛⬛⬛⬛⬛<br/>🔲🔲🔲🔲🔲🔲🔲🔲🔲🔲🔲🔲⬛🔲🔲🔲🔲🔲🔲🔲🔲🔲<br/>🔲🔲⬛🔲🔲🔲🔲⬛🔲🔲🔲🔲🔲🔲⬛🔲⬛🔲🔲⬛🔲🔲<br/>⬛⬛⬛⬛⬛⬛🔲🔲⬛⬛⬛⬛⬛⬛🔲🔲⬛⬛⬛⬛⬛⬛<br/>⬛⬛⬛⬛⬛⬛🔲🔲⬛⬛⬛⬛🔲⬛🔲🔲⬛⬛⬛⬛⬛⬛<br/>⬛🔲⬛⬛⬛⬛🔲🔲⬛⬛🔲⬛⬛⬛🔲🔲⬛🔲⬛⬛⬛⬛<br/>⬛⬛⬛⬛🔲⬛🔲🔲⬛⬛⬛⬛⬛⬛🔲⬛⬛⬛⬛🔲⬛⬛<br/>⬛⬛⬛⬛⬛⬛⬛🔲⬛⬛⬛🔲⬛⬛🔲🔲⬛⬛⬛⬛⬛🔲<br/>⬛⬛⬛⬛⬛⬛🔲🔲⬛⬛⬛⬛⬛⬛⬛🔲⬛⬛⬛⬛⬛⬛<br/>🔲🔲🔲🔲🔲🔲🔲🔲🔲🔲⬛🔲🔲🔲🔲🔲🔲🔲🔲🔲🔲🔲<br/>🔲🔲⬛🔲🔲🔲🔲⬛🔲🔲🔲🔲🔲🔲🔲🔲🔲🔲🔲🔲🔲🔲<br/>⬛⬛⬛⬛⬛⬛🔲🔲⬛⬛⬛⬛⬛⬛🔲🔲⬛⬛⬛⬛⬛⬛<br/>⬛🔲⬛⬛⬛⬛🔲🔲⬛🔲⬛⬛⬛⬛⬛🔲⬛⬛⬛⬛⬛🔲<br/>⬛⬛⬛⬛🔲⬛🔲🔲⬛⬛⬛⬛⬛⬛🔲🔲⬛⬛⬛⬛⬛⬛<br/>⬛⬛⬛⬛⬛🔲⬛🔲⬛⬛⬛🔲⬛⬛🔲⬛⬛🔲🔲⬛⬛⬛<br/>⬛⬛⬛⬛⬛⬛🔲🔲⬛⬛⬛⬛⬛⬛🔲🔲⬛⬛⬛⬛⬛⬛<br/>⬛⬛⬛⬛⬛⬛🔲🔲⬛⬛⬛⬛⬛⬛🔲🔲⬛⬛⬛⬛⬛⬛</span></pre><p id="abc2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">每个子网格中的白色像素或白色网格线中的黑色像素可以被视为噪声。然后，我们求出图像矩阵在纵轴和横轴上的总和。</p><pre class="lm ln lo lp fd ly lx lz ma aw mb bi"><span id="483c" class="km kn hh lx b fi mc md l me mf">⬛⬛⬛⬛⬛⬛ 🔲🔲 ⬛⬛⬛⬛⬛⬛ 🔲🔲 ⬛⬛⬛⬛⬛⬛ 4<br/>⬛🔲⬛⬛🔲⬛ 🔲🔲 ⬛🔲⬛⬛⬛⬛ ⬛🔲 ⬛⬛⬛⬛⬛⬛ 6<br/>⬛⬛🔲⬛🔲⬛ 🔲🔲 ⬛⬛⬛⬛⬛⬛ 🔲🔲 ⬛🔲⬛⬛⬛⬛ 7<br/>⬛⬛⬛⬛⬛⬛ 🔲⬛ ⬛⬛⬛🔲🔲⬛ 🔲⬛ ⬛⬛🔲⬛⬛⬛ 5    H<br/>🔲⬛🔲⬛⬛🔲 🔲🔲 ⬛🔲⬛⬛⬛⬛ 🔲🔲 ⬛⬛⬛⬛⬛⬛ 8    o<br/>⬛⬛⬛⬛⬛⬛ ⬛🔲 ⬛⬛⬛⬛⬛⬛ 🔲🔲 ⬛⬛⬛⬛⬛⬛ 3    r<br/>🔲🔲🔲🔲🔲🔲 🔲🔲 🔲🔲🔲🔲⬛🔲 🔲🔲 🔲🔲🔲🔲🔲🔲 21   i<br/>🔲🔲⬛🔲🔲🔲 🔲⬛ 🔲🔲🔲🔲🔲🔲 ⬛🔲 ⬛🔲🔲⬛🔲🔲 17   z<br/>⬛⬛⬛⬛⬛⬛ 🔲🔲 ⬛⬛⬛⬛⬛⬛ 🔲🔲 ⬛⬛⬛⬛⬛⬛ 4    o<br/>⬛⬛⬛⬛⬛⬛ 🔲🔲 ⬛⬛⬛⬛🔲⬛ 🔲🔲 ⬛⬛⬛⬛⬛⬛ 5    n<br/>⬛🔲⬛⬛⬛⬛ 🔲🔲 ⬛⬛🔲⬛⬛⬛ 🔲🔲 ⬛🔲⬛⬛⬛⬛ 7    t<br/>⬛⬛⬛⬛🔲⬛ 🔲🔲 ⬛⬛⬛⬛⬛⬛ 🔲⬛ ⬛⬛⬛🔲⬛⬛ 5    a<br/>⬛⬛⬛⬛⬛⬛ ⬛🔲 ⬛⬛⬛🔲⬛⬛ 🔲🔲 ⬛⬛⬛⬛⬛🔲 5    l<br/>⬛⬛⬛⬛⬛⬛ 🔲🔲 ⬛⬛⬛⬛⬛⬛ ⬛🔲 ⬛⬛⬛⬛⬛⬛ 3<br/>🔲🔲🔲🔲🔲🔲 🔲🔲 🔲🔲⬛🔲🔲🔲 🔲🔲 🔲🔲🔲🔲🔲🔲 21   S<br/>🔲🔲⬛🔲🔲🔲 🔲⬛ 🔲🔲🔲🔲🔲🔲 🔲🔲 🔲🔲🔲🔲🔲🔲 20   u<br/>⬛⬛⬛⬛⬛⬛ 🔲🔲 ⬛⬛⬛⬛⬛⬛ 🔲🔲 ⬛⬛⬛⬛⬛⬛ 4    m<br/>⬛🔲⬛⬛⬛⬛ 🔲🔲 ⬛🔲⬛⬛⬛⬛ ⬛🔲 ⬛⬛⬛⬛⬛🔲 6<br/>⬛⬛⬛⬛🔲⬛ 🔲🔲 ⬛⬛⬛⬛⬛⬛ 🔲🔲 ⬛⬛⬛⬛⬛⬛ 5<br/>⬛⬛⬛⬛⬛🔲 ⬛🔲 ⬛⬛⬛🔲⬛⬛ 🔲⬛ ⬛🔲🔲⬛⬛⬛ 6<br/>⬛⬛⬛⬛⬛⬛ 🔲🔲 ⬛⬛⬛⬛⬛⬛ 🔲🔲 ⬛⬛⬛⬛⬛⬛ 4<br/>⬛⬛⬛⬛⬛⬛ 🔲🔲 ⬛⬛⬛⬛⬛⬛ 🔲🔲 ⬛⬛⬛⬛⬛⬛ 4<br/>5  7 4 4 8 6 19 19 4 7 4 7 5 4  18 19 3 7 6 4 4 6<br/>                Vertical  Sum</span></pre><p id="f03c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果任何行或列的总和分别大于宽度或高度的2/3，则检查轴的总和。然后在一个新的数组中，标记为1，否则为0。</p><pre class="lm ln lo lp fd ly lx lz ma aw mb bi"><span id="9226" class="km kn hh lx b fi mc md l me mf">Height of Image = 22 <br/>Width of Image = 22<br/>66% of Height = 15 <br/>66% of Width = 15 <br/>Vertical Sum = [5 7 4 4 8 6 19 19 4 7 4 7 5 4 18 19 3 7 6 4 4 6] Horizontal Sum = [4 6 7 5 8 3 21 17 4 5 7 5 5 3 21 20 4 6 5 6 4 4] Vertical Bool = [0 0 0 0 0 0 1 1 0 0 0 0 0 0 1 1 0 0 0 0 0 0]<br/>Horizontal Bool = [0 0 0 0 0 0 1 1 0 0 0 0 0 0 1 1 0 0 0 0 0 0] Total number of 0 to 1 Transitions in Vertical Bool = 2 <br/>Total number of 0 to 1 Transitions in Horizontal Bool = 2</span></pre><p id="632a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">步骤4a):预处理数字单元格- </strong></p><figure class="lm ln lo lp fd ii"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="71b8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">“<strong class="ir hi"> preprocess_digit </strong>”方法用于预处理难题中的每个单元，以便使用卷积神经网络进行进一步检测。我们首先将图像的大小调整为112x112像素。然后，我们应用高斯模糊和阈值图像转换值为0或1。然后，我们清除边界，以确保从边缘去除噪声。我们再次将图像大小调整回28x28，使其适合我们的数字识别模型。</p><p id="4079" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">接下来，我们检查单元格图像中白色像素的数量是否小于10，如果是，我们假设单元格为空，并返回None。然后，我们将值小于150的像素缩放至其值的75%,将其余像素的值加倍。</p><p id="6d38" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">步骤4b):获得最终矩阵- </strong></p><figure class="lm ln lo lp fd ii"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="771c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这里，我们首先得到扭曲的图像和数独谜题的尺寸。接下来，我们初始化一个空矩阵并加载我们训练好的模型文件。然后，我们确定每个单元格的宽度和高度，并对每个单元格进行迭代。一旦我们完成了细胞的预处理，我们就将它输入到我们的模型中，以找到细胞的数字值。</p><p id="61da" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然后，我们执行健全性检查，以确保同一行、列或框中没有其他单元格具有相同的值。如果出现这种情况，我们还会找出该单元格的预测得分。具有较高预测得分的一个获得该值，另一个获得其第二高的预测得分值。</p><p id="7c90" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">在图像上绘图- </strong></p><figure class="lm ln lo lp fd ii"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="e539" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">“<strong class="ir hi"> plot_on_image </strong>”方法用于在图像上绘制解决方案。我们执行所有前面提到的步骤，以达到扭曲的图像阶段。然后我们迭代每个单元格图像，并使用cv2.putText绘制单元格中的值。</p><p id="0886" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">注意:</strong>我们已经在扭曲的图像上绘制了我们的解决方案，因此要将该图像转换回原始图像，我们首先计算从cv2.getPerspective获得的扭曲转换矩阵的逆矩阵，并使用cv2.warpPerspective应用初始转换的逆矩阵，以将其恢复到原始图像位置。</p><figure class="lm ln lo lp fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/0be5f2ced9bac1358f40141a1bea999e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W4Yg9uKv7jumf34ZTxcmiQ.png"/></div></div></figure><figure class="lm ln lo lp fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/af5f9d048b1a88803b8ce9cffd820a3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OjRumvB27CUTfLM6fQ46Bw.png"/></div></div></figure></div><div class="ab cl mg mh go mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ha hb hc hd he"><p id="64d4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="kl">这里</em>  <em class="kl">可以找到完整的python实现</em> <a class="ae kk" href="https://github.com/shashank3199/VisioNxN-Sudoku/blob/master/Image_Processing/process_image.py" rel="noopener ugc nofollow" target="_blank"> <em class="kl">。如果你觉得这篇文章很有帮助，请跟我上</em> </a><a class="ae kk" href="https://shashank-goyal-blogs.medium.com/" rel="noopener"> <em class="kl">中</em> </a> <em class="kl">和</em><a class="ae kk" href="https://github.com/shashank3199/" rel="noopener ugc nofollow" target="_blank"><em class="kl">GitHub</em></a><em class="kl">和star</em><a class="ae kk" href="https://github.com/shashank3199/VisioNxN-Sudoku" rel="noopener ugc nofollow" target="_blank"><em class="kl">项目库</em> </a> <em class="kl">。</em></p></div><div class="ab cl mg mh go mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ha hb hc hd he"><p id="e9e7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您可以在此处找到此项目<a class="ae kk" rel="noopener" href="/mlearning-ai/augmented-reality-sudoku-solver-part-i-8e29e59cecab">的完整详细实施说明。</a></p></div><div class="ab cl mg mh go mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ha hb hc hd he"><p id="1b4e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">请查看本系列文章的其他部分</p><ul class=""><li id="d3e1" class="jw jx hh ir b is it iw ix ja jy je jz ji ka jm kb kc kd ke bi translated"><a class="ae kk" rel="noopener" href="/mlearning-ai/augmented-reality-sudoku-solver-part-i-8e29e59cecab">增强现实数独解算器——第一部分</a>。</li><li id="fd26" class="jw jx hh ir b is kf iw kg ja kh je ki ji kj jm kb kc kd ke bi translated"><a class="ae kk" href="https://shashank-goyal-blogs.medium.com/augmented-reality-sudoku-solver-part-iii-d2370a9cbace" rel="noopener">增强现实数独解算器——第三部分。</a></li><li id="0d0f" class="jw jx hh ir b is kf iw kg ja kh je ki ji kj jm kb kc kd ke bi translated"><a class="ae kk" href="https://shashank-goyal-blogs.medium.com/augmented-reality-sudoku-solver-part-iv-65afe2231e46" rel="noopener">增强现实数独解算器——第四部分。</a></li></ul></div></div>    
</body>
</html>