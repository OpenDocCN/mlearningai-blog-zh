<html>
<head>
<title>Application of Generalized additive models (GAMs) in detecting diabetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">广义可加模型在糖尿病检测中的应用</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/application-of-generalized-additive-models-gams-in-detecting-diabetes-3a44a26017aa?source=collection_archive---------1-----------------------#2021-06-10">https://medium.com/mlearning-ai/application-of-generalized-additive-models-gams-in-detecting-diabetes-3a44a26017aa?source=collection_archive---------1-----------------------#2021-06-10</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="31c0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">逻辑回归被证明是理解个体特征、<strong class="ig hi"> X </strong> ⱼ和响应变量、<strong class="ig hi"> y </strong>之间关系的强大建模工具。尽管如此，它假设自变量和logit之间的关系是线性的和单调的。广义可加模型(GAMs)是一种在保持可加性的同时，在logistic模型框架内对非单调响应进行建模的方法。因为模型是可加的，每个独立变量的影响可以单独检查，同时保持所有其他变量不变，类似于逻辑回归。</p><p id="19e9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下面是二元分类问题中逻辑回归GAM的数学公式:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es jc"><img src="../Images/2031f978fbab273bd5e7f7d5786503c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:902/format:webp/1*CbVwHh1CBbUkH8FG4y-XwQ.png"/></div></figure><p id="3457" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jk"> f </em> ⱼ是预测器j的非线性函数(平滑样条)。正是这些非线性函数允许对各个特征和响应之间的非线性关系进行建模。</p><p id="3ae9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们通过一个简单的例子来看看它是如何工作的。此外，在本演示结束时，我们可以看到逻辑回归和GAM之间的性能差异。</p><p id="7666" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">首先，在r中加载所需的库包。</p><pre class="jd je jf jg fd jl jm jn jo aw jp bi"><span id="9e0b" class="jq jr hh jm b fi js jt l ju jv">library(mgcv) # library for GAM<br/>library(ggplot2) # for beautiful plots<br/>library(cdata) # data wrangling<br/>library(sigr) # AUC calculation</span></pre><p id="9bb2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">设置数据文件所在的工作目录。将数据分为训练数据(80%)和测试数据(20%)，类似于上一篇文章。</p><pre class="jd je jf jg fd jl jm jn jo aw jp bi"><span id="510a" class="jq jr hh jm b fi js jt l ju jv">data=read.csv(‘diabetes.csv’) # load the data into global #environment</span><span id="e84d" class="jq jr hh jm b fi jw jt l ju jv">set.seed(123) # for reproducibility<br/>randn=runif(nrow(data))<br/>train_idx=randn&lt;=0.8<br/>train=data[train_idx,]<br/>test=data[!train_idx,]</span></pre><p id="c59a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jk">“mgcv”包中的gam() </em>函数用于训练gam模型。由于事先不知道每个预测值和logit之间的关系，因此我们使用<em class="jk"> s() </em>来表示所有属性的基函数。</p><pre class="jd je jf jg fd jl jm jn jo aw jp bi"><span id="e03a" class="jq jr hh jm b fi js jt l ju jv"># formula: “Outcome==1” is to binarize the response variable<br/>form_gam=as.formula(“Outcome==1~s(Pregnancies)+s(Glucose)+s(BloodPressure)+<br/> s(SkinThickness)+s(Insulin)+s(BMI)+s(DiabetesPedigreeFunction)+<br/> s(Age)”)</span><span id="fcf9" class="jq jr hh jm b fi jw jt l ju jv">gam_model=gam(form_gam,data=train,family = binomial(link=”logit”))<br/>gam_model$converged # check if the algorithm converges<br/>summary(gam_model)</span></pre><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="er es jx"><img src="../Images/6abfe5739f172fd7807307e20981239e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SzOcGikSLcIc6ETQuFaSzA.png"/></div></div></figure><p id="094d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">变量<strong class="ig hi"> X </strong> ⱼ的函数<em class="jk"> f </em> ⱼ的平滑度可以通过上述输出中的edf进行总结。接近1的edf表示变量与输出具有近似的线性关系。像怀孕、血压、皮肤厚度和胰岛素这样的预测因素的edf正好为1或接近1。与逻辑回归相似，p值可用于评估预测值的统计显著性。“解释的偏差”告诉我们由模型解释的logit输出中方差的比例—在这种情况下，36.6%的方差可以由模型解释。</p><p id="4619" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们总是可以使用绘图(模型)语法来可视化每个预测值上的基函数映射。然而，这种语法只允许在一个图形中线性预测器标度上绘制一个平滑函数。以下代码片段提供了另一种可视化每个预测值上的基函数映射的方式。</p><pre class="jd je jf jg fd jl jm jn jo aw jp bi"><span id="deb0" class="jq jr hh jm b fi js jt l ju jv"># Visualize s() output <br/>terms=predict(gam_model,type=”terms”)<br/>terms=cbind(Outcome=train$Outcome,terms)</span><span id="acac" class="jq jr hh jm b fi jw jt l ju jv"># convert terms into data frame<br/>frame1=as.data.frame(terms)<br/># remove brackets<br/>colnames(frame1)=gsub(‘[()]’,’’,colnames(frame1))<br/>vars=setdiff(colnames(train),”Outcome”)<br/># remove first character ‘s’<br/>colnames(frame1)[-1]=sub(“.”,””,colnames(frame1)[-1])<br/># Convert the wide to long form<br/>library(cdata)<br/>frame1_long=unpivot_to_blocks(frame1,nameForNewKeyColumn = “basis_function”,<br/> nameForNewValueColumn = “basis_value”,<br/> columnsToTakeFrom = vars)<br/># get the predictor values from training data<br/>data_long=unpivot_to_blocks(train,nameForNewKeyColumn = “predictor”,<br/> nameForNewValueColumn = “value”,<br/> columnsToTakeFrom = vars)<br/>frame1_long=cbind(frame1_long,value=data_long$value)</span><span id="36ed" class="jq jr hh jm b fi jw jt l ju jv">ggplot(data=frame1_long,aes(x=value,y=basis_value)) +<br/> geom_smooth() +<br/> facet_wrap(~basis_function,ncol = 3,scales = “free”)</span></pre><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="er es kc"><img src="../Images/97d72a6d8888e4f018734ab8f048e6e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O7f-M2GqJ3HHF8JL1VPpCg.png"/></div></div></figure><p id="addc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">解释每个预测因子和反应之间的关系的方法，logit非常简单，如上图所示。例如，通过参考图的左上图，被诊断为糖尿病的对数几率从20岁增加到45岁左右，然后趋于平稳，最后在50岁后下降。如果所有的预测因子保持不变，这种解释是正确的。请记住，在解释GAM模型时，也应考虑图的垂直刻度中显示的刻度以及模型摘要中的p值。</p><pre class="jd je jf jg fd jl jm jn jo aw jp bi"><span id="c0f1" class="jq jr hh jm b fi js jt l ju jv"># function to calculate the performance of model in terms of #accuracy, precision, recall and<br/># area under the curve (AUC). The curve refers to receiver operating #characteristics curve.<br/>performance=function(y,pred){<br/>  confmat_test=table(truth=y,predict=pred&gt;0.5)<br/>  acc=sum(diag(confmat_test))/sum(confmat_test)<br/>  precision=confmat_test[2,2]/sum(confmat_test[,2])<br/>  recall=confmat_test[2,2]/sum(confmat_test[2,])<br/>  auc=calcAUC(pred,y)<br/>  c(acc,precision,recall,auc)<br/>}</span></pre><p id="391c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为某些需要重复执行的计算任务编写函数总是一个好的做法。“训练”和“测试”数据帧中的“预测”列包含后验概率P(Y=1|X)，其中Y=1表示阳性反应(糖尿病)。因此，如果两个类别的误分类成本不同，则可以选择任意阈值来进行权衡建模。</p><pre class="jd je jf jg fd jl jm jn jo aw jp bi"><span id="d329" class="jq jr hh jm b fi js jt l ju jv"># Posterior probability<br/>train$pred=predict(gam_model,newdata = train,type = "response")<br/>test$pred=predict(gam_model,newdata=test,type="response")</span><span id="f53a" class="jq jr hh jm b fi jw jt l ju jv"># model performance evaluated using training data<br/>perf_train=performance(train$Outcome,train$pred)<br/>perf_test=performance(test$Outcome,test$pred)<br/>perf_mat=rbind(perf_train,perf_test)<br/>colnames(perf_mat)=c("accuracy","precision","recall","AUC")<br/>round(perf_mat,4)</span></pre><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es kd"><img src="../Images/ab962442be22ad32845d0738171b0f54.png" data-original-src="https://miro.medium.com/v2/resize:fit:882/format:webp/1*UCLg7mGjsUqz14Ja0Tdw4g.png"/></div></figure><p id="b0e0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">逻辑回归模型(见<a class="ae ke" href="https://jq0112358.medium.com/data-visualization-and-diagnosis-of-diabetes-using-logistic-regression-1ea3958335a5" rel="noopener"> <strong class="ig hi">上一篇</strong> </a>)和GAM模型的性能指标列表如下。GAM在准确度、精确度和AUC方面表现稍好，但在召回率方面不如LR模型。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="er es kf"><img src="../Images/2927489dd74089b1de7c25e1afd06020.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tfaphWR7a5WJ5H448f_8Jw.png"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx">Performances of both LR model and GAM.</figcaption></figure><p id="6622" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">总之，广义加性模型(GAMs)是线性模型的一个有用的扩展，它支持非线性建模(更灵活),同时保留了模型的可解释性。这些代码可以在<a class="ae ke" href="https://github.com/Jacky-lim-data-analyst/programmer.git" rel="noopener ugc nofollow" target="_blank"> Github </a>和<a class="ae ke" href="http://rpubs.com/JQ_programmer_92/779781" rel="noopener ugc nofollow" target="_blank"> RPubs </a>中找到。使用Rstudio“闪亮”包开发了一个交互式应用程序。在<a class="ae ke" href="https://github.com/Jacky-lim-data-analyst/programmer.git" rel="noopener ugc nofollow" target="_blank"> Github </a>和这个<a class="ae ke" href="https://jqprogrammer.shinyapps.io/prediction2/?_ga=2.143980150.2136395793.1623984469-680060565.1623984469" rel="noopener ugc nofollow" target="_blank">链接</a>中检查一下。</p></div></div>    
</body>
</html>