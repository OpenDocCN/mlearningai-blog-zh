<html>
<head>
<title>YOLOX Explanation — Mosaic and Mixup For Data Augmentation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">YOLOX解释—用于数据扩充的镶嵌和混合</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/yolox-explanation-mosaic-and-mixup-for-data-augmentation-3839465a3adf?source=collection_archive---------0-----------------------#2022-05-20">https://medium.com/mlearning-ai/yolox-explanation-mosaic-and-mixup-for-data-augmentation-3839465a3adf?source=collection_archive---------0-----------------------#2022-05-20</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="d165" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">本文是我全面解释YOLOX(你只看一次X)模型如何工作的系列文章的第四篇，也是最后一篇。如果您对该代码感兴趣，可以在下面找到它的链接:</p><div class="jc jd ez fb je jf"><a href="https://github.com/gmongaras/YOLOX_From_Scratch" rel="noopener  ugc nofollow" target="_blank"><div class="jg ab dw"><div class="jh ab ji cl cj jj"><h2 class="bd hi fi z dy jk ea eb jl ed ef hg bi translated">GitHub-gmongaras/YOLOX _从头开始</h2><div class="jm l"><h3 class="bd b fi z dy jk ea eb jl ed ef dx translated">试图从头开始构建YOLOX算法</h3></div><div class="jn l"><p class="bd b fp z dy jk ea eb jl ed ef dx translated">github.com</p></div></div><div class="jo l"><div class="jp l jq jr js jo jt ju jf"/></div></div></a></div><p id="9889" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">本系列有4个部分来全面介绍YOLOX算法:</p><ul class=""><li id="cc0b" class="jv jw hh ig b ih ii il im ip jx it jy ix jz jb ka kb kc kd bi translated">什么是YOLO，它有什么特别之处？</li><li id="34fe" class="jv jw hh ig b ih kf il kg ip kh it ki ix kj jb ka kb kc kd bi translated">【YOLOX是怎么工作的？</li><li id="82f6" class="jv jw hh ig b ih kf il kg ip kh it ki ix kj jb ka kb kc kd bi translated"><a class="ae ke" rel="noopener" href="/p/8fa5ae397f76">用于动态标签分配的SimOTA</a></li><li id="99ce" class="jv jw hh ig b ih kf il kg ip kh it ki ix kj jb ka kb kc kd bi translated"><strong class="ig hi">用于数据扩充的镶嵌和混合</strong> ( <a class="ae ke" rel="noopener" href="/p/3839465a3adf">自身</a>)</li></ul><h1 id="0b77" class="kk kl hh bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">数据扩充</h1><p id="3bb5" class="pw-post-body-paragraph ie if hh ig b ih li ij ik il lj in io ip lk ir is it ll iv iw ix lm iz ja jb ha bi translated">数据扩充是帮助模型泛化的一种方式。当扩充数据时，模型必须在数据中找到新的特征来识别对象，而不是依赖一些特征来确定图像中的对象。</p><p id="b585" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">YOLOX使用一些最好的数据扩充来帮助模型对数据进行更多的概括。我将在本文中讨论YOLOX使用的两个最好的数据增强。</p><h1 id="110f" class="kk kl hh bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">马赛克</h1><p id="ee1d" class="pw-post-body-paragraph ie if hh ig b ih li ij ik il lj in io ip lk ir is it ll iv iw ix lm iz ja jb ha bi translated">镶嵌数据扩充首先在YOLOv4中引入，是对<a class="ae ke" href="https://arxiv.org/abs/1905.04899" rel="noopener ugc nofollow" target="_blank"> CutMix </a>数据扩充的改进。</p><p id="1897" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">马赛克背后的想法非常简单。取4张图片，组合成一张图片。Mosaic通过调整四幅图像的大小，将它们拼接在一起，然后随机剪切拼接的图像来获得最终的马赛克图像。</p><p id="aa8d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当用YOLO算法执行镶嵌增强时的一个困难是，当创建最终图像时，我们必须担心边界框。这个任务并不太难，因为我们可以很容易地调整边界框的大小并移动它们。只是在将图像拼接在一起并创建剪切后，要弄清楚盒子应该移动到哪里有点烦人。</p><p id="fdd6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">给定四幅图像和生成图像的最终尺寸，以下是创建最终镶嵌图像的步骤:</p><ol class=""><li id="3de9" class="jv jw hh ig b ih ii il im ip jx it jy ix jz jb ln kb kc kd bi translated">调整图像大小。在这种情况下，我调整到输出图像的形状</li><li id="f038" class="jv jw hh ig b ih kf il kg ip kh it ki ix kj jb ln kb kc kd bi translated">将所有图像合并成一个图像，其中4个调整大小的图像分别位于不同的角落</li><li id="9899" class="jv jw hh ig b ih kf il kg ip kh it ki ix kj jb ln kb kc kd bi translated">将边界框放在新图像的正确区域。</li><li id="5bd8" class="jv jw hh ig b ih kf il kg ip kh it ki ix kj jb ln kb kc kd bi translated">采取一个随机的剪切，这是我们想要的最终结果的图像大小。这个剪切可以在4个图像组合的任何地方，但是我做了一些限制，使最终的图像更好一些</li><li id="8e46" class="jv jw hh ig b ih kf il kg ip kh it ki ix kj jb ln kb kc kd bi translated">移除不在剪切块中的边界框</li><li id="96b4" class="jv jw hh ig b ih kf il kg ip kh it ki ix kj jb ln kb kc kd bi translated">调整被剪切掉的任何剩余边界框的大小</li></ol><p id="930f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">给定以下4幅图像，并希望最终图像尺寸为256×256，让我们来看看这个过程是如何工作的:</p><figure class="lp lq lr ls fd lt er es paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="er es lo"><img src="../Images/a78e7078fc46960b69b753a0f41d40c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XKu8lAC8hqMSHZJkPYC-gQ.png"/></div></div><figcaption class="lz ma et er es mb mc bd b be z dx">4 images to Mosaic together</figcaption></figure><p id="95c1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">1.将图像大小调整为最终图像大小(256×256)。这一步可以用很多方法来完成，但我是通过找到图像的比例，然后手动调整图像的大小来完成的。当调整边界框大小时，比例开始起作用，因为那些边界框需要按照调整图像大小时的相同比例来调整大小。我的代码中有一个名为<a class="ae ke" href="https://github.com/gmongaras/YOLOX_From_Scratch/blob/main/src/dataAugmentation.py" rel="noopener ugc nofollow" target="_blank"> resize </a>的函数，如果你想看看我是如何调整每个图像及其边界框的大小的。</p><figure class="lp lq lr ls fd lt er es paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="er es md"><img src="../Images/3bf8689508e30ab4b17e020e6da9e8d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AaWFWL2Z2IlkxRMfC-XLCg.png"/></div></div><figcaption class="lz ma et er es mb mc bd b be z dx">Each image is now of size 256×256 and each bounding box is in the correct location</figcaption></figure><p id="1cec" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">2.将所有图像合并成一个图像。为此，创建一个3×512×512的零张量，并将每个图像叠加到新张量的每个角上。注意下图中所有的边界框都是混乱的，所以我们必须把它们移动到正确的位置。</p><figure class="lp lq lr ls fd lt er es paragraph-image"><div class="er es me"><img src="../Images/a68be322c32d151c2cef6769bacb64a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:738/format:webp/1*5i3Dtz5cjZI1kO76tJxoiw.png"/></div><figcaption class="lz ma et er es mb mc bd b be z dx">Combination of all four images</figcaption></figure><p id="4c5d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">3.移动边界框非常简单:</p><ul class=""><li id="bab0" class="jv jw hh ig b ih ii il im ip jx it jy ix jz jb ka kb kc kd bi translated">左上角图像的边界框不必移动</li><li id="481a" class="jv jw hh ig b ih kf il kg ip kh it ki ix kj jb ka kb kc kd bi translated">右上角图像中的边界框应该向右移动256</li><li id="2b53" class="jv jw hh ig b ih kf il kg ip kh it ki ix kj jb ka kb kc kd bi translated">左下角的边界框应该向下移动256像素</li><li id="38f3" class="jv jw hh ig b ih kf il kg ip kh it ki ix kj jb ka kb kc kd bi translated">右下角的边界框应该向右下方移动256像素</li></ul><p id="bf28" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">要将边界框移动256，只需将边界框数组中的x或y值加上256。记住每个边界框有4个部分(x，y，w，h)</p><figure class="lp lq lr ls fd lt er es paragraph-image"><div class="er es me"><img src="../Images/33e39a909023cd6386f15a87e50dc56a.png" data-original-src="https://miro.medium.com/v2/resize:fit:738/format:webp/1*fxAFf6YO1WXnShQGNJZSjw.png"/></div><figcaption class="lz ma et er es mb mc bd b be z dx">Combination of all four images with bounding boxes in the correct location</figcaption></figure><p id="8d9f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">4.随机截取图像。</p><p id="ae9b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在图像的任何地方随机截取一个图像的一个问题是，截取的图像通常包含一到两个图像，但是我们希望它包含所有四个图像。为此，我们可以在最终图像尺寸的平方根(16到240)内的任何地方进行剪切。虽然，我设置的条件可能太小了，但是您可以通过值约束来找到您喜欢的条件。</p><p id="26f8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我制作剪影的方法是在最终图像尺寸的平方根(16)和当前组合图像尺寸的一半减去平方根(240)之间选择一个随机点，得到剪影的左上角。然后在这个随机的点上加上256，就得到切口的右下角位置。这样，剪切部分永远不会超出最大图像尺寸，并保持在我们希望剪切部分所在的平方根边界内。</p><figure class="lp lq lr ls fd lt er es paragraph-image"><div class="er es me"><img src="../Images/eaee0fec5a1719bf8f961ba6b7b7bc5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:738/format:webp/1*sOia-AP4Gf-cSDFwjeOXtQ.png"/></div><figcaption class="lz ma et er es mb mc bd b be z dx">Cutout of the image</figcaption></figure><p id="66cb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">5.移除剪切块外的边界框。</p><p id="92ec" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">请注意大多数边界框是如何位于剪切区域之外的。为了解决这个问题，我们可以首先移除剪切块外部的所有边界框，但是保留剪切块内部的那些边界框。</p><figure class="lp lq lr ls fd lt er es paragraph-image"><div class="er es me"><img src="../Images/12006e08232860fcf896183c9585d21d.png" data-original-src="https://miro.medium.com/v2/resize:fit:738/format:webp/1*e07AH0f6hbQI3z0LIMkoCQ.png"/></div><figcaption class="lz ma et er es mb mc bd b be z dx">Cutout of the image with outside bounding boxes removed</figcaption></figure><p id="3b0a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">请注意一些边界框仍然位于剪切块之外。我们本可以摆脱这些，但是这种技术的问题是模型没有学习我们想要它学习的东西。我们希望模型学习不同的特征来区分不同的项目，所以我们保留不完全在剪切中的边界框</p><p id="5ad9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">6.调整剪切块中所有剩余边界框的大小</p><p id="b60e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了处理剩余的边界框，我们可以调整它们的大小，使它们位于剪切块中。要做到这一点，我们可以将所有边界框从剪切块中移到剪切块之外，然后根据我们重新定位每个边界框的量来调整边界框的大小。最终结果如下所示:</p><figure class="lp lq lr ls fd lt er es paragraph-image"><div class="er es me"><img src="../Images/365c8e717fe27afa4eaa430bdf7a3e32.png" data-original-src="https://miro.medium.com/v2/resize:fit:738/format:webp/1*NSxKZ9h4dPuHBPzMYrEQLw.png"/></div><figcaption class="lz ma et er es mb mc bd b be z dx">Final Mosaic image</figcaption></figure><p id="76ed" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">请注意，即使是最小的边界框也保留在图像中，就像图像左上角的三明治一样。该模型必须进行更多的归纳，才能将该对象识别为三明治，因为该对象不包含典型三明治可能包含的所有特征。</p><p id="378f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我发现了马赛克的一个改进版本，它解决了马赛克算法的问题。如果你想了解更多，你可以通过链接找到论文<a class="ae ke" href="https://iopscience.iop.org/article/10.1088/1742-6596/1684/1/012094/pdf" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="72ab" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">至于最初的马赛克算法，我找不到关于它的论文，但在YOLOv4中对它进行了简要介绍，并且网上有一些资料谈到了该算法的工作原理。</p><h1 id="4189" class="kk kl hh bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">混合</h1><p id="3dbd" class="pw-post-body-paragraph ie if hh ig b ih li ij ik il lj in io ip lk ir is it ll iv iw ix lm iz ja jb ha bi translated">Mixup最初是为分类任务而创建的，但它仍然非常适合对象检测任务。Mixup基本上基于加权参数λ将两幅图像平均在一起。更正式地，该论文通过以下两个公式来描述定义的混合:</p><figure class="lp lq lr ls fd lt er es paragraph-image"><div class="er es mf"><img src="../Images/fcbe2306aff5e2c17f1d3c1f1a45a6e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1122/format:webp/1*HAt2pgpcqK3J_iqO4RrY8Q.png"/></div><figcaption class="lz ma et er es mb mc bd b be z dx">Mixup Definition</figcaption></figure><p id="d8d7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，我们可以通过组合两幅图像xᵢ和xⱼ.来创建输出图像x̃但是，由于这种增加是为了标签分配，我们也对一次性类嵌入进行平均。我们要解决的任务与边界框有关，所以我们不是将边界框平均在一起，而是将两幅图像的注释合并成一个。因此所有的边界框将被组合到相同的列表中，表示来自两个图像的所有边界框也属于组合图像。</p><p id="2832" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">该论文建议从贝塔分布中取样λ参数:</p><figure class="lp lq lr ls fd lt er es paragraph-image"><div class="er es mg"><img src="../Images/137c0bf0c872a595c41f6be13d20bc4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/1*S827N_TPl1qwfON4alXvnQ.png"/></div><figcaption class="lz ma et er es mb mc bd b be z dx">Original Lambda paper definition</figcaption></figure><p id="bd4d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这篇论文显示了α值为0.2、0.3和0.4时的结果，尽管我发现这导致平均值可能向0或1的高端倾斜。这意味着图像平均值不会真正成为两幅图像的平均值，而是更像一幅带有一些噪声的图像。我在网上的某个地方(我忘了是哪个网站了)发现α为1.5似乎效果更好，出来的图像更平均。</p><figure class="lp lq lr ls fd lt er es paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="er es mh"><img src="../Images/013339869204623515b5d1245bb36095.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XA9DyQsDAqUgIMUtFCQjsQ.png"/></div></div><figcaption class="lz ma et er es mb mc bd b be z dx">Beta Distribution at α=0.2 and α=1.5 <a class="ae ke" href="http://eurekastatistics.com/beta-distribution-pdf-grapher/" rel="noopener ugc nofollow" target="_blank">http://eurekastatistics.com/beta-distribution-pdf-grapher/</a></figcaption></figure><p id="656e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">看起来α = 1.5时的β分布倾向于接近0.5的值，而α = 0.2时的分布倾向于接近0和1的值。</p><p id="7ac5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Mixup的结果有一些有趣的结果，如下所示:</p><figure class="lp lq lr ls fd lt er es paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="er es mi"><img src="../Images/799f680a15a7bc405ce4673749cb81c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uYy0ru1y3H6ky3X7U3BTqA.png"/></div></div><figcaption class="lz ma et er es mb mc bd b be z dx">Mixup example</figcaption></figure><p id="3433" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">《Mixup》一文还探讨了Mixup的工作原理。如果你想了解为什么Mixup会起作用，我已经在本文末尾链接了这篇文章。</p><p id="3483" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">实现对象检测的混合并不困难，需要一些基本步骤:</p><ol class=""><li id="9f48" class="jv jw hh ig b ih ii il im ip jx it jy ix jz jb ln kb kc kd bi translated">将图像调整到相同的尺寸</li><li id="8e9a" class="jv jw hh ig b ih kf il kg ip kh it ki ix kj jb ln kb kc kd bi translated">从Beta分布中取样以获得λ值</li><li id="da88" class="jv jw hh ig b ih kf il kg ip kh it ki ix kj jb ln kb kc kd bi translated">将图像1中的所有值乘以λ</li><li id="44f1" class="jv jw hh ig b ih kf il kg ip kh it ki ix kj jb ln kb kc kd bi translated">将图2中的所有值乘以1-λ</li><li id="6cdb" class="jv jw hh ig b ih kf il kg ip kh it ki ix kj jb ln kb kc kd bi translated">将两幅图像相加得到最终图像</li><li id="423a" class="jv jw hh ig b ih kf il kg ip kh it ki ix kj jb ln kb kc kd bi translated">合并注释以获得图像的最终注释</li></ol><p id="3c35" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果你想看看我是如何实现Mixup或者Mosaic的，你可以在我的Github上找到，链接在本文的顶部。</p><p id="033f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">混合和镶嵌是YOLOX使用的两大增强功能。两者背后的思想都相对简单，实现起来也不太困难。这是关于YOLOX如何工作的最后一篇文章。如果你有任何问题，请让我知道，我会尽力回答他们。</p><h1 id="486d" class="kk kl hh bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">参考</h1><p id="a76f" class="pw-post-body-paragraph ie if hh ig b ih li ij ik il lj in io ip lk ir is it ll iv iw ix lm iz ja jb ha bi translated">约洛夫4:<a class="ae ke" href="https://arxiv.org/abs/2004.10934" rel="noopener ugc nofollow" target="_blank">https://arxiv.org/abs/2004.10934</a></p><p id="1abc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">马赛克解释:【https://www.youtube.com/watch?time_continue=450】T2&amp;v = V6uj-egme 7g&amp;feature = emb _ title</p><p id="5a65" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">混淆:【https://arxiv.org/abs/1710.09412v2】T4</p><div class="jc jd ez fb je jf"><a rel="noopener follow" target="_blank" href="/mlearning-ai/mlearning-ai-submission-suggestions-b51e2b130bfb"><div class="jg ab dw"><div class="jh ab ji cl cj jj"><h2 class="bd hi fi z dy jk ea eb jl ed ef hg bi translated">Mlearning.ai提交建议</h2><div class="jm l"><h3 class="bd b fi z dy jk ea eb jl ed ef dx translated">如何成为Mlearning.ai上的作家</h3></div><div class="jn l"><p class="bd b fp z dy jk ea eb jl ed ef dx translated">medium.com</p></div></div><div class="jo l"><div class="mj l jq jr js jo jt ju jf"/></div></div></a></div></div></div>    
</body>
</html>