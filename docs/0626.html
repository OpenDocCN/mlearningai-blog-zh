<html>
<head>
<title>Different search algorithms in data science</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据科学中的不同搜索算法</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/different-search-algorithms-in-data-science-4340c524098c?source=collection_archive---------2-----------------------#2021-05-29">https://medium.com/mlearning-ai/different-search-algorithms-in-data-science-4340c524098c?source=collection_archive---------2-----------------------#2021-05-29</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="5693" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">目前有许多有用的搜索算法，它们可以根据我们想要解决的需求来适应不同的问题。它们分为两大类，请参见以下内容:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es jc"><img src="../Images/72e1b881cf51747d2a761bb0abc1b6ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:908/format:webp/0*8yxMTnbfclqz9DPt.png"/></div></figure><p id="8c5e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当我们必须识别给定问题或数组中不同值时，可以使用不同的搜索算法。</p><p id="bd75" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">线性搜索</p><p id="218a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">二进位检索</p><p id="3d9a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">跳转搜索</p><p id="7b5a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">插值搜索</p><p id="645f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">指数搜索</p><p id="9620" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">子列表搜索(在另一个列表中搜索链接列表)</p><p id="b81f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">斐波那契搜索</p><p id="bd00" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">无处不在的二分搜索法</p><p id="33d7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">递归程序，线性搜索给定数组中的元素</p><p id="ba82" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">递归函数进行子串搜索。</p><p id="3133" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">无界二分搜索法示例(找到单调递增函数第一次变为正值的点)</p><p id="a051" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们来探讨一下知情搜索算法中的贪婪搜索。</p><p id="ce28" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Greedy是一种算法范式，它一个节点一个节点地构建解决方案，总是选择下一个提供最明显和直接好处的节点。所以，选择局部最优的问题也会导致全局最优解。</p><p id="71fb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">贪婪算法中有标准类型，我们可以看到如下:</p><p id="75a9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">活动选择问题</p><p id="6101" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">埃及分数</p><p id="cd20" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">作业排序问题</p><p id="45b4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">作业排序问题(使用不相交集)</p><p id="33b2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">作业排序问题——损失最小化</p><p id="5259" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">作业选择问题——损失最小化策略</p><p id="dc3c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">霍夫曼编码</p><p id="ddda" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">用于排序输入的高效霍夫曼编码</p><p id="d2be" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">霍夫曼解码</p><p id="c834" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">水连接问题</p><p id="9519" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">警察抓小偷。</p><p id="96f9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">支架平衡的最小互换</p><p id="7253" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">装配货架问题</p><p id="977a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">将鼠标分配到孔中</p><p id="9a08" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们可以用它来解决标准类型的问题，但是当我们不得不使用图来解决问题时，我们参考下面的贪婪图解决方案。</p><p id="42f8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">克鲁斯卡尔最小生成树</p><p id="c07b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Prim的最小生成树</p><p id="9752" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">博鲁夫卡最小生成树</p><p id="43e7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">MST的反向删除算法。</p><p id="48cc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最小生成树的问题求解(克鲁斯卡尔和普里姆的)</p><p id="31c7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Dijkstra最短路径算法</p><p id="8c25" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">戴尔算法</p><p id="fdc1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">用于邻接表表示的Dijkstra算法</p><p id="13e5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">用于邻接表表示的Prim的MST</p><p id="c042" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">贪婪算法的正确性</p><p id="84ab" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">连接所有城市的最低成本。</p><p id="7a53" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最大流量问题简介</p><p id="50a9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">无向图中单圈分量的个数</p><p id="e502" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们将使用Dijkstra算法中的最短路径算法来解决其中的一个例子。</p><p id="0677" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们考虑一下，A想从孟菲斯去纳什维尔，找到到达那里的最便宜的路径。有很多公路或航空公司遵循这一点，以确定最便宜的路线到达。</p><p id="e4ca" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">从下图中找到到达不同城市的不同路线和费用。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es jk"><img src="../Images/bc9e8312b424fbaf5057ae534cce2448.png" data-original-src="https://miro.medium.com/v2/resize:fit:790/format:webp/0*XsLHLGYl-HqzIXJk.png"/></div></figure><p id="4512" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Dijkstra算法用于解决加权有向图上的单源最短路径问题。</p><p id="4816" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们找到从孟菲斯到纳什维尔的最短路径。我们将使用该表来确定和更新放松。</p><p id="b6f1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">步骤1)从孟菲斯出发，选择从孟菲斯出发的最小费用，它在表格下面突出显示(新奥尔良)，这里从孟菲斯出发的最小费用是3，也就是到达新奥尔良。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es jl"><img src="../Images/7c48484ba9f6fdabc50f200f54fa2941.png" data-original-src="https://miro.medium.com/v2/resize:fit:1130/format:webp/0*ayd7cr2Akcj-U4lN.png"/></div></figure><p id="133e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果我们从孟菲斯到新奥尔良去莫比尔，比去莫比尔要多花6美元。因此，将更新图表中的内容(以黄色突出显示)。</p><p id="1d4d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">步骤2)现在选择另一个顶点，它将给出到达下一个目的地的最小成本。我们已经解决了新奥尔良的问题，现在选择另一个成本更低的城市，即莫比尔。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es jm"><img src="../Images/a193e08272e989ca820455a134d06e1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1126/format:webp/0*7At_Vez8PkKG8GXT.png"/></div></figure><p id="7de3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">从孟菲斯到萨凡纳，我们会得到12美元的零钱，这是前所未有的。</p><p id="f409" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">从孟菲斯到莫比尔需要6美元，从莫比尔再到那里需要6美元，所以总共是12美元。</p><p id="ea17" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">步骤3)现在让我们考虑另一个成本更低的城市，那就是萨凡纳。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es jn"><img src="../Images/49bc10ca6c5a05d42cd64a7300dac258.png" data-original-src="https://miro.medium.com/v2/resize:fit:1128/format:webp/0*9y0zWr5a-Dq-Pw5T.png"/></div></figure><p id="d7d8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">要到达亚特兰大，我们有以下路径:</p><p id="8bda" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">1.我们可以直接从孟菲斯到亚特兰大，这样可以给我们10美元</p><p id="b56b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">2.如果我们从萨凡纳到亚特兰大，这将给我们13美元，但我们已经有价值少于到达亚特兰大10美元，所以将保持原样。</p><p id="67b8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">步骤4)现在我们可以选择下一个城市到达下一个目的地。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es jm"><img src="../Images/196495c2271ae0bc509eea5a1e0e3b06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1126/format:webp/0*I8RD85w3snCRK45p.png"/></div></figure><p id="5e0c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">要到达亚特兰大，我们有三条路:</p><p id="5a14" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">1.我们已经推导出到达亚特兰大的路径，即孟菲斯到亚特兰大，花费10美元，在这一点上更少。</p><p id="378c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">2.如果我们选择从莫比尔到亚特兰大的路线，如果我们从莫比尔到亚特兰大，我们可能在8$内到达亚特兰大。因此，重写表中的参数。</p><p id="3829" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">步骤5)现在让我们选择亚特兰大作为顶点来解决下一个城市问题。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es jl"><img src="../Images/1fdf3332dc5c7c9c25322a03e18e746d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1130/format:webp/0*zg1nv4sRVgevZpxt.png"/></div></figure><p id="1f46" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们已经知道，到达纳什维尔需要15美元，但如果我们沿着从亚特兰大到纳什维尔的路线，将花费2美元。</p><p id="1d4e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们已经从孟菲斯到达亚特兰大，最低花费8美元。因此，我们可以将纳什维尔成本改写为(8+2) $ = 10美元</p><p id="00ac" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，我们已经解决了使用贪婪方法的Dijkstra算法的问题，该算法使我们达到孟菲斯到纳什维尔的最低成本为10美元。我们的决赛桌如下图所示，起点是孟菲斯。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es jo"><img src="../Images/775660923f10896c18b5a662d4648d9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:688/format:webp/0*_6RwFh_ccEUQVF_D.png"/></div></figure><h1 id="73d9" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">Dijkstra算法的复杂性分析；</h1><p id="3810" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">假设一个图中有V个顶点。那么根据定义，将有|V-1|条边。主外循环运行|V|次。内部循环意味着实际成本计算发生的地方，对于一个完整的图运行|V-1|次，因为每个顶点都有|V-1|条边。</p><p id="127a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">此外，对于内部循环的每次迭代，我们对顶点执行提取最小值和减少键操作。</p><p id="9b35" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，总运行时间的上限为O(|V| * |V-1|)，相当于O(|V|2)</p><p id="4e41" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们的初始化要求每个节点的工作量不变，再加上我们考虑所有节点的时间来确定最佳解决方案，这将给我们O(N)O(N)个节点进入优先级队列将花费O(N * LG(N))O(N∫LG(N))的时间。这是所有初始化工作的O(N * LG(N))O(N÷LG(N))总时间。</p><p id="7272" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们将每条边更新一次表中的成本，即O(M)O(M)次。每次优先级表更新花费O(lg(N))O(lg(N))时间。也就是O(M * LG(N))O(M∫LG(N))总时间。</p><p id="6555" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">将所有步骤放在一起，Dijkstra算法的时间复杂度为O(N * LG(N)+M * LG(N))O(N∫LG(N)+M∫LG(N))。有时候，这个复杂度写成O((N + M)lg(n))O((N+M)lg(n))。</p><p id="92d7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">时间复杂度:θ((v+e)logv)=((6+9)log6)= 15 log6 = 11.67。</strong></p></div></div>    
</body>
</html>