<html>
<head>
<title>Understanding the patterns of a demand question (part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解需求问题的模式(第1部分)</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/understanding-the-patterns-of-a-demand-question-f5b34362249?source=collection_archive---------1-----------------------#2022-12-22">https://medium.com/mlearning-ai/understanding-the-patterns-of-a-demand-question-f5b34362249?source=collection_archive---------1-----------------------#2022-12-22</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="27ec" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">傅立叶变换、频谱分析和谐波</h2></div><p id="189e" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在这篇博文中，我将讨论我在预测模型方面的工作，以预测来电和电子邮件的数量，从而告知可靠运行服务中心所需的人员数量。数据是商业的，所以我不能分享，但无论如何让我们开始。我会尽量做到透明。</p><pre class="js jt ju jv fd jw jx jy bn jz ka bi"><span id="702a" class="kb kc hh jx b be kd ke l kf kg">library(readr)<br/>library(DataExplorer)<br/>library(dplyr)<br/>library(ggplot2)<br/>library(lubridate)<br/>library(data.table)<br/>library(tsibble)<br/>library(fable)<br/>library(fabletools)<br/>library(forecast)<br/>library(timetk);interactive &lt;- FALSE<br/>library(tidymodels)<br/>library(modeltime)<br/>library(modeltime.ensemble)<br/>library(parsnip)<br/>library(gt)<br/><br/>library(doParallel);parallelCluster &lt;- makeCluster(6, type = "SOCK", methods = FALSE)</span></pre><figure class="js jt ju jv fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es kh"><img src="../Images/bc56246819e4f824121e38971c67ff72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RtsDlfGrvZtiFLHxk68paA.png"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx">The dataset. Since it is commercial I cannot share it with you but I can try and show you, as best as possible, what the data is all about.</figcaption></figure><p id="9005" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">服务中心接收两种类型的来电——通过VOIP和电子邮件。当然后者并不是真正的需求，但它仍然是需求。正如你所看到的，在过去的一年中，已经收集了相当多的数据。这是每分钟捕获的传统时间序列数据。</p><pre class="js jt ju jv fd jw jx jy bn jz ka bi"><span id="9a60" class="kb kc hh jx b be kd ke l kf kg">&gt; dim(df)<br/>[1] 1464469      95<br/>&gt; str(df)<br/>spec_tbl_df [1,464,469 x 95] (S3: spec_tbl_df/tbl_df/tbl/data.frame)<br/> $ ConfigTenantID      : chr [1:1464469] "99" "99" "99" "99" ...<br/> $ Call_ID             : chr [1:1464469] "0x2ADD97D6E87F0039" "NULL" "0x2ADD97D6E87F0039" "0x2ADD97D6E87F0039" ...<br/> $ CallID              : chr [1:1464469] "3,08879E+18" "NULL" "3,08879E+18" "3,08879E+18" ...<br/> $ CallDirection       : chr [1:1464469] "Outgoing" "NULL" "NULL" "NULL" ...<br/> $ RecordType          : chr [1:1464469] "VOIP call" "AgentState" "AgentState" "AgentState" ...<br/> $ StateName           : chr [1:1464469] "NULL" "Released In Call" "In Call" "Wrap Up" ...<br/> $ Queue_ID            : chr [1:1464469] "NULL" "NULL" "NULL" "NULL" ...<br/> $ QueueName           : chr [1:1464469] "NULL" "NULL" "NULL" "NULL" ...<br/> $ Group_ID            : chr [1:1464469] "2236" "2236" "2236" "2236" ...<br/> $ GroupName           : chr [1:1464469] "Klantenservice" "Klantenservice" "Klantenservice" "Klantenservice" ...<br/> $ Skill_ID            : chr [1:1464469] "NULL" "NULL" "NULL" "NULL" ...<br/> $ SkillName           : chr [1:1464469] "NULL" "NULL" "NULL" "NULL" ...<br/> $ SkillSequence       : chr [1:1464469] "NULL" "NULL" "NULL" "NULL" ...<br/> $ Agent_ID            : chr [1:1464469] "21412" "21412" "21412" "21412" ...<br/> $ AgentName           : chr [1:1464469] "Christiaan Silanoe" "Christiaan Silanoe" "Christiaan Silanoe" "Christiaan Silanoe" ...<br/> $ Team_ID             : chr [1:1464469] "NULL" "NULL" "NULL" "NULL" ...<br/> $ TeamName            : chr [1:1464469] "NULL" "NULL" "NULL" "NULL" ...<br/> $ AgentSequence       : chr [1:1464469] "1" "NULL" "NULL" "NULL" ...<br/> $ CallingNumber       : chr [1:1464469] "31887082000" "NULL" "NULL" "NULL" ...<br/> $ CalledNumber        : chr [1:1464469] "31681893134" "NULL" "NULL" "NULL" ...<br/> $ WrapUpCode          : chr [1:1464469] "3491" "NULL" "NULL" "NULL" ...<br/> $ WrapUpName          : chr [1:1464469] "geen Wrap-up" "NULL" "NULL" "NULL" ...<br/> $ WrapUpData          : chr [1:1464469] NA "NULL" "NULL" "NULL" ...<br/> $ DispositionCode_ID  : chr [1:1464469] "0" "NULL" "NULL" "NULL" ...<br/> $ DispositionCode     : chr [1:1464469] "Other" "NULL" "NULL" "NULL" ...<br/> $ Offered             : chr [1:1464469] "1" "NULL" "NULL" "NULL" ...<br/> $ DoneInIVR           : chr [1:1464469] "0" "NULL" "NULL" "NULL" ...<br/> $ TransferToSystem    : chr [1:1464469] "0" "NULL" "NULL" "NULL" ...<br/> $ CallOut             : chr [1:1464469] "1" "NULL" "NULL" "NULL" ...<br/> $ OnHold              : chr [1:1464469] "0" "NULL" "NULL" "NULL" ...<br/> $ Handled             : chr [1:1464469] "1" "NULL" "NULL" "NULL" ...<br/> $ Transferred         : chr [1:1464469] "0" "NULL" "NULL" "NULL" ...<br/> $ Conference          : chr [1:1464469] "0" "NULL" "NULL" "NULL" ...<br/> $ AbandonedInQueue    : chr [1:1464469] "0" "NULL" "NULL" "NULL" ...<br/> $ AbandonedDuringHold : chr [1:1464469] "0" "NULL" "NULL" "NULL" ...<br/> $ ServiceLevel        : chr [1:1464469] "0" "NULL" "NULL" "NULL" ...<br/> $ AnswerTime          : chr [1:1464469] "1" "NULL" "NULL" "NULL" ...<br/> $ tAnswerTime         : chr [1:1464469] "0.0000115700" "NULL" "NULL" "NULL" ...<br/> $ InQueueTime         : chr [1:1464469] "0" "NULL" "NULL" "NULL" ...<br/> $ tInQueueTime        : chr [1:1464469] "0.0000000000" "NULL" "NULL" "NULL" ...<br/> $ TalkTime            : chr [1:1464469] "25" "NULL" "NULL" "NULL" ...</span></pre><p id="b18e" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">一如既往，最好是展示数据一窥究竟。在这里，您可以看到传入的VOIP呼叫被发送到代理。</p><pre class="js jt ju jv fd jw jx jy bn jz ka bi"><span id="43aa" class="kb kc hh jx b be kd ke l kf kg">df%&gt;%<br/>  filter(RecordType == "VOIP call" &amp; CallDirection=="Incoming" &amp; <br/>           DoneInIVR==0 &amp; AgentSequence==1)%&gt;%<br/>  group_by(Date, Month)%&gt;%<br/>  filter(Hour &gt;= 8 &amp; Hour &lt;=17)%&gt;%<br/>  count()%&gt;%<br/>  tidyr::drop_na()%&gt;%<br/>  mutate(dayname = weekdays(Date, abbreviate = TRUE))%&gt;%<br/>  mutate(dayname = factor(dayname,levels=c("Mon", "Tue", "Wed",<br/>                                           "Thu","Fri","Sat","Sun")))%&gt;%<br/>  ggplot(., aes(x=Date, y=n, fill=factor(dayname)), alpha=0.5)+<br/>  geom_bar(stat="identity")+<br/>  theme_bw()+<br/>  labs(x="Date", <br/>       y="Telephone calls", <br/>       fill="Dayname",<br/>       title="Actual telephone calls between 8am and 5 pm for each day of the week")</span></pre><figure class="js jt ju jv fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es kt"><img src="../Images/91fa36e20d4a2a9de8bc9ea5d32a8171.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HHYfXrt5SYdAuxfLRlbbiQ.png"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx">Thats quite a lot of calls. There is a very discernable pattern here, which is not immediately clear because of the amount of data but I will zoom in to show.</figcaption></figure><pre class="js jt ju jv fd jw jx jy bn jz ka bi"><span id="c4ac" class="kb kc hh jx b be kd ke l kf kg">df%&gt;%<br/>  filter(RecordType == "VOIP call" &amp; CallDirection=="Incoming" &amp; <br/>           DoneInIVR==0 &amp; AgentSequence==1)%&gt;%<br/>  group_by(Date, Month)%&gt;%<br/>  filter(Hour &gt;= 8 &amp; Hour &lt;=17)%&gt;%<br/>  count()%&gt;%<br/>  tidyr::drop_na()%&gt;%<br/>  ggplot(., <br/>         aes(x=Date, y=n))+<br/>  geom_bar(stat="identity")+<br/>  facet_wrap(~Month, scales="free_x")+<br/>  theme_bw()<br/><br/><br/>df%&gt;%<br/>  group_by(RecordType, Date, Month)%&gt;%<br/>  filter(!RecordType %in% c("AgentState", "Callback call"))%&gt;%<br/>  filter(Hour &gt;= 8 &amp; Hour &lt;=17)%&gt;%<br/>  filter(CallDirection=="Incoming" &amp; <br/>           DoneInIVR==0 &amp; AgentSequence==1)%&gt;%<br/>  count()%&gt;%<br/>  tidyr::drop_na()%&gt;%<br/>  ggplot(., <br/>         aes(x=Date, y=n, fill=RecordType))+<br/>  geom_bar(stat="identity", position="dodge")+<br/>  facet_wrap(~Month, scales="free_x")+<br/>  theme_bw()</span></pre><div class="js jt ju jv fd ab cb"><figure class="ku ki kv kw kx ky kz paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><img src="../Images/cfb62cd4e71c7bd3a7c2375db51bfc89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*vnTqqIQV2NaDetjTpMON_w.png"/></div></figure><figure class="ku ki la kw kx ky kz paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><img src="../Images/b608b462a130fbb9f56dc2ceda374678.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*LSfty3EBsbRffkpUPjzEPw.png"/></div><figcaption class="kp kq et er es kr ks bd b be z dx lb di lc ld">For some months I have data across two years — for the majority I have only one year. Also, the majority of the incoming calls are VOIP, some are e-mails.</figcaption></figure></div><p id="4065" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们看看是否能更好地展示这种模式。</p><pre class="js jt ju jv fd jw jx jy bn jz ka bi"><span id="045b" class="kb kc hh jx b be kd ke l kf kg">df%&gt;%<br/>  group_by(RecordType, Date, Month)%&gt;%<br/>  filter(!RecordType %in% c("AgentState", "Callback call"))%&gt;%<br/>  filter(Hour &gt;= 8 &amp; Hour &lt;=17)%&gt;%<br/>  filter(CallDirection=="Incoming" &amp; <br/>           DoneInIVR==0 &amp; AgentSequence==1)%&gt;%<br/>  count()%&gt;%<br/>  tidyr::drop_na()%&gt;%<br/>  ggplot(., <br/>         aes(x=Date, y=n, color=RecordType))+<br/>  geom_point()+<br/>  geom_line()+<br/>  facet_wrap(~Month, scales="free_x")+<br/>  theme_bw()<br/><br/>df%&gt;%<br/>  group_by(RecordType, Date, Month)%&gt;%<br/>  filter(!RecordType %in% c("AgentState", "Callback call"))%&gt;%<br/>  filter(Hour &gt;= 8 &amp; Hour &lt;=17)%&gt;%<br/>  filter(CallDirection=="Incoming" &amp; <br/>           DoneInIVR==0 &amp; AgentSequence==1)%&gt;%<br/>  count()%&gt;%<br/>  tidyr::drop_na()%&gt;%<br/>  ggplot(., <br/>         aes(x=Date, y=n, color=RecordType))+<br/>  geom_point()+<br/>  geom_line()+<br/>  theme_bw()</span></pre><div class="js jt ju jv fd ab cb"><figure class="ku ki le kw kx ky kz paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><img src="../Images/8e9155fe164ec73b6067220b562b8a53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1032/format:webp/1*kqp5mD7uoQrI7Hn2jkfiOw.png"/></div></figure><figure class="ku ki lf kw kx ky kz paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><img src="../Images/c3d7ace2e10f88b88e32a12f6ce4c770.png" data-original-src="https://miro.medium.com/v2/resize:fit:970/format:webp/1*UVA_HKjteyYuIfdxMWOp3g.png"/></div><figcaption class="kp kq et er es kr ks bd b be z dx lg di lh ld">The pattern by zooming in a bit. It is highly cyclical and if you have cyclical data, that's when you need to start thinking about Fourier transforms and spectral analysis.</figcaption></figure></div><p id="2278" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果我们不仅仅着眼于几天，而是直接进入一刻钟——这是这种特殊情况下首选的预测水平。</p><pre class="js jt ju jv fd jw jx jy bn jz ka bi"><span id="5b67" class="kb kc hh jx b be kd ke l kf kg">df%&gt;%<br/>  dplyr::mutate(newdate = with(., ymd(Date) + hms(QuarterHour)))%&gt;%<br/>  group_by(RecordType, newdate, Month)%&gt;%<br/>  filter(!RecordType %in% c("AgentState", "Callback call"))%&gt;%<br/>  filter(CallDirection=="Incoming" &amp; <br/>           DoneInIVR==0 &amp; AgentSequence==1)%&gt;%<br/>  count()%&gt;%<br/>  tidyr::drop_na()%&gt;%<br/>  ggplot(., <br/>         aes(x=newdate, y=n, color=RecordType))+<br/>  geom_point()+<br/>  geom_line()+<br/>  facet_wrap(~Month, scales="free_x")+<br/>  theme_bw()</span></pre><figure class="js jt ju jv fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es li"><img src="../Images/fbaef0a34e554087ded796c68e335cb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MV24t0uWw17PKFFXhzsQeg.png"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx">The graphs becomes practically unusable. To heavy in detail it does not add anything.</figcaption></figure><p id="f5a6" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果我们绘制每一刻钟、每天和每月的数据呢？</p><pre class="js jt ju jv fd jw jx jy bn jz ka bi"><span id="1c15" class="kb kc hh jx b be kd ke l kf kg">df%&gt;%<br/>  group_by(RecordType, Month, Day, QuarterHour)%&gt;%<br/>  filter(!RecordType %in% c("AgentState", "Callback call", "E-mail call"))%&gt;%<br/>  filter(Hour &gt;= 8 &amp; Hour &lt;=17)%&gt;%<br/>  filter(CallDirection=="Incoming" &amp; <br/>           DoneInIVR==0 &amp; AgentSequence==1)%&gt;%<br/>  count()%&gt;%<br/>  tidyr::drop_na()%&gt;%<br/>  ggplot(., <br/>         aes(x=QuarterHour, y=n, color=factor(Month)))+<br/>  geom_point()+<br/>  geom_line()+<br/>  facet_wrap(~Day, scales="free_x")+<br/>  theme_bw()</span></pre><figure class="js jt ju jv fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es lj"><img src="../Images/f40f60a2ef7a86fc8c78521986a166bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9NOXcPYjraQAwWxBPAdboA.png"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx">A lot of things going on but the cyclical pattern that we saw per day has disappeared into much more volatile data. This is fun data to model but not easy.</figcaption></figure><p id="da59" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在高粒度数据中寻找模式的一个很好的方法是使用热图，热图具有以方格模式转换时间序列数据的天然能力。</p><pre class="js jt ju jv fd jw jx jy bn jz ka bi"><span id="8a6d" class="kb kc hh jx b be kd ke l kf kg">df%&gt;%<br/>  group_by(RecordType, Month, Day, QuarterHour)%&gt;%<br/>  filter(!RecordType %in% c("AgentState", "Callback call", "E-mail call"))%&gt;%<br/>  filter(Hour &gt;= 8 &amp; Hour &lt;=17)%&gt;%<br/>  filter(CallDirection=="Incoming" &amp; <br/>           DoneInIVR==0 &amp; AgentSequence==1)%&gt;%<br/>  count()%&gt;%<br/>  tidyr::drop_na()%&gt;%<br/>  ggplot(., <br/>         aes(x=QuarterHour, fill=n, y=factor(Month)))+<br/>  geom_tile()+<br/>  scale_fill_viridis_c(option="turbo")+<br/>  facet_wrap(~Day, scales="free_x")+<br/>  theme_bw()<br/><br/>df%&gt;%<br/>  group_by(RecordType, Month, Day, QuarterHour)%&gt;%<br/>  filter(!RecordType %in% c("AgentState", "Callback call", "E-mail call"))%&gt;%<br/>  filter(Hour &gt;= 8 &amp; Hour &lt;=17)%&gt;%<br/>  filter(CallDirection=="Incoming" &amp; <br/>           DoneInIVR==0 &amp; AgentSequence==1)%&gt;%<br/>  count()%&gt;%<br/>  tidyr::drop_na()%&gt;%<br/>  ggplot(., <br/>         aes(y=QuarterHour, fill=n, x=factor(Month)))+<br/>  geom_tile()+<br/>  scale_fill_viridis_c(option="turbo")+<br/>  facet_wrap(~Day, scales="free_x")+<br/>  theme_bw()</span></pre><div class="js jt ju jv fd ab cb"><figure class="ku ki lk kw kx ky kz paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><img src="../Images/9c1cd34c23885b355a3d6526bdeb04f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1032/format:webp/1*D6wSXTdD4lvEkW9jywedig.png"/></div></figure><figure class="ku ki ll kw kx ky kz paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><img src="../Images/6cce4059222d0d8b836713ef4dcbcf31.png" data-original-src="https://miro.medium.com/v2/resize:fit:970/format:webp/1*IzMaPw45KYpFZRA53m9M2g.png"/></div><figcaption class="kp kq et er es kr ks bd b be z dx lg di lh ld">The same data plotted using different axes — you can clearly see patterns across days and time. The presence of such patterns will make the time-series analysis more easy to conduct.</figcaption></figure></div><p id="1ca7" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">好的，这肯定给了我们额外的信息。它并不完美，但它突出了模式(这也是我们在前面的情节中看到的)。</p><pre class="js jt ju jv fd jw jx jy bn jz ka bi"><span id="6072" class="kb kc hh jx b be kd ke l kf kg">df%&gt;%<br/>  group_by(RecordType, MonthName, Day, QuarterHour)%&gt;%<br/>  filter(!RecordType %in% c("AgentState", "Callback call", "E-mail call"))%&gt;%<br/>  filter(Hour &gt;= 8 &amp; Hour &lt;=17)%&gt;%<br/>  filter(CallDirection=="Incoming" &amp; <br/>           DoneInIVR==0 &amp; AgentSequence==1)%&gt;%<br/>  count()%&gt;%<br/>  tidyr::drop_na()%&gt;%<br/>  ggplot(., <br/>         aes(y=QuarterHour, fill=n, x=factor(Day)))+<br/>  geom_tile()+<br/>  scale_fill_viridis_c(option="turbo")+<br/>  facet_wrap(~MonthName, scales="free_x")+<br/>  theme_bw()</span></pre><figure class="js jt ju jv fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es lm"><img src="../Images/30ef7e5d215ed3f6393fae3552e0d808.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M6StCcITHBXtNpMA0wIf-A.png"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx">Per quarter hour, hour, day, and month you can see the number of incoming VOIP calls. It is very easy to discern patterns here, especially when using a specific heatmap collouring with a wide range of possibilities.</figcaption></figure><p id="0932" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我知道大多数电话会在早上8点到下午5点之间，所以现在让我们把重点放在这一点上。</p><pre class="js jt ju jv fd jw jx jy bn jz ka bi"><span id="e5b6" class="kb kc hh jx b be kd ke l kf kg">df%&gt;%<br/>  group_by(RecordType, Day, Month)%&gt;%<br/>  filter(!RecordType %in% c("AgentState", "Callback call"))%&gt;%<br/>  filter(Hour &gt;= 8 &amp; Hour &lt;=17)%&gt;%<br/>  filter(CallDirection=="Incoming" &amp; <br/>           DoneInIVR==0 &amp; AgentSequence==1)%&gt;%<br/>  count()%&gt;%<br/>  tidyr::drop_na()%&gt;%<br/>  ggplot(., <br/>         aes(x=Day, y=n, fill=factor(Month)), col="black")+<br/>  geom_bar(stat="identity", position="dodge")+<br/>  facet_wrap(~RecordType, scales="free_y", ncol=1)+<br/>  theme_bw()</span></pre><figure class="js jt ju jv fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es ln"><img src="../Images/5197b724d96ba5e05791912076dcb5bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cxKkU-qx_Jjjty576eOc4A.png"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx">Heavy patterns again, for both VOIP and e-mail calls.</figcaption></figure><p id="e5b5" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们将时间过滤器(上午8点到下午5点)应用到热图中，并选择一种更复杂的着色方式。由于服务中心关闭，人们也不太可能在周末打电话。因此，我将应用一个额外的过滤器来尝试并关注大部分信息。</p><pre class="js jt ju jv fd jw jx jy bn jz ka bi"><span id="9191" class="kb kc hh jx b be kd ke l kf kg">df%&gt;%<br/>  filter(RecordType == "VOIP call" &amp; CallDirection=="Incoming")%&gt;%<br/>  group_by(Date, Month, Hour)%&gt;%<br/>  filter(Hour &gt;= 8 &amp; Hour &lt;=17)%&gt;%<br/>  filter(!DayName %in% c("Zaterdag", "Zondag"))%&gt;%<br/>  count()%&gt;%<br/>  tidyr::drop_na()%&gt;%<br/>  ggplot(., <br/>         aes(x=Date, fill=n, y=factor(Hour)))+<br/>  geom_tile()+<br/>  scale_fill_viridis_c(option="magma")+<br/>  facet_wrap(~Month, scales="free")+<br/>  theme_bw()<br/><br/>df%&gt;%<br/>  filter(Hour &gt;= 8 &amp; Hour &lt;=17)%&gt;%<br/>  filter(!DayName %in% c("Zaterdag", "Zondag"))%&gt;%<br/>  filter(CallDirection=="Incoming")%&gt;%<br/>  group_by(Month, Day)%&gt;%<br/>  count()%&gt;%<br/>  tidyr::drop_na()%&gt;%<br/>  ggplot(., <br/>         aes(x=factor(Day), y=n, fill=factor(Month)))+<br/>  geom_bar(stat="identity", position="dodge")+<br/>  theme_bw()</span></pre><div class="js jt ju jv fd ab cb"><figure class="ku ki lo kw kx ky kz paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><img src="../Images/8c885f6648d8ce0417fdd490e32dca5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1020/format:webp/1*_fWlxNemOmL_fFzfuhmnmQ.png"/></div></figure><figure class="ku ki lp kw kx ky kz paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><img src="../Images/dc01de7857aeb4e257c5becceaaf9b96.png" data-original-src="https://miro.medium.com/v2/resize:fit:982/format:webp/1*L2f28GOqqFKxKFe3u-3zKw.png"/></div><figcaption class="kp kq et er es kr ks bd b be z dx lq di lr ld">For some months I have more data than for others, and although there are definitely patterns, I am not sure if showcasing it like this is the best possible way forward. Quite some volatility.</figcaption></figure></div><p id="08f5" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">试图超越数据波动的一个非常好的方法是使用移动平均线。移动平均线使用移动窗口汇总数据，从理论上讲，移动窗口应该会拾取潜在的信号。下面，我将使用30小时和一刻钟的移动平均线。因此，将合计30小时或30/4 = 7.5小时。</p><pre class="js jt ju jv fd jw jx jy bn jz ka bi"><span id="675a" class="kb kc hh jx b be kd ke l kf kg">roll_avg_30 &lt;- timetk::slidify(.f = tidyquant::AVERAGE, .period = 30, .align = "center", .partial = TRUE)<br/>df%&gt;%<br/>  dplyr::mutate(newdate = with(., ymd(Date) + hms(QuarterHour)))%&gt;%<br/>  group_by(RecordType, newdate)%&gt;%<br/>  filter(!RecordType %in% c("AgentState", "Callback call"))%&gt;%<br/>  filter(CallDirection=="Incoming" &amp; <br/>           DoneInIVR==0 &amp; AgentSequence==1)%&gt;%<br/>  count()%&gt;%<br/>  group_by(RecordType) %&gt;%<br/>  imputeTS::na_kalman(.) %&gt;%<br/>  mutate(rolling_avg_30 = roll_avg_30(n)) %&gt;%<br/>  tidyr::pivot_longer(cols = c(n, rolling_avg_30)) %&gt;%<br/>  plot_time_series(newdate, value, .color_var = name,<br/>                   .facet_ncol = 2, .smooth = FALSE, <br/>                   .interactive = FALSE)<br/><br/>df%&gt;%<br/>  dplyr::mutate(newdate = with(., ymd(Date) + hours(Hour)))%&gt;%<br/>  group_by(RecordType, newdate)%&gt;%<br/>  filter(!RecordType %in% c("AgentState", "Callback call"))%&gt;%<br/>  filter(CallDirection=="Incoming" &amp; <br/>           DoneInIVR==0 &amp; AgentSequence==1)%&gt;%<br/>  count()%&gt;%<br/>  group_by(RecordType) %&gt;%<br/>  imputeTS::na_kalman(.) %&gt;%<br/>  mutate(rolling_avg_30 = roll_avg_30(n)) %&gt;%<br/>  tidyr::pivot_longer(cols = c(n, rolling_avg_30)) %&gt;%<br/>  plot_time_series(newdate, value, .color_var = name,<br/>                   .facet_ncol = 2, .smooth = FALSE, <br/>                   .interactive = FALSE)</span></pre><div class="js jt ju jv fd ab cb"><figure class="ku ki ls kw kx ky kz paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><img src="../Images/7b388d574d8901828dfea4ddf1ecac1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:986/format:webp/1*N3WJga5GqBCsZ84Q050EVA.png"/></div></figure><figure class="ku ki lt kw kx ky kz paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><img src="../Images/00a0d71b4b96387c59017629a1607723.png" data-original-src="https://miro.medium.com/v2/resize:fit:1016/format:webp/1*wKyksJXISbUQUZ6Cv6GhUQ.png"/></div><figcaption class="kp kq et er es kr ks bd b be z dx lu di lv ld">I cannot say that the moving average is really helping me get a better understanding of the data. Highly cyclical, it just deletes the high peaks and valleys but does not really add anything. In fact, to be honest, I find it more confusing and distracting than the original data.</figcaption></figure></div><p id="b402" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当然，有多种方法可以控制数据，对我来说，分解是最直接的选择。由于几乎所有的计量经济学工具都依赖于某种形式的(统计)分解，这是一个坚实的开端。请注意，没有标准分解这种东西——存在多种分解数据的方式，您的选择取决于您将看到的内容。这就像剥洋葱皮一样。</p><pre class="js jt ju jv fd jw jx jy bn jz ka bi"><span id="2b0b" class="kb kc hh jx b be kd ke l kf kg">df%&gt;%<br/>  group_by(RecordType, Date)%&gt;%<br/>  filter(!RecordType %in% c("AgentState", "Callback call"))%&gt;%<br/>  filter(CallDirection=="Incoming" &amp; <br/>           DoneInIVR==0 &amp; AgentSequence==1)%&gt;%<br/>  count()%&gt;%<br/>  group_by(RecordType) %&gt;%<br/>  imputeTS::na_kalman(.) %&gt;%<br/>  plot_time_series_boxplot(Date,<br/>                           n,<br/>                           .facet_ncol = 2,<br/>                           .period = "2 weeks",<br/>                           .smooth = TRUE,<br/>                           .interactive = FALSE)</span></pre><figure class="js jt ju jv fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es lw"><img src="../Images/4ef970e9defbce5cbd8c2d786bf63321.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QjHefkY3xR7PBtavmL4FCw.png"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx">Data aggregated in periods of 2 weeks. Looks quite different all of a sudden.</figcaption></figure><p id="f01d" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在谈谈季节性诊断。</p><pre class="js jt ju jv fd jw jx jy bn jz ka bi"><span id="9ee3" class="kb kc hh jx b be kd ke l kf kg">df%&gt;%<br/>  group_by(RecordType, Date)%&gt;%<br/>  filter(!RecordType %in% c("AgentState", "Callback call"))%&gt;%<br/>  filter(CallDirection=="Incoming" &amp; <br/>           DoneInIVR==0 &amp; AgentSequence==1)%&gt;%<br/>  count()%&gt;%<br/>  group_by(RecordType) %&gt;%<br/>  imputeTS::na_kalman(.) %&gt;%<br/>  plot_seasonal_diagnostics(Date,n,.interactive = FALSE)</span></pre><figure class="js jt ju jv fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es lx"><img src="../Images/8b94608800b90ee92cbbd20bbbedd9b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9OPo3vsTfhWmTCmIUN6gCg.png"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx">In every part of decomposed time (minutes, hours, day, weeks, months, quarter-months, years) there is something to be gained as you can see. Hence, it would not surprise me at all if a decomposition model will work best when working on a model.</figcaption></figure><p id="b6cb" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们更深入地研究构图。</p><pre class="js jt ju jv fd jw jx jy bn jz ka bi"><span id="6123" class="kb kc hh jx b be kd ke l kf kg">df%&gt;%<br/>  group_by(RecordType, Date)%&gt;%<br/>  filter(!RecordType %in% c("AgentState", "Callback call"))%&gt;%<br/>  filter(CallDirection=="Incoming" &amp; <br/>           DoneInIVR==0 &amp; AgentSequence==1)%&gt;%<br/>  count()%&gt;%<br/>  group_by(RecordType) %&gt;%<br/>  imputeTS::na_kalman(.) %&gt;%<br/>  plot_stl_diagnostics(Date,n, <br/>                       .frequency = "auto", <br/>                       .trend = "auto",<br/>                       .feature_set = c("observed", "season", "trend", "remainder"),<br/>                       .interactive = FALSE)</span></pre><figure class="js jt ju jv fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es ly"><img src="../Images/ad3a846614d019aae5258a63bfaf94f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lWImXfX9MhBEXZQPMOLXQg.png"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx">Hmm, cannot say this is helping me more. Some parts are strange, which could be due to having only one-and-a-half years of data, but in minutes.</figcaption></figure><p id="f1d5" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">异常情况呢？</p><pre class="js jt ju jv fd jw jx jy bn jz ka bi"><span id="e512" class="kb kc hh jx b be kd ke l kf kg">df%&gt;%<br/>  group_by(RecordType, Date)%&gt;%<br/>  filter(!RecordType %in% c("AgentState", "Callback call"))%&gt;%<br/>  filter(CallDirection=="Incoming" &amp; <br/>           DoneInIVR==0 &amp; AgentSequence==1)%&gt;%<br/>  count()%&gt;%<br/>  group_by(RecordType) %&gt;%<br/>  imputeTS::na_kalman(.) %&gt;%<br/>  plot_anomaly_diagnostics(Date, n,.interactive = FALSE)</span></pre><figure class="js jt ju jv fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es lz"><img src="../Images/ba32cfa893a4607b7bf84da518f324c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*owO9nkjeh7oUQu8S21qV3A.png"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx">None really to be detected — up and down it goes for both VOIP calls and e-mails. Do take note that these are STATISTICAL anomalies. To me, a tru anomaly is one in which the observation crosses an internal threshold based on internal boundaries and knowledge.</figcaption></figure><p id="f24e" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们最后一次看一下原始形式的每小时数据。</p><pre class="js jt ju jv fd jw jx jy bn jz ka bi"><span id="471f" class="kb kc hh jx b be kd ke l kf kg">df%&gt;%<br/>  dplyr::mutate(newdate = with(., ymd(Date) + hours(Hour)))%&gt;%<br/>  filter(!RecordType %in% c("AgentState", "Callback call"))%&gt;%<br/>  group_by(RecordType, newdate)%&gt;%<br/>  filter(CallDirection=="Incoming" &amp; <br/>           DoneInIVR==0 &amp; AgentSequence==1)%&gt;%<br/>  count()%&gt;%<br/>  select(newdate, n)%&gt;%<br/>  as_tsibble(key = RecordType, index = newdate) %&gt;%<br/>  fill_gaps(n = 0, .full = end()) %&gt;%<br/>  autoplot(n) +<br/>  theme_bw()</span></pre><figure class="js jt ju jv fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es ma"><img src="../Images/2a487f7349bd3f99122eb5d5de13ed3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SzShAifP0mhcW4kESeguSA.png"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx">What I need to do is step into the world of spectral analysis.</figcaption></figure></div><div class="ab cl mb mc go md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ha hb hc hd he"><h2 id="f1fd" class="mi kc hh bd mj mk ml mm mn mo mp mq mr jf ms mt mu jj mv mw mx jn my mz na nb bi translated">光谱分析</h2><p id="3a1a" class="pw-post-body-paragraph iw ix hh iy b iz nc ii jb jc nd il je jf ne jh ji jj nf jl jm jn ng jp jq jr ha bi translated">光谱分析是一种研究循环模式的分析形式。使用<a class="ae nh" href="https://www.sciencedirect.com/topics/agricultural-and-biological-sciences/spectral-analysis#:~:text=Spectral%20analysis%20involves%20the%20calculation,is%20assumed%20to%20be%20constant." rel="noopener ugc nofollow" target="_blank">科学指导</a>，我们得到以下描述:</p><blockquote class="ni nj nk"><p id="6042" class="iw ix nl iy b iz ja ii jb jc jd il je nm jg jh ji nn jk jl jm no jo jp jq jr ha bi translated">光谱分析包括对一组有序数据中的波或振荡的计算。这些数据可以作为一个或多个独立变量的函数来观察，例如三个笛卡尔空间坐标或时间。假设空间或时间观察间隔是恒定的。</p></blockquote><p id="959d" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">简而言之，频谱分析寻找时间序列中的周期性重复行为。这就是振荡，通过将时间序列分解成光谱分析，你应该能够找到关键特征，并预测接下来会发生什么。</p><p id="623e" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">所以，我想做的是对这种类型的数据进行光谱分析，看看我能否减去时间序列的光谱部分，然后我可以用它来建立一个模型。我将使用与之前相同的数据集。</p><pre class="js jt ju jv fd jw jx jy bn jz ka bi"><span id="33f0" class="kb kc hh jx b be kd ke l kf kg">TC_df&lt;-df%&gt;%<br/>  dplyr::mutate(newdate = with(., ymd(Date) + hours(Hour)),<br/>                RecordTpe = factor(RecordType))%&gt;%<br/>  #dplyr::mutate(newdate = with(., ymd(Date)))%&gt;%<br/>  group_by(RecordType, newdate)%&gt;%<br/>  filter(!RecordType %in% c("AgentState", "Callback call"))%&gt;%<br/>  filter(CallDirection=="Incoming" &amp; <br/>           DoneInIVR==0 &amp; AgentSequence==1)%&gt;%<br/>  count()%&gt;%<br/>  group_by(RecordType) %&gt;%<br/>  imputeTS::na_kalman(.) %&gt;% <br/>  select(RecordType, newdate, n)%&gt;%<br/>  as_tsibble(key = RecordType, index = newdate) %&gt;%<br/>  fill_gaps(n = 0, .full = end())%&gt;%<br/>  as_tibble()%&gt;%<br/>  arrange(RecordType, newdate)<br/>&gt; str(TC_df)<br/>tibble [25,503 x 3] (S3: tbl_df/tbl/data.frame)<br/> $ RecordType: chr [1:25503] "Chat call" "Chat call" "Chat call" "Chat call" ...<br/> $ newdate   : POSIXct[1:25503], format: "2022-11-28 09:00:00" "2022-11-28 10:00:00" "2022-11-28 11:00:00" "2022-11-28 12:00:00" ...<br/> $ n         : num [1:25503] 9 1 0 0 0 0 11 8 0 0 ...</span></pre><p id="50d5" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">构建一个频谱周期图并不困难，事实上它内置在r的<em class="nl"> stats </em>函数中，名为<em class="nl"> spec.pgram </em>，它允许你使用快速傅立叶变换构建一个周期图。周期图是信号频谱密度的估计值。正如世界上的许多事情一样，如果我展示而不是打字，那是最好的。</p><pre class="js jt ju jv fd jw jx jy bn jz ka bi"><span id="4515" class="kb kc hh jx b be kd ke l kf kg">raw.spec &lt;-TC_df%&gt;%<br/>  filter(RecordType=="VOIP call")%&gt;%<br/>  spec.pgram(., taper=0)<br/>&gt; summary(raw.spec)<br/>          Length Class  Mode     <br/>freq       6400  -none- numeric  <br/>spec      19200  -none- numeric  <br/>coh       19200  -none- numeric  <br/>phase     19200  -none- numeric  <br/>kernel        0  -none- NULL     <br/>df            1  -none- numeric  <br/>bandwidth     1  -none- numeric  <br/>n.used        1  -none- numeric  <br/>orig.n        1  -none- numeric  <br/>series        1  -none- character<br/>snames        3  -none- character<br/>method        1  -none- character<br/>taper         1  -none- numeric  <br/>pad           1  -none- numeric  <br/>detrend       1  -none- logical  <br/>demean        1  -none- logical<br/><br/>plot(raw.spec)<br/>plot(raw.spec, log = "no")</span></pre><div class="js jt ju jv fd ab cb"><figure class="ku ki np kw kx ky kz paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><img src="../Images/73a52932b8b953dd4bded726010d893d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1104/format:webp/1*azBSWvAqFSXFzHuJPXPhOA.png"/></div></figure><figure class="ku ki nq kw kx ky kz paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><img src="../Images/76f5baa1b60405099452d5e291eecd7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:898/format:webp/1*e7YNFNOWql62JLC3qwJyiw.png"/></div><figcaption class="kp kq et er es kr ks bd b be z dx nr di ns ld">de see a periodogram for the VOIP calls. You can clearly see that there is a pattern to be discerned which becomes even clearer if you let go of the log scale (right plot). The plot to the right has information (the spikes) you can use when building your own Fourier terms, something I will talk about later.</figcaption></figure></div><p id="db7c" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果数据是静态的，时间序列分析效果最好，这意味着时间成分被排除在外-联合概率分布在随时间移动时不会改变。创建stationairy数据的一个简单方法是通过从当前值中减去前一个值来区分时间序列。我想看看如果我这样做，光谱密度会有什么变化。</p><pre class="js jt ju jv fd jw jx jy bn jz ka bi"><span id="1379" class="kb kc hh jx b be kd ke l kf kg">raw.spec &lt;-TC_df%&gt;%<br/>  filter(RecordType=="VOIP call")%&gt;%<br/>  mutate(diff = n-lag(n))%&gt;%<br/>  select(-n)%&gt;%<br/>  drop_na()%&gt;%<br/>  spec.pgram(., taper=0)<br/></span></pre><figure class="js jt ju jv fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es nt"><img src="../Images/59d4d47c5372cb8d9118b477ec792639.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-masZdWXMeoifaLEgM2XxA.png"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx">Nothing striking.</figcaption></figure><p id="9326" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">记得我说过原始音阶上的周期图是最重要的吗？让我通过构建相同的周期图，并以不同的方式绘制出来，来告诉你为什么。</p><pre class="js jt ju jv fd jw jx jy bn jz ka bi"><span id="6ac1" class="kb kc hh jx b be kd ke l kf kg">raw.spec &lt;-TC_df%&gt;%<br/>  filter(RecordType=="VOIP call")%&gt;%<br/>  mutate(diff = n-lag(n))%&gt;%<br/>  select(-n)%&gt;%<br/>  drop_na()%&gt;%<br/>  spec.pgram(., taper=0)<br/>spec.df &lt;- data.frame(freq = raw.spec$freq, spec = raw.spec$spec)<br/>hours.period &lt;- rev(c(1/6, 1/5, 1/4, 1/3, 0.5, 1, 3, 5, 10, 100))<br/>hours.labels &lt;- rev(c("1/6", "1/5", "1/4", "1/3", "1/2", "1", "3", "5", "10", <br/>                    "100"))<br/>hours.freqs &lt;- 1/hours.period * 1/4  #Convert houry period to hourly freq, and then to quarterly freq<br/>spec.df$period &lt;- 1/spec.df$freq<br/>spec.df<br/>           freq spec.1       spec.2       spec.3      period<br/>1   0.000078125      0 3.784085e-25 2.291720e-02 12800.00000<br/>2   0.000156250      0 4.167051e-23 3.888956e-03  6400.00000<br/>3   0.000234375      0 6.253588e-23 2.164362e-03  4266.66667<br/>4   0.000312500      0 1.114799e-22 1.292227e-03  3200.00000<br/>5   0.000390625      0 3.542334e-24 9.934706e-03  2560.00000<br/>6   0.000468750      0 4.301732e-22 2.664525e-03  2133.33333<br/>7   0.000546875      0 2.406620e-23 1.186406e-02  1828.57143<br/>8   0.000625000      0 2.290866e-22 1.499429e-02  1600.00000<br/>9   0.000703125      0 3.062672e-22 5.879470e-03  1422.22222<br/>10  0.000781250      0 4.157089e-22 2.916041e-02  1280.00000<br/>11  0.000859375      0 1.060980e-23 2.073200e-02  1163.63636<br/>12  0.000937500      0 8.569833e-22 3.039029e-02  1066.66667<br/>13  0.001015625      0 6.816308e-23 5.737517e-02   984.61538<br/>14  0.001093750      0 2.918175e-22 2.162401e-02   914.28571<br/>15  0.001171875      0 4.315086e-22 3.156534e-02   853.33333<br/>16  0.001250000      0 1.155874e-22 1.175910e-01   800.00000<br/>17  0.001328125      0 4.506040e-22 5.830660e-03   752.94118<br/>18  0.001406250      0 1.698297e-21 6.192288e-02   711.11111<br/>19  0.001484375      0 6.861074e-22 3.199262e-02   673.68421<br/>20  0.001562500      0 1.461395e-23 1.911038e-02   640.00000<br/>21  0.001640625      0 6.512788e-22 4.708815e-02   609.52381<br/>22  0.001718750      0 1.612486e-22 3.393423e-02   581.81818<br/>23  0.001796875      0 5.432993e-23 5.358052e-03   556.52174<br/>24  0.001875000      0 3.252505e-23 6.003705e-02   533.33333<br/>25  0.001953125      0 4.534174e-23 7.098041e-03   512.00000<br/>26  0.002031250      0 5.903458e-23 3.802192e-02   492.30769<br/>27  0.002109375      0 6.708265e-22 1.427860e-02   474.07407<br/>28  0.002187500      0 1.855928e-26 6.681841e-02   457.14286<br/>29  0.002265625      0 2.287686e-22 1.329557e-02   441.37931<br/>30  0.002343750      0 9.672564e-24 5.055994e-02   426.66667<br/>31  0.002421875      0 1.311867e-22 4.297470e-02   412.90323<br/>32  0.002500000      0 6.719445e-23 1.742689e-02   400.00000<br/>33  0.002578125      0 3.092362e-23 1.419823e-02   387.87879</span></pre><pre class="nu jw jx jy bn jz ka bi"><span id="533e" class="kb kc hh jx b be kd ke l kf kg">g1&lt;-ggplot(data = subset(spec.df)) + <br/>  geom_line(aes(x = freq, y = spec.3)) + <br/>  scale_x_continuous("Period (hours)", <br/>                     breaks = hours.freqs, <br/>                     labels = hours.labels) + <br/>  scale_y_continuous()+<br/>  theme_bw()<br/>g2&lt;-ggplot(data = subset(spec.df)) + <br/>  geom_line(aes(x = freq, y = spec.3)) + <br/>  scale_x_continuous("Period (hours)",<br/>                     breaks = hours.freqs, <br/>                     labels = hours.labels) + <br/>  scale_y_log10() +<br/>  theme_bw()<br/>g3&lt;-ggplot(data = subset(spec.df)) + <br/>  geom_line(aes(x = freq, y = spec.3)) + <br/>  scale_x_log10("Period (hours)",<br/>                breaks = hours.freqs, <br/>                labels = hours.labels) + <br/>  scale_y_log10()+<br/>  theme_bw()<br/>gridExtra::grid.arrange(g1,g2,g3,ncol=1)</span></pre><figure class="js jt ju jv fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es nv"><img src="../Images/46e93542345f6bd287018535e7d7319e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r_xhSj2Tyba4v-RZndCcRw.png"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx">You see the spectral results per hour, in three different ways. What you see, and the top plot is most important, is that there are specific parts of the time-series which stand out. Meaning that there are cycles underlying the time-series. This information can feed a model using Fourier transformations.</figcaption></figure><p id="0a35" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">上面的三幅图显示了完全相同的东西，但是比例不同(看代码)。我总是发现第一个情节是最有帮助的，因为它显示了突出的周期。每个峰值都与一个频率或一段时间相关联，告诉我这可能是一个周期。如果你认为时间序列是一组具有不同周期(链长)的链，那么你也可以理解谱分析的重要性。我来补充一张我从网上找到的gif来突出那个概念。</p><figure class="js jt ju jv fd ki er es paragraph-image"><div class="er es nw"><img src="../Images/8cbc86421738910c110964d369c3df32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/0*aJDxd3FUxt3XqccS.gif"/></div><figcaption class="kp kq et er es kr ks bd b be z dx">Here, you see the sine and cosine working, separate, but certainly also together so they are able to create cyclical patterns. The same cycles you can see in time-series. <a class="ae nh" href="https://commons.wikimedia.org/wiki/File:Circle_cos_sin.gif" rel="noopener ugc nofollow" target="_blank">https://commons.wikimedia.org/wiki/File:Circle_cos_sin.gif</a></figcaption></figure><p id="ad60" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">下一个gif将结合不同长度和速度的循环。对我来说，它们代表了一个链条，但可能与时钟的内部运作有更多的共同之处。从其内部运作，时间序列是创造了一系列的时期。</p><figure class="js jt ju jv fd ki er es paragraph-image"><div class="er es nx"><img src="../Images/bd543d5460eda66371e12ff6c869ab9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*yoLMZnSqcbqTRyvN"/></div><figcaption class="kp kq et er es kr ks bd b be z dx">You can see, in the top-right corner of the gif, the formula to create this time-series which is a model made up of sine and cosine functions. <a class="ae nh" href="https://fischerbach.medium.com/introduction-to-fourier-analysis-of-time-series-42151703524a" rel="noopener">https://fischerbach.medium.com/introduction-to-fourier-analysis-of-time-series-42151703524a</a></figcaption></figure><p id="5174" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">最后一张gif展示了正弦和余弦函数的工作原理。</p><figure class="js jt ju jv fd ki er es paragraph-image"><div class="er es ny"><img src="../Images/0b0c5b9eb3ace5b121141f4550775a46.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/0*bRHuVWZvjqBxcjNj.gif"/></div><figcaption class="kp kq et er es kr ks bd b be z dx">You can see that each part offers a different cyclical pattern. If you look at spectral analysis as a decomposition method then you should be able to discern now what it is I am looking for. <a class="ae nh" href="https://commons.wikimedia.org/wiki/File:Fourier_series_square_wave_circles_animation.gif" rel="noopener ugc nofollow" target="_blank">https://commons.wikimedia.org/wiki/File:Fourier_series_square_wave_circles_animation.gif</a></figcaption></figure><p id="e43d" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">希望光谱分析的目的变得更加清晰。现在，让我们继续前进。从前面的图中可以看出，尽管周期图的目的是从噪音中过滤信号，但它的噪音很大。我们能做的抵消是使用核估计平滑频谱分析。这里我将使用一个预定义的内核。</p><pre class="js jt ju jv fd jw jx jy bn jz ka bi"><span id="53af" class="kb kc hh jx b be kd ke l kf kg">k = kernel("daniell", c(24, 24, 24))<br/>TC_df&lt;-TC_df%&gt;%<br/>  filter(RecordType=="VOIP call")%&gt;%<br/>  ungroup()<br/>smooth.spec &lt;- spec.pgram(TC_df$n, kernel = k, taper = 0)<br/>spec.df &lt;- data.frame(freq = smooth.spec$freq, <br/>                      `c(24,24,24)` = smooth.spec$spec)<br/>names(spec.df) &lt;- c("freq", "c(24,24,24)")<br/># Add other smooths<br/>k &lt;- kernel("daniell", c(24, 24))<br/>spec.df[, "c(24,24)"] &lt;- spec.pgram(TC_df$n, kernel = k, taper = 0, plot = FALSE)$spec<br/>k &lt;- kernel("daniell", c(24))<br/>spec.df[, "c(24)"] &lt;- spec.pgram(TC_df$n, kernel = k, taper = 0, plot = FALSE)$spec<br/>spec.df &lt;- reshape2::melt(spec.df, <br/>                          id.vars = "freq", <br/>                          value.name = "spec", <br/>                          variable.name = "kernel")<br/>spec.df<br/>           freq      kernel      spec<br/>1   0.000078125 c(24,24,24)  318.8043<br/>2   0.000156250 c(24,24,24)  318.5979<br/>3   0.000234375 c(24,24,24)  318.2723<br/>4   0.000312500 c(24,24,24)  319.2094<br/>5   0.000390625 c(24,24,24)  321.4967<br/>6   0.000468750 c(24,24,24)  325.1580<br/>7   0.000546875 c(24,24,24)  330.2003<br/>8   0.000625000 c(24,24,24)  336.6251<br/>9   0.000703125 c(24,24,24)  344.4505<br/>10  0.000781250 c(24,24,24)  353.6930<br/>11  0.000859375 c(24,24,24)  364.3642<br/>12  0.000937500 c(24,24,24)  376.4706<br/>13  0.001015625 c(24,24,24)  390.0240<br/>14  0.001093750 c(24,24,24)  405.0391<br/>15  0.001171875 c(24,24,24)  421.5098<br/>16  0.001250000 c(24,24,24)  439.4497<br/>17  0.001328125 c(24,24,24)  458.8569<br/>18  0.001406250 c(24,24,24)  479.7424<br/>19  0.001484375 c(24,24,24)  502.1111<br/>20  0.001562500 c(24,24,24)  525.9676<br/>21  0.001640625 c(24,24,24)  551.3425<br/>22  0.001718750 c(24,24,24)  578.2441<br/>23  0.001796875 c(24,24,24)  606.6778<br/>24  0.001875000 c(24,24,24)  636.6403<br/>25  0.001953125 c(24,24,24)  668.1353<br/>26  0.002031250 c(24,24,24)  701.1556<br/>27  0.002109375 c(24,24,24)  735.7042<br/>28  0.002187500 c(24,24,24)  771.7751<br/>29  0.002265625 c(24,24,24)  809.3732<br/>30  0.002343750 c(24,24,24)  848.5064<br/>31  0.002421875 c(24,24,24)  889.2045<br/>32  0.002500000 c(24,24,24)  931.4631<br/>33  0.002578125 c(24,24,24)  975.2870<br/>34  0.002656250 c(24,24,24) 1020.6859<br/>35  0.002734375 c(24,24,24) 1067.6608<br/><br/><br/><br/>plot1 &lt;- ggplot(data = subset(spec.df)) + <br/>  geom_path(aes(x = freq, y = spec,color = kernel)) + <br/>  scale_x_continuous("Period (hours)", <br/>                     breaks = hours.freqs,<br/>                     labels = hours.labels) + <br/>  scale_y_log10()+<br/>  theme_bw()<br/>plot2 &lt;- ggplot(data = subset(spec.df)) + <br/>  geom_path(aes(x = freq, y = spec,color = kernel)) + <br/>  scale_x_log10("Period (hours)", <br/>                breaks = hours.freqs,<br/>                labels = hours.labels) + <br/>  scale_y_log10()+<br/>  theme_bw()<br/>gridExtra::grid.arrange(plot1, plot2)</span></pre><figure class="js jt ju jv fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es nz"><img src="../Images/6916c9975b69560ec1024c792240ccf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TK7eOwwSbgS-uNxmpc5sHQ.png"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx">The spectral analysis using the smoothed kernel.</figcaption></figure><figure class="js jt ju jv fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es oa"><img src="../Images/6df7bcec02afac3505a7a630264c55f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gN9Gf333s_NtIe2AOkxeIQ.png"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx">And different plots of different kernels. In the end, it all looks nice, but to me the original periodogram is the most helpful, and so I will use that.</figcaption></figure><p id="a72e" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我已经展示了对包含大量循环模式的时间序列数据进行建模的一种有效方法是使用正弦和余弦函数。我现在要做的是建立一个线性回归模型，并添加正弦和余弦函数。但是，我将首先转换日级别的数据，然后将数据分割成组件，并对其进行切片。选择切片的最佳方法是查看周期图的峰值。让我们通过观察数据进行切片、回归和比较拟合。</p><pre class="js jt ju jv fd jw jx jy bn jz ka bi"><span id="850c" class="kb kc hh jx b be kd ke l kf kg">TC_df_wave2&lt;-TC_df%&gt;%<br/>  filter(RecordType=="VOIP call")%&gt;%<br/>  timetk::summarise_by_time(<br/>    .date_var = newdate,<br/>    .by       = "day",<br/>    value  = sum(n))%&gt;%<br/>  mutate(day = as.numeric(yday(newdate)))%&gt;%<br/>  ungroup()<br/>fit &lt;- lm(value~day + sin(2*pi*day/7)+cos(2*pi*day/7)+<br/>            sin(2*pi*day/3)+cos(2*pi*day/3)+<br/>            sin(2*pi*day/6)+cos(2*pi*day/6)+<br/>            sin(2*pi*day/8)+cos(2*pi*day/8)+<br/>            sin(2*pi*day/9)+cos(2*pi*day/9)+<br/>            sin(2*pi*day/100)+cos(2*pi*day/100),<br/>          data=TC_df_wave2)<br/>TC_df_wave2$fitted&lt;-fitted(fit, TC_df_wave2)<br/>ggplot2::ggplot() +<br/>  geom_point(data=TC_df_wave2, aes(x = newdate, y = value), color='black', size=1) +<br/>  geom_line(data=TC_df_wave2, aes(x = newdate, y = fitted), colour = "red", size=1)+<br/>  labs(title="TimeSeries with fitted values", x="Date", y="Incoming Calls") +<br/>  theme(plot.title = element_text(hjust = 0.5, face="bold", size=14),<br/>        axis.text=element_text(size=10),<br/>        axis.title=element_text(size=12),<br/>        legend.title=element_text(size=13, face="bold"),<br/>        legend.text=element_text(size=13))+<br/>  theme_bw()</span></pre><figure class="js jt ju jv fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es ob"><img src="../Images/791e594018494f8f51dbb5fb2452f989.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9cvq0TJn1YdLAA5NnoL9xA.png"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx">The sine and cosine functions provide a highly cylical pattern, which does capture the main part of the data, but not the boundary nor the peaks. However, for demand data, it is exactly the peaks and valleys that are of importance to me. So we get cycles, but we do not descend nor ascend to the place we need to be.</figcaption></figure><p id="0e4b" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">因此，除了是一个使用线性回归分析时间序列数据的好例子之外，它没有提供我想要的模型。</p><p id="75c3" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我可以尝试建立的另一个模型是谐波模型。谐波旨在将数据集分解为一组正弦和余弦函数。因此，它将非常适合，但对未来的预测作用不大。</p><pre class="js jt ju jv fd jw jx jy bn jz ka bi"><span id="22ac" class="kb kc hh jx b be kd ke l kf kg">TC_df_wave2&lt;-TC_df%&gt;%<br/>  filter(RecordType=="VOIP call")%&gt;%<br/>  timetk::summarise_by_time(<br/>    .date_var = newdate,<br/>    .by       = "day",<br/>    value  = sum(n))%&gt;%<br/>  mutate(newdate = date(newdate))%&gt;%<br/>  select(newdate, value)%&gt;%<br/>  ungroup()<br/>fitted &lt;- rHarmonics::harmonics_fun(user_vals = TC_df_wave2$value,<br/>                                user_dates = TC_df_wave2$newdate,<br/>                                harmonic_deg = 365)<br/>combined_df &lt;- cbind(TC_df_wave2, fitted)<br/>names(combined_df) &lt;- c("dates", "calls", "fitted")<br/>ggplot2::ggplot() +<br/>  geom_point(data=combined_df, aes(x = dates, y = calls), color='black', size=1) +<br/>  geom_line(data=combined_df, aes(x = dates, y = fitted), colour = "red", size=1)+<br/>  labs(title="TimeSeries with fitted values", x="Date", y="Incoming Calls") +<br/>  theme(plot.title = element_text(hjust = 0.5, face="bold", size=14),<br/>        axis.text=element_text(size=10),<br/>        axis.title=element_text(size=12),<br/>        legend.title=element_text(size=13, face="bold"),<br/>        legend.text=element_text(size=13))+<br/>  theme_bw()</span></pre><figure class="js jt ju jv fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es oc"><img src="../Images/6109e6e33f46a3e87e0c021edce92425.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q2uBEZPsZcwGX_7PcEQz9A.png"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx">Perfict fit. Overfit once could even say. Sure, I could slice the time-series to construct a model, but there are more straightfoward ways of analyzing cyclical data.</figcaption></figure><p id="6351" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当然，在R中有多种方法可以做同样的分析。这里用来进行谐波分析的软件包(<em class="nl">rHarmonics</em>en<em class="nl">geoTS</em>)有着稍微不同的目的，但它们确实有助于辨别正弦和余弦函数的大小和位置在可行模型中的使用位置。</p><pre class="js jt ju jv fd jw jx jy bn jz ka bi"><span id="658f" class="kb kc hh jx b be kd ke l kf kg">TC_df_wave2&lt;-TC_df%&gt;%<br/>  filter(RecordType=="VOIP call")%&gt;%<br/>  timetk::summarise_by_time(<br/>    .date_var = newdate,<br/>    .by       = "day",<br/>    value  = sum(n))%&gt;%<br/>  mutate(newdate = date(newdate))%&gt;%<br/>  ungroup()%&gt;%<br/>  as.data.frame()%&gt;%<br/>  as.ts()<br/>fit_harmR &lt;-geoTS::haRmonics(TC_df_wave2$value, <br/>                             numFreq = round((max(TC_df_wave2$day)/2)-2), <br/>                             delta = 0.1)<br/>&gt; summary(fit_harmR$a.coef)<br/>   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. <br/>-15.682  -9.004  -5.735  -6.016  -3.352   4.016 <br/>&gt; summary(fit_harmR$b.coef)<br/>   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. <br/> 0.7904  4.5014  5.4020  5.7148  7.9489  8.9102 <br/><br/>fitLow_hants &lt;- geoTS::haRmonics(y = TC_df_wave2$value, <br/>                                 method = "hants", <br/>                                 numFreq = 7, <br/>                                 HiLo = "Lo",<br/>                                 low = 0, <br/>                                 high = 1000, <br/>                                 fitErrorTol = 5, <br/>                                 degreeOverDeter = 1,<br/>                                 delta = 0.1)<br/>fitHigh_hants &lt;- geoTS::haRmonics(y = TC_df_wave2$value, <br/>                                  method = "hants", <br/>                                  numFreq = 7, <br/>                                  HiLo = "Hi", <br/>                                  low = 0, <br/>                                  high = 1000, <br/>                                  fitErrorTol = 5, degreeOverDeter = 1, <br/>                           delta = 0.1)<br/>plot(TC_df_wave2$value, pch = 16, main = "haRmonics fitting")<br/>lines(fit_harmR$fitted ,lty = 4, col = "green")<br/>lines(fitLow_hants$fitted, lty = 4, col = "red")<br/>lines(fitHigh_hants$fitted, lty = 2, col = "blue")</span></pre><figure class="js jt ju jv fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es od"><img src="../Images/103e17cbbff3f69f3cf4bd2a1fbcda84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pQ0rKmVHQBLMjGFjc7ovtg.png"/></div></div></figure><p id="40a7" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">使用<a class="ae nh" href="https://www.tmwr.org/recipes.html" rel="noopener ugc nofollow" target="_blank"> tidymodels </a>家族，我还可以构建一个<a class="ae nh" href="https://recipes.tidymodels.org/" rel="noopener ugc nofollow" target="_blank"> <em class="nl">食谱</em> </a> <em class="nl"> </em>，在其中我使用谐波构建一个步骤。我将应用与之前相同的频谱分解，定义六个循环，每个循环大小为一。他们将一起创建以下模型和输出，然后我可以将其与我观察到的进行比较。</p><pre class="js jt ju jv fd jw jx jy bn jz ka bi"><span id="a7cb" class="kb kc hh jx b be kd ke l kf kg">TC_df_wave2<br/>findfrequency(TC_df_wave2)<br/>dat &lt;- recipe(value ~ newdate, <br/>              data = TC_df_wave2) %&gt;%<br/>  step_harmonic(newdate, <br/>                frequency = c(1/3,1/6,1/7,1/8,1/9,1/100), <br/>                cycle_size = 1) %&gt;%<br/>  prep() %&gt;%<br/>  bake(new_data = NULL)<br/>fit &lt;- lm(value ~ ., data = dat)<br/>TC_df_wave2$type&lt;-"Observed"<br/>fits &lt;- tibble(<br/>  newdate = TC_df_wave2$newdate,<br/>  value = fit$fitted.values,<br/>  type = "Fitted")<br/>bind_rows(TC_df_wave2, fits) %&gt;%<br/>  ggplot(aes(x = newdate, y = value, color = type)) +<br/>  geom_line()+<br/>  theme_bw()+<br/>  labs(col="", <br/>       x="Date", <br/>       y="Incoming calls")</span></pre><figure class="js jt ju jv fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es oe"><img src="../Images/aca8f822b674ced12de48517fa2bccb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XFjreleRq_oR8lEXvRRbrQ.png"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx">Not bad, but not perfect either. Lets move on.</figcaption></figure></div><div class="ab cl mb mc go md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ha hb hc hd he"><h2 id="acbf" class="mi kc hh bd mj mk ml mm mn mo mp mq mr jf ms mt mu jj mv mw mx jn my mz na nb bi translated">傅立叶变换</h2><p id="78ef" class="pw-post-body-paragraph iw ix hh iy b iz nc ii jb jc nd il je jf ne jh ji jj nf jl jm jn ng jp jq jr ha bi translated">是时候进入正题了——傅立叶变换。傅立叶变换到底是什么？这个问题我自己也思考了很久，所以让我们看看维基百科是怎么说的:</p><blockquote class="ni nj nk"><p id="2b8f" class="iw ix nl iy b iz ja ii jb jc jd il je nm jg jh ji nn jk jl jm no jo jp jq jr ha bi translated">一个<strong class="iy hi">傅立叶变换</strong> ( <strong class="iy hi"> FT </strong>)是一个<a class="ae nh" href="https://en.wikipedia.org/wiki/Mathematics" rel="noopener ugc nofollow" target="_blank">数学</a> <a class="ae nh" href="https://en.wikipedia.org/wiki/Integral_transform" rel="noopener ugc nofollow" target="_blank">变换</a>，它将<a class="ae nh" href="https://en.wikipedia.org/wiki/Function_(mathematics)" rel="noopener ugc nofollow" target="_blank">函数</a>分解成频率分量，这些分量由作为频率函数的变换输出来表示。将最常见的<a class="ae nh" href="https://en.wikipedia.org/wiki/Time" rel="noopener ugc nofollow" target="_blank">时间</a>或<a class="ae nh" href="https://en.wikipedia.org/wiki/Space" rel="noopener ugc nofollow" target="_blank">空间</a>的函数进行变换，分别输出一个依赖于<a class="ae nh" href="https://en.wikipedia.org/wiki/Frequency" rel="noopener ugc nofollow" target="_blank">时间频率</a>或<a class="ae nh" href="https://en.wikipedia.org/wiki/Spatial_frequency" rel="noopener ugc nofollow" target="_blank">空间频率</a>的函数。那个过程也叫做<a class="ae nh" href="https://en.wikipedia.org/wiki/Analysis" rel="noopener ugc nofollow" target="_blank"> <em class="hh">分析</em> </a>。一个示例应用是将音乐<a class="ae nh" href="https://en.wikipedia.org/wiki/Chord_(music)" rel="noopener ugc nofollow" target="_blank">和弦</a>的<a class="ae nh" href="https://en.wikipedia.org/wiki/Waveform" rel="noopener ugc nofollow" target="_blank">波形</a>分解成其组成<a class="ae nh" href="https://en.wikipedia.org/wiki/Pitch_(music)" rel="noopener ugc nofollow" target="_blank">音高</a>的<a class="ae nh" href="https://en.wikipedia.org/wiki/Sound_intensity" rel="noopener ugc nofollow" target="_blank">强度</a>。术语<em class="hh">傅立叶变换</em>指的是<a class="ae nh" href="https://en.wikipedia.org/wiki/Frequency_domain" rel="noopener ugc nofollow" target="_blank">频域</a>表示和<a class="ae nh" href="https://en.wikipedia.org/wiki/Operation_(mathematics)" rel="noopener ugc nofollow" target="_blank">数学运算</a>，其将频域表示与空间或时间的函数相关联。</p></blockquote><p id="d796" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这就是我们一直在做的，不是吗？让我们用另一个gif把傅立叶变换和周期图放在一起。</p><figure class="js jt ju jv fd ki er es paragraph-image"><div class="er es of"><img src="../Images/188b70753f1453d563e915a52db81344.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/0*tsprN9Tf1H_Ek6Vr.gif"/></div><figcaption class="kp kq et er es kr ks bd b be z dx">Notice that the beginning is a time-series and that the end is the periodogram. So what I will do is use a periodogram to inform a Fourier function in a time-series model. <a class="ae nh" href="https://commons.wikimedia.org/wiki/File:Fourier_transform_time_and_frequency_domains.gif" rel="noopener ugc nofollow" target="_blank">https://commons.wikimedia.org/wiki/File:Fourier_transform_time_and_frequency_domains.gif</a></figcaption></figure><p id="bad3" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">另一种表达方式是用声音这样的信号来思考，如下图所示。</p><figure class="js jt ju jv fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es og"><img src="../Images/8a6d00c0c4048035917c785f1f76931a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1086/0*TOgvDCWT198yGQwF.gif"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx">What you can see here, very clearly, is how the time-series, power spectrum and Fourier transform are applied. <a class="ae nh" href="https://www.dataq.com/data-acquisition/general-education-tutorials/fft-fast-fourier-transform-waveform-analysis.html" rel="noopener ugc nofollow" target="_blank">https://www.dataq.com/data-acquisition/general-education-tutorials/fft-fast-fourier-transform-waveform-analysis.html</a></figcaption></figure><p id="8629" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我要做的是获取时间序列，制作一个功率谱，并使用该信息通过傅立叶变换建立一个模型。然后我会检查这个模型是否对我观察到的时间序列有意义。换句话说，我是否充分分解了时间序列？让我们从周期图开始，它是功率谱。</p><pre class="js jt ju jv fd jw jx jy bn jz ka bi"><span id="b383" class="kb kc hh jx b be kd ke l kf kg">TC_df&lt;-df%&gt;%<br/>  dplyr::mutate(newdate = with(., ymd(Date)+ hours(Hour)),<br/>                RecordTpe = factor(RecordType))%&gt;%<br/>  filter(!RecordType %in% c("AgentState", "Callback call", "E-mail call"))%&gt;%<br/>  filter(CallDirection=="Incoming")%&gt;%<br/>  group_by(newdate)%&gt;%<br/>  dplyr::select(newdate)%&gt;%<br/>  count()%&gt;%<br/>  ungroup()%&gt;%<br/>  imputeTS::na_kalman(.) %&gt;% <br/>  as_tsibble()%&gt;%<br/>  tsibble::fill_gaps()%&gt;%<br/>  replace(is.na(.), 0)<br/>TC_ts &lt;- ts(TC_df$n,start = c(2022,1),frequency = 365*24)<br/>ndiffs(TC_ts) # needs differences<br/>TC_ts<br/>ndiffs(diff(TC_ts))<br/>[1] 0<br/>TC_ts_diff=diff(TC_ts)<br/>Time Series:<br/>Start = c(2022, 1) <br/>End = c(2023, 3824) <br/>Frequency = 8760 <br/>   [1]   3   7   1   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0<br/>  [23]   2   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0  13   2   1<br/>  [45]  12   3   1  10   4   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0<br/>  [67]   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0<br/>  [89]   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0<br/> [111]   0   0   0   0   2   0   0   0   9   0   2   2   0   0   0   0   0   0   0   0   0   0<br/> [133]   0   0   0   0   0   1   3   3   2   3   0   2   2   1  31   9   0   1   0   0   0   0<br/> [155]   0   0   0   0   0   1   4  85  77  71  90  62  46  46  56  46  10   2   0   0   1   0<br/> [177]   0   1   0   0   0   0   0   2   3  51  68  60  63  49  55  54  33  43   6   2   1   0<br/> [199]   1   0   0   0   0   0   0   0   0   1   0  47  71  75  82  49  58  72  57  39   8   1<br/> [221]   0   2   0   0   0   0   0   0   0   0   0   0   2   7   5  15  12   5  10   7   5   2<br/> [243]   0   0   3   1   1   0   0   0   0   0   0   0   0   0   0   0   0   2   3   2   2   2<br/> [265]   0   1   1   2   0   0   0   0   0   0   0   0   0   0   0   1   2  63 106  89  84  78<br/> [287]  83  95  88  52  10   2   0   3   0   0   0   0   0   0   0   0   0   0   3  47  60  74<br/> [309]  86  49  89  61  69  47   5   4   4   3   0   1   0   0   0   0   0   0   0   1   4  51<br/> [331]  72  91  83  48  88  63  60  62   9   2   1   0   0   0   0   0   0   0   0   0   0   0<br/> [353]   3  28  66  75  86  44  63  54  46  69  11   5   2   5   0   0   0   0   0   0   0   0<br/> [375]   0   0   0  31  88 116  89  74  81  65  60  35   5   3   0   1   1   0   0   0   0   0<br/> [397]   0   0   0   0   0   2  10   9  13  10   3  10   9   4   0   1   0   1   0   0   0   0<br/> [419]   0   0   0   0   0   0   0   0   0   0   1   2   2   6   1   0   2   0   0   0   0   0<br/> [441]   0   0   0   0   0   0   0   0   3  63 115 115 101  85  60  84  67  38   7   3   4   2<br/> [463]   0   0   0   0   0   0   0   0   0   0   3  67  71  86  71  82  64  57  46  45  10   2<br/> [485]   2   0   0   0   0   0   0   0   0   1   0   0   7  56  74  67  74  55  54  63  71  54<br/> [507]   7   1   0   0   0   0   0   0   0   0   0   0   0   0   1  42  80  87  77  72  57  49<br/> [529]  53  48   7   3   2   0   0   0   0   0   0   0   0   0   0   0   1  35  69  62  74  38<br/> [551]  52  39  27  35   3   3   1   1   0   0   0   0   0   0   0   0   0   0   0   0   4   8<br/> [573]   3   7  10   0   3   2   2   1   2   0   0   0   0   0   0   0   0   0   0   0   0   0<br/> [595]   0   1   2   1   0   0   0   0   1   0   1   0   0   0   0   0   0   0   0   0   0   0<br/> [617]   1  59  92 104  98  52  64  87  65  47  12   1   1   1   0   0   0   0   0   0   0   0<br/> [639]   0   0   2  39  67  78  58  55  91  45  58  43  10   1   0   0   1   0   1   0   0   0<br/> [661]   0   0   0   0   3  37  87  69  67  58  54  66  39  32   2   2   2   1   1   0   0   0<br/> [683]   0   0   0   0   0   0   2  32  73  68  56  58  51  58  54  42   8   0   1   0   1   0<br/> [705]   0   0   0   0   0   0   0   1   2  37  61  84  72  55  42  39  35  26   8   3   1   1<br/> [727]   0   0   0   0   0   0   0   0   0   0   0   1  12  10   3   4   6   3   8   5   1   0<br/> [749]   2   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   3   3   1   1   2   0<br/> [771]   0   0   4   0   0   0   0   0   0   0   0   0   0   0   1  65 101 111  94  72  78  72<br/> [793]  47  41   5   4   0   0   0   0   0   0   0   0   0   0   0   0   3  39  54  60  55  36<br/> [815]  43  56  47  24   5   2   1   1   0   0   0   0   0   0   0   0   0   0   4  37  52  65<br/> [837]  64  48  47  63  64  43   8   7   0   0   0   0   0   0   0   0   0   0   0   0   2  50<br/> [859]  66  66  72  54  40  61  49  49   8   1   3   0   1   0   0   0   0   0   0   0   0   2<br/> [881]   2  43  74  56  55  45  41  65  60  36   7   1   3   1   0   0   0   0   0   0   0   0<br/> [903]   0   0   1   3   8  12   4   7   6   2   4   2   2   1   0   2   1   0   0   0   0   0<br/> [925]   0   0   0   0   0   0   0   0   4   1   0   1   2   0   2   0   1   2   0   0   0   0<br/> [947]   0   0   0   0   0   0   4  49  78  98  73  75  64  66  60  47   6   0   1   0   0   0<br/> [969]   0   0   0   0   0   0   0   0   2  33  66  71  47  49  55  75  51  40   7   0   0   1<br/> [991]   0   1   2   0   0   0   0   0   0   0<br/> [ reached getOption("max.print") -- omitted 11584 entries ]<br/>p &lt;- TSA::periodogram(TC_ts)<br/></span></pre><figure class="js jt ju jv fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es oh"><img src="../Images/75894e45ae00d7c21dca7c2d874ca051.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vdbGGTOzuTy0K_C5cz71Lg.png"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx">Okay, so now we have our peak frequencies.</figcaption></figure><p id="22fc" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们看看哪些是正确的。</p><pre class="js jt ju jv fd jw jx jy bn jz ka bi"><span id="63c8" class="kb kc hh jx b be kd ke l kf kg">pp&lt;-data.table(period=1/p$freq, spec=p$spec)[order(-spec)][1:10];pp<br/>        period      spec<br/> 1:  24.015009 2345808.7<br/> 2:  23.970037  700813.4<br/> 3: 168.421053  491890.5<br/> 4:  11.996251  433476.7<br/> 5:  28.008753  361109.9<br/> 6:  33.595801  244074.5<br/> 7:  84.210526  194381.6<br/> 8:   6.000938  154977.4<br/> 9:  20.983607  141334.7<br/>10:  21.018062  114253.8</span></pre><p id="6975" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这些频率是我可以用来进行傅立叶变换的频率。这些转换是如此的基本和强大，以至于你可以将它们包含在一个标准的时间序列模型中，比如一个<em class="nl"> auto.arima </em>，或者你可以将它们作为一个配方添加进去。<em class="nl"> auto.arima </em>先来。让我们运行一个没有傅立叶变换的模型，看看哪个ARIMA最适合VOIP来电的时间序列。</p><pre class="js jt ju jv fd jw jx jy bn jz ka bi"><span id="4e73" class="kb kc hh jx b be kd ke l kf kg">fit0 &lt;- auto.arima(TC_ts_diff)<br/>(bestfit &lt;- list(aicc=fit0$aicc, i=0, j=0, fit=fit0))<br/>$aicc<br/>[1] 98410.95<br/><br/>$i<br/>[1] 0<br/><br/>$j<br/>[1] 0<br/><br/>$fit<br/>Series: TC_ts_diff <br/>ARIMA(3,0,3) with zero mean <br/><br/>Coefficients:<br/>          ar1      ar2      ar3     ma1     ma2     ma3<br/>      -0.2850  -0.5639  -0.6294  0.4499  0.6607  0.7047<br/>s.e.   0.0357   0.0186   0.0320  0.0332  0.0134  0.0291<br/><br/>sigma^2 = 145.8:  log likelihood = -49198.47<br/>AIC=98410.94   AICc=98410.95   BIC=98463.02</span></pre><p id="7525" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们最终得到一个ARIMA模型，它具有AR(3)和MA(3)分量，对此不需要进行差分。我还可以做的是建立一个线性回归模型，其中包括几个组件，如趋势和季节。可以用傅立叶变换来逼近周期。<em class="nl"> tslm </em>车型可以完成这样的壮举。K是可以包含的傅立叶项的最大阶数。我已经将k设置为4，这意味着我想包含4个更高级的术语。我拥有的项越多，我要做的分解就越多。数量<em class="nl"> k </em>肯定是有限的，你可以像在<strong class="iy hi">套索</strong>中找到最优<em class="nl"> k </em>一样找到最优<em class="nl">λ</em>。但是在这里，我只选择了四个，因为根据上面显示的周期图，我已经知道我想要包括多少个。</p><pre class="js jt ju jv fd jw jx jy bn jz ka bi"><span id="5cb4" class="kb kc hh jx b be kd ke l kf kg">fourier.calls &lt;- tslm(TC_ts ~ trend + season + fourier(TC_ts, K=4), lambda="auto")<br/>summary(fourier.calls)<br/>Call:<br/>tslm(formula = TC_ts ~ trend + season + fourier(TC_ts, K = 4), <br/>    lambda = "auto")<br/><br/>Residuals:<br/>    Min      1Q  Median      3Q     Max <br/>-68.689  -0.732   0.000   0.732  68.689 <br/><br/>Coefficients: (7 not defined because of singularities)<br/>                               Estimate Std. Error t value Pr(&gt;|t|)    <br/>(Intercept)                   4.739e+13  4.496e+13   1.054    0.292    <br/>trend                        -2.022e-04  3.726e-05  -5.426 6.11e-08 ***<br/>season2                      -3.657e+07  3.469e+07  -1.054    0.292    <br/>season3                      -9.752e+07  9.252e+07  -1.054    0.292    <br/>season4                      -1.829e+08  1.735e+08  -1.054    0.292    <br/>season5                      -2.926e+08  2.775e+08  -1.054    0.292    <br/>season6                      -4.267e+08  4.048e+08  -1.054    0.292    <br/>season7                      -5.851e+08  5.551e+08  -1.054    0.292    <br/>season8                      -7.680e+08  7.286e+08  -1.054    0.292    <br/> [ reached getOption("max.print") -- omitted 8569 rows ]<br/>---<br/>Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1<br/><br/>Residual standard error: 14.22 on 3822 degrees of freedom<br/>Multiple R-squared:  0.9009, Adjusted R-squared:  0.6738 <br/>F-statistic: 3.967 on 8761 and 3822 DF,  p-value: &lt; 2.2e-16</span></pre><p id="399d" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">看上面的输出。看到我省略了多少系数了吗？这个模型中有8000多个系数。太疯狂了，这不是我想要的。不过，让我们看看自动检测傅立叶项的模型是如何执行的。</p><pre class="js jt ju jv fd jw jx jy bn jz ka bi"><span id="0b3c" class="kb kc hh jx b be kd ke l kf kg">TC_df$fitted&lt;-fourier.calls$fitted.values<br/>ggplot()+<br/>  geom_point(data=TC_df, aes(x=newdate, y=n))+<br/>  geom_line(data=TC_df, aes(x=newdate, y=fitted), col="red")+<br/>  theme_bw()</span></pre><figure class="js jt ju jv fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es oi"><img src="../Images/eb47f17f035ec678cacbef18e905643a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TU94JuhzaRXOD4I2-11Gmg.png"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx">Not bad at all! This is getting somewhere.</figcaption></figure><p id="1adc" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在，我想做一个手动傅立叶变换。我将以必要的形式构建数据，再次显示周期图结果，然后将前六个信号以傅立叶序列相加。</p><pre class="js jt ju jv fd jw jx jy bn jz ka bi"><span id="ceec" class="kb kc hh jx b be kd ke l kf kg">y&lt;-df%&gt;%<br/>  dplyr::mutate(newdate = with(., ymd(Date) + hours(Hour)),<br/>                RecordTpe = factor(RecordType))%&gt;%<br/>  filter(!RecordType %in% c("AgentState", "Callback call", "E-mail call"))%&gt;%<br/>  filter(CallDirection=="Incoming" &amp; <br/>           DoneInIVR==0 &amp; AgentSequence==1)%&gt;%<br/>  group_by(newdate)%&gt;%<br/>  dplyr::select(newdate)%&gt;%<br/>  count()%&gt;%<br/>  ungroup()%&gt;%<br/>  imputeTS::na_kalman(.) %&gt;% <br/>  as_tsibble()%&gt;%<br/>  tsibble::fill_gaps()%&gt;%<br/>  replace(is.na(.), 0)%&gt;%<br/>  as.data.frame()%&gt;%<br/>  select(n)%&gt;%<br/>  pull(n)<br/><br/>&gt; tail(TC_df)<br/>                  newdate  n<br/>12574 2022-12-13 12:00:00 40<br/>12575 2022-12-13 13:00:00 41<br/>12576 2022-12-13 14:00:00 47<br/>12577 2022-12-13 15:00:00 40<br/>12578 2022-12-13 16:00:00 43<br/>12579 2022-12-13 17:00:00  1<br/>&gt; head(TC_df)<br/>              newdate n<br/>1 2021-07-07 15:00:00 2<br/>2 2021-07-07 16:00:00 6<br/>3 2021-07-07 17:00:00 0<br/>4 2021-07-07 18:00:00 0<br/>5 2021-07-07 19:00:00 0<br/>6 2021-07-07 20:00:00 0<br/><br/>time_index &lt;- seq(from = as.POSIXct("2021-07-07 15:00:00"), <br/>                  to = as.POSIXct("2022-12-13 16:00:00"), by = "hour")<br/>&gt; length(time_index)<br/>[1] 12579<br/>&gt; length(y)<br/>[1] 12579<br/>TC_ts &lt;- xts::xts(y, order.by = time_index)<br/>TC_ts %&gt;% diff() %&gt;% ggtsdisplay(main="")<br/>TC_ts  %&gt;% ggtsdisplay(main="")<br/>TC_ts_diff &lt;-TC_ts %&gt;% diff()<br/>fit0 &lt;- auto.arima(TC_ts_diff)<br/>fc0 &lt;- forecast(fit0,h=24*7);plot(fc0)</span></pre><pre class="nu jw jx jy bn jz ka bi"><span id="e71d" class="kb kc hh jx b be kd ke l kf kg">pp&lt;-data.table(period=1/p$freq, spec=p$spec)[order(-spec)][1:10];pp<br/>        period      spec<br/> 1:  24.015009 2345808.7<br/> 2:  23.970037  700813.4<br/> 3: 168.421053  491890.5<br/> 4:  11.996251  433476.7<br/> 5:  28.008753  361109.9<br/> 6:  33.595801  244074.5<br/> 7:  84.210526  194381.6<br/> 8:   6.000938  154977.4<br/> 9:  20.983607  141334.7<br/>10:  21.018062  114253.8</span></pre><pre class="nu jw jx jy bn jz ka bi"><span id="b21f" class="kb kc hh jx b be kd ke l kf kg">f1&lt;-fourier(ts(y, frequency=24.015009 ),K=4)<br/>f2&lt;-fourier(ts(y, frequency=23.970037),K=4)<br/>f3&lt;-fourier(ts(y, frequency=168.421053),K=4)<br/>f4&lt;-fourier(ts(y, frequency=11.996251),K=4)<br/>f5&lt;-fourier(ts(y, frequency=28.008753),K=4)<br/>f6&lt;-fourier(ts(y, frequency=33.595801),K=2)<br/>fit0 &lt;- auto.arima(TC_ts,<br/>                   seasonal=T,<br/>                   xreg=cbind(f1,f2, f3,f4,f5,f6))<br/>Series: TC_ts <br/>Regression with ARIMA(5,0,3) errors <br/><br/>Coefficients:<br/>         ar1      ar2      ar3     ar4     ar5     ma1     ma2     ma3  intercept     S1-24    C1-24   S2-24    C2-24    S3-24    C3-24   S4-24   C4-24<br/>      0.3552  -0.4183  -0.1667  0.3341  0.1004  0.4198  0.6706  0.6855    10.9811  -14.5392  -0.6359  0.4722  -3.0621  -0.1633  -0.2072  0.4430  0.9516<br/>s.e.  0.0202   0.0225   0.0256  0.0170  0.0097  0.0186  0.0095  0.0171     0.2505    0.2804   0.2804  0.1978   0.1978   0.1543   0.1542  0.1379  0.1379<br/>       S1-24   C1-24    S2-24   C2-24   S3-24    C3-24    S4-24    C4-24   S1-168  C1-168  S2-168   C2-168   S3-168  C3-168   S4-168   C4-168    S1-12<br/>      7.3421  1.1886  -0.2872  1.6166  0.0199  -0.1927  -0.0823  -0.5817  -5.5891  4.5335  4.5734  -0.7544  -1.4123  0.0766  -0.1935  -0.8260  -1.8855<br/>s.e.  0.2802  0.2802   0.1976  0.1976  0.1541   0.1541   0.1379   0.1379   0.3522  0.3519  0.3457   0.3458   0.3361  0.3359   0.3237   0.3237   0.1977<br/>       C1-12    S2-12    C2-12   S3-12   C3-12    S4-12   C4-12    S1-28   C1-28   S2-28   C2-28   S3-28    C3-28   S4-28   C4-28   S1-34    C1-34<br/>      6.2837  -0.2458  -2.1936  0.0429  0.2067  -0.0745  0.0760  -4.1749  4.8826  2.3110  0.9198  0.1359  -0.2125  0.1023  0.2585  1.2358  -5.1028<br/>s.e.  0.1977   0.1379   0.1379  0.0642  0.0642   0.0732  0.0732   0.2951  0.2950  0.2168  0.2168  0.1691   0.1691  0.1440  0.1440  0.3097   0.3096<br/>        S2-34   C2-34<br/>      -0.4747  1.6580<br/>s.e.   0.2395  0.2395<br/><br/>sigma^2 = 65.09:  log likelihood = -44086.57<br/>AIC=88281.13   AICc=88281.61   BIC=88682.88</span></pre><p id="3108" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">上面你可以看到所有的正弦和余弦函数都包含在我组合的六个傅立叶函数中。让我们将模型输出与观察值进行比较。</p><pre class="js jt ju jv fd jw jx jy bn jz ka bi"><span id="348d" class="kb kc hh jx b be kd ke l kf kg">TC_df$fitted&lt;-fit0$fitted<br/>ggplot()+<br/>  geom_point(data=TC_df, aes(x=newdate, y=n))+<br/>  geom_line(data=TC_df, aes(x=newdate, y=fitted), col="red")+<br/>  theme_bw()<br/>fc0 &lt;- forecast(fit0, <br/>                xreg=cbind(f1,f2, f3,f4,f5,f6),<br/>                h=24*7)<br/><br/>plot(fc0)<br/>pred&lt;-fc0%&gt;%as.data.frame()<br/>pred$date&lt;-format(date_decimal(as.numeric(row.names(as.data.frame(pred)))),"%d/%m/%Y %H:%M")</span></pre><figure class="js jt ju jv fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es oi"><img src="../Images/87ace4f57d5c266d89a3e13f3a97e199.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*83mFpTZ1_cc_wPQtH772vw.png"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx">Once again not bad. Could be better, but still not bad.</figcaption></figure><p id="2575" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">那么，如果我开始预测呢？我最终会得到什么？</p><pre class="js jt ju jv fd jw jx jy bn jz ka bi"><span id="b30a" class="kb kc hh jx b be kd ke l kf kg">fc0 &lt;- forecast(fit0, <br/>                xreg=cbind(f1,f2, f3,f4,f5,f6),<br/>                h=24*7)<br/><br/>plot(fc0)<br/>pred&lt;-fc0%&gt;%as.data.frame()<br/>pred$date&lt;-format(date_decimal(as.numeric(row.names(as.data.frame(pred)))),"%d/%m/%Y %H:%M")</span></pre><figure class="js jt ju jv fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es oj"><img src="../Images/d2a5b9fa459f7c8ddff65c00efa3ed5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qE9zdEVOPFKBmeRzSlaZRw.png"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx">Ouch!! That is NOT what I had expected, and for sure not good. It also looks like I am getting six forecasts combined — one for each <strong class="bd mj">xreg </strong>function.</figcaption></figure><p id="4625" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">作为最后一部分，我想将分解傅立叶模型与其他更标准的模型进行比较，如指数平滑和季节性朴素模型。让我们看看会怎样。顺便说一下，下面的代码不仅仅是建模，它们是一个管道的开始，在这个管道中运行多个模型，进行比较，并宣布获胜者。</p><pre class="js jt ju jv fd jw jx jy bn jz ka bi"><span id="80c0" class="kb kc hh jx b be kd ke l kf kg">df_tbl&lt;-df%&gt;%<br/>  dplyr::mutate(newdate = with(., ymd(Date)))%&gt;%<br/>  #dplyr::mutate(newdate = with(., ymd(Date)))%&gt;%<br/>  group_by(RecordType, newdate)%&gt;%<br/>  filter(!RecordType %in% c("AgentState", "Callback call"))%&gt;%<br/>  filter(CallDirection=="Incoming" &amp; <br/>           DoneInIVR==0 &amp; AgentSequence==1)%&gt;%<br/>  count()%&gt;%<br/>  group_by(RecordType) %&gt;%<br/>  imputeTS::na_kalman(.) %&gt;% <br/>  select(RecordType, newdate, n)%&gt;%<br/>  as_tsibble(key = RecordType, index = newdate) %&gt;%<br/>  fill_gaps(n = 0, .full = end())<br/>train_tbl &lt;- df_tbl %&gt;%<br/>  filter_index(. ~ "2022-10-01")<br/>test_tbl &lt;- df_tbl %&gt;%<br/>  filter_index("2022-10-01" ~ .)<br/>model_table &lt;- train_tbl %&gt;%<br/>  model(<br/>    naive_mod = NAIVE(n),<br/>    snaive_mod = SNAIVE(n),<br/>    drift_mod = RW(n ~ drift()), <br/>    ses_mod = ETS(n ~ error("A") + trend("N") + season("N"), opt_crit = "mse"),<br/>    hl_mod = ETS(n ~ error("A") + trend("A") + season("N"), opt_crit = "mse"),<br/>    hldamp_mod = ETS(n ~ error("A") + trend("Ad") + season("N"), opt_crit = "mse"),<br/>    arima_mod = ARIMA(n),<br/>    dhr_mod = ARIMA(n ~ PDQ(0,0,0) + fourier(K=2) + 1),<br/>    tslm_mod = TSLM(n ~ 1))<br/>&gt; model_table<br/># A mable: 2 x 10<br/># Key:     RecordType [2]<br/>  RecordType  naive_mod snaive_mod     drift_mod      ses_mod       hl_mod    hldamp_mod                arima_mod<br/>  &lt;chr&gt;         &lt;model&gt;    &lt;model&gt;       &lt;model&gt;      &lt;model&gt;      &lt;model&gt;       &lt;model&gt;                  &lt;model&gt;<br/>1 E-mail call   &lt;NAIVE&gt;   &lt;SNAIVE&gt; &lt;RW w/ drift&gt; &lt;ETS(A,N,N)&gt; &lt;ETS(A,A,N)&gt; &lt;ETS(A,Ad,N)&gt; &lt;ARIMA(2,0,1)(1,1,1)[7]&gt;<br/>2 VOIP call     &lt;NAIVE&gt;   &lt;SNAIVE&gt; &lt;RW w/ drift&gt; &lt;ETS(A,N,N)&gt; &lt;ETS(A,A,N)&gt; &lt;ETS(A,Ad,N)&gt; &lt;ARIMA(0,0,0)(2,1,2)[7]&gt;<br/># ... with 2 more variables: dhr_mod &lt;model&gt;, tslm_mod &lt;model&gt;</span></pre><pre class="nu jw jx jy bn jz ka bi"><span id="f8ab" class="kb kc hh jx b be kd ke l kf kg">forecast_tbl &lt;- model_table %&gt;%<br/>  fabletools::forecast(test_tbl, times = 0) %&gt;%<br/>  as_tibble() %&gt;%<br/>  select(newdate, RecordType, .model, fc_qty = .mean)<br/>forecast_tbl &lt;- df_tbl %&gt;%<br/>  as_tibble() %&gt;% <br/>  select(newdate, RecordType, n) %&gt;%<br/>  right_join(forecast_tbl, by = c("newdate", "RecordType")) %&gt;% <br/>  mutate(fc_qty = ifelse(fc_qty &lt; 0, 0, fc_qty))<br/>&gt; forecast_tbl<br/># A tibble: 1,332 x 5<br/>   newdate    RecordType      n .model     fc_qty<br/>   &lt;date&gt;     &lt;chr&gt;       &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt;<br/> 1 2022-10-01 E-mail call    10 naive_mod    10  <br/> 2 2022-10-01 E-mail call    10 snaive_mod   21  <br/> 3 2022-10-01 E-mail call    10 drift_mod    10.0<br/> 4 2022-10-01 E-mail call    10 ses_mod      46.9<br/> 5 2022-10-01 E-mail call    10 hl_mod       45.3<br/> 6 2022-10-01 E-mail call    10 hldamp_mod   47.7<br/> 7 2022-10-01 E-mail call    10 arima_mod    18.2<br/> 8 2022-10-01 E-mail call    10 dhr_mod      15.9<br/> 9 2022-10-01 E-mail call    10 tslm_mod     48.1<br/>10 2022-10-02 E-mail call    15 naive_mod    10  </span></pre><pre class="nu jw jx jy bn jz ka bi"><span id="d23a" class="kb kc hh jx b be kd ke l kf kg">accuracy_tbl &lt;- forecast_tbl %&gt;%<br/>  group_by(RecordType, .model) %&gt;%<br/>  summarise(accuracy_rmsle = Metrics::rmsle(n, fc_qty))<br/>&gt; accuracy_tbl<br/># A tibble: 18 x 3<br/># Groups:   RecordType [2]<br/>   RecordType  .model     accuracy_rmsle<br/>   &lt;chr&gt;       &lt;chr&gt;               &lt;dbl&gt;<br/> 1 E-mail call arima_mod           0.629<br/> 2 E-mail call dhr_mod             0.268<br/> 3 E-mail call drift_mod           1.47 <br/> 4 E-mail call hl_mod              0.549<br/> 5 E-mail call hldamp_mod          0.551<br/> 6 E-mail call naive_mod           1.52 <br/> 7 E-mail call ses_mod             0.551<br/> 8 E-mail call snaive_mod          0.756<br/> 9 E-mail call tslm_mod            0.554<br/>10 VOIP call   arima_mod           3.16 <br/>11 VOIP call   dhr_mod             1.45 <br/>12 VOIP call   drift_mod           4.91 <br/>13 VOIP call   hl_mod              3.04 <br/>14 VOIP call   hldamp_mod          3.06 <br/>15 VOIP call   naive_mod           4.91 <br/>16 VOIP call   ses_mod             3.05 <br/>17 VOIP call   snaive_mod          3.12 <br/>18 VOIP call   tslm_mod            3.05 </span></pre><pre class="nu jw jx jy bn jz ka bi"><span id="8960" class="kb kc hh jx b be kd ke l kf kg">suitable_model_tbl &lt;- accuracy_tbl %&gt;%<br/>  ungroup() %&gt;%<br/>  group_by(RecordType) %&gt;%<br/>  filter(accuracy_rmsle == min(accuracy_rmsle)) %&gt;%<br/>  slice(n = 1)<br/>&gt; suitable_model_tbl<br/># A tibble: 2 x 3<br/># Groups:   RecordType [2]<br/>  RecordType  .model  accuracy_rmsle<br/>  &lt;chr&gt;       &lt;chr&gt;            &lt;dbl&gt;<br/>1 E-mail call dhr_mod          0.268<br/>2 VOIP call   dhr_mod          1.45 </span></pre><p id="0c02" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如您所见，包含傅立叶项的模型在电子邮件和VOIP预测中都取得了胜利。但是，出于好奇，所有模型的预测看起来如何？</p><pre class="js jt ju jv fd jw jx jy bn jz ka bi"><span id="ac3f" class="kb kc hh jx b be kd ke l kf kg">forecast_tbl%&gt;%<br/>  filter(RecordType =="VOIP call")%&gt;%<br/>  ggplot()+<br/>  geom_line(aes(x=newdate, y=fc_qty, color=.model))+<br/>  geom_line(data=df_tbl, <br/>            aes(x=newdate, y=n), alpha=0.2)+<br/>  theme_bw()</span></pre><figure class="js jt ju jv fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es ok"><img src="../Images/7fdeeb3e9696b200492ebc07eb3c775c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vhz2cdlku1fAlzo53SeSFg.png"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx">Not a very clear plot.</figcaption></figure><p id="4559" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">看起来似乎大多数模型都能够获得数据的模式，但这并不容易。这可能是因为我试图建模的原因是间歇性需求数据，这意味着你也必须预测零。而且断断续续的数据不容易建模。最后，我确实找到了解决方案，使用了我不想使用的模型。你可以在这里找到那篇博文。</p><div class="ol om ez fb on oo"><a rel="noopener follow" target="_blank" href="/mlearning-ai/mlearning-ai-submission-suggestions-b51e2b130bfb"><div class="op ab dw"><div class="oq ab or cl cj os"><h2 class="bd hi fi z dy ot ea eb ou ed ef hg bi translated">Mlearning.ai提交建议</h2><div class="ov l"><h3 class="bd b fi z dy ot ea eb ou ed ef dx translated">如何成为Mlearning.ai上的作家</h3></div><div class="ow l"><p class="bd b fp z dy ot ea eb ou ed ef dx translated">medium.com</p></div></div><div class="ox l"><div class="oy l oz pa pb ox pc kn oo"/></div></div></a></div></div></div>    
</body>
</html>