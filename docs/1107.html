<html>
<head>
<title>3 Ways to get close to Pi</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">接近圆周率的3种方法</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/3-ways-to-get-close-to-pi-a94182502b5b?source=collection_archive---------2-----------------------#2021-10-03">https://medium.com/mlearning-ai/3-ways-to-get-close-to-pi-a94182502b5b?source=collection_archive---------2-----------------------#2021-10-03</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="cc7b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我第一次接触面向对象编程。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/776b12efebc2b5f82321f04f64d153bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7T-0FZ0T0qC-aPjr5t5zvA.jpeg"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Photo by <a class="ae js" href="https://unsplash.com/@hnhmarketing" rel="noopener ugc nofollow" target="_blank">Hunter Haley</a> on <a class="ae js" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="a8f7" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">介绍</h1><p id="ef61" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">欢迎来到我的下一篇关于媒体的文章。我目前正在学习面向对象编程，并决定在一个新项目中测试我的新技能。因为我的背景，我选了一个数学方面的题目。目标是开发不同的方法来估计和近似圆周率。在每个对象类的末尾，我创建了一个方法来绘制到底发生了什么。</p><p id="a899" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">你可以在这里找到相关的仓库<a class="ae js" href="https://github.com/jonastheiler/estimate-and-approximate-pi" rel="noopener ugc nofollow" target="_blank"/>。它包含三个Python文件，每种方法一个。选择了以下方法:</p><blockquote class="kw kx ky"><p id="27a1" class="ie if kz ig b ih ii ij ik il im in io la iq ir is lb iu iv iw lc iy iz ja jb ha bi translated">1.蒙特卡罗估算器<br/> 2。Riemann_Sum_Approximation <br/> 3。莱布尼兹级数近似</p></blockquote><p id="e4d4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因为我想更深入地研究这个主题，所以这些方法包含不同的属性和方法。</p></div><div class="ab cl ld le go lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="ha hb hc hd he"><h1 id="c34a" class="jt ju hh bd jv jw lk jy jz ka ll kc kd ke lm kg kh ki ln kk kl km lo ko kp kq bi translated">蒙特卡罗估计量(自我，n=1000)</h1><p id="cb88" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">该估计器在2x2区域内生成随机点，并计算最终位于单位圆内的点的比率。既然我们知道单位圆的面积等于π，我们就可以把这个比值乘以4(总面积)。</p><p id="2edd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这个估计量的属性是模拟次数(n)。它包含两个方法，即<code class="du lp lq lr ls b">estimate_pi()</code>和<code class="du lp lq lr ls b">circle_plot()</code>。以下代码用于估算圆周率:</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="7f11" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下面的图显示了该方法:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es lv"><img src="../Images/ec013b7cb03daa46481adda993439ffb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nabs4KBuKcQJhhdTKxPJHw.png"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Monte Carlo Estimator Plot (n=1000)</figcaption></figure><p id="7938" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这个估计器工作得很好，但是它仍然是一个估计器，并且依赖于随机方法。尽管如此，我认为这是一个很好的估算方法。</p><p id="455d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="kz">备注:</em>为了得到更稳定的结果，可以重复该过程m次并取平均值。同样，我的目标是提高我的编程技能，所以我放弃了这个任务。</p></div><div class="ab cl ld le go lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="ha hb hc hd he"><h1 id="1f13" class="jt ju hh bd jv jw lk jy jz ka ll kc kd ke lm kg kh ki ln kk kl km lo ko kp kq bi translated">Riemann_Sum_Approximation(self，n=100)</h1><p id="1e6a" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">虽然这种方法不同于蒙特卡洛，但它有一个共同点:在这里，我们也试图近似单位圆的面积(众所周知，它是圆周率)。为了实现这一点，我们尝试从0到1近似函数sqrt(1-x)的积分，并乘以4。</p><p id="fe2f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这个近似值的属性是被加数的个数(n)。它提供了方法<code class="du lp lq lr ls b">approximate_pi()</code>和<code class="du lp lq lr ls b">bar_plot()</code>。以下代码用于近似圆周率:</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="1390" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下图显示了条形以及单位圆的相关部分:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es lv"><img src="../Images/8be629b77b6d6a684cf95c09cc32fbab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OI-vzx6bCykfUAYznQ3RIw.png"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Riemann Sum Approximation Plot (n=12)</figcaption></figure><p id="cd96" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这种圆周率逼近的方法工作得很好，并且用相对较少的被加数给出了好的结果。</p></div><div class="ab cl ld le go lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="ha hb hc hd he"><h1 id="205b" class="jt ju hh bd jv jw lk jy jz ka ll kc kd ke lm kg kh ki ln kk kl km lo ko kp kq bi translated">莱布尼兹级数近似值(自身，n=100)</h1><p id="6690" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">这种方法与其他方法不同。下面以戈特弗里德·莱布尼茨命名的关于圆周率的莱布尼茨公式已经提供了我们正在寻找的东西:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es lw"><img src="../Images/3b160029930081e014bcf147634ca48f.png" data-original-src="https://miro.medium.com/v2/resize:fit:464/format:webp/1*j7a5lhlwkqrlS-bvTN3HWw.png"/></div><figcaption class="jo jp et er es jq jr bd b be z dx">Liebniz Series for Pi</figcaption></figure><p id="80af" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这一点上，没有公式的证明。我想你必须相信我这个等式是真的。因此，在这种方法中，取前n个被加数，乘以4。</p><p id="a6bc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这个对象的属性是Lebniz级数的被加数(n)。它包含方法<code class="du lp lq lr ls b">approximate_pi()</code>和<code class="du lp lq lr ls b">series_plot()</code>。以下代码用于近似圆周率:</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="f16d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了直观显示这种方法，创建了以下图:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es lv"><img src="../Images/3f563e2ddcb7239b586be043bd936de1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qRuWU82ydmgX_pXhAiq7eg.png"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Leibniz Series Approximation Plot (n=31)</figcaption></figure><p id="9a06" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">像黎曼求和近似一样，这种方法也为相对少量的被加数提供了好的结果。</p></div><div class="ab cl ld le go lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="ha hb hc hd he"><h1 id="bab5" class="jt ju hh bd jv jw lk jy jz ka ll kc kd ke lm kg kh ki ln kk kl km lo ko kp kq bi translated">结论</h1><p id="73e6" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">这是一个非常好的项目，提高了我的面向对象编程技能。我知道在这一点上没有给出数学证明，但我认为可视化对理解正在发生的事情很有帮助。</p><p id="aaef" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我意识到这些主题只是被触及，并没有一定的深度。我从练习中学到了很多，可以推荐每一个数据科学初学者(像我一样)去实现自己的项目。</p><p id="8e9c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="kz">备注:</em>有了提供的Python文件，创建自己的PyPI包就很容易了。在这个阶段，我决定不发布这样的包，但是欢迎您使用代码来训练您的Python技能。</p><p id="9638" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下次见。</p></div></div>    
</body>
</html>