<html>
<head>
<title>Handwritten Character Recognition Web App with EMNIST</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用EMNIST的手写字符识别Web应用程序</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/handwritten-character-recognition-web-app-with-emnist-9af77d895a52?source=collection_archive---------1-----------------------#2022-03-18">https://medium.com/mlearning-ai/handwritten-character-recognition-web-app-with-emnist-9af77d895a52?source=collection_archive---------1-----------------------#2022-03-18</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="69b5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">早在古埃及人创造象形文字𐦚之前，人类就已经在实物上记录下他们的思想和想法。快进几千年，随着计算机和互联网的出现，几乎我们所做的一切都以某种方式利用了这台机器。然而，手写和做笔记还远未消亡，相反，它已经被<strong class="ig hi">振兴了</strong>。有一些软件，如谷歌镜头或苹果的Live Text，可以识别手写文本，并允许用户将文本复制到数字记事本上。这些软件是OCR驱动的应用程序，采用人工智能进行准确快速的识别。</p><p id="66fc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对于那些正在机器学习领域旅行的人来说，这是一个创建用于分类手写数字和字母的web应用程序的指南。幸运的是，我们已经为这个项目创建了一个标准化数据集，它被称为EMNIST数据集。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es jc"><img src="../Images/5fa409318cb6e51f9b7977aa34970ceb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tGvtca2aG3RWP4Zm"/></div><figcaption class="jk jl et er es jm jn bd b be z dx">Visualization of the EMNIST Dataset</figcaption></figure><h1 id="5f3e" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">EMNIST数据集</h1><p id="d2fc" class="pw-post-body-paragraph ie if hh ig b ih km ij ik il kn in io ip ko ir is it kp iv iw ix kq iz ja jb ha bi translated">扩展MNIST数据集或<a class="ae kr" href="https://www.nist.gov/itl/products-and-services/emnist-dataset" rel="noopener ugc nofollow" target="_blank"> EMNIST数据集</a>是一组28×28像素格式的手写字母和数字。e MNIST数据集源自MNIST数据集，该数据集被认为是机器学习基准的通用标准，它对ML模型提出了更大的挑战。该数据集中包括62个不同的类，由26 + 26个大小写字母以及10位数字组成。这个数据集易于获取和使用，允许我们创建一个体面的ML模型，同时花费最少的精力进行预处理和格式化。</p><p id="cd4b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">首先，该数据集有6种不同的拆分形式:</p><ul class=""><li id="9cb9" class="kt ku hh ig b ih ii il im ip kv it kw ix kx jb ky kz la lb bi translated"><strong class="ig hi">em NIST by class</strong>:814255个字符。62不平衡类。</li><li id="f9db" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb ky kz la lb bi translated">em NIST by merge:814255个字符。47不平衡类。</li><li id="2292" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb ky kz la lb bi translated"><strong class="ig hi"> EMNIST平衡</strong>:13.16万字符。47平衡班。</li><li id="64af" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb ky kz la lb bi translated"><strong class="ig hi"> EMNIST字母</strong>:14.56万字符。26平衡类。</li><li id="33dc" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb ky kz la lb bi translated"><strong class="ig hi"> EMNIST位数</strong> : 28万字符。10个平衡类。</li><li id="fb42" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb ky kz la lb bi translated"><strong class="ig hi"> EMNIST MNIST </strong> : 7万字。10个平衡类。</li></ul><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es lh"><img src="../Images/7a23e9d5e3e41f34b5c9e405f9730d29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v4cOrgFawIbxn6SYLybs8A.png"/></div></div></figure><p id="7d5c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">每个分割都是为不同的目的和不同的模型创建的，但是我使用的是<strong class="ig hi"> by_class分割</strong>。这包括数据集中的所有62个类-10个数字+ 26个小写字母+ 26个大写字母，以及图像和数据的全部宽度，没有任何缩减。</p></div><div class="ab cl lm ln go lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ha hb hc hd he"><h1 id="30ce" class="jo jp hh bd jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh lx kj kk kl bi translated">卷积神经网络</h1><p id="9519" class="pw-post-body-paragraph ie if hh ig b ih km ij ik il kn in io ip ko ir is it kp iv iw ix kq iz ja jb ha bi translated">对于这个项目，我使用了一个<strong class="ig hi">卷积神经网络</strong>，所以在进入代码之前，需要对CNN做一个简要的解释。</p><p id="5612" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">卷积神经网络，简称CNN，是一种对计算机视觉极其有用的深度学习算法。CNN可以比任何其他算法更好地“理解”复杂图像的复杂性。CNN算法有两个主要部分:卷积和最大池。</p><h2 id="8bbe" class="ly jp hh bd jq lz ma mb ju mc md me jy ip mf mg kc it mh mi kg ix mj mk kk ml bi translated">回旋</h2><p id="7c58" class="pw-post-body-paragraph ie if hh ig b ih km ij ik il kn in io ip ko ir is it kp iv iw ix kq iz ja jb ha bi translated">卷积本质上是CNN模型<em class="ks">通过在图像上传递许多不同类型的过滤器来检测图像中的模式</em>。<br/>这里有三个不同层次的过滤器通过图像的例子；它们变得越来越复杂，以检测图像中更复杂的图案。这些是过滤器的可视化表示，但在实际训练中，它们只是一个数字矩阵。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es mm"><img src="../Images/493ae16ee556326bff63502669752c23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1230/0*-xz9RZCTGDpuYrcr"/></div><figcaption class="jk jl et er es jm jn bd b be z dx">CNN Filters from 3 Different Layers</figcaption></figure><p id="992c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">要问的主要问题是如何使用滤波器来卷积图像？所以，让我给你一个简短的解释…</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="mn mo l"/></div></figure><p id="7550" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">假设我们有这个5x 5的图像，这里有一个3x 3的过滤器/内核矩阵:</p><pre class="jd je jf jg fd mp mq mr ms aw mt bi"><span id="093a" class="ly jp hh mq b fi mu mv l mw mx">1  0  1 <br/>0  1  0 <br/>1  0  1</span></pre><p id="d87e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后在图像上扫描这个过滤器矩阵，计算图像的<strong class="ig hi">过滤器大小的碎片</strong>和<strong class="ig hi">内核矩阵</strong>的<strong class="ig hi">点积</strong>(上面的gif直观地表示了这个过程)。点积是两个矩阵的所有对应元素相加后的乘法。这个值存储在一个新的矩阵中，该矩阵表示卷积图像。<br/>这个过程用几种不同的过滤器重复多次，以提取图像中的所有特征。</p><p id="7373" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">CNN在他们的训练中不仅仅使用一个滤镜，事实上，对于一个CNN来说，为一个图像并行学习32到512个滤镜是很常见的。所有这些不同的过滤器提取不同的特征，允许CNN学习这些特征。</p><p id="8e11" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">另一个强大的特性是能够将CNN层层叠加。这允许对图像进行更深层次的分解，并使模型能够在后续层中拾取更深和更复杂的图案。</p><h2 id="0059" class="ly jp hh bd jq lz ma mb ju mc md me jy ip mf mg kc it mh mi kg ix mj mk kk ml bi translated">最大池化</h2><p id="3e82" class="pw-post-body-paragraph ie if hh ig b ih km ij ik il kn in io ip ko ir is it kp iv iw ix kq iz ja jb ha bi translated">卷积图像或特征图是提取了特定特征的图像的表示。应用于图像的每个滤波器产生1个新的卷积图像，因此如果使用32个甚至64个滤波器，我们最终得到32倍的数据量。这是一个巨大的数量，因此为了降低计算能力和提高效率，卷积图像被汇总并减小尺寸。这个过程称为最大池化。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es my"><img src="../Images/9d4c996864d19f6d16ea6ddf3e2d152c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rG_3CUqSmXgXba5i"/></div></div><figcaption class="jk jl et er es jm jn bd b be z dx">An example of Max Pooling which utilizes a 2 by 2 grid size as well as a stride of 2.</figcaption></figure><p id="fcfa" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">此外，最大池是另一种特征提取方法。通过总结图像中的区域，我们得到了图像中最清晰或最突出的特征。最大池非常有益，因为它还在原始图像中创建了<a class="ae kr" href="https://stats.stackexchange.com/questions/208936/what-is-translation-invariance-in-computer-vision-and-convolutional-neural-netwo" rel="noopener ugc nofollow" target="_blank">平移不变性</a>。max pooling的所有好处导致了这种方法在大多数CNN模型中的突出使用。</p><p id="648e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了执行最大池化，需要指定跨距和网格。网格是池的大小，跨距是网格在图像上滑动的像素数。</p></div><div class="ab cl lm ln go lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ha hb hc hd he"><p id="679c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这是CNN建立的两个基本概念。现在，让我们转到实际的EMNIST分类器。</p><h1 id="7458" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">模型创建</h1><p id="f7ab" class="pw-post-body-paragraph ie if hh ig b ih km ij ik il kn in io ip ko ir is it kp iv iw ix kq iz ja jb ha bi translated">在开始创建人工智能模型之前，所有的代码和文件都可以在我的Github Repo中找到:https://github.com/PuravG/EMNIST-Classifier<a class="ae kr" href="https://github.com/PuravG/EMNIST-Classifier" rel="noopener ugc nofollow" target="_blank"/>！现在，继续创建模型。</p><p id="12d0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">所有人工智能模型，更确切地说是所有人工智能项目的第一步是<strong class="ig hi">导入我们的库</strong>。TensorFlow是我们将要使用的框架，这是最流行的机器学习工具。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="mz mo l"/></div></figure><h1 id="8292" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">加载数据集和图像预处理</h1><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="mz mo l"/></div></figure><p id="0b58" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">从EMNIST数据集，我加载了<strong class="ig hi"> by_class split </strong>并预处理了数据。第一步是<strong class="ig hi">归一化</strong>数据，这将改变数据的像素范围。图像的像素值通常在0到255之间，但是我们需要将这些值标准化，使它们在0到1的范围内。这是机器学习中的一个很好的实践，它有许多好处，从提高效率到更好的模型性能。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="mz mo l"/></div></figure><p id="745e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这被称为<strong class="ig hi">数据扩充</strong>，其中我正在改变或扩充数据，以便为神经网络创建更多的<em class="ks">方差</em>。这允许<em class="ks">更好地概括数据</em>和<em class="ks">提高性能</em>。在我们最终的web应用程序中，用户将使用鼠标在画布上绘制字符，因此通过执行数据增强，模型将能够识别不完全居中或直的图像，而是弯曲或旋转的图像。</p><p id="4759" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">以下代码片段是数据扩充如何改变或修改影像数据集的图示示例。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="mz mo l"/></div></figure><div class="jd je jf jg fd ab cb"><figure class="na jh nb nc nd ne nf paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><img src="../Images/8e6225de4b5a2aa5380d0a425850e59f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*WMS8zg_DY_M2x0nZ9qq9zw.png"/></div></figure><figure class="na jh nb nc nd ne nf paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><img src="../Images/c0982cc691bffb31e628565d8f5ebfa1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*JdSv4Rh0fW1rpK1M_bUbCQ.png"/></div><figcaption class="jk jl et er es jm jn bd b be z dx ng di nh ni">Before and After Data Augmentation</figcaption></figure></div><h1 id="c24b" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">模型架构和培训</h1><p id="013e" class="pw-post-body-paragraph ie if hh ig b ih km ij ik il kn in io ip ko ir is it kp iv iw ix kq iz ja jb ha bi translated">机器学习模型具有执行计算的各种互连层。这是一个<strong class="ig hi">卷积神经网络</strong>，它有<strong class="ig hi"> 2个卷积层</strong>，每个卷积层后面跟着一个<strong class="ig hi">最大池层</strong>。卷积层之后是<strong class="ig hi"> 2个完全连接的密集层</strong>，具有<strong class="ig hi"> 256个</strong>然后是<strong class="ig hi"> 128个神经元</strong>。最后，该模型有一个具有62个节点的<strong class="ig hi">输出层</strong> <strong class="ig hi">。最终层中的每个节点代表一类字符，并且模型将输出范围[0，1]中的62个不同值，代表图像属于该类的概率。</strong></p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="mz mo l"/></div></figure><p id="a9ec" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">编译模型，然后训练它20个纪元。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="mz mo l"/></div></figure><p id="9d7e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">所以我们的<strong class="ig hi">最终准确率是86.75%！</strong>对于这个数据集来说，这是一个不错的分数，显然你可能会问的问题是，其他13.25%发生了什么？好吧，继续读下去，了解这个模型的缺点和可以做出的改进。</p><h1 id="8458" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">模型历史图表</h1><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="mz mo l"/></div></figure><p id="11bf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这个图表看起来不错，随着时间的推移，稳步改善是巨大的。现在是将这些成果转化为有形产品的时候了。<br/>第一种方法，是创建一个<strong class="ig hi">本地笔记本</strong>并从你自己的系统中预测图像(已经在你前面了🙂；我的预测笔记本是<a class="ae kr" href="https://github.com/PuravG/EMNIST-Classifier/blob/main/EMNIST%20Predictions.ipynb" rel="noopener ugc nofollow" target="_blank">这里</a>。然而，想象一下，每次需要预测图像时，都必须运行整个笔记本。它既不优雅也不友好。</p></div><div class="ab cl lm ln go lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ha hb hc hd he"><p id="be5a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">介绍web应用程序…</p><h1 id="414c" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">Web App！</h1><p id="2b2f" class="pw-post-body-paragraph ie if hh ig b ih km ij ik il kn in io ip ko ir is it kp iv iw ix kq iz ja jb ha bi translated">想象一下，一个运行在你的浏览器上的应用程序可以被任何地方的任何人访问。这是一款网络应用，非常适合分享，对用户来说尤其直观。</p><p id="fb9f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">创建此应用程序的第一步是为web准备模型。</p><h2 id="bc89" class="ly jp hh bd jq lz ma mb ju mc md me jy ip mf mg kc it mh mi kg ix mj mk kk ml bi translated">将模型保存为tfjs格式</h2><p id="88a5" class="pw-post-body-paragraph ie if hh ig b ih km ij ik il kn in io ip ko ir is it kp iv iw ix kq iz ja jb ha bi translated">TensorFlow.js是一个Javascript的机器学习库，专门用于将机器学习模型集成到网站上以及创建web应用程序。使用这个库，我们将把TensorFlow Keras模型转换成TensorFlow.js格式。</p><p id="3295" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在您完成将您的模型保存为. tfjs模型的训练后，添加此代码片段。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="mz mo l"/></div></figure><p id="7c17" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们不会很快需要那个保存的文件，所以让我们把注意力转移到创建web应用程序上。</p><h1 id="4aab" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">帆布</h1><p id="e2a2" class="pw-post-body-paragraph ie if hh ig b ih km ij ik il kn in io ip ko ir is it kp iv iw ix kq iz ja jb ha bi translated">HTML是网络最基本的组成部分，因为所有的网站都是使用HTML创建的。把HTML想象成一个网站的骨架——它创造了一个结构，把所有的东西连接在一起。使用HTML，我们可以创建一个画布元素，允许用户直接在应用程序上绘制字符，这个元素将作为一个绘图空间，因此得名-画布。</p><p id="a98b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">创建这个画布非常简单，因为它只需要一行代码。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="mz mo l"/></div></figure><p id="5bc0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">所以你已经成功地创建了一个画布！很简单，对吧？嗯，事情变得有点棘手了。</p><h1 id="87ee" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">初始化画布</h1><p id="80ed" class="pw-post-body-paragraph ie if hh ig b ih km ij ik il kn in io ip ko ir is it kp iv iw ix kq iz ja jb ha bi translated">使用HTML，我们创建了一个画布的骨架。仅使用HTML脚本的结果将是一个尺寸为280×280的基本方形框。画布上的绘制不是内置的，而是一个需要使用Javascript创建的函数。</p><p id="d85d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第一步使用两个方法:getElementById和getContext。这是获取画布状态和属性的两个基本方法。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="mz mo l"/></div></figure><h1 id="267b" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">事件监听器</h1><p id="6179" class="pw-post-body-paragraph ie if hh ig b ih km ij ik il kn in io ip ko ir is it kp iv iw ix kq iz ja jb ha bi translated">所以现在你已经准备好了画布，你需要使用它。使用它和访问画布的不同状态需要一个叫做事件监听器的东西。事件侦听器静静地坐在后台，不断更新对象的状态。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="mz mo l"/></div></figure><p id="8c2e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">if(canvas)是一个检查画布何时初始化的条件。只有当画布准备好了，事件监听器才会被初始化。这些事件侦听器正在侦听用户可以执行的不同操作，一旦它们执行了这些操作，这些侦听器中的功能就会被执行。</p><h1 id="ed18" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">获取光标的位置</h1><p id="817f" class="pw-post-body-paragraph ie if hh ig b ih km ij ik il kn in io ip ko ir is it kp iv iw ix kq iz ja jb ha bi translated">要在画布上画一条线或任何形状，程序需要随时知道光标的准确位置。为此，我们可以创建一个字典来存储光标的位置，然后随着光标的移动不断更新它。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="mz mo l"/></div></figure><h1 id="321d" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">图画</h1><p id="113a" class="pw-post-body-paragraph ie if hh ig b ih km ij ik il kn in io ip ko ir is it kp iv iw ix kq iz ja jb ha bi translated">绘画是所有先前功能的顶点；它调用并使用它们，最终的结果是能够在画布上画画！</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="mz mo l"/></div></figure><p id="9049" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">开始绘画和停止绘画是在事件侦听器中调用的函数。继续讨论草图功能，<em class="ks"> if(！paint) return </em>，是一个检查，以确保paint标志为<em class="ks">真</em>，如果为<em class="ks">假</em>，该功能将停止，不返回任何内容。</p><p id="588e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这就是你所拥有的——在web应用程序中的画布上绘图的能力！现在我们可以画画了，让我们来看看这个web应用程序的主要目的，它是从用户绘制的图画中预测一个字符。</p><h1 id="656b" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">整合CNN模型</h1><p id="fa56" class="pw-post-body-paragraph ie if hh ig b ih km ij ik il kn in io ip ko ir is it kp iv iw ix kq iz ja jb ha bi translated">ML工程师80%的时间花在收集和处理数据上，而只有20%的时间花在编写AI模型和创建预测上。因此，在完成了创建网站、画布和其他所有工作之后，我们现在处于最后一步——整合CNN模型。</p><p id="af79" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">还记得你留着以后用的TensorFlow.js模型吗，现在是时候拿出来了。</p><h1 id="401b" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">加载模型</h1><p id="a80a" class="pw-post-body-paragraph ie if hh ig b ih km ij ik il kn in io ip ko ir is it kp iv iw ix kq iz ja jb ha bi translated">第一个要求是将TensorFlow.js保存的模型上传到Github等服务器上。然后程序访问Github上的文件，并使用async函数加载它。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="mz mo l"/></div></figure><h1 id="8f32" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">预处理</h1><p id="76cc" class="pw-post-body-paragraph ie if hh ig b ih km ij ik il kn in io ip ko ir is it kp iv iw ix kq iz ja jb ha bi translated">画在画布上的字符具有280乘280的尺寸。需要对该图像进行预处理，并将其转换为模型创建预测所需的格式。首先用<em class="ks"> tf.browser.fromPixels() </em>方法创建一个张量，可以流入模型的第一个输入层。<em class="ks">TF . image . resizenearestneighborhood()</em>将图像的大小调整为(28，28)的新形状，这样图像就可以匹配原始模型的数据。<em class="ks"> tf.mean() </em>将图像从具有3个颜色通道的彩色图像转换为黑白图像。<em class="ks"> tf.toFloat() </em>函数将图像数组转换为Float类型。最后，<em class="ks"> tensor.div() </em>函数将数组除以最大RGB值255，有效地将图像归一化。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="mz mo l"/></div></figure><h1 id="7793" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">预测和输出</h1><p id="c549" class="pw-post-body-paragraph ie if hh ig b ih km ij ik il kn in io ip ko ir is it kp iv iw ix kq iz ja jb ha bi translated">剩下的就是为模型创建一个函数来预测图像。只有当点击预测按钮时，模型才会首先从画布中取出图像，对其进行预处理，然后在其上创建预测。<br/>输出的是该类的字典和相应的预测。因此，要找到模型最有把握的预测，我们必须遍历字典，找到模型最有把握的类。</p><p id="0d13" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">找到该类后，web应用程序上的元素将更改为预测，并显示模型的置信度(百分比)。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="mz mo l"/></div></figure></div><div class="ab cl lm ln go lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ha hb hc hd he"><h1 id="defe" class="jo jp hh bd jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh lx kj kk kl bi translated">最终想法+改进</h1><p id="e232" class="pw-post-body-paragraph ie if hh ig b ih km ij ik il kn in io ip ko ir is it kp iv iw ix kq iz ja jb ha bi translated">因此，您最终创建了一个有效的、基本准确的手写字符分类器。在测试和使用这个web应用程序之后，应该会出现一个模式。这种型号不是最好的😅… <em class="ks">给这些角色分类不是最大的</em>。该模型的最终准确率仅为87%，尽管这对于ML模型来说是不错的，但它无法与人类或最新的OCR软件相比。所以让我们来分解一下…</p><p id="bb31" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这个问题的根源其实来自于ML模型的学习方式。ML模型通过识别数据中的模式并将这些模式与特定标签相关联来学习。在我们的例子中，CNN提取图像的特征，这些特征就是模型所学习的。</p><p id="bc8c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">例如，在字母“N”中，“N”有<strong class="ig hi">两条平行线，后跟一条对角线。</strong>这些是模型将选取的特征类型，但是字母“M”与该描述非常相似。如果你仔细想想，字母“M”只是两个“N”的融合。所以模型混淆了这两个字母，把它们混淆了。其他一些令人困惑的模式包括<em class="ks">N vs W vs M</em>；<em class="ks"> 1和我</em>；<em class="ks"> L和7</em>；还有很多其他的。因为所有这些字母都非常相似，所以模型通常会弄错这些图像。然而，像“B”或“X”这样的字母有着非常独特的模式，从而导致准确的预测。</p><p id="68bf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">那么笔迹检测软件是如何工作的呢？首先，他们在巨大的计算机上接受训练，因此他们可以有多达15层或更多的CNN层，以及数百个时期进行训练。其次，输入完整的句子或单词；单词在句子中的上下文对预测有很大帮助。</p><p id="eb91" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在还不要感到沮丧，因为有一种方法可以解决这个问题。解决方法是<strong class="ig hi">转移学习</strong>！你可以利用和使用大公司或大学已经创建的训练有素的模型，并根据自己的情况进行调整。有一些模型是由各个大学的研究人员创建的，它们是开源的，供你免费使用！</p></div><div class="ab cl lm ln go lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ha hb hc hd he"><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es nj"><img src="../Images/dc5986f340b78c397aba3d9c47bc5c6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vkN6IGQwJD5DfCFZ_Vdzrg.png"/></div></div><figcaption class="jk jl et er es jm jn bd b be z dx">A Snapshot of the Web App that I Made for this Classifier. <a class="ae kr" href="https://puravg.github.io/EMNIST-Classifier/" rel="noopener ugc nofollow" target="_blank">Link</a> to the Web App</figcaption></figure><p id="b0b5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">唷！太多了，但最重要的是你终于坚持到了最后！这是一个漫长的，但非常富有成效的🍎一段充满挑战的旅程。我希望这篇指南能帮助你踏上机器学习的旅程。</p><p id="d27a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这里是<a class="ae kr" href="https://github.com/PuravG/EMNIST-Classifier" rel="noopener ugc nofollow" target="_blank"> Github Repo </a>的链接，你可以在这里找到这个项目的所有文件和代码。感谢您的阅读，祝您愉快！👋</p><h1 id="ad08" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">让我们连接</h1><p id="6857" class="pw-post-body-paragraph ie if hh ig b ih km ij ik il kn in io ip ko ir is it kp iv iw ix kq iz ja jb ha bi translated">我很乐意连接和谈论这个项目更多！在<a class="ae kr" href="https://www.linkedin.com/in/puravgupta?lipi=urn%3Ali%3Apage%3Ad_flagship3_profile_view_base_contact_details%3BDku9koYQQbmKNjq6%2BGtTGw%3D%3D" rel="noopener ugc nofollow" target="_blank"> Linkedin </a>上给我发消息，或者在<a class="ae kr" href="mailto:guptapurav@gmail.com" rel="noopener ugc nofollow" target="_blank">guptapurav@gmail.com</a>给我发邮件！</p><div class="nk nl ez fb nm nn"><a rel="noopener follow" target="_blank" href="/mlearning-ai/mlearning-ai-submission-suggestions-b51e2b130bfb"><div class="no ab dw"><div class="np ab nq cl cj nr"><h2 class="bd hi fi z dy ns ea eb nt ed ef hg bi translated">Mlearning.ai提交建议</h2><div class="nu l"><h3 class="bd b fi z dy ns ea eb nt ed ef dx translated">如何成为Mlearning.ai上的作家</h3></div><div class="nv l"><p class="bd b fp z dy ns ea eb nt ed ef dx translated">medium.com</p></div></div><div class="nw l"><div class="nx l ny nz oa nw ob ji nn"/></div></div></a></div></div></div>    
</body>
</html>