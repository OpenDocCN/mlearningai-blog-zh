<html>
<head>
<title>Hugging Face Transformer pipeline running batch of input sentence with different sentence length</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">拥抱面转换器流水线运行不同语句长度的输入语句批</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/hugging-face-transformer-pipeline-running-batch-of-input-sentence-with-different-sentence-length-197a4aff17cf?source=collection_archive---------1-----------------------#2021-03-26">https://medium.com/mlearning-ai/hugging-face-transformer-pipeline-running-batch-of-input-sentence-with-different-sentence-length-197a4aff17cf?source=collection_archive---------1-----------------------#2021-03-26</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="c2fa" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这是一个关于使用拥抱面对变压器管道和我所面临的问题的快速总结。</p><p id="58d9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">流水线是一个非常好想法，可以简化NLP过程中需要使用transformer库处理的一些操作，至少包括但不限于:</p><ol class=""><li id="bbbe" class="jc jd hh ig b ih ii il im ip je it jf ix jg jb jh ji jj jk bi translated">将输入字符串标记化</li><li id="ce52" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb jh ji jj jk bi translated">将令牌映射到id(整数)</li><li id="3969" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb jh ji jj jk bi translated">将映射的id作为张量传递给模型</li></ol><p id="b2ff" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">管道之前的老办法:</p><pre class="jq jr js jt fd ju jv jw jx aw jy bi"><span id="d9c7" class="jz ka hh jv b fi kb kc l kd ke"># Load pretrained model/tokenizer<br/>from transformers import DistilBertModel, DistilBertTokenizer<br/>model_class, tokenizer_class, pretrained_weights = (DistilBertModel, DistilBertTokenizer, 'distilbert-base-uncased')<br/>tokenizer = tokenizer_class.from_pretrained(pretrained_weights)<br/>model = model_class.from_pretrained(pretrained_weights)</span><span id="856f" class="jz ka hh jv b fi kf kc l kd ke">input_ids = torch.tensor([tokenizer.encode("this is a test")])<br/>with torch.no_grad():<br/>  last_hidden_states = model(input_ids)[0]  # Models outputs can include multiple outputs like attention mask</span></pre><p id="4063" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">管道道:</p><pre class="jq jr js jt fd ju jv jw jx aw jy bi"><span id="cf87" class="jz ka hh jv b fi kb kc l kd ke">feature_extractor = pipeline("feature-extraction", model="distilbert-base-uncased", tokenizer="bert-base-uncased")<br/>feature_extractor("this is a test")</span></pre><p id="584a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">所以当我们使用管道时，看起来简单多了</p><h1 id="c525" class="kg ka hh bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">第一个问题—错误的标记器</h1><figure class="jq jr js jt fd le er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es ld"><img src="../Images/511353fbfd26f82d7b2d1e26209fe6ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mWJ1M1HwjAuaUqCmQ296-Q.png"/></div></div></figure><p id="c036" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在线快速搜索，这个huggingface github <a class="ae ll" href="https://github.com/huggingface/transformers/issues/2702" rel="noopener ugc nofollow" target="_blank"> issue </a>指出，bert基础令牌化器给出token_type_ids作为输出，但是DistilBertModel并不期望它，因此建议在传递给Model之前删除它。</p><p id="93b6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我丑陋的实现:</p><figure class="jq jr js jt fd le er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es lm"><img src="../Images/a0e7fc10174075688cbdf22f8c1292c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RMVKG9LO_qpS9pzPK3w6Iw.png"/></div></div></figure><p id="b9a0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这是为了在传递给实际模型之前创建一个包装器来丢弃token_type_ids。</p><p id="b7f6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">正确的方法是使用正确的记号赋予器(“distilbert-base-uncased”，而不是“bert-base-uncased”):</p><pre class="jq jr js jt fd ju jv jw jx aw jy bi"><span id="a41c" class="jz ka hh jv b fi kb kc l kd ke">feature_extractor = pipeline("feature-extraction", model="distilbert-base-uncased", tokenizer="distilbert-base-uncased")</span><span id="086c" class="jz ka hh jv b fi kf kc l kd ke">feature_extractor("this is a test")</span></pre><h1 id="b1f3" class="kg ka hh bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">第二项—控制我是否需要特殊令牌</h1><p id="8aaf" class="pw-post-body-paragraph ie if hh ig b ih ln ij ik il lo in io ip lp ir is it lq iv iw ix lr iz ja jb ha bi translated">人们会发现输出的长度是6，而不是4(字)，这是因为对于Transformer模型，它将在前面包括[CLS]标记，在结尾包括[SEP]标记。</p><p id="cfbb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们如何提供这个参数来告诉标记器添加或不添加这些特殊的标记呢？令牌化器允许使用“添加特殊令牌”开关:</p><pre class="jq jr js jt fd ju jv jw jx aw jy bi"><span id="da8f" class="jz ka hh jv b fi kb kc l kd ke">tokenizer.encode("this is a test", add_special_tokens=False)</span></pre><p id="e552" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">管道怎么样？看完源代码，方式很相似:</p><pre class="jq jr js jt fd ju jv jw jx aw jy bi"><span id="a714" class="jz ka hh jv b fi kb kc l kd ke">feature_extractor("this is a test",add_special_tokens=False)</span></pre><figure class="jq jr js jt fd le er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es ls"><img src="../Images/abc307efc876fc0c592c7ad421262de0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5UWJuzNvystgiUH4gyeYwA.png"/></div></div><figcaption class="lt lu et er es lv lw bd b be z dx"><a class="ae ll" href="https://huggingface.co/transformers/_modules/transformers/pipelines/base.html#Pipeline" rel="noopener ugc nofollow" target="_blank">https://huggingface.co/transformers/_modules/transformers/pipelines/base.html#Pipeline</a> =&gt; the __call__ function take in kwargs and pass to _parse_and_tokenize function</figcaption></figure><h1 id="a374" class="kg ka hh bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">第三项—批量输入</h1><p id="faf9" class="pw-post-body-paragraph ie if hh ig b ih ln ij ik il lo in io ip lp ir is it lq iv iw ix lr iz ja jb ha bi translated">对于这一点，我只关注管道(管道前的旧代码有点长)</p><p id="d91a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">管道API支持将字符串列表作为输入，并将它们作为批处理，但是请记住，张量大小是固定的，因此对于可变长度的输入字符串，应该对它们进行填充:</p><figure class="jq jr js jt fd le er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es lx"><img src="../Images/925deda0c8db9189be083ebe7fc53dfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*COm3rrszycbsSL7ybcdttA.png"/></div></div></figure><p id="2b8f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我想要做的是得到一个“有意义的”记号的平均值(这对于解释为句子的嵌入来说不是100%正确，但是我只是想要一个方便的嵌入)</p><p id="1b03" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">所以，我做的是:</p><pre class="jq jr js jt fd ju jv jw jx aw jy bi"><span id="5bb9" class="jz ka hh jv b fi kb kc l kd ke">result_tensor = torch.tensor(feature_extractor(["this is a test", "I like hugging face pipeline"],add_special_tokens=False))</span><span id="53e4" class="jz ka hh jv b fi kf kc l kd ke">result_avg = torch.mean(result_tensor[0,:4,:],dim=0)</span></pre><p id="1514" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">result_tensor[0，:4，:= &gt;第一个索引是关于引用第一个输入“这是一个测试”的#item，第二个:4“是我只想要第二维中的前4个令牌</p><p id="4351" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这个解决方案肯定非常难看，因为它使用了一个硬编码数(4)，人们可能希望通过计算令牌来动态地计算它。但是这并不是100%无关紧要的，因为记号赋予器使用了Wordpiece，并且它不仅仅是按空格分解:</p><figure class="jq jr js jt fd le er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es ly"><img src="../Images/1692d840a53218224c1aa9750b94e0b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EHfBYmG6jMIdiay7aicHRg.png"/></div></div></figure><p id="76f2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">记号赋予器像这样拆分它(像这样拆分“’”和“t”)</p><figure class="jq jr js jt fd le er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es lz"><img src="../Images/db723b1058ea12fea408d0651217cec4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dS_yaaewf2Fy3FaaxJKX2A.png"/></div></div></figure><p id="4689" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">########[开始]跟进2021年8月9日# # # # # # # #</p><p id="6682" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了迎合“有意义的”(非pad令牌)的平均问题，我在实现中得到了更新，这是使用注意掩码。</p><figure class="jq jr js jt fd le er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es ma"><img src="../Images/611ef7cc5e6dda6afb46a1aa336c8416.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Skl7d_iPTh1oS704PFnaAw.png"/></div></div></figure><p id="177a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">用最简单的形式来解释，huggingface pipline __call__函数进行标记化，将标记转换为id，并传递给模型进行处理，标记化器将输出ID和注意掩码。</p><figure class="jq jr js jt fd le er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es mb"><img src="../Images/a27cfcc5be8f17e5dbf8e47c40f0afd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KaRh7c8MhY9BbUtk6NEEbA.png"/></div></div><figcaption class="lt lu et er es lv lw bd b be z dx">Huggingface transformer library documentation on Pipeline class: <a class="ae ll" href="https://huggingface.co/transformers/_modules/transformers/pipelines/base.html#Pipeline" rel="noopener ugc nofollow" target="_blank">https://huggingface.co/transformers/_modules/transformers/pipelines/base.html#Pipeline</a></figcaption></figure><p id="78d3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下面的代码将更加动态地管理pad(每批都不同)，而不是在固定的令牌范围内执行简单的torch.mean(…)</p><p id="46da" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">代码示例:</p><figure class="jq jr js jt fd le er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es mc"><img src="../Images/d91be1f67a4d300d689f9008c269566c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NTfmDt_NUpVlfMSidWoikw.png"/></div></div></figure><p id="246c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">######## [End]跟进2021年8月9日########</p><h1 id="0230" class="kg ka hh bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">结论/临时结果</h1><p id="697b" class="pw-post-body-paragraph ie if hh ig b ih ln ij ik il lo in io ip lp ir is it lq iv iw ix lr iz ja jb ha bi translated">最后，我尝试了4种不同的变化，结果如下，我会说…没有裁决。</p><p id="c216" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这4种变化是:</p><ol class=""><li id="b3a6" class="jc jd hh ig b ih ii il im ip je it jf ix jg jb jh ji jj jk bi translated">(左上)<strong class="ig hi">拥有</strong>特殊代币，拥有超过<strong class="ig hi">所有</strong>代币的平均值(包括填充)</li><li id="1474" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb jh ji jj jk bi translated">(右上)<strong class="ig hi">没有</strong>特殊令牌，并且有一个平均值超过<strong class="ig hi">所有</strong>令牌(包括填充符)</li><li id="9f5d" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb jh ji jj jk bi translated">(左下角)<strong class="ig hi">具有</strong>特殊令牌，具有超过<strong class="ig hi">非填充</strong>令牌(无填充)的平均值</li><li id="e5d2" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb jh ji jj jk bi translated">(右下)<strong class="ig hi">无</strong>特殊令牌，且平均超过<strong class="ig hi">无填充</strong>令牌(无填充)</li></ol><p id="94be" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下面是UMAP的一些结果。请注意，这是一个降维，根据经验，有时这是非常混乱的降维应用，所以最好做最近邻分析(我通常通过faiss)</p><p id="70bd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">另外，另一个想法是变压器[CLS]令牌通常被训练来表示一个句子级嵌入，这篇文章将被更新，一旦分析正在运行。</p><figure class="jq jr js jt fd le er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es md"><img src="../Images/a4b27b9c721e3bd03e755de426f175f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PzJ3xRvYGaeUhtBLI06MiQ.jpeg"/></div></div></figure><figure class="jq jr js jt fd le er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es md"><img src="../Images/d4d18efdec530aa6ee2dc73a2e9db0de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Oz8VEVv8TZj7mE9n_sudBg.jpeg"/></div></div></figure><h1 id="67f2" class="kg ka hh bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">跟进(2021年3月29日)</h1><p id="219c" class="pw-post-body-paragraph ie if hh ig b ih ln ij ik il lo in io ip lp ir is it lq iv iw ix lr iz ja jb ha bi translated">在接下来的文章中，我添加了CLS向量，并使用Faiss在原始维度空间中寻找最近邻(余弦相似度)。</p><p id="8d2b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">请注意，生成的UMAP结果(降维)与上面预期的不同。</p><p id="e66d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">还通过Faiss索引收录了768个原始维度top 5近邻(使用余弦相似度作为度量)。结果是…巨大的，我只是把它们倒在底部。</p><p id="ccdc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">有一些观察(基于我的人类判断):</p><ol class=""><li id="4cb8" class="jc jd hh ig b ih ii il im ip je it jf ix jg jb jh ji jj jk bi translated">[CLS]的方法并不像我预期的那样能抓住一般的序列(句子)思想(事实上很多时候人们会把它用于像QA这样的下游任务)，而且总的来说，我更喜欢无特殊标记对。</li><li id="2b91" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb jh ji jj jk bi translated">(显然)归一化是高度优选的，因为我们试图使用余弦相似性，Faiss只做内点积，而不为我们归一化(他们的文档指示用户在传递到索引之前进行归一化)，并且该值更容易在不同方法之间进行比较</li><li id="4722" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb jh ji jj jk bi translated">仍有一些“语义意义”被CLS捕捉得更好，像失踪的人和自杀更接近(比其他人)，正如我能想象的那样它与“失去人”有关</li><li id="48f7" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb jh ji jj jk bi translated">奇怪的是，对于具有特殊标记和平均值(包括填充)的方法，最接近的有时并不相同(即，在索引中的搜索查询=“XYZ”并不作为顶部结果返回，得分也不是1.0)</li></ol><p id="def7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下面是结果，有兴趣的考察一下。</p><figure class="jq jr js jt fd le er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es md"><img src="../Images/40bed26d83c6a19b829e2346fb44043f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uVZIePgkMOLcIjjnfIZLoQ.jpeg"/></div></div></figure><figure class="jq jr js jt fd le er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es md"><img src="../Images/8082951a9f4b2661d0500b82dcd79e7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N_lu72Fx9IfS-jLMMVuShw.jpeg"/></div></div></figure><div class="jq jr js jt fd ab cb"><figure class="me le mf mg mh mi mj paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><img src="../Images/bdfff2b040d5fe1a1fcb80573cf9854c.png" data-original-src="https://miro.medium.com/v2/resize:fit:732/format:webp/1*_KFJRCJnLj3imMv0msH8KA.png"/></div></figure><figure class="me le mk mg mh mi mj paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><img src="../Images/b1c088d3febde961386c8dab7bb2d182.png" data-original-src="https://miro.medium.com/v2/resize:fit:1270/format:webp/1*EIE2hpTYtFVebajak3UwpQ.png"/></div></figure></div></div></div>    
</body>
</html>