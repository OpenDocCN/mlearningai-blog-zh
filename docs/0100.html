<html>
<head>
<title>Apply Machine Learning Algorithms for Genomics Data Classification</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将机器学习算法应用于基因组数据分类</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/apply-machine-learning-algorithms-for-genomics-data-classification-132972933723?source=collection_archive---------0-----------------------#2021-02-03">https://medium.com/mlearning-ai/apply-machine-learning-algorithms-for-genomics-data-classification-132972933723?source=collection_archive---------0-----------------------#2021-02-03</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/6fa6d6ea0a663bb920fd6bfda65deed4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kso0ldKEXQ2Sk-546PcyQg.jpeg"/></div></div></figure><div class=""/><p id="c351" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Ernest Bonat博士，Bishes Rayamajhi硕士</p><p id="4f54" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">(更新日期:2021年9月11日)</p><p id="6104" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">1.<a class="ae jn" href="#c401" rel="noopener ugc nofollow">概述</a> <br/> 2。<a class="ae jn" href="#9a28" rel="noopener ugc nofollow"> DNA序列</a> <br/> 3。<a class="ae jn" href="#7c00" rel="noopener ugc nofollow">验证DNA序列字符串</a> <br/> 4。<a class="ae jn" href="#9431" rel="noopener ugc nofollow">计数DNA序列串中的碱基核苷酸</a> <br/> 5。<a class="ae jn" href="#d2e8" rel="noopener ugc nofollow">反转一个DNA序列串</a> <br/> 6。<a class="ae jn" href="#4536" rel="noopener ugc nofollow">互补DNA序列串</a> <br/> 7。<a class="ae jn" href="#7cc6" rel="noopener ugc nofollow">反向互补一个DNA序列串</a> <br/> 8。<a class="ae jn" href="#c97e" rel="noopener ugc nofollow">计算DNA序列串中CG含量</a> <br/> 9。<a class="ae jn" href="#9f89" rel="noopener ugc nofollow">将DNA序列串转换成NumPy数组</a> <br/> 10。<a class="ae jn" href="#f04f" rel="noopener ugc nofollow">搜索DNA序列模式</a> <br/> 11。<a class="ae jn" href="#0127" rel="noopener ugc nofollow"> DNA序列串翻译成蛋白质</a> <br/> 12。<a class="ae jn" href="#7e3e" rel="noopener ugc nofollow"> DNA序列串转录成RNA序列串</a> <br/> 13。<a class="ae jn" href="#3330" rel="noopener ugc nofollow">编码DNA序列的第14串</a> <br/>。<a class="ae jn" href="#caba" rel="noopener ugc nofollow">包字为一个DNA序列串</a> <br/> 15。<a class="ae jn" href="#7c74" rel="noopener ugc nofollow"> RNA序列</a> <br/> 16。<a class="ae jn" href="#563b" rel="noopener ugc nofollow">验证RNA序列字符串</a> <br/> 17。<a class="ae jn" href="#96cd" rel="noopener ugc nofollow">对RNA序列串中的碱基核苷酸进行计数</a> <br/> 18。<a class="ae jn" href="#df0a" rel="noopener ugc nofollow"> RNA序列串翻译成蛋白质</a> <br/> 19。<a class="ae jn" href="#3b3c" rel="noopener ugc nofollow"> DNA、RNA和蛋白质序列比对</a> <br/> 20。<a class="ae jn" href="#7f51" rel="noopener ugc nofollow"> Biopython库概述</a> <br/> 21。<a class="ae jn" href="#197c" rel="noopener ugc nofollow">自定义PyDNA库</a> <br/> 22。<a class="ae jn" href="#0f4e" rel="noopener ugc nofollow">利用机器学习算法进行DNA序列分类</a> <br/> 23。<a class="ae jn" href="#b8c2" rel="noopener ugc nofollow">应用卷积神经网络(CNN)进行DNA序列分类</a> <br/> 24。<a class="ae jn" href="#7c36" rel="noopener ugc nofollow">应用长短期记忆网络(LSTM)进行DNA序列分类</a> <br/> 25。<a class="ae jn" href="#56e1" rel="noopener ugc nofollow">结论</a></p><h2 id="c401" class="jo jp hs bd jq jr js jt ju jv jw jx jy ja jz ka kb je kc kd ke ji kf kg kh ki bi translated">1.概观</h2><p id="8e01" class="pw-post-body-paragraph ip iq hs ir b is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji kn jk jl jm ha bi translated">在分子生物学和遗传学领域，基因组是生物体的所有遗传物质。它由DNA(或RNA病毒中的RNA)组成。基因组包括基因(编码区)和非编码DNA，以及线粒体DNA和叶绿体DNA。对基因组的研究被称为基因组学。它包括基因之间的相互作用以及与人的环境的相互作用。基因组数据用于生物信息学领域，用于收集、存储和处理生物基因组。基因组数据处理需要大量的数据存储和用于统计分析的高性能硬件和软件。</p><p id="4409" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">机器学习(ML)是人工智能(AI)的一种应用，它能够根据经验进行自动学习和改进，而无需显式编程和学习环境的知识。最重要的目标是开发和部署一个可以在没有任何人为干预的情况下自动学习的计算机系统。根据定义，它必须能够根据先前的结果调整自己的行动。</p><p id="8f5b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">机器学习已经成为当今许多基因组学研究任务的主要方法之一，包括:</p><p id="5a24" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">1.大规模基因组数据集的描述和解释。<br/> 2。各种基因组序列元素的注释。<br/> 3。预测遗传变异对DNA/RNA序列的影响。<br/> 4。确定患某种疾病的可能性，并确定遗传性。<br/> 5。识别模式，进行预测，并对特定疾病的进展或治疗进行建模。</p><p id="d63a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">ML在基因组学中的未来应用可能是:药物基因组学、新生儿基因筛选工具、农业等。基于ML项目类型，我们可以定义特定的应用。对于分类(监督学习):将较短的序列分类成类(门、属、种等)。);序列的系统发育推断；质粒和染色体的检测；寻找编码区；人类基因组学中的染色体预测；等等。对于聚类(无监督学习):宏基因组重叠群的宁滨；质粒和染色体的鉴定；聚类读入染色体，以便更好的组装；作为读取集合的预处理器的读取聚类，<a class="ae jn" href="https://towardsdatascience.com/machine-learning-for-genomics-c02270a51795" rel="noopener" target="_blank">等</a>。</p><p id="668c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这篇博客文章中，我们将理解DNA/RNA/蛋白质序列的结构，以及它们使用Python数据生态系统库的操作。它将展示ML算法如何用于DNA/RNA/蛋白质序列的分类和预测。将提供基因组数据集的传统和现代ML分类算法的比较表。将介绍一个简单的Python库PyDNA，用于DNA/RNA/蛋白质序列字符串处理和ML分类算法。</p><h2 id="9a28" class="jo jp hs bd jq jr js jt ju jv jw jx jy ja jz ka kb je kc kd ke ji kf kg kh ki bi translated">2.DNA序列</h2><p id="9fed" class="pw-post-body-paragraph ip iq hs ir b is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji kn jk jl jm ha bi translated">根据国家人类基因组研究所的研究，<a class="ae jn" href="https://www.genome.gov/genetics-glossary/Deoxyribonucleic-Acid" rel="noopener ugc nofollow" target="_blank">脱氧核糖核酸</a> (DNA)是一种化合物，它由开发和指导几乎所有生命体的活动所需的指令组成。DNA分子是一种双螺旋结构，由两条扭绞成对的链组成。DNA由四种碱基组成，分别是腺嘌呤[A]、胞嘧啶[C]、鸟嘌呤[G]或胸腺嘧啶[T]。DNA测序是确定DNA分子中这四种碱基序列的实验室过程。关于DNA测序的更多信息可以在“<a class="ae jn" href="https://www.illumina.com/techniques/sequencing/dna-sequencing.html" rel="noopener ugc nofollow" target="_blank">DNA测序简介</a>中找到。</p><p id="9536" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们看看使用Python数据生态系统库的DNA序列字符串操作。所有提供的函数调用都在名为PyDNA的Python定制DNA库中实现。关于这个库的进一步解释可以在这篇博客文章的后面找到。</p><h2 id="7c00" class="jo jp hs bd jq jr js jt ju jv jw jx jy ja jz ka kb je kc kd ke ji kf kg kh ki bi translated">3.验证DNA序列字符串</h2><p id="ca35" class="pw-post-body-paragraph ip iq hs ir b is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji kn jk jl jm ha bi translated">DNA序列字符串必须包含四个碱基核苷酸[“A”、“C”、“G”、“T”]。该功能允许使用任何已定义的自定义核苷酸碱基来验证DNA序列。</p><p id="a24a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">示例:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="e010" class="jo jp hs kt b fi kx ky l kz la">dna_sequence_string = “ATATATCCCGGGAATTTTCGTAGTTAGGCTGATTTTATTGGCGCGAAAATTT”<br/>is_dna_result = PyDNA.is_dna(dna_sequence_string)<br/>print(“DNA sequence string:\n{}”.format(dna_sequence_string))<br/>print(“Is DNA:\n{}”.format(is_dna_result))</span></pre><p id="cf52" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">结果:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="0541" class="jo jp hs kt b fi kx ky l kz la">DNA sequence string:<br/>ATATATCCCGGGAATTTTCGTAGTTAGGCTGATTTTATTGGCGCGAAAATTT<br/>Is DNA:<br/>True</span></pre><p id="18ce" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">示例:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="3800" class="jo jp hs kt b fi kx ky l kz la">dna_sequence_string = “ATATATCCCGGGAATTTTCGTAGTTAGGCTGATTTTATTGGCGCGAAAATTF”<br/>is_dna_result = PyDNA.is_dna(dna_sequence_string)<br/>print(“DNA sequence string:\n{}”.format(dna_sequence_string))<br/>print(“Is DNA:\n{}”.format(is_dna_result))</span></pre><p id="36d1" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">结果:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="5a1b" class="jo jp hs kt b fi kx ky l kz la">DNA sequence string:<br/>ATATATCCCGGGAATTTTCGTAGTTAGGCTGATTTTATTGGCGCGAAAATTF<br/>Is DNA:<br/>False</span></pre><h2 id="9431" class="jo jp hs bd jq jr js jt ju jv jw jx jy ja jz ka kb je kc kd ke ji kf kg kh ki bi translated">4.计数DNA序列串中的碱基核苷酸</h2><p id="7cf6" class="pw-post-body-paragraph ip iq hs ir b is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji kn jk jl jm ha bi translated">下面的函数允许用任何定义的自定义碱基计数DNA序列核苷酸。DNA序列的长度也将被返回。</p><p id="36d2" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">示例:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="ffee" class="jo jp hs kt b fi kx ky l kz la">dna_sequence_string = “ATATATCCCGGGAATTTTCGTAGTTAGGCTGATTTTATTGGCGCGAAAATTTTTT”<br/>base_sequence_count, dna_sequence_length = PyDNA.dna_count_nucleotide(dna_sequence_string, base_sequence=[“A”,”C”,”G”,”T”], is_length=True)<br/>print(“DNA sequence string:\n{}”.format(dna_sequence_string))<br/>print(“DNA nucleotides count:\n{}”.format(base_sequence_count))<br/>print(“DNA length:\n{}”.format(dna_sequence_length))</span></pre><p id="9cc7" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">结果:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="483e" class="jo jp hs kt b fi kx ky l kz la">DNA sequence string:<br/>ATATATCCCGGGAATTTTCGTAGTTAGGCTGATTTTATTGGCGCGAAAATTTTTT<br/>DNA nucleotides count:<br/>{‘A’: 13, ‘C’: 7, ‘G’: 12, ‘T’: 23}<br/>DNA length:<br/>55</span></pre><p id="eb3d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">示例:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="d158" class="jo jp hs kt b fi kx ky l kz la">dna_sequence_string = “ATYTRTCCYGGYAATRYTCGTAGTTAGRCTGATYTTATTGGYGCGAARATTYYTR”base_sequence_count, dna_sequence_length = PyDNA.dna_count_nucleotide(dna_sequence_string, base_sequence=[“A”,”C”,”G”,”T”,”R”,”Y”], is_length=True)print(“DNA Nucleotide Count:\n{}”.format(base_sequence_count))print(“DNA length:\n{}”.format(dna_sequence_length))</span></pre><p id="e026" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">结果:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="fe88" class="jo jp hs kt b fi kx ky l kz la">DNA Nucleotide Count:<br/>{‘A’: 10, ‘C’: 5, ‘G’: 10, ‘T’: 17, ‘R’: 5, ‘Y’: 8}<br/>DNA length:<br/>55</span></pre><h2 id="d2e8" class="jo jp hs bd jq jr js jt ju jv jw jx jy ja jz ka kb je kc kd ke ji kf kg kh ki bi translated">5.逆转DNA序列串</h2><p id="afcb" class="pw-post-body-paragraph ip iq hs ir b is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji kn jk jl jm ha bi translated">下面的函数反转一个DNA序列字符串。</p><p id="7239" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">示例:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="35ca" class="jo jp hs kt b fi kx ky l kz la">dna_sequence_string = “ATATATCCCGGGAATTTTCGTAGTTAGGCTGATTTTATTGGCGCGAAAATTTTTT”<br/>dna_reverse_sequence = PyDNA.dna_sequence_reverse(dna_sequence_string)<br/>print(“DNA Sequence String:\n{}”.format(dna_sequence_string))<br/>print(“Reverse DNA sequence:\n{}”.format(dna_reverse_sequence))</span></pre><p id="e763" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">结果:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="061a" class="jo jp hs kt b fi kx ky l kz la">DNA Sequence String:<br/>ATATATCCCGGGAATTTTCGTAGTTAGGCTGATTTTATTGGCGCGAAAATTTTTT<br/>Reverse DNA sequence:<br/>TTTTTTAAAAGCGCGGTTATTTTAGTCGGATTGATGCTTTTAAGGGCCCTATATA</span></pre><h2 id="4536" class="jo jp hs bd jq jr js jt ju jv jw jx jy ja jz ka kb je kc kd ke ji kf kg kh ki bi translated">6.互补DNA序列串</h2><p id="b1be" class="pw-post-body-paragraph ip iq hs ir b is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji kn jk jl jm ha bi translated">DNS序列的互补基于IUPAC简并转换(【https://www.bioinformatics.org/sms/iupac.html】T4)。</p><p id="8225" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">示例:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="380e" class="jo jp hs kt b fi kx ky l kz la">dna_sequence_test = “ATATATCCCGGGAATTTTCGTAGTTAGGCTGATTTTATTGGCGCGAAAATTTTTT”<br/>dna_complement_sequence = PyDNA.dna_sequence_complement(dna_sequence_test)<br/>print(“DNA sequence string:\n{}”.format(dna_sequence_test))<br/>print(“Complement DNA sequence:\n{}”.format(dna_complement_sequence))</span></pre><p id="8b14" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">结果:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="378c" class="jo jp hs kt b fi kx ky l kz la">DNA sequence string:<br/>ATATATCCCGGGAATTTTCGTAGTTAGGCTGATTTTATTGGCGCGAAAATTTTTT<br/>Complement DNA sequence:<br/>TATATAGGGCCCTTAAAAGCATCAATCCGACTAAAATAACCGCGCTTTTAAAAAA</span></pre><h2 id="7cc6" class="jo jp hs bd jq jr js jt ju jv jw jx jy ja jz ka kb je kc kd ke ji kf kg kh ki bi translated">7.反向-互补DNA序列串</h2><p id="4fdc" class="pw-post-body-paragraph ip iq hs ir b is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji kn jk jl jm ha bi translated">DNS序列字符串的反向补码是通过使用dna_sequence_reverse()和dna_sequence_complement()函数实现的。</p><p id="b859" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">示例:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="041c" class="jo jp hs kt b fi kx ky l kz la">dna_sequence_string = “ATATATCCCGGGAATTTTCGTAGTTAGGCTGATTTTATTGGCGCGAAAATTT”<br/>dna_reverse_complement_sequence = PyDNA.dna_sequence_reverse_complement(dna_sequence_string)<br/>print(“DNA sequence string:\n{}”.format(dna_sequence_string))<br/>print(“Reverse-Complement DNA sequence:\n{}”.format(dna_reverse_complement_sequence))</span></pre><p id="1221" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">结果:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="e1b5" class="jo jp hs kt b fi kx ky l kz la">ATATATCCCGGGAATTTTCGTAGTTAGGCTGATTTTATTGGCGCGAAAATTT<br/>AAATTTTCGCGCCAATAAAATCAGCCTAACTACGAAAATTCCCGGGATATAT</span></pre><h2 id="c97e" class="jo jp hs bd jq jr js jt ju jv jw jx jy ja jz ka kb je kc kd ke ji kf kg kh ki bi translated">8.对DNA序列串中的GC含量进行计数</h2><p id="cfa4" class="pw-post-body-paragraph ip iq hs ir b is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji kn jk jl jm ha bi translated">GC含量代表DNA或RNA序列中含氮碱基的百分比。</p><p id="75a1" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">示例:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="3e72" class="jo jp hs kt b fi kx ky l kz la">dna_sequence_string = “ATATATCCCGGGAATTTTCGTAGTTAGGCTGATTTTATTGGCGCGAAAATTT”<br/>gc_content = PyDNA.dna_count_gc_content(dna_sequence_string)<br/>print(“DNA sequence string:\n{}”.format(dna_sequence_string))<br/>print(“GC-content:\n{}”.format(gc_content))</span></pre><p id="9ad0" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">结果:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="8bec" class="jo jp hs kt b fi kx ky l kz la">DNA sequence string:<br/>ATATATCCCGGGAATTTTCGTAGTTAGGCTGATTTTATTGGCGCGAAAATTT<br/>GC-content:<br/>36.5%</span></pre><h2 id="9f89" class="jo jp hs bd jq jr js jt ju jv jw jx jy ja jz ka kb je kc kd ke ji kf kg kh ki bi translated">9.将DNA序列串转换成NumPy数组</h2><p id="73c4" class="pw-post-body-paragraph ip iq hs ir b is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji kn jk jl jm ha bi translated">Numerical Python ( <a class="ae jn" href="https://numpy.org/" rel="noopener ugc nofollow" target="_blank"> NumPy </a>)是Python编程语言的主要库，增加了对大型多维数组和矩阵的支持，以及对这些数组进行操作的大量高级数学函数。这个库是目前Python数据生态系统中最快的库之一。</p><p id="3436" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">NumPy核心程序是经过编译和优化的C代码。因此，强烈建议将其用于计算生物学和生物信息学中的字符串高性能处理和机器学习算法。仍然有许多数据科学家在Python中使用列表/集合/字典对象进行字符串操作。他们中的一些人在日常工作中编写糟糕的编程代码时抱怨Python非常慢。我总是建议我的数据科学家/工程师朋友在编写一行Python代码之前先学习高级Python编程课程。当你有机会的时候，我想让你读一读下面这篇有趣的博客文章:“<a class="ae jn" rel="noopener" href="/@ernest.bonat/refactoring-python-code-for-machine-learning-projects-python-spaghetti-code-everywhere-daaa6c116bd1">为机器学习项目重构Python代码。Python“意大利面条代码”无处不在！</a></p><p id="db4d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">下面是将DNA序列字符串转换为NumPy一维数组的PyDNA函数代码。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="cbc4" class="jo jp hs kt b fi kx ky l kz la"><a class="ae jn" href="http://twitter.com/staticmethod" rel="noopener ugc nofollow" target="_blank">@staticmethod</a><br/>def dna_sequence_np_array(dna_sequence_string):<br/>    dna_sequence_array = None<br/>    try:<br/>        dna_sequence_string = dna_sequence_string.lower()   <br/>        regex_acgt = re.compile('[^acgt]') <br/>        if (regex_acgt.search(dna_sequence_string) == None):           <br/>            dna_sequence_array = np.array(list(dna_sequence_string))<br/>        else:       <br/>            dna_sequence_array = None    <br/>    except:               <br/>        print(PyDNA.get_exception_info())<br/>        if PyDNA._app_is_log: PyDNA.write_log_file("error",   PyDNA.get_exception_info())  <br/>    return dna_sequence_array</span></pre><p id="056e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">示例:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="2816" class="jo jp hs kt b fi kx ky l kz la">dna_sequence_string = “ATATATCCCGGGAATTTTCGTAGTTAGGCTGATTTTATTGGCGCGAAAATTTTTT”<br/>dna_np_array = PyDNA.dna_sequence_np_array(dna_sequence_string) <br/>print(“DNA sequence string:\n{}”.format(dna_sequence_string))<br/>print(“DNA NumPy array:\n{}”.format(dna_np_array))</span></pre><p id="a09f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">结果:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="fe93" class="jo jp hs kt b fi kx ky l kz la">DNA sequence string:<br/>ATATATCCCGGGAATTTTCGTAGTTAGGCTGATTTTATTGGCGCGAAAATTTTTT<br/>DNA NumPy array:<br/>['a' 't' 'a' 't' 'a' 't' 'c' 'c' 'c' 'g' 'g' 'g' 'a' 'a' 't' 't' 't' 't' 'c' 'g' 't' 'a' 'g' 't' 't' 'a' 'g' 'g' 'c' 't' 'g' 'a' 't' 't' 't' 't' 'a' 't' 't' 'g' 'g' 'c' 'g' 'c' 'g' 'a' 'a' 'a' 'a' 't' 't' 't' 't' 't' 't']</span></pre><h2 id="f04f" class="jo jp hs bd jq jr js jt ju jv jw jx jy ja jz ka kb je kc kd ke ji kf kg kh ki bi translated">10.搜索DNA序列模式</h2><p id="6660" class="pw-post-body-paragraph ip iq hs ir b is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji kn jk jl jm ha bi translated">搜索DNA序列模式是当今生物信息学中的一项标准任务，包括蛋白质结构域、DNA转录因子结合基序、限制性酶切位点、简并PCR引物位点、单核苷酸序列等等。PyDNA库包含一个简单的dna_sequence_pattern()方法，用于在DNA序列字符串中查找模式。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="0a03" class="jo jp hs kt b fi kx ky l kz la"><a class="ae jn" href="http://twitter.com/staticmethod" rel="noopener ugc nofollow" target="_blank">@staticmethod</a><br/>def dna_sequence_pattern(dna_sequence_string, dna_sequence_pattern):<br/>    search_result = False<br/>    try:<br/>        search_pattern = re.search(dna_sequence_pattern.lower(), dna_sequence_string.lower())<br/>        if search_pattern: search_result = True       <br/>    except:               <br/>        print(PyDNA.get_exception_info())<br/>        if PyDNA._app_is_log: PyDNA.write_log_file("error", PyDNA.get_exception_info())  <br/>    return search_result</span></pre><p id="5672" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们看一些例子。</p><p id="6a83" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">例1。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="ae0e" class="jo jp hs kt b fi kx ky l kz la">dna_sequence_string = “ATATATCCCGGGAATTTTCGTAGTTAGGCTGATTTTATTGGCGCGAAAATTTTTT”<br/>dna_sequence_pattern = “AATTTT”<br/>result = PyDNA.dna_sequence_pattern(dna_sequence_string, dna_sequence_pattern)<br/>print(result)<br/>True</span></pre><p id="53fc" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">例2。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="3587" class="jo jp hs kt b fi kx ky l kz la">dna_sequence_string = “ATATATCCCGGGAATTTTCGTAGTTAGGCTGATTTTATTGGCGCGAAAATTTTTT”<br/>dna_sequence_pattern = “AATTTTAA”<br/>result = PyDNA.dna_sequence_pattern(dna_sequence_string, dna_sequence_pattern)<br/>print(result)<br/>False</span></pre><h2 id="0127" class="jo jp hs bd jq jr js jt ju jv jw jx jy ja jz ka kb je kc kd ke ji kf kg kh ki bi translated">11.DNA序列串翻译成蛋白质</h2><p id="a467" class="pw-post-body-paragraph ip iq hs ir b is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji kn jk jl jm ha bi translated">为了将DNA序列翻译成蛋白质，使用了<a class="ae jn" href="https://en.wikipedia.org/wiki/DNA_and_RNA_codon_tables" rel="noopener ugc nofollow" target="_blank"> DNA遗传密码图</a>。</p><p id="9009" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">示例:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="0fa4" class="jo jp hs kt b fi kx ky l kz la">dna_sequence_string = “ATGGAAGTATTTAAAGCGCCACCTATTGGGATATAAG” <br/>protein_translation = PyDNA.dna_protein_translation(dna_sequence_string)<br/>print(“DNA sequence string:\n{}”.format(dna_sequence_string))<br/>print(“Protein translation:\n{}”.format(protein_translation))</span></pre><p id="56d9" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">结果:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="ada0" class="jo jp hs kt b fi kx ky l kz la">DNA sequence string:<br/>ATGGAAGTATTTAAAGCGCCACCTATTGGGATATAAG<br/>Protein translation:<br/>MEVFKAPPIGI</span></pre><h2 id="7e3e" class="jo jp hs bd jq jr js jt ju jv jw jx jy ja jz ka kb je kc kd ke ji kf kg kh ki bi translated">12.DNA序列串转录成RNA序列串</h2><p id="7192" class="pw-post-body-paragraph ip iq hs ir b is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji kn jk jl jm ha bi translated">下面的函数将DNA序列串转录成RNA序列串。</p><p id="b762" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">示例:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="9119" class="jo jp hs kt b fi kx ky l kz la">dna_sequence_string = “ATGGAAGTATTTAAAGCGCCACCTATTGGGATATAAG” <br/>rna_transcription = PyDNA.dna_rna_transcription(dna_sequence_string)<br/>print(“DNA sequence string:\n{}”.format(dna_sequence_string))<br/>print(“RNA transcription:\n{}”.format(rna_transcription))</span></pre><p id="cdf3" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">结果:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="9666" class="jo jp hs kt b fi kx ky l kz la">DNA sequence string:<br/>ATGGAAGTATTTAAAGCGCCACCTATTGGGATATAAG<br/>RNA transcription:<br/>AUGGAAGUAUUUAAAGCGCCACCUAUUGGGAUAUAAG</span></pre><h2 id="3330" class="jo jp hs bd jq jr js jt ju jv jw jx jy ja jz ka kb je kc kd ke ji kf kg kh ki bi translated">13.编码DNA序列串</h2><p id="3650" class="pw-post-body-paragraph ip iq hs ir b is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji kn jk jl jm ha bi translated">要在ML项目中使用DNA序列字符串，首先需要对其进行编码。ML数学算法不适用于文本分类数据。根据所选的ML算法，有三种主要类型的DNA序列字符串编码:</p><p id="556b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">1.<strong class="ir ht">标签编码</strong> —该标签(普通)编码将每个碱基核苷酸编码为自定义数值。一般来说，为了使最大似然算法更加精确，使用了浮点(十进制)数。在应用这种编码之前，需要将DNA序列字符串转换成NumPy一维数组。这种类型的编码在使用<a class="ae jn" href="https://scikit-learn.org/stable/" rel="noopener ugc nofollow" target="_blank"> scikit-learn </a>库的监督学习中非常流行。在下面的例子中，“ACGT”序列字符串将被编码为[0.25，0.5，0.75，1.0]。</p><p id="6910" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">示例:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="be2d" class="jo jp hs kt b fi kx ky l kz la">dna_sequence_string = “ATATATCCCGGGAATTTTCGTAGTTAGGCTGATTTTATTGGCGCGAAAATTTTTT”<br/>dna_np_array = PyDNA.dna_sequence_np_array(dna_sequence_string) <br/>dna_label_encoder = PyDNA.dna_label_encoder(dna_np_array) <br/>print(“DNA sequence string:\n{}”.format(dna_sequence_string))<br/>print(“DNA NumPy array:\n{}”.format(dna_np_array))<br/>print(“Custom Label Encoding:\n{}”.format(dna_label_encoder))</span></pre><p id="2fc4" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">结果:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="2f0e" class="jo jp hs kt b fi kx ky l kz la">DNA sequence string:<br/>ATATATCCCGGGAATTTTCGTAGTTAGGCTGATTTTATTGGCGCGAAAATTTTTT<br/>DNA NumPy array:<br/>[‘a’ ‘t’ ‘a’ ‘t’ ‘a’ ‘t’ ‘c’ ‘c’ ‘c’ ‘g’ ‘g’ ‘g’ ‘a’ ‘a’ ‘t’ ‘t’ ‘t’ ‘t’ ‘c’ ‘g’ ‘t’ ‘a’ ‘g’ ‘t’ ‘t’ ‘a’ ‘g’ ‘g’ ‘c’ ‘t’ ‘g’ ‘a’ ‘t’ ‘t’ ‘t’ ‘t’ ‘a’ ‘t’ ‘t’ ‘g’ ‘g’ ‘c’ ‘g’ ‘c’ ‘g’ ‘a’ ‘a’ ‘a’ ‘a’ ‘t’ ‘t’ ‘t’ ‘t’ ‘t’ ‘t’]<br/>Custom Label Encoding:<br/>[0.25 1. 0.25 1. 0.25 1. 0.5 0.5 0.5 0.75 0.75 0.75 0.25 0.25 1. 1. 1. 1. 0.5 0.75 1. 0.25 0.75 1. 1. 0.25 0.75 0.75 0.5 1. 0.75 0.25 1. 1. 1. 1. 0.25 1. 1. 0.75 0.75 0.5 0.75 0.5 0.75 0.25 0.25 0.25 0.25 1. 1. 1. 1. 1. 1. ]</span></pre><p id="692a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">2.<strong class="ir ht">一键编码</strong> —这种编码常用于人工神经网络(ANN)。很多时候，ANN都被称为深度学习。深度学习(也称为深度结构化学习)是基于具有表示学习的ANN的更广泛的ML方法家族的一部分。包括以下主要架构:深度神经网络(DNN)、深度信念网络(DBN)、递归神经网络(RNN)和<a class="ae jn" href="https://en.wikipedia.org/wiki/Deep_learning" rel="noopener ugc nofollow" target="_blank">卷积神经网络</a> (CNN)。scikit-learn和<a class="ae jn" href="https://keras.io/" rel="noopener ugc nofollow" target="_blank"> Keras </a>库可以提供这种一键编码实现。对于核苷酸的标准碱基,“ACGT”序列串将被一次性编码为[[1。0.0.0.] [0.1.0.0.] [0.0.1.0.] [0.0.0.1.]]使用NumPy数组['a' 'c' 'g' 't']。</p><p id="9889" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">示例:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="5a61" class="jo jp hs kt b fi kx ky l kz la">dna_sequence_string = “ATATATCCCGGGAATTTTCGTAGTTAGGCTGATTTTATTGGCGCGAAAATTTTTT”<br/>dna_np_array = PyDNA.dna_sequence_np_array(dna_sequence_string) <br/>dna_one_hot = PyDNA.dna_onehot_encoder(dna_np_array) <br/>print(“DNA sequence string:\n{}”.format(dna_sequence_string))<br/>print(“DNA NumPy array:\n{}”.format(dna_np_array))<br/>print(“DNA One-Hot Encoding with Scikit-Learn framework:\n{}”.format(dna_one_hot))</span></pre><p id="6c30" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">结果:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="a99a" class="jo jp hs kt b fi kx ky l kz la">DNA sequence string:<br/>ATATATCCCGGGAATTTTCGTAGTTAGGCTGATTTTATTGGCGCGAAAATTTTTT <br/>DNA NumPy array:<br/>[‘a’ ‘t’ ‘a’ ‘t’ ‘a’ ‘t’ ‘c’ ‘c’ ‘c’ ‘g’ ‘g’ ‘g’ ‘a’ ‘a’ ‘t’ ‘t’ ‘t’ ‘t’ ‘c’ ‘g’ ‘t’ ‘a’ ‘g’ ‘t’ ‘t’ ‘a’ ‘g’ ‘g’ ‘c’ ‘t’ ‘g’ ‘a’ ‘t’ ‘t’ ‘t’ ‘t’ ‘a’ ‘t’ ‘t’ ‘g’ ‘g’ ‘c’ ‘g’ ‘c’ ‘g’ ‘a’ ‘a’ ‘a’ ‘a’ ‘t’ ‘t’ ‘t’ ‘t’ ‘t’ ‘t’]<br/>DNA One-Hot Encoding with Scikit-Learn framework:<br/>[[1. 0. 0. 0.] [0. 0. 0. 1.] [1. 0. 0. 0.] [0. 0. 0. 1.] [1. 0. 0. 0.] [0. 0. 0. 1.] [0. 1. 0. 0.] [0. 1. 0. 0.] [0. 1. 0. 0.] [0. 0. 1. 0.] [0. 0. 1. 0.] [0. 0. 1. 0.] [1. 0. 0. 0.] [1. 0. 0. 0.] [0. 0. 0. 1.] [0. 0. 0. 1.] [0. 0. 0. 1.] [0. 0. 0. 1.] [0. 1. 0. 0.] [0. 0. 1. 0.] [0. 0. 0. 1.] [1. 0. 0. 0.] [0. 0. 1. 0.] [0. 0. 0. 1.] [0. 0. 0. 1.] [1. 0. 0. 0.] [0. 0. 1. 0.] [0. 0. 1. 0.] [0. 1. 0. 0.] [0. 0. 0. 1.] [0. 0. 1. 0.] [1. 0. 0. 0.] [0. 0. 0. 1.] [0. 0. 0. 1.] [0. 0. 0. 1.] [0. 0. 0. 1.] [1. 0. 0. 0.] [0. 0. 0. 1.] [0. 0. 0. 1.] [0. 0. 1. 0.] [0. 0. 1. 0.] [0. 1. 0. 0.] [0. 0. 1. 0.] [0. 1. 0. 0.] [0. 0. 1. 0.] [1. 0. 0. 0.] [1. 0. 0. 0.] [1. 0. 0. 0.] [1. 0. 0. 0.] [0. 0. 0. 1.] [0. 0. 0. 1.] [0. 0. 0. 1.] [0. 0. 0. 1.] [0. 0. 0. 1.] [0. 0. 0. 1.]]</span></pre><p id="4847" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">使用Keras库可以得到相同的结果。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="29c4" class="jo jp hs kt b fi kx ky l kz la">dna_sequence_string = “ATATATCCCGGGAATTTTCGTAGTTAGGCTGATTTTATTGGCGCGAAAATTTTTT”<br/>dna_np_array = PyDNA.dna_sequence_np_array(dna_sequence_string) <br/>dna_one_hot = PyDNA.dna_onehot_encoder_keras(dna_np_array) <br/>print(“DNA sequence string:\n{}”.format(dna_sequence_string))<br/>print(“DNA NumPy array:\n{}”.format(dna_np_array))<br/>print(“DNA One-Hot Encoding with Scikit-Learn framework:\n{}”.format(dna_one_hot))</span></pre><p id="0d6e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">3.<strong class="ir ht"> K-mer计数</strong> —在生物信息学中，<a class="ae jn" href="https://en.wikipedia.org/wiki/K-mer" rel="noopener ugc nofollow" target="_blank">K-mer</a>是生物序列中包含的长度子序列。通常，术语k-mer是指长度为k的序列的所有子序列，这样序列AGat将具有四个单体(A、G、A和T)、三个二聚体(AG、GA、AT)、两个三聚体(AGA和GAT)和一个四聚体(AGAT)——来自<a class="ae jn" href="https://en.wikipedia.org/wiki/K-mer" rel="noopener ugc nofollow" target="_blank"> k-mer </a>定义。一般来说，将一个序列分解成k-mers固定大小的块允许快速和容易的字符串操作。这被明智地应用于ML算法的自然语言处理(NLP)单词包方法中。这个方法将在下一个主题中讨论。</p><p id="8c76" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">示例:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="9266" class="jo jp hs kt b fi kx ky l kz la">dna_sequence_string = “ATATATCCCGGGAATTTTCGTAGTTAGGCTGATTTTATTGGCGCGAAAATTT”<br/>k_mer_list, k_mer_numpy_array = PyDNA.k_mer_words(dna_sequence_string, k_mer_length=6)<br/>print(“DNA sequence string:\n{}”.format(dna_sequence_string))<br/>print(“K-mer list:\n{}”.format(k_mer_list))<br/>print(“K-mer array:\n{}”.format(k_mer_numpy_array))</span></pre><p id="14b8" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">结果:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="c290" class="jo jp hs kt b fi kx ky l kz la">DNA sequence string:<br/>ATATATCCCGGGAATTTTCGTAGTTAGGCTGATTTTATTGGCGCGAAAATTT<br/>K-mer list:<br/>[‘atatat’, ‘tatatc’, ‘atatcc’, ‘tatccc’, ‘atcccg’, ‘tcccgg’, ‘cccggg’, ‘ccggga’, ‘cgggaa’, ‘gggaat’, ‘ggaatt’, ‘gaattt’, ‘aatttt’, ‘attttc’, ‘ttttcg’, ‘tttcgt’, ‘ttcgta’, ‘tcgtag’, ‘cgtagt’, ‘gtagtt’, ‘tagtta’, ‘agttag’, ‘gttagg’, ‘ttaggc’, ‘taggct’, ‘aggctg’, ‘ggctga’, ‘gctgat’, ‘ctgatt’, ‘tgattt’, ‘gatttt’, ‘atttta’, ‘ttttat’, ‘tttatt’, ‘ttattg’, ‘tattgg’, ‘attggc’, ‘ttggcg’, ‘tggcgc’, ‘ggcgcg’, ‘gcgcga’, ‘cgcgaa’, ‘gcgaaa’, ‘cgaaaa’, ‘gaaaat’, ‘aaaatt’, ‘aaattt’]<br/>K-mer array:<br/>[‘atatat’ ‘tatatc’ ‘atatcc’ ‘tatccc’ ‘atcccg’ ‘tcccgg’ ‘cccggg’ ‘ccggga’ ‘cgggaa’ ‘gggaat’ ‘ggaatt’ ‘gaattt’ ‘aatttt’ ‘attttc’ ‘ttttcg’ ‘tttcgt’ ‘ttcgta’ ‘tcgtag’ ‘cgtagt’ ‘gtagtt’ ‘tagtta’ ‘agttag’ ‘gttagg’ ‘ttaggc’ ‘taggct’ ‘aggctg’ ‘ggctga’ ‘gctgat’ ‘ctgatt’ ‘tgattt’ ‘gatttt’ ‘atttta’ ‘ttttat’ ‘tttatt’ ‘ttattg’ ‘tattgg’ ‘attggc’ ‘ttggcg’ ‘tggcgc’ ‘ggcgcg’ ‘gcgcga’ ‘cgcgaa’ ‘gcgaaa’ ‘cgaaaa’ ‘gaaaat’ ‘aaaatt’ ‘aaattt’]</span></pre><h2 id="caba" class="jo jp hs bd jq jr js jt ju jv jw jx jy ja jz ka kb je kc kd ke ji kf kg kh ki bi translated">14.DNA序列字符串的单词包</h2><p id="18ac" class="pw-post-body-paragraph ip iq hs ir b is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji kn jk jl jm ha bi translated">DNA序列是简单的非结构化文本数据。因此，NLP应该是一个很好的工具。使用NLP的主要思想是让计算机理解非结构化文本，并从中检索有意义的信息片段，以做出商业决策。NLP是人工智能生态系统的一部分。</p><p id="e8ef" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">词袋是自然语言处理中的一种方法。它的主要功能是将原始文本数据转换成单词，并统计它们在文本中的出现频率。这些词在文中的顺序无关紧要。对于文本文档，生成令牌计数矩阵。一般来说，这个矩阵表示将在ML算法中应用的最终特征向量。在我们下面的例子中，DNA子序列的k-mers列表是为它生成单词包的输入参数。</p><p id="8035" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">示例:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="b013" class="jo jp hs kt b fi kx ky l kz la">k_mer_list = [‘atatat’, ‘tatatc’, ‘atatcc’, ‘tatccc’, ‘atcccg’, ‘tcccgg’, ‘cccggg’, ‘ccggga’, ‘cgggaa’, ‘gggaat’]<br/>word_ngram = 1<br/>k_mer_token_count = PyDNA.bag_of_word_list(k_mer_list, word_ngram)<br/>print(“K-mer list:\n{}”.format(k_mer_list))<br/>print(“Word ngram:\n{}”.format(word_ngram))<br/>print(“K-mer matrix token counts:\n{}”.format(k_mer_token_count.toarray()))</span></pre><p id="d0af" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">结果:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="69e8" class="jo jp hs kt b fi kx ky l kz la">K-mer list:<br/>[‘atatat’, ‘tatatc’, ‘atatcc’, ‘tatccc’, ‘atcccg’, ‘tcccgg’, ‘cccggg’, ‘ccggga’, ‘cgggaa’, ‘gggaat’]<br/>Word ngram:<br/>1<br/>K-mer matrix of token counts:<br/>[[1 0 0 0 0 0 0 0 0 0]<br/> [0 0 0 0 0 0 0 1 0 0]<br/> [0 1 0 0 0 0 0 0 0 0]<br/> [0 0 0 0 0 0 0 0 1 0]<br/> [0 0 1 0 0 0 0 0 0 0]<br/> [0 0 0 0 0 0 0 0 0 1]<br/> [0 0 0 1 0 0 0 0 0 0]<br/> [0 0 0 0 1 0 0 0 0 0]<br/> [0 0 0 0 0 1 0 0 0 0]<br/> [0 0 0 0 0 0 1 0 0 0]]</span></pre><h2 id="7c74" class="jo jp hs bd jq jr js jt ju jv jw jx jy ja jz ka kb je kc kd ke ji kf kg kh ki bi translated">15.RNA序列</h2><p id="561f" class="pw-post-body-paragraph ip iq hs ir b is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji kn jk jl jm ha bi translated">基于国家人类基因组研究所，<a class="ae jn" href="https://www.genome.gov/genetics-glossary/RNA-Ribonucleic-Acid" rel="noopener ugc nofollow" target="_blank">核糖核酸</a> (RNA)是一种与DNA结构相似，但在细微方面有所不同的核酸。细胞使用RNA完成许多不同的任务，其中一种叫做信使RNA，或mRNA。这是核酸信息分子，通过翻译将信息从基因组转移到蛋白质中。RNA的另一种形式是tRNA，或转移RNA，它们是非蛋白质编码的RNA分子，将氨基酸物理携带到翻译位点，使它们在翻译过程中装配成蛋白质链。</p><p id="679d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">RNA测序使用<a class="ae jn" href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3841808/" rel="noopener ugc nofollow" target="_blank">下一代测序</a> (NGS)技术分析不断变化的细胞转录组。NGS是一个大规模的自动化过程，可以完成DNA或RNA样品中碱基对的快速测序。NGS使研究人员能够进行多项生物学研究，并能在一天内对整个人类基因组进行测序。NGS应用广泛用于各种现代技术，如高通量完整病毒基因组测序、病毒基因组变异检测和宿主进化。</p><p id="7195" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们看一些PyDNA函数来支持RNA序列字符串操作。</p><h2 id="563b" class="jo jp hs bd jq jr js jt ju jv jw jx jy ja jz ka kb je kc kd ke ji kf kg kh ki bi translated">16.验证RNA序列字符串</h2><p id="6a4f" class="pw-post-body-paragraph ip iq hs ir b is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji kn jk jl jm ha bi translated">RNA序列字符串必须包含四个碱基核苷酸[“A”、“C”、“G”、“U”]。该功能允许用任何定义的定制碱基核苷酸验证RNA序列。</p><p id="0b10" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">示例:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="e397" class="jo jp hs kt b fi kx ky l kz la">rna_sequence_string = “AUGGCCAUGGCGCCCAGAACUGAGAUCAAUAGUACCCGUAUUAACGGGUGA”<br/>is_rna_result = PyDNA.is_rna(rna_sequence_string, base_sequence=[“A”,”C”,”G”,”U”])<br/>print(“RNA sequence string:\n{}”.format(rna_sequence_string))<br/>print(“Is RNA:\n{}”.format(is_rna_result))</span></pre><p id="164d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">结果:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="495f" class="jo jp hs kt b fi kx ky l kz la">RNA sequence string:<br/>AUGGCCAUGGCGCCCAGAACUGAGAUCAAUAGUACCCGUAUUAACGGGUGA<br/>Is RNA:<br/>True</span></pre><p id="2ed6" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">示例:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="3b91" class="jo jp hs kt b fi kx ky l kz la">rna_sequence_string = “AUGGCCTUGGCGCCCAGAACUGAGAUCTAUAGUACCCGUAUUAACTGGUGA”<br/>is_rna_result = PyDNA.is_rna(rna_sequence_string, base_sequence=[“A”,”C”,”G”,”U”])<br/>print(“RNA sequence string:\n{}”.format(rna_sequence_string))<br/>print(“Is RNA:\n{}”.format(is_rna_result))</span></pre><p id="0dc3" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">结果:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="18d4" class="jo jp hs kt b fi kx ky l kz la">RNA sequence string:<br/>AUGGCCTUGGCGCCCAGAACUGAGAUCTAUAGUACCCGUAUUAACTGGUGA<br/>Is RNA:<br/>False</span></pre><h2 id="96cd" class="jo jp hs bd jq jr js jt ju jv jw jx jy ja jz ka kb je kc kd ke ji kf kg kh ki bi translated">17.计数RNA序列串中的碱基核苷酸</h2><p id="e093" class="pw-post-body-paragraph ip iq hs ir b is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji kn jk jl jm ha bi translated">下面的函数允许用任何定义的自定义碱基计数RNA序列核苷酸。RNA序列的长度也被返回。</p><p id="324b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">示例:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="f190" class="jo jp hs kt b fi kx ky l kz la">rna_sequence_string = “AUGGCCAUGGCGCCCAGAACUGAGAUCAAUAGUACCCGUAUUAACGGGUGA”<br/>base_sequence_count, rna_sequence_length = PyDNA.rna_count_nucleotide(rna_sequence_string, base_sequence=[“A”,”C”,”G”,”U”], is_length=True)<br/>print(“RNA sequence string:\n{}”.format(rna_sequence_string))<br/>print(“RNA nucleotides count:\n{}”.format(base_sequence_count))<br/>print(“RNA length:\n{}”.format(rna_sequence_length))</span></pre><p id="cc2b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">结果:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="a3eb" class="jo jp hs kt b fi kx ky l kz la">RNA sequence string:<br/>AUGGCCAUGGCGCCCAGAACUGAGAUCAAUAGUACCCGUAUUAACGGGUGA<br/>RNA nucleotides count:<br/>{‘A’: 15, ‘C’: 12, ‘G’: 14, ‘U’: 10}<br/>RNA le</span></pre><h2 id="df0a" class="jo jp hs bd jq jr js jt ju jv jw jx jy ja jz ka kb je kc kd ke ji kf kg kh ki bi translated">18.RNA序列串翻译成蛋白质</h2><p id="74ab" class="pw-post-body-paragraph ip iq hs ir b is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji kn jk jl jm ha bi translated">为了将RNA序列翻译成蛋白质，使用了<a class="ae jn" href="https://en.wikipedia.org/wiki/DNA_and_RNA_codon_tables" rel="noopener ugc nofollow" target="_blank"> RNA遗传密码图</a>。</p><p id="8560" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">示例:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="fd7f" class="jo jp hs kt b fi kx ky l kz la">rna_sequence_string = “AUGGCCAUGGCGCCCAGAACUGAGAUCAAUAGUACCCGUAUUAACGGGUGA”<br/>protein_translation = PyDNA. rna_protein_translation(rna_sequence_string)<br/>print(“RNA sequence string:\n{}”.format(rna_sequence_string))<br/>print(“Protein translation:\n{}”.format(protein_translation))</span></pre><p id="a10c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">结果:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="ce3f" class="jo jp hs kt b fi kx ky l kz la">RNA sequence string:<br/>AUGGCCAUGGCGCCCAGAACUGAGAUCAAUAGUACCCGUAUUAACGGGUGA<br/>Protein translation:<br/>MAMAPRTEINSTRING</span></pre><h2 id="3b3c" class="jo jp hs bd jq jr js jt ju jv jw jx jy ja jz ka kb je kc kd ke ji kf kg kh ki bi translated">19.DNA、RNA和蛋白质序列比对</h2><p id="7ff3" class="pw-post-body-paragraph ip iq hs ir b is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji kn jk jl jm ha bi translated"><a class="ae jn" href="https://en.wikipedia.org/wiki/Sequence_alignment" rel="noopener ugc nofollow" target="_blank">序列比对</a>是一种排列DNA、RNA或蛋白质序列的方法，以识别相似区域，这可能是序列之间功能、结构或进化关系的结果。核苷酸或氨基酸残基的比对序列通常表示为矩阵中的行。在残基之间插入间隔，以便相同或相似的字符在连续的列中对齐。序列比对也用于非生物序列，例如计算自然语言或金融数据中字符串之间的距离成本。</p><p id="02a0" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">今天用于更快序列比对的基本技术之一是<a class="ae jn" href="https://en.wikipedia.org/wiki/Dynamic_programming" rel="noopener ugc nofollow" target="_blank">动态编程</a> (DP)。DP既是一种数学优化方法，也是一种计算机编程方法。在这两种情况下，它指的是通过以递归的方式将复杂的问题分解成更简单的子问题来简化它。虽然一些决策问题不能以这种方式分解，但是跨越几个时间点的决策经常会递归地分解。同样，在计算机科学中，如果一个问题可以通过将其分解为子问题，然后递归地找到子问题的最优解来最优地解决，那么它就被称为具有最优子结构。</p><p id="e6a9" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">序列比对可以有以下主要应用:给定一个新序列，根据与另一个序列的相似性预测其功能，发现重要的分子区域，确定起作用的进化约束，发现基因群体或家族中的突变，网络生物学为我们提供基因/蛋白质的功能信息，分析突变体未知基因与疾病的联系，等等。</p><p id="1b0a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果我们比较两个序列，这就是所谓的成对序列比对。如果我们比较两个以上的序列，这就是所谓的多序列比对。一般来说，有两种类型的序列比对:全局比对和局部比对。全局比对试图比对每个序列中的每个残基，当查询集中的序列相似且大小大致相等时，全局比对最有用。(这并不意味着全局比对不能以间隙开始和/或结束。)一种通用的全局比对技术是基于动态编程的<a class="ae jn" href="https://en.wikipedia.org/wiki/Sequence_alignment" rel="noopener ugc nofollow" target="_blank"> Needleman-Wunsch </a>算法。局部比对对于怀疑在其较大的序列范围内包含相似区域或相似序列基序的不相似序列更有用。<a class="ae jn" href="https://en.wikipedia.org/wiki/Sequence_alignment" rel="noopener ugc nofollow" target="_blank"> Smith-Waterman </a>算法是一种通用的局部对齐方法，基于相同的动态规划方案，但具有在任何地方开始和结束的额外选择。</p><p id="f53c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">下面是使用PyDNA库的全局和局部算法比较两个序列的代码。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="ebb0" class="jo jp hs kt b fi kx ky l kz la">sequence_1 = “ACGGGT”<br/>sequence_2 = “ACG”<br/>print(“Needleman-Wunsch Global Algorithm”)<br/>PyDNA..needleman_wunsch_global(sequence_1, sequence_2)<br/>print(“Smith-Waterman Local Algorithm”)<br/>PyDNA.smith_waterman_local(sequence_1, sequence_2)</span></pre><p id="c108" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">结果:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="8282" class="jo jp hs kt b fi kx ky l kz la">Needleman-Wunsch Global Algorithm<br/>score: 15<br/>ACGGGT<br/>AC G<br/>AC — G-</span><span id="3d31" class="jo jp hs kt b fi lb ky l kz la">Smith-Waterman Local Algorithm<br/>score: 30<br/>ACG</span></pre><h2 id="7f51" class="jo jp hs bd jq jr js jt ju jv jw jx jy ja jz ka kb je kc kd ke ji kf kg kh ki bi translated">20.Biopython库概述</h2><p id="5dac" class="pw-post-body-paragraph ip iq hs ir b is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji kn jk jl jm ha bi translated">计算生物学和生物信息学中最流行的Python库是<a class="ae jn" href="https://biopython.org" rel="noopener ugc nofollow" target="_blank"> Biopython </a>。Biopython项目是一个用于计算生物学和生物信息学的非商业python工具的开源集合，由一个国际开发者协会创建。它包含表示生物序列和序列注释的类，并且能够读写各种文件格式。它还允许以编程方式访问在线生物信息数据库，如NCBI的数据库。独立的模块将Biopython的能力扩展到序列比对、蛋白质结构、群体遗传学、系统发育学、序列基序和机器学习。Biopython是许多旨在减少计算生物学中代码重复的Bio*项目之一。</p><p id="8b29" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为了比较，让我们用这个库来比对上面显示的序列。正如你在下面的程序中看到的，生物库已经被导入。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="61cf" class="jo jp hs kt b fi kx ky l kz la">from Bio import pairwise2<br/>from Bio.pairwise2 import format_alignment</span><span id="f5c8" class="jo jp hs kt b fi lb ky l kz la">sequence_1 = "ACGGGT"<br/>sequence_2 = "ACG"<br/>print("Needleman-Wunsch Global Algorithm")<br/>alignments = pairwise2.align.globalxx(sequence_1, sequence_2)<br/>for item in alignments:<br/>    print(format_alignment(*item))<br/>print("Smith-Waterman Local Algorithm")<br/>alignments = pairwise2.align.localxx(sequence_1, sequence_2)<br/>for item in alignments:<br/>    print(format_alignment(*item))</span></pre><p id="adbf" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">结果:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="7e6a" class="jo jp hs kt b fi kx ky l kz la">Needleman-Wunsch Global Algorithm<br/>ACGGGT<br/>||  |<br/>AC--G-<br/>  Score=3<br/>ACGGGT<br/>|| |<br/>AC-G--<br/>  Score=3<br/>ACGGGT<br/>|||<br/>ACG---<br/>  Score=3</span><span id="8202" class="jo jp hs kt b fi lb ky l kz la">Smith-Waterman Local Algorithm<br/>1 ACGGG<br/>  ||  |<br/>1 AC--G<br/>  Score=3<br/>1 ACGG<br/>  || |<br/>1 AC-G<br/>  Score=3<br/>1 ACG<br/>  |||<br/>1 ACG<br/>  Score=3</span></pre><p id="d47e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">两个库产生相同的结果。对于我们的情况，最好的全局和局部比对是AC-G-和ACG。</p><h2 id="197c" class="jo jp hs bd jq jr js jt ju jv jw jx jy ja jz ka kb je kc kd ke ji kf kg kh ki bi translated">21.自定义PyDNA库</h2><p id="2013" class="pw-post-body-paragraph ip iq hs ir b is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji kn jk jl jm ha bi translated">During researching the applications of ML algorithms for genomics data I found many standard and generic programming procedures and sequence data preprocessing were unavailable. The Biopython library does not provide the required modern ANN and Boosting Gradient models like Convolutional Neural Networks (CNN), Recurrent Neural Networks (RNN), Extreme Gradient Boosting (XGBoost), etc. Because of this, I decided to build a simple Python library so I could reuse it in my daily ML bioinformatics work. After a couple of months of work, this library became simple, good and large. The setup packaging for it may be available in the future. Below are the main design basics.</p><p id="d5ba" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">1. Easy to use by copying and pasting the files pydna.py and ipydna.py into any Python project.<br/>2. Generic ML methods and logic procedures for the whole project work flow.<br/>3. Error handling, configuration file and log messages implementation.<br/>4. Simple maintenance and future upgrades.<br/>5. Unit tests project implementation.</p><p id="8f8e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Here is an example code of the PyDNA library public interface file.</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="cd3d" class="jo jp hs kt b fi kx ky l kz la">from zope.interface import Interface<br/>class IPyDNA(Interface):   <br/>    def dna_sequence_np_array(dna_sequence_string):<br/>        """<br/>        convert a dna sequence string to numpy one-dimensional array<br/>        dna_sequence_string: dna sequence string<br/>        return: numpy one-dimensional array<br/>        """<br/>        pass</span></pre><h2 id="0f4e" class="jo jp hs bd jq jr js jt ju jv jw jx jy ja jz ka kb je kc kd ke ji kf kg kh ki bi translated">22. DNA Sequence Classification using Machine Learning Algorithms</h2><p id="3b65" class="pw-post-body-paragraph ip iq hs ir b is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji kn jk jl jm ha bi translated">There is a huge demand of applying ML to genomics dataset analytics today. Many questions about it are still not very clear at all. Let me mentions some of them:</p><ul class=""><li id="2282" class="lc ld hs ir b is it iw ix ja le je lf ji lg jm lh li lj lk bi translated">What DNA sequence encoder to use based on the selected ML model?</li><li id="2f61" class="lc ld hs ir b is ll iw lm ja ln je lo ji lp jm lh li lj lk bi translated">What ML models to use for generic genomics datasets and how to interpret it?</li><li id="7b91" class="lc ld hs ir b is ll iw lm ja ln je lo ji lp jm lh li lj lk bi translated">How to optimize the ML model hyperparameters?</li><li id="18f6" class="lc ld hs ir b is ll iw lm ja ln je lo ji lp jm lh li lj lk bi translated">How to apply Natural Language processing to DNA sequence as an unstructured text dataset?</li><li id="af95" class="lc ld hs ir b is ll iw lm ja ln je lo ji lp jm lh li lj lk bi translated">How to handle high dimensional and unlabeled gene expression datasets?</li><li id="f601" class="lc ld hs ir b is ll iw lm ja ln je lo ji lp jm lh li lj lk bi translated">What method to use to handle genomic datasets with imbalanced classes?</li><li id="3f9c" class="lc ld hs ir b is ll iw lm ja ln je lo ji lp jm lh li lj lk bi translated">What metrics to use to validate the ML model with genomics datasets?</li><li id="782a" class="lc ld hs ir b is ll iw lm ja ln je lo ji lp jm lh li lj lk bi translated">How to expose and consume the ML model using web services API’s call?</li><li id="04f7" class="lc ld hs ir b is ll iw lm ja ln je lo ji lp jm lh li lj lk bi translated">How to design and build a client side and/or desktop application to use these ML models in real research and/or production business environments?</li></ul><p id="ae80" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Selection of the ML model and its hyperparameters optimization is part of the ML project flow from the steps shown below:</p><ul class=""><li id="805d" class="lc ld hs ir b is it iw ix ja le je lf ji lg jm lh li lj lk bi translated">Project description and specifications.</li><li id="4c32" class="lc ld hs ir b is ll iw lm ja ln je lo ji lp jm lh li lj lk bi translated">Data loading.</li><li id="55f3" class="lc ld hs ir b is ll iw lm ja ln je lo ji lp jm lh li lj lk bi translated">Data preprocessing.</li><li id="733e" class="lc ld hs ir b is ll iw lm ja ln je lo ji lp jm lh li lj lk bi translated">Data exploration and visualization.</li><li id="043b" class="lc ld hs ir b is ll iw lm ja ln je lo ji lp jm lh li lj lk bi translated">Features engineering and reduction.</li><li id="bde5" class="lc ld hs ir b is ll iw lm ja ln je lo ji lp jm lh li lj lk bi translated">Features and labels encoding.</li><li id="3e71" class="lc ld hs ir b is ll iw lm ja ln je lo ji lp jm lh li lj lk bi translated">Features and labels data splitting.</li><li id="b901" class="lc ld hs ir b is ll iw lm ja ln je lo ji lp jm lh li lj lk bi translated">Features and labels scaling.</li><li id="b4bd" class="lc ld hs ir b is ll iw lm ja ln je lo ji lp jm lh li lj lk bi translated">Model selection and hyperparameters optimization.</li><li id="2f55" class="lc ld hs ir b is ll iw lm ja ln je lo ji lp jm lh li lj lk bi translated">Model cross validation.</li><li id="ee0d" class="lc ld hs ir b is ll iw lm ja ln je lo ji lp jm lh li lj lk bi translated">Model prediction.</li><li id="544c" class="lc ld hs ir b is ll iw lm ja ln je lo ji lp jm lh li lj lk bi translated">Model performance metrics analysis.</li><li id="435a" class="lc ld hs ir b is ll iw lm ja ln je lo ji lp jm lh li lj lk bi translated">Model production deployment using Web APIs IT application integration.</li><li id="1b17" class="lc ld hs ir b is ll iw lm ja ln je lo ji lp jm lh li lj lk bi translated">Model retraining schedule and redeployment business intelligence and decisions making.</li></ul><p id="55eb" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">对于生物信息学家、生物学家和临床医生来说，为特定的基因组数据集定义这个模型是一个重要的决定。在许多用例中，这种选择是根据数据集DNA序列长度的一致性来定义的。传统的ML算法(线性和逻辑回归、决策树、支持向量机、随机森林、Boosting算法、贝叶斯网络等。)可以用于任何长度的DNA序列。像CNN和RNN这样的现代人工神经网络算法要求整个数据集列中的DNA序列长度一致。PyDNA库提供了一个简单的函数来确定所选的DNA序列字符串是否包含统一的长度。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="8bab" class="jo jp hs kt b fi kx ky l kz la">dna_is_same_length = PyDNA.dna_sequence_is_equal_length(X)   <br/>if dna_is_same_length == False:<br/>    print("DNA sequence length validation")</span></pre><p id="82b6" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们看看第一个用例。假设我们需要建立一个分类模型，该模型可以基于人类DNA序列数据集预测一个基因家族。基于共享的核苷酸或蛋白质序列，基因被分类成家族。<a class="ae jn" href="https://en.wikipedia.org/wiki/Gene_family" rel="noopener ugc nofollow" target="_blank">基因家族</a>是几个相似基因的集合，由单个原始基因复制而成，一般具有相似的生化功能。这个案例将使用一个可以从GitHub网站下载的“human_data.txt”文件(<a class="ae jn" href="https://github.com/nageshsinghc4/DNA-Sequence-Machine-learning/blob/master/human_data.txt" rel="noopener ugc nofollow" target="_blank">https://GitHub . com/nageshsinghc 4/DNA-Sequence-Machine-learning/blob/master/human _ data . txt</a></p><p id="cfd9" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">熊猫数据框架的信息方法将为我们提供一个完整的数据集描述。它包含“序列”和“类”两列，共4380行。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="685e" class="jo jp hs kt b fi kx ky l kz la">&lt;class 'pandas.core.frame.DataFrame'&gt;<br/>RangeIndex: 4380 entries, 0 to 4379<br/>Data columns (total 2 columns):<br/> #   Column    Non-Null Count  Dtype<br/>---  ------    --------------  -----<br/> 0   sequence  4380 non-null   object<br/> 1   class     4380 non-null   int64<br/>dtypes: int64(1), object(1)<br/>memory usage: 68.6+ KB<br/>None</span></pre><p id="ae66" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">数据集示例:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="8574" class="jo jp hs kt b fi kx ky l kz la">sequence   class<br/>0     ATGCCCCAACTAAATACTACCGTATGGCCCACCATAATTACCCCCA...      4<br/>1     ATGAACGAAAATCTGTTCGCTTCATTCATTGCCCCCACAATCCTAG...      4<br/>2     ATGTGTGGCATTTGGGCGCTGTTTGGCAGTGATGATTGCCTTTCTG...      3<br/>3     ATGTGTGGCATTTGGGCGCTGTTTGGCAGTGATGATTGCCTTTCTG...      3<br/>[4380 rows x 2 columns]</span></pre><p id="9142" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如您所见，该数据集包含两个数据列。“序列”列是DNA序列字符串和“类别”列，包含7个可能的基因家族标签，如下表1所示。</p><figure class="ko kp kq kr fd hj er es paragraph-image"><div class="er es lq"><img src="../Images/8de6432a877f7a86101d595c3cac1455.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*5oSeCOioqp5XHVs5A9N8Mg.png"/></div></figure><p id="5ab6" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">表1。基因家族名称和计数。</p><p id="c2cd" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">图1显示了类标签的聊天记录。我们得到了这个数据集的<a class="ae jn" href="https://www.analyticsvidhya.com/blog/2017/03/imbalanced-data-classification/" rel="noopener ugc nofollow" target="_blank">不平衡类</a>情况。一般来说，在应用ML算法之前，这些类需要过采样或欠采样。让我们看看我们是否需要为我们的分类模型应用这些技术。</p><figure class="ko kp kq kr fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lr"><img src="../Images/f3c36823ac0be263061f96b3c1da10bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hDHpC2UNdto2eiBTTtIlEg.png"/></div></div></figure><p id="b6c1" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">图一。人类类标签蝙蝠图。</p><p id="ef84" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">以下是y级标签示例。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="e03c" class="jo jp hs kt b fi kx ky l kz la">y     class<br/>0       4<br/>1       4<br/>2       3<br/>3       3</span></pre><p id="bd1d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这是最终的X特性包的单词和类列示例。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="3d61" class="jo jp hs kt b fi kx ky l kz la"> X           class<br/>(0, 52803)     1<br/>(0, 207969)    1<br/>(0, 136621)    1<br/>(0, 79202)     1</span></pre><p id="702f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们检查DNA序列的长度是否一致。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="fb3b" class="jo jp hs kt b fi kx ky l kz la">X = PyDNA.select_df_column(df_dna, “sequence”)<br/>dna_is_same_length = PyDNA.dna_sequence_is_equal_length(X) <br/>print(dna_is_same_length)<br/>False</span></pre><p id="f814" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">结果为“假”，因此DNA序列长度在整个柱上是不一致的。在这种情况下，将使用传统的ML算法。</p><p id="2f3d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">基于PyDNA库，ML算法的完整代码如下所示。我对每一行代码都做了注释，让任何人都能理解这个程序是如何工作的。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="8c9e" class="jo jp hs kt b fi kx ky l kz la">import sys<br/>import time<br/>import os<br/>os.system("cls")</span><span id="d81e" class="jo jp hs kt b fi lb ky l kz la">import numpy as np<br/>import pandas as pd<br/>import matplotlib.pyplot as plt<br/>import seaborn as sns<br/>import xgboost as xgb</span><span id="d1de" class="jo jp hs kt b fi lb ky l kz la">from sklearn.feature_extraction.text import CountVectorizer<br/>from sklearn.model_selection import train_test_split<br/>from sklearn.metrics import classification_report, confusion_matrix, accuracy_score<br/>from sklearn.metrics import roc_auc_score, precision_score, recall_score, f1_score<br/>from sklearn.naive_bayes import MultinomialNB<br/>from sklearn.neural_network import MLPClassifier <br/>from sklearn.ensemble import RandomForestClassifier<br/>from sklearn.preprocessing import StandardScaler, MinMaxScaler, RobustScaler, MaxAbsScaler<br/>from pydna import PyDNA</span><span id="cfc3" class="jo jp hs kt b fi lb ky l kz la">import warnings                                  <br/>warnings.filterwarnings('ignore')</span><span id="e8d1" class="jo jp hs kt b fi lb ky l kz la">def get_program_running(start_time):<br/>    end_time = time. process_time()<br/>    diff_time = end_time - start_time<br/>    result = time.strftime("%H:%M:%S", time.gmtime(diff_time)) <br/>    print("program runtime: {}".format(result))</span><span id="2920" class="jo jp hs kt b fi lb ky l kz la">def main():<br/>    # text file path and name. this path to be defined in the project config file<br/>    human_data_txt = r"folder_path\human_data.txt"<br/>    <br/>    # data load<br/>    df_dna = PyDNA.pandas_read_data("TXT", human_data_txt, None)</span><span id="3ab6" class="jo jp hs kt b fi lb ky l kz la"># select y label<br/>    y = PyDNA.select_y_label(df_dna, "class")<br/>    <br/>    # generate a k-mer of words data frame column<br/>    df_dna = PyDNA.create_dataframe_column_words(df_dna, "sequence", "words") <br/>    <br/>    # show y label imbalanced classes plot<br/>    PyDNA.imbalanced_classes_plot(y, True, "class", "Gene Family Class", "Count", "Human Gene Family Classes")<br/>    <br/>    # generate X feature bag of works <br/>    X = PyDNA.bag_of_word_series(df_dna["words"], 4)   <br/>    <br/>    # data split in train, valid and test (80%/10%/10%)<br/>    X_train, y_train, X_valid, y_valid, X_test, y_test = PyDNA.train_validation_test_split(X, y, True, test_size=0.2, valid_size=0.5)<br/>    <br/>    # create machine learning model and optimize it's hyperparameters <br/>    ml_model, ml_model_hyperparameter = PyDNA.create_ml_model("MultinomialNB", X_train, y_train)<br/>    print(ml_model_hyperparameter)<br/>    <br/>    # get y predicted valid<br/>    y_predicted_valid = PyDNA.ml_model_predict(ml_model, X_valid)<br/>    <br/>    # calculate valid classification metrics<br/>    accuracy_score_value, precision_value, recall_value,    f1_score_value, confusion_matrix_value, classification_report_value = PyDNA.calculate_classification_metrics(y_valid, y_predicted_valid)<br/>    print("valid accuracy score:\n{}\n".format(accuracy_score_value))        <br/>    print("valid precision:\n{}\n".format(precision_value)) <br/>    print("valid recall:\n{}\n".format(recall_value)) <br/>    print("valid f1 score:\n{}\n".format(f1_score_value)) <br/>    print("valid confusion matrix:\n{}\n".format(confusion_matrix_value))  <br/>    print("valid classification report:\n{}\n".format(classification_report_value))  <br/>    <br/>    # get y predicted test<br/>    y_predicted_test = PyDNA.ml_model_predict(ml_model, X_test)<br/>    <br/>    # calculate test classification metrics<br/>    accuracy_score_value, precision_value, recall_value, f1_score_value, confusion_matrix_value, classification_report_value = PyDNA.calculate_classification_metrics(y_test, y_predicted_test)<br/>    print("test accuracy score:\n{}\n".format(accuracy_score_value))        <br/>    print("test precision:\n{}\n".format(precision_value)) <br/>    print("test recall:\n{}\n".format(recall_value)) <br/>    print("test f1 score:\n{}\n".format(f1_score_value)) <br/>    print("test confusion matrix:\n{}\n".format(confusion_matrix_value))  <br/>    print("test classification report:\n{}\n".format(classification_report_value))</span><span id="9293" class="jo jp hs kt b fi lb ky l kz la">if __name__ == '__main__':<br/>    start_time = time. process_time()<br/>    main()<br/>    get_program_running(start_time)</span></pre><p id="a61e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">以下是使用多项式朴素贝叶斯分类器模型的程序结果。结果显示了分类模型验证中使用的六个主要计算指标:准确度分数、精确度、召回率、f1分数、混淆矩阵和分类报告。对于我们的基因组数据集，97.7%的测试准确度分数是一个极好的结果。查看验证和测试准确度分值，我们可以确保模型过拟合/欠拟合问题不是我们的情况。由于这些原因，没有必要对我们的数据集应用任何不平衡的类方法。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="e4b1" class="jo jp hs kt b fi kx ky l kz la">validation accuracy score:<br/>98.858</span><span id="c655" class="jo jp hs kt b fi lb ky l kz la">validation precision:<br/>98.872</span><span id="33a3" class="jo jp hs kt b fi lb ky l kz la">validation recall:<br/>98.858</span><span id="63e8" class="jo jp hs kt b fi lb ky l kz la">validation f1 score:<br/>98.86</span><span id="2cd1" class="jo jp hs kt b fi lb ky l kz la">validation confusion matrix:<br/>[[ 53   0   0   0   0   0   0]<br/> [  0  52   0   0   0   1   0]<br/> [  0   0  35   0   0   0   0]<br/> [  0   0   0  66   1   0   0]<br/> [  1   0   0   0  69   0   1]<br/> [  0   0   0   0   0  24   0]<br/> [  0   0   0   0   1   0 134]]</span><span id="dd93" class="jo jp hs kt b fi lb ky l kz la">validation classification report:<br/>              precision    recall  f1-score   support</span><span id="99d5" class="jo jp hs kt b fi lb ky l kz la">0       0.98      1.00      0.99        53<br/>           1      1.00      0.98      0.99        53<br/>           2      1.00      1.00      1.00        35<br/>           3      1.00      0.99      0.99        67<br/>           4      0.97      0.97      0.97        71<br/>           5      0.96      1.00      0.98        24<br/>           6      0.99      0.99      0.99       135</span><span id="d16b" class="jo jp hs kt b fi lb ky l kz la">    accuracy                           0.99       438<br/>   macro avg      0.99      0.99       0.99       438<br/>weighted avg      0.99      0.99       0.99       438</span><span id="781c" class="jo jp hs kt b fi lb ky l kz la">test accuracy score:<br/>97.717</span><span id="b88b" class="jo jp hs kt b fi lb ky l kz la">test precision:<br/>97.8</span><span id="84de" class="jo jp hs kt b fi lb ky l kz la">test recall:<br/>97.717</span><span id="a2ed" class="jo jp hs kt b fi lb ky l kz la">test f1 score:<br/>97.732</span><span id="1727" class="jo jp hs kt b fi lb ky l kz la">test confusion matrix:<br/>[[ 50   0   0   0   3   0   0]<br/> [  0  53   0   0   0   0   1]<br/> [  0   0  35   0   0   0   0]<br/> [  0   0   0  67   0   0   0]<br/> [  0   1   0   0  70   0   0]<br/> [  0   0   0   0   0  23   1]<br/> [  0   0   0   0   1   3 130]]</span><span id="1419" class="jo jp hs kt b fi lb ky l kz la">test classification report:<br/>              precision    recall  f1-score   support</span><span id="65a2" class="jo jp hs kt b fi lb ky l kz la">0       1.00       0.94      0.97        53<br/>           1       0.98      0.98      0.98        54<br/>           2       1.00      1.00      1.00        35<br/>           3       1.00      1.00      1.00        67<br/>           4       0.95      0.99      0.97        71<br/>           5       0.88      0.96      0.92        24<br/>           6       0.98      0.97      0.98       134</span><span id="d11a" class="jo jp hs kt b fi lb ky l kz la">    accuracy                           0.98       438<br/>   macro avg       0.97      0.98      0.97       438<br/>weighted avg       0.98      0.98      0.98       438</span></pre><p id="e26b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">表2显示了应用不同类型的ML分类模型的结果。使用多项式朴素贝叶斯和多层感知器分类器模型获得了最好的结果，具有超过97%的测试准确度分数。逻辑回归和随机森林模型提供了大约92%的测试准确度分数。通常，随机森林模型实际上为许多可能的数据集提供了良好的结果。我建议任何ML回归和分类项目都从随机森林模型开始。梯度推进模型对我们的数据集不起作用。也许，总的来说，这些模型对于基因组数据集的分类还不够好。在接下来的博客文章中，我会提供更多的信息和新的结果。</p><figure class="ko kp kq kr fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ls"><img src="../Images/e061772943ad5a05dc34259585fb153b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JnqnXJABhCZiJvkdcXnY-A.png"/></div></div></figure><p id="daf0" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">表二。ML分类器用基因家族数据集模拟结果。</p><h2 id="b8c2" class="jo jp hs bd jq jr js jt ju jv jw jx jy ja jz ka kb je kc kd ke ji kf kg kh ki bi translated">23.卷积神经网络在DNA序列分类中的应用</h2><p id="d14c" class="pw-post-body-paragraph ip iq hs ir b is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji kn jk jl jm ha bi translated">在我们的第二个用例中，我们将预测DNA序列是否能与蛋白质结合。<a class="ae jn" href="https://en.wikipedia.org/wiki/DNA-binding_protein" rel="noopener ugc nofollow" target="_blank"> DNA结合蛋白质</a>是具有DNA结合结构域的蛋白质，因此对单链或双链DNA具有特异性或一般性亲和力。DNA结合结构域是一个独立折叠的蛋白质结构域，包含至少一个识别双链或单链DNA的结构基序。这是一个检测DNA序列中转录因子结合位点的标准功能基因组问题。</p><p id="6b91" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><a class="ae jn" href="https://en.wikipedia.org/wiki/Convolutional_neural_network" rel="noopener ugc nofollow" target="_blank">卷积神经网络</a> (CNN)是一类深度神经网络(DLN)，最常用于分析视觉图像。基于它们的共享权重架构和平移不变性特征，它们也被称为移位不变或空间不变人工神经网络(SIANN)。它们在图像和视频识别、推荐系统、图像分类、医学图像分析、自然语言处理、脑-机接口、金融时间序列等方面有应用。</p><p id="8cd9" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">众所周知，CNN通常用于二维(2D)和三维(3D)图像卷积分析。对于我们的基因组数据集，将应用简单的1D CNN模型和Keras库。DNA序列和标签文本数据的例子可以从以下URL链接下载:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="838c" class="jo jp hs kt b fi kx ky l kz la">dna_sequence = “<a class="ae jn" href="https://raw.githubusercontent.com/abidlabs/deep-learning-genomics" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/abidlabs/deep-learning-genomics</a><br/>-primer/master/sequences.txt”<br/>dna_label = “<a class="ae jn" href="https://raw.githubusercontent.com/abidlabs/deep-learning-genomics-primer/master/labels.txt" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/abidlabs/deep-learning-genomics-primer/master/labels.txt</a>"</span></pre><p id="a9e8" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">例如，在使用Jupyter笔记本的ML交互式项目中，将这些数据加载到pandas数据框架中需要一些程序运行时间。为了避免这种情况，PyDNA库中开发了一个简单的通用函数。该函数并行加载这两个链接，并创建一个包含DNA序列字符串和标签编号列的最终CSV文件。第三个参数“dna_sequence_protein”是CSV文件的定义名称。调用函数如下所示。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="5f5d" class="jo jp hs kt b fi kx ky l kz la">PyDNA.GenerateCSVFileParallel(dna_sequence, dna_label, ‘’dna_sequence_protein’’)</span></pre><p id="5b37" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">ML项目中的数据加载是一项备受关注的任务，尤其是在大数据领域。即使是一个有数百万行的简单数据集也会减慢加载熊猫数据帧的过程。应用像Python异步和多处理编程这样的技术将大大改进这个过程。以后我会为这个问题准备一篇好的博客论文。</p><p id="0249" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">表3显示了最终“dna_sequence_protein.csv”文件的十行。“dna_label”列包含两个二进制值:0-DNA序列不能与蛋白质结合，1-可以与蛋白质结合。这是一个简单的二元分类ML任务。</p><figure class="ko kp kq kr fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lt"><img src="../Images/0eb5fcfcbcb1cf309a8744e6246f4af5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*701JoDnYI0AdsIZeKa04qw.png"/></div></div></figure><p id="9a55" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">表3。dna_sequence_protein.csv '数据行。</p><p id="eed2" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为了查看数据集描述<strong class="ir ht">，</strong>，应用了熊猫数据帧信息方法。该数据集包含2，000行，具有两列“dna_sequence”字符串和“dna_label”二进制数0和1。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="9bdc" class="jo jp hs kt b fi kx ky l kz la">&lt;class 'pandas.core.frame.DataFrame'&gt;<br/>Int64Index: 2000 entries, 0 to 1999<br/>Data columns (total 2 columns):<br/> #   Column        Non-Null Count  Dtype<br/>---  ------        --------------  -----<br/> 0   dna_sequence  2000 non-null   object<br/> 1   dna_label     2000 non-null   int64<br/>dtypes: int64(1), object(1)<br/>memory usage: 46.9+ KB<br/>None</span></pre><p id="d2fd" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在应用任何人工神经网络模型之前，需要检查DNA序列长度的一致性。下面代码的结果是“真”，因此CNN和RNN模型可以应用于这个基因组数据集。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="1272" class="jo jp hs kt b fi kx ky l kz la">X = PyDNA.select_df_column(df_genomics, “dna_sequence”)<br/>dna_is_same_length = PyDNA.dna_sequence_is_equal_length(X) <br/>print(dna_is_same_length)</span></pre><p id="21f6" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">DNA序列和类别标签已经使用一键编码进行了编码。如前所述，这是CNN和RNN模型中主要的标准编码之一。一键编码(X特征)的DNA序列的例子如下所示。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="d52a" class="jo jp hs kt b fi kx ky l kz la">[[[0. 1. 0. 0.] <br/>  [0. 1. 0. 0.] <br/>  [0. 0. 1. 0.] <br/>  ...<br/>  [1. 0. 0. 0.] <br/>  [0. 1. 0. 0.] <br/>  [0. 1. 0. 0.]]</span><span id="53f0" class="jo jp hs kt b fi lb ky l kz la">[[0. 0. 1. 0.] <br/>  [1. 0. 0. 0.] <br/>  [0. 0. 1. 0.] <br/>  ...<br/>  [0. 0. 0. 1.] <br/>  [0. 1. 0. 0.] <br/>  [0. 0. 1. 0.]]</span><span id="36ed" class="jo jp hs kt b fi lb ky l kz la">[[0. 0. 1. 0.] <br/>  [1. 0. 0. 0.] <br/>  [0. 0. 0. 1.] <br/>  ...<br/>  [0. 1. 0. 0.] <br/>  [0. 1. 0. 0.] <br/>  [0. 0. 0. 1.]]]</span></pre><p id="518c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这里是类标签one-hot编码(y标签)。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="d248" class="jo jp hs kt b fi kx ky l kz la">[[1. 0.]<br/> [1. 0.]<br/> [1. 0.]<br/> ...<br/> [1. 0.]<br/> [0. 1.]<br/> [0. 1.]]</span></pre><p id="18ca" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">下面是使用PyDNA自定义库实现该基因组数据集的CNN模型的完整程序代码。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="76fa" class="jo jp hs kt b fi kx ky l kz la">import sys<br/>import time<br/>import os<br/>os.system("cls")<br/>os.environ['TF_CPP_MIN_LOG_LEVEL'] = '2'</span><span id="4650" class="jo jp hs kt b fi lb ky l kz la">import tensorflow as tf<br/>tf.random.set_seed(10)</span><span id="24ca" class="jo jp hs kt b fi lb ky l kz la">import tensorflow.keras.backend as K<br/>from tensorflow.keras.models import load_model<br/>import numpy as np<br/>import pandas as pd<br/>import matplotlib.pyplot as plt<br/>import seaborn as sns<br/>import requests<br/>from sklearn.preprocessing import LabelEncoder, OneHotEncoder<br/>from sklearn.model_selection import train_test_split<br/>from sklearn.metrics import classification_report, confusion_matrix, accuracy_score<br/>from sklearn.metrics import roc_auc_score, precision_score, recall_score, f1_score<br/>from pydna import PyDNA</span><span id="bba5" class="jo jp hs kt b fi lb ky l kz la">import warnings<br/>warnings.filterwarnings("ignore")</span><span id="83c0" class="jo jp hs kt b fi lb ky l kz la">def get_program_running(start_time):<br/>    end_time = time.process_time()<br/>    diff_time = end_time - start_time<br/>    result = time.strftime("%H:%M:%S", time.gmtime(diff_time)) <br/>    print("program runtime: {}".format(result))<br/>    <br/>def main():<br/>    # csv file path and name<br/>    csv_path_file = r"csv_file_path/name.csv"</span><span id="ffd2" class="jo jp hs kt b fi lb ky l kz la"># data frame load<br/>    df_genomics = PyDNA.pandas_read_data("CSV", csv_path_file, None)</span><span id="b04a" class="jo jp hs kt b fi lb ky l kz la"># remove rows and columns with missing values.<br/>    df_genomics.dropna(how="all", inplace=True)</span><span id="5131" class="jo jp hs kt b fi lb ky l kz la"># select X features<br/>    X = PyDNA.select_df_column(df_genomics, "dna_sequence")</span><span id="995c" class="jo jp hs kt b fi lb ky l kz la"># check if dna sequences have the same legnth - part of dna sequence preprocessing!  <br/>    dna_is_same_length = PyDNA.dna_sequence_is_equal_length(X)   <br/>    if dna_is_same_length == False:<br/>        exit()</span><span id="b0d9" class="jo jp hs kt b fi lb ky l kz la"># X features one-hot encoder<br/>    X = PyDNA.cnn_X_onehot_encoder(X)</span><span id="6632" class="jo jp hs kt b fi lb ky l kz la"># select y label<br/>    y = PyDNA.select_df_column(df_genomics, "dna_label")</span><span id="c1fa" class="jo jp hs kt b fi lb ky l kz la"># show y label imbalanced classes plot<br/>    PyDNA.imbalanced_classes_plot(y, True, "dna_label", "DNA bind to protein class", "Count", "DNA Sequence Protein Classes")</span><span id="4a6d" class="jo jp hs kt b fi lb ky l kz la"># y label one-hot encoder<br/>    y = PyDNA.cnn_y_onehot_encoder(y)</span><span id="969c" class="jo jp hs kt b fi lb ky l kz la"># data split in train, valid and test (80%/10%/10%)<br/>    X_train, y_train, X_valid, y_valid, X_test, y_test = PyDNA.train_validation_test_split(X, y, test_size=0.2, valid_size=0.5)</span><span id="544f" class="jo jp hs kt b fi lb ky l kz la"># create cnn model and get loss/metrics values history<br/>    epochs = 50<br/>    data_split = 0.2    <br/>    cnn_model, cnn_history = PyDNA.create_cnn_model(y_train, X_train, epochs, data_split)</span><span id="1e9c" class="jo jp hs kt b fi lb ky l kz la"># plot cnn model loss<br/>    font_size = 8<br/>    PyDNA.cnn_model_loss_plot(cnn_history, font_size, "CNN Model Loss", "Epoch", "Loss", ["Train", "Validation"])</span><span id="3d53" class="jo jp hs kt b fi lb ky l kz la"># plot cnn model accuracy<br/>    PyDNA.cnn_model_accuracy_plot(cnn_history, font_size, "CNN Model Accuracy", "Epoch", "Accuracy", ["Train", "Validation"])</span><span id="7c44" class="jo jp hs kt b fi lb ky l kz la">print("Model Validation")<br/>    # get y_predicted valid<br/>    y_predicted = cnn_model.predict(X_valid)</span><span id="b8c7" class="jo jp hs kt b fi lb ky l kz la"># get max indices of the maximum values along an axis<br/>    y_val_max = PyDNA.get_max_nparray(y_valid)<br/>    y_predicted_max = PyDNA.get_max_nparray(y_predicted)</span><span id="37c7" class="jo jp hs kt b fi lb ky l kz la"># calculate valid classification metrics<br/>    accuracy_score_value, precision_value, recall_value, f1_score_value, confusion_matrix_value, classification_report_value = PyDNA.calculate_classification_metrics(y_val_max, y_predicted_max)<br/>    print("valid accuracy score:\n{}\n".format(accuracy_score_value))        <br/>    print("valid precision:\n{}\n".format(precision_value)) <br/>    print("valid recall:\n{}\n".format(recall_value)) <br/>    print("valid f1 score:\n{}\n".format(f1_score_value)) <br/>    print("valid confusion matrix:\n{}\n".format(confusion_matrix_value))  <br/>    print("valid classification report:\n{}\n".format(classification_report_value))</span><span id="1baf" class="jo jp hs kt b fi lb ky l kz la">print("Model Test")<br/>    # get y_predicted test<br/>    y_predicted = cnn_model.predict(X_test)<br/>    <br/>    # get max indices of the maximum values along an axis<br/>    y_test_max = PyDNA.get_max_nparray(y_test)    <br/>    y_predicted_max = PyDNA.get_max_nparray(y_predicted)</span><span id="5588" class="jo jp hs kt b fi lb ky l kz la"># calculate test classification metrics<br/>    accuracy_score_value, precision_value, recall_value, f1_score_value, confusion_matrix_value, classification_report_value = PyDNA.calculate_classification_metrics(y_test_max, y_predicted_max)<br/>    print("test accuracy score:\n{}\n".format(accuracy_score_value))        <br/>    print("test precision:\n{}\n".format(precision_value)) <br/>    print("test recall:\n{}\n".format(recall_value)) <br/>    print("test f1 score:\n{}\n".format(f1_score_value)) <br/>    print("test confusion matrix:\n{}\n".format(confusion_matrix_value))  <br/>    print("test classification report:\n{}\n".format(classification_report_value))   <br/>    <br/>    # save cnn model h5<br/>    cnn_model_path = r"cnn_model_path  "<br/>    cnn_model_name = "cnn_model_name"    <br/>    PyDNA.cnn_model_save_h5(cnn_model, cnn_model_path, cnn_model_name)<br/>   <br/>    # load cnn model h5<br/>    cnn_model = PyDNA.cnn_model_load_h5(cnn_model_path, cnn_model_name)<br/>    print(cnn_model)</span><span id="ccb5" class="jo jp hs kt b fi lb ky l kz la">if __name__ == '__main__':<br/>    start_time = time.process_time()<br/>    main()<br/>    get_program_running(start_time)</span></pre><p id="d32c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在ML分类项目中首先要做的事情之一是检查不平衡的类，就像我们对以前的基因家族数据集所做的那样。图2显示了DNA二进制类标签的聊天记录。很明显，这两个类别的标签都处于良好的平衡状态。</p><figure class="ko kp kq kr fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lu"><img src="../Images/29863c48f402d081cc72784d2f09def8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9VeNT22SwTFQuJ6KZPN5aQ.png"/></div></div></figure><p id="93e3" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">图二。DNA二元分类标签条形图。</p><p id="9f27" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">该计划的结果如下所示。97.0 %的测试准确度分数是非常好的分数。这种CNN模型可以用于对DNA序列进行分类，该DNA序列可以与蛋白质结合，也可以不与蛋白质结合。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="a4fc" class="jo jp hs kt b fi kx ky l kz la">Layer (type)                 Output Shape              Param #   <br/>=================================================================<br/>conv1d_1 (Conv1D)            (None, 39, 32)             1568      <br/>_________________________________________________________________<br/>max_pooling1d_1 (MaxPooling1 (None, 9, 32)              0<br/>_________________________________________________________________<br/>flatten_1 (Flatten)          (None, 288)                0<br/>_________________________________________________________________<br/>dense_1 (Dense)              (None, 16)                 4624      <br/>_________________________________________________________________<br/>dense_2 (Dense)              (None, 2)                  34        <br/>=================================================================<br/>Total params: 6,226<br/>Trainable params: 6,226<br/>Non-trainable params: 0<br/>_________________________________________________________________</span><span id="44ff" class="jo jp hs kt b fi lb ky l kz la">validation accuracy score:<br/>97.5</span><span id="f27c" class="jo jp hs kt b fi lb ky l kz la">validation precision:<br/>97.544</span><span id="9957" class="jo jp hs kt b fi lb ky l kz la">validation recall:<br/>97.5</span><span id="4da1" class="jo jp hs kt b fi lb ky l kz la">validation f1 score:<br/>97.5</span><span id="e837" class="jo jp hs kt b fi lb ky l kz la">validation confusion matrix:<br/>[[98  4]<br/> [ 1 97]]</span><span id="7786" class="jo jp hs kt b fi lb ky l kz la">validation classification report:<br/>              precision    recall  f1-score   support</span><span id="2a85" class="jo jp hs kt b fi lb ky l kz la">           0      0.99      0.96      0.98       102<br/>           1      0.96      0.99      0.97        98</span><span id="e6c7" class="jo jp hs kt b fi lb ky l kz la">    accuracy                           0.97       200<br/>   macro avg      0.98      0.98       0.97       200<br/>weighted avg      0.98      0.97       0.98       200</span><span id="7208" class="jo jp hs kt b fi lb ky l kz la">test accuracy score:<br/>97.0</span><span id="c4c3" class="jo jp hs kt b fi lb ky l kz la">test precision:<br/>97.019</span><span id="a663" class="jo jp hs kt b fi lb ky l kz la">test recall:<br/>97.0</span><span id="f2ef" class="jo jp hs kt b fi lb ky l kz la">test f1 score:<br/>97.0</span><span id="b0a0" class="jo jp hs kt b fi lb ky l kz la">test confusion matrix:<br/>[[97  4]<br/> [ 2 97]]</span><span id="49ad" class="jo jp hs kt b fi lb ky l kz la">test classification report:<br/>              precision    recall  f1-score   support</span><span id="6858" class="jo jp hs kt b fi lb ky l kz la">           0      0.98      0.96      0.97       101<br/>           1      0.96      0.98      0.97        99</span><span id="786d" class="jo jp hs kt b fi lb ky l kz la">    accuracy                           0.97       200<br/>   macro avg      0.97      0.97       0.97       200<br/>weighted avg      0.97      0.97       0.97       200</span></pre><p id="d061" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在ML中使用CNN来可视化和验证基于历元迭代的训练/验证集的损失和准确度图是一个很好的实践。历元数是一个模型超参数，它定义了学习算法在整个训练数据集中工作的次数。图3示出了CNN模型训练/验证损失图(曲线)。一旦验证集的损失在整个学习周期中停止改善或变得更糟，就应该停止训练，因为模型已经收敛，可能只是<a class="ae jn" href="https://datascience.foundation/sciencewhitepaper/underfitting-and-overfitting-in-machine-learning" rel="noopener ugc nofollow" target="_blank">过度拟合</a>。在我们的例子中，历元的数量应该在40和50之间。这个数字不应该小于40，以防止模型欠拟合。因此，历元数的选择对于保证CNN模型的准确率非常重要。</p><figure class="ko kp kq kr fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lv"><img src="../Images/d5fafd854573f843233d62490060295f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ssuncqRSu8k-CZelGSDYOg.png"/></div></div></figure><p id="7cbc" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">图3。CNN模型训练/验证损失图。</p><p id="5f49" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">图4显示了CNN模型训练/验证准确度图。如您所见，经过30个时期后，验证集的准确性保持稳定。因此，结合这两个图，我们可以得出结论，对于这个特定的基因组数据集，选择40到50之间的代数是一个好的解决方案。</p><figure class="ko kp kq kr fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lw"><img src="../Images/5c252f69c20bc4cc022208650dce5eda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PiGjvnLYD463XisbREykGA.png"/></div></div></figure><p id="6131" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">图4。CNN模型训练/验证准确度图。</p><h2 id="7c36" class="jo jp hs bd jq jr js jt ju jv jw jx jy ja jz ka kb je kc kd ke ji kf kg kh ki bi translated">24.应用长短期记忆网络(LSTM)进行DNA序列分类</h2><p id="7591" class="pw-post-body-paragraph ip iq hs ir b is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji kn jk jl jm ha bi translated"><a class="ae jn" href="https://en.wikipedia.org/wiki/Recurrent_neural_network" rel="noopener ugc nofollow" target="_blank">递归神经网络</a> (RNN)是一类人工神经网络(ANN)，其中节点之间的连接沿着时间序列形成有向图。这允许它展示时间动态行为。源自前馈神经网络的rnn可以使用其内部状态(记忆)来处理可变长度的输入序列。这使得它们适用于诸如未分段的、连接的手写识别或语音识别之类的任务。</p><p id="a644" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><a class="ae jn" href="https://en.wikipedia.org/wiki/Long_short-term_memory" rel="noopener ugc nofollow" target="_blank">长短期记忆</a> (LSTM)是RNN架构在深度学习领域的运用。与标准的前馈神经网络不同，LSTM有反馈连接。它不仅可以处理单个数据点(如图像)，还可以处理整个数据序列(如语音或视频)。例如，LSTM适用于诸如未分段的、连接的手写识别、语音识别和网络流量或IDSs中的异常检测等任务。</p><p id="2f5a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">假设有足够的数据可用，LSTMs能够通过记忆序列中的许多先前步骤来学习长期依赖性。LSTM为任何可能存在层次分解的顺序处理任务提供了希望，但他事先并不知道这种分解是什么。如果我们将DNA定义为具有长记忆性的序列，这种长记忆性是通过序列的长程相关性表现出来的，那么为什么不将LSTM算法应用于DNA序列分类呢？</p><p id="49d4" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">要运行LSTM算法，需要对前面使用CNN的程序进行以下更改。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="c4b4" class="jo jp hs kt b fi kx ky l kz la"># create lstm model and get loss/metrics values history<br/>epoch = 50<br/>data_split = 0.2    <br/>lstm_model, lstm_history = PyDNA.create_lstm_model(y_train, X_train, epoch, data_split)</span><span id="90e3" class="jo jp hs kt b fi lb ky l kz la"># plot lstm model loss<br/>font_size = 8<br/>PyDNA. lstm_model_loss_plot(lstm_history, font_size, "LSTM Model Loss", "Epoch", "Loss", ["Train", "Validation"])</span><span id="f9ef" class="jo jp hs kt b fi lb ky l kz la"># plot lstm model accuracy<br/>PyDNA.lstm_model_accuracy_plot(lstm_history, font_size, "LSTM Model Accuracy", "Epoch", "Accuracy", ["Train", "Validation"])</span></pre><p id="96a9" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">对于同一个“dna_sequence_protein.csv”文件，结果如下所示。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="14bd" class="jo jp hs kt b fi kx ky l kz la">_________________________________________________________________<br/>Layer (type)                 Output Shape              Param #   <br/>=================================================================<br/>conv1d_1 (Conv1D)            (None, 39, 32)            1568      <br/>_________________________________________________________________<br/>lstm_1 (LSTM)                (None, 39, 64)            24832     <br/>_________________________________________________________________<br/>max_pooling1d_1 (MaxPooling1 (None, 9, 64)             0<br/>_________________________________________________________________<br/>flatten_1 (Flatten)          (None, 576)               0<br/>_________________________________________________________________<br/>masking_1 (Masking)          (None, 576)               0<br/>_________________________________________________________________<br/>dense_1 (Dense)              (None, 64)                36928     <br/>_________________________________________________________________<br/>dropout_1 (Dropout)          (None, 64)                0<br/>_________________________________________________________________<br/>dense_2 (Dense)              (None, 2)                 130<br/>=================================================================<br/>Total params: 63,458<br/>Trainable params: 63,458<br/>Non-trainable params: 0<br/>_________________________________________________________________<br/><br/>validation accuracy score:<br/>98.5</span><span id="54a1" class="jo jp hs kt b fi lb ky l kz la">validation precision:<br/>98.545</span><span id="fa2b" class="jo jp hs kt b fi lb ky l kz la">validation recall:<br/>98.5</span><span id="eee4" class="jo jp hs kt b fi lb ky l kz la">validation f1 score:<br/>98.5</span><span id="aa74" class="jo jp hs kt b fi lb ky l kz la">validation confusion matrix:<br/>[[99  3]<br/> [ 0 98]]</span><span id="2e26" class="jo jp hs kt b fi lb ky l kz la">validation classification report:<br/>              precision    recall  f1-score   support</span><span id="0710" class="jo jp hs kt b fi lb ky l kz la">           0      1.00      0.97      0.99       102<br/>           1      0.97      1.00      0.98        98</span><span id="933b" class="jo jp hs kt b fi lb ky l kz la">    accuracy                           0.98       200<br/>   macro avg      0.99      0.99       0.98       200<br/>weighted avg      0.99      0.98       0.99       200</span><span id="fa83" class="jo jp hs kt b fi lb ky l kz la">test accuracy score:<br/>99.5</span><span id="a621" class="jo jp hs kt b fi lb ky l kz la">test precision:<br/>99.505</span><span id="e613" class="jo jp hs kt b fi lb ky l kz la">test recall:<br/>99.5</span><span id="8d26" class="jo jp hs kt b fi lb ky l kz la">test f1 score:<br/>99.5</span><span id="344d" class="jo jp hs kt b fi lb ky l kz la">test confusion matrix:<br/>[[100   1]<br/> [  0  99]]</span><span id="198a" class="jo jp hs kt b fi lb ky l kz la">test classification report:<br/>              precision    recall  f1-score   support</span><span id="f82f" class="jo jp hs kt b fi lb ky l kz la">           0      1.00      0.99      1.00       101<br/>           1      0.99      1.00      0.99        99</span><span id="ef93" class="jo jp hs kt b fi lb ky l kz la">    accuracy                           0.99       200<br/>   macro avg      0.99      1.00       0.99       200<br/>weighted avg      1.00      0.99       1.00       200</span></pre><p id="ded4" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在测试数据上评估模型性能时，获得的准确度分数为99.5%。我运行了几个基因组数据集，LSTM算法提供了迄今为止最好的DNA序列分类结果。如果我们应用多层感知器分类器算法MLPClassifier()，最终结果可以如下所示。测试准确率评分非常好，达到98.0%。LSTM算法性能更好。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="0a70" class="jo jp hs kt b fi kx ky l kz la">validation accuracy score:<br/>96.0</span><span id="381b" class="jo jp hs kt b fi lb ky l kz la">validation precision:<br/>96.299</span><span id="b9ea" class="jo jp hs kt b fi lb ky l kz la">validation recall:<br/>96.0</span><span id="efc6" class="jo jp hs kt b fi lb ky l kz la">validation f1 score:<br/>95.995</span><span id="f786" class="jo jp hs kt b fi lb ky l kz la">validation confusion matrix:<br/>[[93  8]<br/> [ 0 99]]</span><span id="0ed2" class="jo jp hs kt b fi lb ky l kz la">validation classification report:<br/>              precision    recall  f1-score   support</span><span id="8373" class="jo jp hs kt b fi lb ky l kz la">           0      1.00      0.92      0.96       101<br/>           1      0.93      1.00      0.96        99</span><span id="c16f" class="jo jp hs kt b fi lb ky l kz la">    accuracy                           0.96       200<br/>   macro avg      0.96      0.96       0.96       200<br/>weighted avg      0.96      0.96       0.96       200</span><span id="2196" class="jo jp hs kt b fi lb ky l kz la">test accuracy score:<br/>98.0</span><span id="5339" class="jo jp hs kt b fi lb ky l kz la">test precision:<br/>98.078</span><span id="1b3c" class="jo jp hs kt b fi lb ky l kz la">test recall:<br/>98.0</span><span id="e0d7" class="jo jp hs kt b fi lb ky l kz la">test f1 score:<br/>98.0</span><span id="1c27" class="jo jp hs kt b fi lb ky l kz la">test confusion matrix:<br/>[[98  4]<br/> [ 0 98]]</span><span id="fe9d" class="jo jp hs kt b fi lb ky l kz la">test classification report:<br/>              precision    recall  f1-score   support</span><span id="d8a1" class="jo jp hs kt b fi lb ky l kz la">           0      1.00      0.96      0.98       102<br/>           1      0.96      1.00      0.98        98</span><span id="0946" class="jo jp hs kt b fi lb ky l kz la">    accuracy                           0.98       200<br/>   macro avg      0.98      0.98       0.98       200<br/>weighted avg      0.98      0.98       0.98       200</span></pre><p id="06f4" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">图5和图6显示了LSTM模型训练/验证损失和准确度图。正如我们可以看到的<strong class="ir ht">，</strong>选择30到40之间的历元数可以保证良好的LSTM模型性能。</p><figure class="ko kp kq kr fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lx"><img src="../Images/f80a33f08c29c8a52ba07177759dd22d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hOH33sAuMgk4KOCc_PkL3g.png"/></div></div></figure><p id="4516" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">图5。LSTM模型火车/验证损失图。</p><figure class="ko kp kq kr fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lr"><img src="../Images/8c7c995afbef901588863804e747941e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JsVmoICxMT0a4f4UcLlw5w.png"/></div></div></figure><p id="c100" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">图6。LSTM模型训练/验证精度图。</p><p id="1634" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">以下结果是使用多项式朴素贝叶斯分类器模型MultinomialNB()获得的。正如你所看到的，这个分类器在这个特定的基因组数据集上表现得不是很好。这是一个很好的实践例子，证明每个基因组数据集都是唯一的，任何数据科学家的最佳实践是对每个数据集应用所有传统和现代的ML算法。许多数据科学家认为深度学习可以为他们做ML中的一切事情。这是非常简单和容易证明的，即使是随机森林和极端梯度提升算法在许多情况下也比包括CNN和LSTM在内的深度学习算法表现得更好。因此，始终对每个特定的基因组数据集应用所有这些指标，并使用指标性能更好的指标。我知道这可能需要一些时间，但这是获得最佳模型的必要条件。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="4484" class="jo jp hs kt b fi kx ky l kz la">validation accuracy score:<br/>80.5</span><span id="7bd8" class="jo jp hs kt b fi lb ky l kz la">validation precision:<br/>86.011</span><span id="3ca0" class="jo jp hs kt b fi lb ky l kz la">validation recall:<br/>80.5</span><span id="afed" class="jo jp hs kt b fi lb ky l kz la">validation f1 score:<br/>79.772</span><span id="6555" class="jo jp hs kt b fi lb ky l kz la">validation confusion matrix:<br/>[[62 39]<br/> [ 0 99]]</span><span id="84ef" class="jo jp hs kt b fi lb ky l kz la">validation classification report:<br/>              precision    recall  f1-score   support</span><span id="f6a6" class="jo jp hs kt b fi lb ky l kz la">           0      1.00      0.61      0.76       101<br/>           1      0.72      1.00      0.84        99</span><span id="0b90" class="jo jp hs kt b fi lb ky l kz la">    accuracy                           0.81       200<br/>   macro avg      0.86      0.81       0.80       200<br/>weighted avg      0.86      0.81       0.80       200</span><span id="0756" class="jo jp hs kt b fi lb ky l kz la">test accuracy score:<br/>79.5</span><span id="1384" class="jo jp hs kt b fi lb ky l kz la">test precision:<br/>85.547</span><span id="3030" class="jo jp hs kt b fi lb ky l kz la">test recall:<br/>79.5</span><span id="0328" class="jo jp hs kt b fi lb ky l kz la">test f1 score:<br/>78.695</span><span id="8245" class="jo jp hs kt b fi lb ky l kz la">test confusion matrix:<br/>[[61 41]<br/> [ 0 98]]</span><span id="b96a" class="jo jp hs kt b fi lb ky l kz la">test classification report:<br/>              precision    recall  f1-score   support</span><span id="6c0d" class="jo jp hs kt b fi lb ky l kz la">           0      1.00      0.60      0.75       102<br/>           1      0.71      1.00      0.83        98</span><span id="228f" class="jo jp hs kt b fi lb ky l kz la">    accuracy                           0.80       200<br/>   macro avg      0.85      0.80       0.79       200<br/>weighted avg      0.86      0.80       0.79       200</span></pre><h2 id="56e1" class="jo jp hs bd jq jr js jt ju jv jw jx jy ja jz ka kb je kc kd ke ji kf kg kh ki bi translated">25.结论</h2><ul class=""><li id="7dd8" class="lc ld hs ir b is kj iw kk ja ly je lz ji ma jm lh li lj lk bi translated">为DNA/RNA/蛋白质序列字符串处理和ML分类基因组数据集开发了自定义Python库PyDNA。</li><li id="b86a" class="lc ld hs ir b is ll iw lm ja ln je lo ji lp jm lh li lj lk bi translated">为了提高大型DNA序列字符串处理的性能，建议尽可能使用NumPy ndarrys。</li><li id="22b6" class="lc ld hs ir b is ll iw lm ja ln je lo ji lp jm lh li lj lk bi translated">介绍并分析了以下几种主要的DNA序列编码:标签编码、一键编码和K-mer计数。</li><li id="5ed7" class="lc ld hs ir b is ll iw lm ja ln je lo ji lp jm lh li lj lk bi translated">实现了自然语言处理单词包算法，用于DNA序列串的处理。</li><li id="08bb" class="lc ld hs ir b is ll iw lm ja ln je lo ji lp jm lh li lj lk bi translated">整个数据集中DNA序列长度的一致性可以决定使用正确的ML算法。</li><li id="2eab" class="lc ld hs ir b is ll iw lm ja ln je lo ji lp jm lh li lj lk bi translated">多项式朴素和多层感知器分类器模型在DNA多类数据集和无统一字符串长度的情况下提供了超过97%的分类准确度分数。</li><li id="17eb" class="lc ld hs ir b is ll iw lm ja ln je lo ji lp jm lh li lj lk bi translated">卷积神经网络模型在DNA序列串长度一致的情况下可以提供97%的分类精度。</li><li id="d1c4" class="lc ld hs ir b is ll iw lm ja ln je lo ji lp jm lh li lj lk bi translated">长短期记忆模型提供了最好的结果，在DNA均匀序列串长度的情况下具有99.5%的分类准确度分数。</li><li id="06be" class="lc ld hs ir b is ll iw lm ja ln je lo ji lp jm lh li lj lk bi translated">强烈建议将所有传统和现代ML分类算法应用于任何基因组数据集，并找出哪个模型提供最佳预测结果。</li></ul></div></div>    
</body>
</html>