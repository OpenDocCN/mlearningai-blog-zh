<html>
<head>
<title>End-to-End Image Recognition With Open Source Data — Part 2: Model Deployment with Plotly Dash and Heroku</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用开源数据的端到端图像识别—第2部分:使用Plotly Dash和Heroku的模型部署</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/end-to-end-image-recognition-with-open-source-data-part-2-model-deployment-with-plotly-dash-and-3c8608b99faa?source=collection_archive---------2-----------------------#2021-05-05">https://medium.com/mlearning-ai/end-to-end-image-recognition-with-open-source-data-part-2-model-deployment-with-plotly-dash-and-3c8608b99faa?source=collection_archive---------2-----------------------#2021-05-05</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/e23d0b21dbdc718ab4054d5e29a7995a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GW4K54w7aTg5HYZGtRjQ0w.png"/></div></div></figure><div class=""/><p id="bb31" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Dash部署初学者指南:部署一个对纽约大都会艺术博物馆的绘画进行分类的模型</p><p id="754f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在本系列的第1部分<a class="ae jn" href="https://data4help.medium.com/end-to-end-image-recognition-with-open-source-data-part-1-data-acquisition-model-training-fe9f4be9b915" rel="noopener">中，我们展示了我们如何从大都会艺术博物馆收集和分析开源图像数据，以构建一个图像分类器，根据画作的来源国对其进行分类。在本帖中，我们将更进一步，展示如何利用这个训练有素的模型，并通过一个交互式前端仪表板将它变为现实。</a></p><p id="e36c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这篇文章旨在为那些对部署他们的模型和学习Plotly Dash和Heroku的基础知识感兴趣的数据科学家提供一个教程。</p><h1 id="d048" class="jo jp hs bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">如何部署？</h1><p id="3ca6" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">部署的第一步是决定如何以及在哪里部署你的应用。你可能会问自己有哪些选择，以及如何最好地展示你的预测。这有很多选择。</p><p id="1c41" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">最直接的选择之一是将您的模型部署为一个简单的web应用程序。这意味着您的模型变成了一个可以接受请求的web服务。假设最初用于训练模型的输入要素相同，您可以将请求视为模型预测的订单。然后，web服务通过模型运行这些输入要素，并将预测作为输出返回。web服务的美妙之处在于，它的输出几乎可以被任何其他应用程序使用，包括用其他语言编写的应用程序。这使得简单的web服务非常适合与其他计算机组件进行交互。在这里，我们将介绍如何将您的模型部署为一个简单的web应用<a class="ae jn" rel="noopener" href="/swlh/bringing-your-ml-models-to-life-with-flask-620c21461c8">。</a></p><p id="f8ad" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">但是如果我们不太在意自己的预测很容易被其他app消费呢？如果我们更关心它们容易被人类吃掉呢？图像识别尤其是机器学习的一个高度视觉化的领域。在这种情况下，不仅仅是从web服务中以文本字符串的形式返回预测，而是将它与相应的图像一起显示，通常是有意义的。</p><p id="e142" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为此，我们需要构建一个前端可视化应用程序。为此，我们将使用Plotly Dash，这是一个用Python构建前端应用程序和仪表板的流行框架。本质上，Dash允许你用Python写HTML和CSS代码。这两种语言通常用于创建网站，以添加按钮和滚动条等元素，并更改网页中的颜色和字体。</p><h1 id="c833" class="jo jp hs bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">我们应用的架构</h1><p id="e002" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">在深入研究代码之前，重要的是要考虑我们希望我们的前端应用程序是什么样子，以及我们的用户将如何与之交互。</p><h2 id="f717" class="kr jp hs bd jq ks kt ku ju kv kw kx jy ja ky kz kc je la lb kg ji lc ld kk le bi translated">模型输入</h2><p id="4441" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">第一步是决定如何将输入图像输入到我们的模型中。我们为此考虑了多种不同的选择。例如，用户可以选择上传一幅新的、看不见的画。然而，这需要用户做更多的工作，因为他们首先需要找到并下载一张图片，然后上传到应用程序中。我们的主要目标是让用户能够与模型互动并立即看到预测，因此我们开始考虑用户可以生成模型预测图像的其他方式。</p><p id="5441" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">最终，我们决定最好是让用户从大都会博物馆的收藏中随机生成一幅图像，并在此基础上进行预测。</p><p id="d075" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">另一种选择是利用下拉选择器来允许用户选择特定的绘画，或者从给定的文化中选择绘画。</p><h2 id="62ef" class="kr jp hs bd jq ks kt ku ju kv kw kx jy ja ky kz kc je la lb kg ji lc ld kk le bi translated">模型输出</h2><p id="91d9" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">一旦我们决定创建一个随机图像生成器来生成模型的输入图像，我们就必须决定输出预测应该如何显示。</p><p id="8765" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们决定简单地在图像下面显示预测，用预测标签的颜色变化来表示预测是否正确:如果预测不正确，预测标签应该显示为红色，如果正确，则显示为绿色。</p><p id="a8e6" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">另一个想法是显示模型预测的每个文化标签的相对可能性，而不是简单地显示可能性最高的标签(最终预测)。对于那些被模型错误预测的画作来说，这将是特别有趣的。</p><p id="966d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">设计我们的应用程序架构的最后一步是勾画出我们希望我们的简单应用程序是什么样子，这样我们就知道在哪里放置每个组件。这个粗略的轮廓如下所示。</p><figure class="lg lh li lj fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lf"><img src="../Images/857907e659761bf3b825857213dd70c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IO_ihnjcyggUeGSXTwkxhw.png"/></div></div><figcaption class="lk ll et er es lm ln bd b be z dx">Rough sketch of the layout of the app</figcaption></figure><h1 id="bf69" class="jo jp hs bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">构建应用程序</h1><p id="f234" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">既然我们已经决定了应用程序的输入和输出，也就是说它应该显示什么以及应用程序的用户应该如何与之交互，那么是时候开始使用Plotly Dash来构建它了。</p><p id="f6bf" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">构建Dash应用程序的第一步是初始化应用程序。只要运行包含应用程序代码的Python脚本(方便地称为app.py ),就会调用该应用程序。当调用应用程序时，它通过本地端口呈现。在命令行中运行app.py脚本后，端口地址将显示在终端中。点击这个本地端口链接会启动一个显示应用程序的浏览器页面。这一步的简单启动代码如下所示。启动一个app就这么简单！</p><figure class="lg lh li lj fd hj"><div class="bz dy l di"><div class="lo lp l"/></div><figcaption class="lk ll et er es lm ln bd b be z dx">Starter script for building your first Dash app</figcaption></figure><p id="2ca2" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在<code class="du lq lr ls lt b">app.run_server()</code>调用中，我们设置了<code class="du lq lr ls lt b">debug=True</code>,使我们的应用程序能够在我们做出更改时自动更新。</p><p id="cb4b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一开始，这款应用只是一个空白的网页。<strong class="ir ht">要构建我们的应用程序，我们只需将Dash组件添加到这个空白页，按照我们希望它们在网页上出现的顺序。</strong></p><p id="4c7e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">该应用程序的所有组件都将存在于<code class="du lq lr ls lt b">app.layout</code>的“孩子”列表中。为了增加应用程序的额外功能，我们只需将<a class="ae jn" href="https://dash.plotly.com/dash-core-components" rel="noopener ugc nofollow" target="_blank"> Dash组件</a>添加到这个子列表中。Dash组件几乎适用于你想添加到应用程序中的任何东西，包括交互式图表和下拉菜单，也适用于更简单的组件，如文本块。</p><p id="f5ed" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为了决定在哪里添加哪些组件，我们参考了我们在上一节中绘制的粗略应用草图。第一步是添加标题。这个组件很容易添加，因为它只包含文本。为了添加它，我们使用行和列的<a class="ae jn" href="https://dash-bootstrap-components.opensource.faculty.ai/" rel="noopener ugc nofollow" target="_blank"> Dash引导组件</a>向我们的应用程序页面添加一个新行。Dash bootstrap组件在基本组件之外添加了一些附加组件，并且基于CSS中流行的<a class="ae jn" href="https://www.w3schools.com/whatis/whatis_bootstrap.asp" rel="noopener ugc nofollow" target="_blank"> bootstrap框架</a>。这些列和行元素帮助我们分隔应用程序的组件。</p><p id="2965" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">第一个组件的代码，以及标题下类似的描述部分，如下所示。</p><figure class="lg lh li lj fd hj"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="179f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们首先为每个元素添加一行，然后添加一列。最后，我们添加一个HTML组件，说明我们想要的文本类型。标题将在HTML，H1提供的最大标题尺寸。描述将以普通文本的形式出现，这里称为<code class="du lq lr ls lt b">Font</code>。</p><p id="0411" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然后，我们使用关键字参数字典来指定颜色和文本对齐等内容。这段代码的输出如下所示。</p><figure class="lg lh li lj fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lu"><img src="../Images/ae6c01f473dc2ff3c53ed2fb300ba367.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MtBVEv2npFGmJfYC5z_EBA.png"/></div></div><figcaption class="lk ll et er es lm ln bd b be z dx">The first text components of our basic Dash app</figcaption></figure><p id="5f87" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这一点上，我们不太担心应用程序的字体看起来如何，主要只是关心功能和获得必要的部分。</p><h2 id="3dc2" class="kr jp hs bd jq ks kt ku ju kv kw kx jy ja ky kz kc je la lb kg ji lc ld kk le bi translated">使用应用程序回调</h2><p id="cdfa" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">下一步是创建随机图像生成器按钮。这一步比我们在上一步中创建的静态文本组件要复杂一些，因为我们希望按钮实际上激活一些功能，即呈现一个图像。</p><p id="19b5" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为此，我们需要使用一个叫做<code class="du lq lr ls lt b">@app.callback()</code>的重要破折号特性。这个特性是一个Python装饰器，从函数开头的<code class="du lq lr ls lt b">@</code>符号可以看出。装饰器就放在一个函数的前面，为它增加一些额外的功能。在这种情况下，装饰者让我们编写的任何函数都与我们的Dash应用程序的组件一起工作。它使用Dash <code class="du lq lr ls lt b">Input()</code>和<code class="du lq lr ls lt b">Output()</code>组件使我们编写的任何函数的输入和输出可被应用程序中的其他组件更新。例如，当我们的“随机图像生成器”按钮被点击时，我们可以使用这个点击动作作为函数的输入，告诉它运行。每次按钮点击的输出可以返回到应用程序的其他部分。下面的代码显示了“随机图像生成器”按钮的工作原理。它使用由我们的训练数据制作的简单CSV，其中只包含每幅画的两列:一列包含其标签，它被标记为文化，另一列包含到大都会博物馆服务器上相应图像的超链接。</p><figure class="lg lh li lj fd hj"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="b430" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">由于我们不希望<code class="du lq lr ls lt b">image_culture</code>立即显示，而是保存，我们将其作为一个组件返回，并将其关键字参数设置为不显示。我们对另一个名为<code class="du lq lr ls lt b">random_image</code>的输出进行同样的操作。这是因为它实际上只是图像的URL链接，而不是图像本身。我们需要将它传递到另一个Dash组件中，以便完全呈现图像。</p><p id="2557" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">下一步显示为添加到下面的代码中。我们还添加了一个额外的组件，用于在图像上打印出绘画的正确文化。</p><figure class="lg lh li lj fd hj"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="b4d1" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">请注意，这里我们使用了两个额外的回调函数:一个简单地生成一个标签，该标签在每次单击按钮时使用新的图像文化进行更新，另一个使用图像的URL链接来获取图像数据并在应用程序中呈现它。这些更新后的应用程序的新输出如下所示。</p><figure class="lg lh li lj fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lv"><img src="../Images/b8b25153deed40815a481b310ee3741b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GQbqNX3Qha36Zkp5OXJZcw.png"/></div></div><figcaption class="lk ll et er es lm ln bd b be z dx">The “random image generator” button now generates and displays a random painting from the Met’s collection.</figcaption></figure><h2 id="d064" class="kr jp hs bd jq ks kt ku ju kv kw kx jy ja ky kz kc je la lb kg ji lc ld kk le bi translated">整合ML模型</h2><p id="880b" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">我们现在已经对模型的输入进行了排序:我们的应用程序允许用户根据我们的需要从大都会博物馆的收藏中生成一张随机图像，并且它还会显示该图像。</p><p id="6e71" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">下一步是使用我们的模型对这些新数据进行预测。为此，我们将从本系列第1部分讨论的模型训练阶段加载我们保存的模型，并使用它的<code class="du lq lr ls lt b">.predict()</code>方法为新生成的图像生成预测。</p><p id="44e2" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们还必须确保对这些新图像应用与训练模型时相同的预处理步骤。</p><p id="8fc3" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">首先，我们加载训练后保存为泡菜的训练模型。我们还设置了一些重要的变量，即图像的高度和宽度。</p><figure class="lg lh li lj fd hj"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="f354" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们更新的应用程序(如下所示)现在在图像下方显示模型的预测。</p><figure class="lg lh li lj fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lw"><img src="../Images/05e47286b75c72f71dfafc58e0549d16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jeJ8S-Oz03dELuiBKl2mZw.png"/></div></div></figure><p id="84ec" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">请注意，在代码中，我们如何通过简单地将区域性标签作为用条件检查更新的变量来指定其颜色的变化。</p><p id="7b9f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们的应用程序现在做了我们希望它做的一切:为用户自动从集合中生成随机图像，渲染图像，并返回颜色编码的预测。构建应用程序的最后一步只是改善应用程序的外观和感觉，并修复对齐。为此，我们调整各种组件的宽度和对齐方式。接下来，我们添加一个CSS样式表来更改字体。</p><p id="8569" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">瞧！应用程序已完成:</p><figure class="lg lh li lj fd hj"><div class="bz dy l di"><div class="lo lp l"/></div></figure><figure class="lg lh li lj fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lx"><img src="../Images/c304855776e966a9a623ff629390148c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dbNUlb8Pa_mNX3xKPw1rRQ.png"/></div></div><figcaption class="lk ll et er es lm ln bd b be z dx">The final app, showing a mis-classified painting.</figcaption></figure><h1 id="e515" class="jo jp hs bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">使用Heroku部署应用程序</h1><p id="0d67" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">现在，我们的应用程序在本地运行良好，看起来符合我们的要求，是时候向全世界展示了。</p><p id="6969" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为此，我们使用Heroku，这是一个免费的开源应用托管平台。按照他们的<a class="ae jn" href="https://devcenter.heroku.com/articles/getting-started-with-python" rel="noopener ugc nofollow" target="_blank">非常容易使用的说明</a>，我们能够部署应用程序。这些步骤包括添加一个需求文件和Procfile，并将您的代码库推送到Heroku。</p><p id="a40b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然而，在将我们的代码推送到Heroku时，我们确实遇到了一些小错误和问题。我们得到一个错误，说“slug size”太大了，这实质上意味着我们的代码和依赖项太大了，无法在Heroku上免费部署。TensorFlow可能太大了，由于Heroku目前不提供GPU支持(这是标准TensorFlow库作为一个依赖项如此庞大的很大一部分原因)，我们切换到了<code class="du lq lr ls lt b">tensorflow-cpu</code>而不是标准Tensorflow。这也导致我们不得不切换到不同版本的CV2，我们使用的预处理库，叫做<code class="du lq lr ls lt b">opencv-python-headless</code>。这些变化将我们的项目规模缩小到足以在Heroku上免费部署。如果您计划将来在Heroku上部署您的图像识别项目，请记住这一点。</p><p id="2bfa" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在这款应用已经在Heroku上线，你可以在这里试用一下:<a class="ae jn" href="https://met-paintings-classifier.herokuapp.com" rel="noopener ugc nofollow" target="_blank"> <strong class="ir ht">试用这款应用！</strong> </a></p></div></div>    
</body>
</html>