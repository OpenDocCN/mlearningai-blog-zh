<html>
<head>
<title>Make Powerful Deep Learning Models Quickly Using Pytorch Lightning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Pytorch Lightning快速制作强大的深度学习模型</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/make-powerful-deep-learning-models-quickly-using-pytorch-lightning-29f040158ef3?source=collection_archive---------0-----------------------#2021-08-23">https://medium.com/mlearning-ai/make-powerful-deep-learning-models-quickly-using-pytorch-lightning-29f040158ef3?source=collection_archive---------0-----------------------#2021-08-23</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/eea1823488f5d0be9036189413f3bd4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7ULFgZ84aN0mJVeS"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Photo by <a class="ae it" href="https://unsplash.com/@antoine1003?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Antoine Dautry</a> on <a class="ae it" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="11f1" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Pytorch深度学习模型很难调试，代码行太多，降低了笔记本的可读性。Pytorch Lightning通过减少您必须编写的代码行来解决这些问题，增加了有用的功能，使其更容易调试并与其他模型进行比较。</p><h1 id="c5fd" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">数据</h1><p id="628f" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">我将为这个笔记本使用二次图像数据集。该数据集可以在Archanghosh提供的<a class="ae it" href="https://www.kaggle.com/archanghosh/images-of-randomly-generated-quadratic-equations" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>上找到。数据集由两个CSV文件和一个图像文件夹组成。CSV文件包含有关图像的信息，如id、每个系数的值和方程的根。系数以随机顺序排列。</p><figure class="kw kx ky kz fd ii er es paragraph-image"><div class="er es kv"><img src="../Images/3bdeb8a0f58c0ad9d6379d87b92c84c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*Gdb8PpHi_QEdS1riTSQzxw.png"/></div><figcaption class="ip iq et er es ir is bd b be z dx">An example of the image for quadratic equations</figcaption></figure><h1 id="d701" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">工作</h1><p id="51b5" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">我们的任务是找出每个方程的系数。为了加快训练时间，我们将使用预训练的神经网络Resnet-50。由于这是一个回归问题，我将改变模型，以更好地适应我们的数据。</p><h1 id="128e" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">安装Pytorch闪电</h1><p id="bcbb" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">在您的环境中安装Pytorch-Lightning。如果您已经安装了PyTorch，那么您应该已经安装了大部分模块</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="47ef" class="lf jt hh lb b fi lg lh l li lj">pip install pytorch-lightning</span></pre><h1 id="3323" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">笔记本</h1><p id="15a4" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">这款笔记本使用GPU在Kaggle上运行。你可以在<a class="ae it" href="https://www.kaggle.com/aristotle609/random-quadratic-equations-coefficent" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>、<a class="ae it" href="https://colab.research.google.com/drive/17oszrotnPpsD3-sqyu3ZNqEsaeesxMMn?usp=sharing" rel="noopener ugc nofollow" target="_blank"> collab </a>或者<a class="ae it" href="https://github.com/Aristotle609/Quadratic_Equations" rel="noopener ugc nofollow" target="_blank"> Github </a>上查看完整的笔记本。</p><h2 id="a9b7" class="lf jt hh bd ju lk ll lm jy ln lo lp kc jf lq lr kg jj ls lt kk jn lu lv ko lw bi translated">属国</h2><p id="172f" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">运行下面的单元格，以确保您的环境中安装了所有必需的软件包。如果您没有安装所有的软件包，它将抛出一个错误。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="9123" class="lf jt hh lb b fi lg lh l li lj">import pandas as pd<br/>import numpy as np<br/>from torch.utils.data import DataLoader,Dataset<br/>from torchvision import transforms<br/>from torch import nn<br/>import cv2<br/>import pytorch_lightning as pl<br/>import torch<br/>from sklearn.model_selection import train_test_split<br/>import torchvision<br/>from pytorch_lightning.callbacks import ModelCheckpoint<br/>from pytorch_lightning import Trainer</span></pre><h2 id="eb7d" class="lf jt hh bd ju lk ll lm jy ln lo lp kc jf lq lr kg jj ls lt kk jn lu lv ko lw bi translated">数据预处理</h2><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="dd12" class="lf jt hh lb b fi lg lh l li lj">input_df = "../input/images-of-randomly-generated-quadratic-equations/Quadratic Equation Full Details.csv"<br/>df = pd.read_csv(input_df)<br/>display(df)</span><span id="0411" class="lf jt hh lb b fi lx lh l li lj">def normalize(df_values,min_,max_):<br/>    df_list = df_values<br/>    return [(x-min_)/(max_ - min_) for x in df_values]</span><span id="f6b0" class="lf jt hh lb b fi lx lh l li lj">def denormalize(df_values,min_,max_):<br/>    df_list = df_values<br/>    return [(x*(max_ - min_) + min_) for x in df_values]</span><span id="dc35" class="lf jt hh lb b fi lx lh l li lj">df['a_'] = normalize(df["a"].values , 1 , 20)<br/>df['b_'] = normalize(df["b"].values,-48,96)<br/>df['c_'] = normalize(df["c"].values,-792,600)</span><span id="f415" class="lf jt hh lb b fi lx lh l li lj">train_df , test_df = train_test_split(df,test_size = 0.2 , random_state= 42)<br/>train_df , val_df = train_test_split(test_df,test_size = 0.33 , random_state= 42)<br/></span></pre><figure class="kw kx ky kz fd ii er es paragraph-image"><div class="er es ly"><img src="../Images/d35ff6eed270c3c84049751805393f61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1112/format:webp/1*QKzlaxR2rVl86MIgZ34lkg.png"/></div></figure><h2 id="74bf" class="lf jt hh bd ju lk ll lm jy ln lo lp kc jf lq lr kg jj ls lt kk jn lu lv ko lw bi translated">Pytorch数据集</h2><p id="03ee" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">接下来，我将构建一个标准PyTorch数据集</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="8a25" class="lf jt hh lb b fi lg lh l li lj">class Quadratic_Dataset(Dataset):<br/>    def __init__(self,path,targets = None):<br/>        self.path =  path<br/>        self.targets = targets<br/>        self.dir_path = "../input/images-of-randomly-generated-quadratic-equations/Images of Equations/"<br/>    <br/>    def __len__(self):<br/>        return len(self.path)<br/>    <br/>    def __getitem__(self, index):<br/>        image_path = self.dir_path + self.path[index] + ".png"<br/>        image = cv2.imread(image_path)<br/>        image = cv2.resize(image,(100,100))<br/>        if self.targets is None:<br/>            return 1.0 - torch.tensor(image).float().reshape(3,100,100)/256<br/>        else:<br/>            return 1.0 - torch.tensor(image).float().reshape(3,100,100)/256 , torch.tensor(self.targets[index]).float().reshape(3)</span></pre><h2 id="4c79" class="lf jt hh bd ju lk ll lm jy ln lo lp kc jf lq lr kg jj ls lt kk jn lu lv ko lw bi translated">闪电数据模块</h2><p id="d2f4" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">Lightning允许用户在他们的代码中使用数据模块进行重用，您可以选择用于训练、测试和验证集的数据。确保使用我使用过的准确的函数名，Lightning知道为训练测试、验证和预测数据寻找这些特定的函数。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="a465" class="lf jt hh lb b fi lg lh l li lj">class Quadratic_Module(pl.LightningDataModule):<br/>    def __init__(self):<br/>        super().__init__()<br/>        self.train_dataset = Quadratic_Dataset(path = train_df["id"].values , targets = train_df[["a_","b_", "c_"]].values)<br/>        self.test_dataset = Quadratic_Dataset(path = test_df["id"].values , targets = test_df[["a_","b_" , "c_"]].values)<br/>        self.val_dataset = Quadratic_Dataset(path = val_df["id"].values , targets = val_df[["a_","b_" , "c_"]].values)<br/>        self.predictions = Quadratic_Dataset(path = test_df["id"].values , targets = None)</span><span id="9bf9" class="lf jt hh lb b fi lx lh l li lj">def prepare_data(self) :<br/>        pass<br/>    <br/>    def train_dataloader(self):<br/>        return DataLoader(self.train_dataset , batch_size = 32  , shuffle = True)</span><span id="31fa" class="lf jt hh lb b fi lx lh l li lj">def test_dataloader(self):<br/>        return DataLoader(self.test_dataset , batch_size = 32  , shuffle = False)</span><span id="82c6" class="lf jt hh lb b fi lx lh l li lj">def val_dataloader(self):<br/>        return DataLoader(self.val_dataset , batch_size = 32  , shuffle = False)<br/>    <br/>    def predict_dataloader(self):<br/>        return DataLoader(self.predictions , batch_size = 1 , shuffle  = False)</span></pre><h2 id="8ccc" class="lf jt hh bd ju lk ll lm jy ln lo lp kc jf lq lr kg jj ls lt kk jn lu lv ko lw bi translated">模型</h2><p id="7691" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">正如我所说，我们将使用torchvision提供的名为resnet-50的预训练模型，并改变最终输出，以便我们可以使用回归技术。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="c4df" class="lf jt hh lb b fi lg lh l li lj">neural_network = torchvision.models.resnet50(pretrained = True)<br/>neural_network.fc = nn.Sequential(<br/>    nn.Linear(2048,1024),<br/>    nn.LeakyReLU(0.2),<br/>    nn.Linear(1024,512),<br/>    nn.LeakyReLU(0.2),<br/>    nn.Linear(512,256),<br/>    nn.LeakyReLU(0.2),<br/>    nn.Linear(256,100),<br/>    nn.LeakyReLU(0.2),<br/>    nn.Linear(100,10),<br/>    nn.Linear(10,3),<br/>)</span></pre><h2 id="d17e" class="lf jt hh bd ju lk ll lm jy ln lo lp kc jf lq lr kg jj ls lt kk jn lu lv ko lw bi translated">闪电模块</h2><p id="f101" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">Lightning的LightningModule类与PyTorch的模块几乎相同。您可以在configure _ optimizers函数通知监视器中声明优化器和学习率调度程序设置为“train_loss”。如果训练损失在十个小批中没有改善，它将降低学习率。没有必要进行循环来训练数据。一旦您将批处理传递给模型并返回确定的损失，它将被传递给training_step函数。如果您想监控损失，您可以选择记录损失。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="5984" class="lf jt hh lb b fi lg lh l li lj">class Quadratic_Model(pl.LightningModule):<br/>    def __init__(self):<br/>        super().__init__()<br/>        self.loss_func = nn.MSELoss()<br/>        self.net = neural_network<br/>        <br/>        <br/>    def forward(self,x):<br/>        out = self.net(x)<br/>        return out<br/>    <br/>    def configure_optimizers(self):<br/>        optimizer = torch.optim.Adam(self.parameters(), lr = 1e-3)<br/>        sch = torch.optim.lr_scheduler.StepLR(<br/>        optimizer, step_size  = 10 , gamma = 0.5)<br/> #learning rate scheduler<br/>        return {<br/>            "optimizer":optimizer,<br/>            "lr_scheduler" : {<br/>                "scheduler" : sch,<br/>                "monitor" : "train_loss",<br/>                <br/>            }<br/>        }</span><span id="047f" class="lf jt hh lb b fi lx lh l li lj">    def training_step(self,batch,batch_idx):<br/>        x , y_true = batch<br/>        y_pred = self(x)<br/>        loss = self.loss_func(y_true, y_pred)<br/>        self.log("train_loss" , loss)<br/>        return loss<br/>    <br/>    def test_step(self,batch,batch_idx):<br/>        x , y_true = batch<br/>        y_pred = self(x)<br/>        loss = self.loss_func(y_true, y_pred)<br/>        self.log("test_loss" , loss)<br/>        return loss<br/>    <br/>    def validation_step(self,batch,batch_idx):<br/>        x , y_true = batch<br/>        y_pred = self(x)<br/>        loss = self.loss_func(y_true, y_pred)<br/>        self.log("val_loss" , loss)<br/>        return loss</span></pre><h2 id="754f" class="lf jt hh bd ju lk ll lm jy ln lo lp kc jf lq lr kg jj ls lt kk jn lu lv ko lw bi translated">培养</h2><p id="0e22" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">Lightning具有可用于模型的内置回调。下面我们使用了ModelCheckpoint一个回调函数来监控“val_loss”并返回具有最低“val_loss”的模型。Lightning的最佳功能之一是GPU跟踪功能，您只需输入您想要使用的GPU数量，Lightning就会处理其余部分，或者，如果您不想使用GPU，可以忽略这一点。max_epochs确定您希望模型运行的时期数。“训练者适应”功能接受您想要训练的模型和您之前制作的数据模块。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="b30c" class="lf jt hh lb b fi lg lh l li lj">checkpoint = ModelCheckpoint(monitor= "val_loss" ,mode = "min")</span><span id="27cb" class="lf jt hh lb b fi lx lh l li lj">model = Quadratic_Model()<br/>module = Quadratic_Module()<br/>trainer = Trainer(max_epochs = 100,callbacks=[checkpoint] , gpus= 1)<br/>trainer.fit(model,module)</span></pre><figure class="kw kx ky kz fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lz"><img src="../Images/20d30091cd43f2776da1b0d3359282f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S0ybIPLqZhpCaxwYe2s18w.png"/></div></div></figure><h2 id="b23e" class="lf jt hh bd ju lk ll lm jy ln lo lp kc jf lq lr kg jj ls lt kk jn lu lv ko lw bi translated">测试和预测</h2><p id="b0f2" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">我们将在数据模块中声明的测试集上进行测试和预测。为了找到“test_loss ”,我们只需调用训练器的测试函数。它返回所有批次的平均损失。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="894d" class="lf jt hh lb b fi lg lh l li lj">trainer.test()</span></pre><figure class="kw kx ky kz fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ma"><img src="../Images/1a136ab1c63f62e666867d9ce22093f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jHaQUGEM7z75VO85J1jqBA.png"/></div></div></figure><p id="65e5" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">predict函数返回我们在测试集中声明的测试集的预测。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="605e" class="lf jt hh lb b fi lg lh l li lj">trainer.predict()</span></pre><figure class="kw kx ky kz fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mb"><img src="../Images/2ad177234ee2b62d3c989eb5dbd935f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RrlBNffIlKH-jFSBMXE4Qg.png"/></div></div></figure><h2 id="c2b2" class="lf jt hh bd ju lk ll lm jy ln lo lp kc jf lq lr kg jj ls lt kk jn lu lv ko lw bi translated">保存模型</h2><p id="8998" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">通常可以使用torch.save()保存模型权重</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="f6d7" class="lf jt hh lb b fi lg lh l li lj">torch.save(model.state_dict(),"./save.pth")</span></pre><h1 id="9352" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">尾注</h1><p id="2515" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">访问官方<a class="ae it" href="https://pytorch-lightning.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> Pytorch Lightning </a>查看完整文档。为了尝试改进模型，你可以尝试添加渐变剪辑和权重衰减。你也可以尝试使用tensorboard。到目前为止，它还不具备在jupyter笔记本上显示的功能。</p></div></div>    
</body>
</html>