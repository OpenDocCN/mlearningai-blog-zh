<html>
<head>
<title>H2O AI cluster on Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes上的H2O AI集群</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/h2o-ai-cluster-on-kubernetes-2e24bb9c717b?source=collection_archive---------9-----------------------#2022-10-11">https://medium.com/mlearning-ai/h2o-ai-cluster-on-kubernetes-2e24bb9c717b?source=collection_archive---------9-----------------------#2022-10-11</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/a16ac1726685c24822fa44322369a949.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CwACP8U4Qu5kn--mtrE-xA.png"/></div></div></figure><p id="b650" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">H2O是一个开源的内存平台，用于分布式、可扩展的机器学习。非常适合在Kubernetes集群上部署，这是一种非常现代的部署方式，服务于&amp;扩展应用。</p><p id="3f10" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">本文解释了如何在Kubernetes上<strong class="ir hi">创建H2O部署</strong>。它还涵盖了选定的H2O内部机制，以便读者更好地理解H2O在Kubernetes集群上的行为。</p><h1 id="3242" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">使用的术语</h1><h1 id="6704" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">H2O</h1><ul class=""><li id="ea1c" class="km kn hh ir b is ko iw kp ja kq je kr ji ks jm kt ku kv kw bi translated"><strong class="ir hi"> H2O节点:</strong>内部运行H2O的JVM的一个实例。通常，每个逻辑机器有一个H2O实例。</li><li id="ccdf" class="km kn hh ir b is kx iw ky ja kz je la ji lb jm kt ku kv kw bi translated"><strong class="ir hi"> H2O集群:</strong> —多个H2O节点在一个公共计算上一起工作。计算平均分布在每个H2O节点上，通常使用Map-Reduce。</li></ul><h1 id="db9c" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">库伯内特斯</h1><ul class=""><li id="19c1" class="km kn hh ir b is ko iw kp ja kq je kr ji ks jm kt ku kv kw bi translated">请注意，Kubernetes使用了与H2O领域相似的术语。以下所有描述均摘自<a class="ae jn" href="https://kubernetes.io/docs/concepts/" rel="noopener ugc nofollow" target="_blank"> Kubernetes concepts </a>文档。</li><li id="94eb" class="km kn hh ir b is kx iw ky ja kz je la ji lb jm kt ku kv kw bi translated"><strong class="ir hi"> Kubernetes节点:</strong>节点是Kubernetes中的工作机，以前称为minion。根据群集的不同，节点可以是虚拟机或物理机。每个节点都包含运行pod所需的服务，并由主组件管理。</li><li id="40ed" class="km kn hh ir b is kx iw ky ja kz je la ji lb jm kt ku kv kw bi translated"><strong class="ir hi"> Kubernetes集群:</strong>一组运行容器化应用的节点机器。</li></ul><h1 id="d569" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">H2O在集群上的架构和行为</h1><p id="c970" class="pw-post-body-paragraph ip iq hh ir b is ko iu iv iw kp iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">为了理解H2O分布式集群的行为和局限性，必须理解H2O设计的基础。</p><h1 id="f603" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">H2O有状态</h1><p id="5a91" class="pw-post-body-paragraph ip iq hh ir b is ko iu iv iw kp iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">一旦H2O节点启动，就会形成一个集群(H2O集群，而不是Kubernetes节点集群)。当数据加载到H2O集群中时，压缩在内部应用，数据均匀分布在H2O节点上。</p><figure class="lg lh li lj fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lf"><img src="../Images/cbb1ed18467dfd56e49b0b60fa359f64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9vyR6UKnEyH08GpO.png"/></div></div></figure><p id="3a88" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这种方法使H2O能够在大数据上扩展和执行机器学习。为了快速计算，数据被<strong class="ir hi">保存在存储器</strong>中。不仅是加载的数据，还有所有的中间计算。除非明确保存到永久存储器。这是H2O速度的关键。一旦数据被加载并跨H2O节点的集群分发，当前就不可能更改集群配置。禁止添加新节点、更改节点大小(内存、CPU ),因为群集会适应初始配置，包括数据分布模式和压缩模式。这种方法的最大优势是H2O的速度。</p><p id="b50b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">上面的信息暗示H2O集群是有状态的。如果一个H2O节点终止，群集会立即被识别为不健康，必须重新启动。</p><p id="2dfd" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这意味着H2O节点<strong class="ir hi">必须被K8S视为有状态节点</strong>。在Kubernetes中，共享一个公共状态的一组pod被称为<a class="ae jn" href="https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/" rel="noopener ugc nofollow" target="_blank">有状态集</a>。Kubernetes状态集确保:</p><ol class=""><li id="2b3a" class="km kn hh ir b is it iw ix ja lk je ll ji lm jm ln ku kv kw bi translated">H2O节点被视为一个单元，可以一起正常启动和关闭。</li><li id="8f6d" class="km kn hh ir b is kx iw ky ja kz je la ji lb jm ln ku kv kw bi translated">如果出现错误，K8S运行状况检查(如果已定义)不会尝试重启单个H2O节点。</li><li id="a689" class="km kn hh ir b is kx iw ky ja kz je la ji lb jm ln ku kv kw bi translated">一旦群集关闭，与H2O节点的状态集相关联的持久性存储和卷将不会被删除。</li></ol><p id="b980" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">要点提示:</strong> H2O是一个有状态的应用程序。H2O节点一起产生，一起死亡。Kubernetes无状态应用工具不适用于H2O。数据库以非常相似的方式部署在Kubernetes集群上。</p><h1 id="12d0" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">H2O节点相互可见性</h1><p id="0b87" class="pw-post-body-paragraph ip iq hh ir b is ko iu iv iw kp iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">为了使H2O集群化，它需要其他H2O节点的地址。在一个简单的本地网络上，内部试探法负责聚类。在Kubernetes集群上，情况变得更加困难，因为包含H2O的pod分布在Kubernetes节点上，默认情况下IP地址是按需分配的。一些用户利用这种可能性来创建和分发带有H2O节点地址的<strong class="ir hi">平面文件</strong>。这是<strong class="ir hi">错误的</strong>方式。在Kubernetes集群上，这是一个额外的、非常复杂且不必要的步骤。首先，必须分配和安装持久存储，这导致了资源和时间的浪费。然后，必须向Kubernetes集群查询所创建的H2O pod的IP地址。该平面文件随后被写入永久存储器，而pod内的H2O Docker <a class="ae jn" href="https://h2o.ai/wiki/containers/" rel="noopener ugc nofollow" target="_blank">容器</a>等待文件出现以启动H2O。一个非常复杂的过程。</p><p id="3294" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">H2O现在<strong class="ir hi">能够使用资源本地Kubernetes — <strong class="ir hi">环境变量和服务</strong>自动<strong class="ir hi">发现</strong>与H2O在同一服务下的其他pod。不需要容器黑客。</strong></p><p id="c7bb" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">根据<a class="ae jn" href="https://kubernetes.io/docs/concepts/cluster-administration/networking/" rel="noopener ugc nofollow" target="_blank"> Kubernetes网络模型</a>，每个Pod都有自己的IP地址。此外，任何节点上的pod都可以与所有节点上的所有pod通信。因此，创建了一个<code class="du lo lp lq lr b">StatefulSet</code>H2O节点，通过一个无头服务公开。之后，通过使用由无头服务创建的DNS记录来自动执行群集。无头服务的名称被传递给H2O pod，然后通过定义<code class="du lo lp lq lr b">H2O_KUBERNETES_SERVICE_DNS</code>环境变量一路传递给H2O Docker容器。格式通常遵循<code class="du lo lp lq lr b">&lt;service-name&gt;.&lt;project-name&gt;.svc.cluster.local</code>模式。一旦这个环境变量出现，H2O就认为它正在Kubernetes集群中运行，并在主H2O程序实际启动之前等待集群结束。都是自动完成的。</p><figure class="lg lh li lj fd ii er es paragraph-image"><div class="er es ls"><img src="../Images/abe27e9d3e6d58566181c84e0ceb99b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/0*P0k2zx0eZ1H5_4vh.png"/></div></figure><p id="dbca" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">关键要点:</strong> H2O能够使用Kubernetes自带的工具——服务和环境变量——在Kubernetes服务中实现集群化。不需要其他工具。</p><h1 id="a228" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">领导节点曝光</h1><p id="50d5" class="pw-post-body-paragraph ip iq hh ir b is ko iu iv iw kp iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">为了确保可再现性，所有请求都应发送到H2O领导节点。领导者节点选举在节点发现过程完成后进行。因此，在群集形成并且领导者节点已知之后，只有具有H2O领导者节点的pod应该是可用的。这也使得部署之上的服务只将所有请求路由到领导节点。为此，使用驻留在<code class="du lo lp lq lr b">/kubernetes/isLeaderNode</code>地址上的就绪探测器。一旦聚类完成，除了领导节点之外的所有节点将它们自己标记为未准备好，只留下领导节点暴露。</p><p id="abc8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">要点提示:</strong>为确保再现性，只应联系领导而不是。就绪探测确保只有领导者节点可通过相应的服务到达。</p><h1 id="95b6" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">在Kubernetes集群中运行H2O</h1><p id="26c9" class="pw-post-body-paragraph ip iq hh ir b is ko iu iv iw kp iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">为了在Kubernetes集群中生成H2O集群，必须满足以下要求:</p><ol class=""><li id="c707" class="km kn hh ir b is it iw ix ja lk je ll ji lm jm ln ku kv kw bi translated">库伯内特星团。对于本土发展来说，<a class="ae jn" href="https://k3s.io/" rel="noopener ugc nofollow" target="_blank"> k3s </a>是很棒的选择。为了方便开始，RedHat的open shift<a class="ae jn" href="https://www.openshift.com/" rel="noopener ugc nofollow" target="_blank">是一个很好的选择，他们有30天的免费试用期。</a></li><li id="4fae" class="km kn hh ir b is kx iw ky ja kz je la ji lb jm ln ku kv kw bi translated">H2O在里面的码头工人图像。</li><li id="1404" class="km kn hh ir b is kx iw ky ja kz je la ji lb jm ln ku kv kw bi translated">一个Kubernetes部署定义，包含一组状态良好的H2O pods和一个无头服务。</li></ol><h1 id="4c4d" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">创建Docker图像</h1><p id="a968" class="pw-post-body-paragraph ip iq hh ir b is ko iu iv iw kp iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">一个简单的Docker容器和启动时运行的H2O就足够了。最简单的创建方法如下图所示。</p><pre class="lg lh li lj fd lt lr lu lv aw lw bi"><span id="0770" class="lx jp hh lr b fi ly lz l ma mb"><strong class="lr hi">FROM</strong> ubuntu:latest</span><span id="d3c8" class="lx jp hh lr b fi mc lz l ma mb">ARG H2O_VERSION</span><span id="c0a5" class="lx jp hh lr b fi mc lz l ma mb"><strong class="lr hi">RUN</strong> apt-get update \<br/>	&amp;&amp; apt-get install default-jdk unzip wget -y</span><span id="191e" class="lx jp hh lr b fi mc lz l ma mb"><strong class="lr hi">RUN</strong> wget <a class="ae jn" href="http://h2o-release.s3.amazonaws.com/h2o/rel-zahradnik/1/h2o-" rel="noopener ugc nofollow" target="_blank">http://h2o-release.s3.amazonaws.com/h2o/rel-zahradnik/1/h2o-</a>${H2O_VERSION}.zip \<br/>	&amp;&amp; unzip h2o-${H2O_VERSION}.zip</span><span id="c5c2" class="lx jp hh lr b fi mc lz l ma mb"><strong class="lr hi">ENV</strong> H2O_VERSION ${H2O_VERSION}<br/><strong class="lr hi">CMD</strong> java -jar h2o-${H2O_VERSION}/h2o.jar</span></pre><p id="0b51" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">要构建Docker映像，请使用<code class="du lo lp lq lr b">docker build . -t {image-name} --build-arg H2O_VERSION=3.30.0.1</code>。确保用有意义的名称替换<code class="du lo lp lq lr b">{image-name}</code>占位符。出于本文的目的，docker图像将被命名为<code class="du lo lp lq lr b">h2o-k8s</code>，结果为<code class="du lo lp lq lr b">docker build . -t h2o-k8s --build-arg H2O_VERSION=3.30.0.1</code></p><h1 id="933e" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">创建无头服务</h1><p id="9cdf" class="pw-post-body-paragraph ip iq hh ir b is ko iu iv iw kp iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">部署在Kubernetes集群上的H2O Pods需要一个<a class="ae jn" href="https://kubernetes.io/docs/concepts/services-networking/service/#headless-services" rel="noopener ugc nofollow" target="_blank">无头服务</a>用于H2O节点发现。无头服务返回所有底层pod的一组地址，而不是对底层H2O pod的传入请求进行负载平衡。这使得H2O能够聚集起来。</p><pre class="lg lh li lj fd lt lr lu lv aw lw bi"><span id="c25c" class="lx jp hh lr b fi ly lz l ma mb">apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: h2o-service<br/>spec:<br/>  type: ClusterIP<br/>  clusterIP: None<br/>  selector:<br/>    app: h2o-k8s<br/>  ports:<br/>  - protocol: TCP<br/>    port: 54321</span></pre><p id="7982" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du lo lp lq lr b">clusterIP: None</code>将服务定义为无头服务。<code class="du lo lp lq lr b">port: 54321</code>是默认的H2O端口。用户和客户端库使用此端口与H2O集群通信。</p><p id="0ac1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du lo lp lq lr b">app: h2o-k8s</code>设置对于<strong class="ir hi">非常重要</strong>，因为这是内部带有H2O吊舱的应用程序的名称。这个名字是任意选择的。请确保此设置对应于所选的H2O部署名称。</p><h1 id="a533" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">创建H2O部署</h1><p id="0eec" class="pw-post-body-paragraph ip iq hh ir b is ko iu iv iw kp iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">强烈建议在Kubernetes集群上将H2O作为有状态集运行。Kubernetes假设集群中的所有pod都是有状态的，并且不会在出现故障时尝试重启单个pod。一旦在H2O集群上触发作业，该集群将被锁定，并且无法添加其他节点。因此，如果需要的话，集群必须作为一个整体重启——这非常适合StatefulSet。</p><pre class="lg lh li lj fd lt lr lu lv aw lw bi"><span id="2df0" class="lx jp hh lr b fi ly lz l ma mb">apiVersion: apps/v1<br/>kind: StatefulSet<br/>metadata:<br/>  name: h2o-stateful-set<br/>  namespace: h2o-statefulset<br/>spec:<br/>  serviceName: h2o-service<br/>  replicas: 3<br/>  selector:<br/>    matchLabels:<br/>      app: h2o-k8s<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: h2o-k8s<br/>    spec:<br/>      terminationGracePeriodSeconds: 10<br/>      containers:<br/>        - name: h2o-k8s<br/>          image: '&lt;someDockerImageWithH2OInside&gt;'<br/>          resources:<br/>            requests:<br/>              memory: "4Gi"<br/>          ports:<br/>            - containerPort: 54321<br/>              protocol: TCP<br/>          readinessProbe:<br/>            httpGet:<br/>              path: /kubernetes/isLeaderNode<br/>              port: 8081<br/>            initialDelaySeconds: 5<br/>            periodSeconds: 5<br/>            failureThreshold: 1<br/>          env:<br/>          - name: H2O_KUBERNETES_SERVICE_DNS<br/>            value: h2o-service.h2o-statefulset.svc.cluster.local<br/>          - name: H2O_NODE_LOOKUP_TIMEOUT<br/>            value: '180'<br/>          - name: H2O_NODE_EXPECTED_COUNT<br/>            value: '3'<br/>          - name: H2O_KUBERNETES_API_PORT<br/>            value: '8081'</span></pre><p id="02e7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">除了标准化的Kubernetes设置，比如<code class="du lo lp lq lr b">replicas: 3</code>定义实例化H2O的pod数量，还有几个设置需要注意。</p><p id="be5d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">应用程序的名称<code class="du lo lp lq lr b">app: h2o-k8s</code>必须对应于上面定义的无头服务所期望的名称，以便H2O节点发现能够工作。H2O在端口54321上通信，因此<code class="du lo lp lq lr b">containerPort: 54321</code>必须被暴露，以使客户端能够连接。</p><p id="1bab" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">驻留在<code class="du lo lp lq lr b">/kubernetes/isLeaderNode</code>上的准备就绪探测器通过使除领导节点之外的所有节点不可用来确保一旦集群形成就只暴露领导节点。H2O Kubernetes API的默认端口是8080。在示例中，一个可选的环境变量将端口更改为<code class="du lo lp lq lr b">8081</code>。</p><p id="851e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">环境变量:</strong></p><ol class=""><li id="9419" class="km kn hh ir b is it iw ix ja lk je ll ji lm jm ln ku kv kw bi translated"><code class="du lo lp lq lr b">H2O_KUBERNETES_SERVICE_DNS</code>–<strong class="ir hi">【强制】</strong>对集群工作至关重要。格式通常遵循<code class="du lo lp lq lr b">&lt;service-name&gt;.&lt;project-name&gt;.svc.cluster.local</code>模式。此设置通过DNS启用H2O节点发现。必须修改它以匹配所创建的无头服务的名称。此外，注意地址的其余部分，以匹配您的Kubernetes实现的细节。</li><li id="c68b" class="km kn hh ir b is kx iw ky ja kz je la ji lb jm ln ku kv kw bi translated"><code class="du lo lp lq lr b">H2O_NODE_LOOKUP_TIMEOUT</code>–<strong class="ir hi">【可选】</strong>节点查找约束。节点查找结束前的时间。</li><li id="91e8" class="km kn hh ir b is kx iw ky ja kz je la ji lb jm ln ku kv kw bi translated"><code class="du lo lp lq lr b">H2O_NODE_EXPECTED_COUNT</code>–<strong class="ir hi">【可选】</strong>节点查找约束。预计发现的H2O豆荚数量。</li><li id="61dd" class="km kn hh ir b is kx iw ky ja kz je la ji lb jm ln ku kv kw bi translated"><code class="du lo lp lq lr b">H2O_KUBERNETES_API_PORT</code>–<strong class="ir hi">【可选】</strong>用于Kubernetes API检查和探针监听的端口。默认为8080。</li></ol><p id="274e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果没有指定任何可选的查找约束，将设置一个合理的默认节点查找超时，当前默认为3分钟。如果定义了任何查找约束条件，则无论哪个条件首先满足，H2O节点查找都会终止。</p><h1 id="1c99" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">暴露H2O星团</h1><p id="008f" class="pw-post-body-paragraph ip iq hh ir b is ko iu iv iw kp iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">公开H2O集群是Kubernetes管理员的责任。默认情况下，可以创建一个<a class="ae jn" href="https://kubernetes.io/docs/concepts/services-networking/ingress/" rel="noopener ugc nofollow" target="_blank">入口</a>。不同的平台提供不同的功能，例如OpenShift提供<a class="ae jn" href="https://docs.openshift.com/container-platform/4.3/networking/routes/route-configuration.html" rel="noopener ugc nofollow" target="_blank">路线</a>。</p><h1 id="cdbe" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">把所有的放在一起</h1><p id="8988" class="pw-post-body-paragraph ip iq hh ir b is ko iu iv iw kp iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">产生的YAML可以放入一个文件中，例如<code class="du lo lp lq lr b">h2o.yaml</code>。</p><pre class="lg lh li lj fd lt lr lu lv aw lw bi"><span id="8b4d" class="lx jp hh lr b fi ly lz l ma mb">apiVersion: apps/v1<br/>kind: StatefulSet<br/>metadata:<br/>  name: h2o-stateful-set<br/>  namespace: h2o-statefulset<br/>spec:<br/>  serviceName: h2o-service<br/>  replicas: 3<br/>  selector:<br/>    matchLabels:<br/>      app: h2o-k8s<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: h2o-k8s<br/>    spec:<br/>      terminationGracePeriodSeconds: 10<br/>      containers:<br/>        - name: h2o-k8s<br/>          image: 'pscheidl/h2o-k8s'<br/>          resources:<br/>            requests:<br/>              memory: "4Gi"<br/>          ports:<br/>            - containerPort: 54321<br/>              protocol: TCP<br/>          env:<br/>          - name: H2O_KUBERNETES_SERVICE_DNS<br/>            value: h2o-service.h2o-statefulset.svc.cluster.local<br/>          - name: H2O_NODE_LOOKUP_TIMEOUT<br/>            value: '180'<br/>          - name: H2O_NODE_EXPECTED_COUNT<br/>            value: '3'<br/>---<br/>apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: h2o-service<br/>spec:<br/>  type: ClusterIP<br/>  clusterIP: None<br/>  selector:<br/>    app: h2o-k8s<br/>  ports:<br/>  - protocol: TCP<br/>    port: 54321</span></pre><p id="7a2e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">使用<code class="du lo lp lq lr b">kubectl apply -f h2o.yaml</code>可以在本地应用结果，或者将结果复制到您喜欢的Kubernetes集群提供者的界面中。</p><div class="md me ez fb mf mg"><a rel="noopener follow" target="_blank" href="/mlearning-ai/mlearning-ai-submission-suggestions-b51e2b130bfb"><div class="mh ab dw"><div class="mi ab mj cl cj mk"><h2 class="bd hi fi z dy ml ea eb mm ed ef hg bi translated">Mlearning.ai提交建议</h2><div class="mn l"><h3 class="bd b fi z dy ml ea eb mm ed ef dx translated">如何成为Mlearning.ai上的作家</h3></div><div class="mo l"><p class="bd b fp z dy ml ea eb mm ed ef dx translated">medium.com</p></div></div><div class="mp l"><div class="mq l mr ms mt mp mu in mg"/></div></div></a></div></div></div>    
</body>
</html>