<html>
<head>
<title>Approaching Multi-label image classification using fastai</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用fastai实现多标签图像分类</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/approaching-multi-label-image-classification-using-fastai-515a4fd52c8c?source=collection_archive---------0-----------------------#2021-11-29">https://medium.com/mlearning-ai/approaching-multi-label-image-classification-using-fastai-515a4fd52c8c?source=collection_archive---------0-----------------------#2021-11-29</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="43c1" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">为什么应该使用多标签分类而不是传统的分类技术。</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/f84209ea5b9ab4ced87a1effa6de2c3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CwNf11nyV0r98T96CrFeIw.jpeg"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx">Photo by <a class="ae jm" href="https://unsplash.com/@pjpavel?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Pavel Pjatakov</a> on <a class="ae jm" href="https://unsplash.com/t/interiors?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure></div><div class="ab cl jn jo go jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ha hb hc hd he"><h1 id="b25c" class="ju jv hh bd jw jx jy jz ka kb kc kd ke in kf io kg iq kh ir ki it kj iu kk kl bi translated">动机</h1><p id="c43d" class="pw-post-body-paragraph km kn hh ko b kp kq ii kr ks kt il ku kv kw kx ky kz la lb lc ld le lf lg lh ha bi translated">我们已经看到了一些单标签分类器，即试图将单个标签分配给所提供的图像的模型。这可以是猫对狗分类器或手写数字分类器，但在一天结束时，单标签分类器会尝试为提供的图像分配一个标签。这种类型的分类器为给定的输入样本提供完美的输出标签。</p><p id="6997" class="pw-post-body-paragraph km kn hh ko b kp li ii kr ks lj il ku kv lk kx ky kz ll lb lc ld lm lf lg lh ha bi translated">但是，当我们在生产环境中使用上述模型时，这可能会成为一个问题，例如，我们已经部署了一个带有狗与猫分类器的web应用程序，它经过训练达到了很高的准确度。但如果一些用户开始上传建筑物的图像或任何非猫或非狗的图像，我们的模型就不理解输入的图像不是狗或猫。它基于被训练的标签的最大概率来提供图像的预测。所以模型只能分辨出图像<strong class="ko hi">可能是一只狗或猫</strong>，而不能告诉<strong class="ko hi">它不是一只狗或猫</strong>。</p><p id="9767" class="pw-post-body-paragraph km kn hh ko b kp li ii kr ks lj il ku kv lk kx ky kz ll lb lc ld lm lf lg lh ha bi translated">单标签分类器的另一个问题是它们只能给图像分配一个标签。但是，如果我们的图像由多个对象组成，则该模型将根据图像中存在的最主要的对象进行分类，并忽略其他对象。因此，这不会导致准确的分类。</p><p id="9834" class="pw-post-body-paragraph km kn hh ko b kp li ii kr ks lj il ku kv lk kx ky kz ll lb lc ld lm lf lg lh ha bi translated">这些问题的解决方案可以通过使用<strong class="ko hi">多标签分类来解决。</strong></p><h1 id="4dd3" class="ju jv hh bd jw jx ln jz ka kb lo kd ke in lp io kg iq lq ir ki it lr iu kk kl bi translated">多标签分类简介</h1><p id="64e5" class="pw-post-body-paragraph km kn hh ko b kp kq ii kr ks kt il ku kv kw kx ky kz la lb lc ld le lf lg lh ha bi translated">多标签分类可用于为每个输入样本(图像、文本、音频……)分配一个或多个标签。这以下列方式解决了单标签分类器的缺点:</p><ul class=""><li id="4de5" class="ls lt hh ko b kp li ks lj kv lu kz lv ld lw lh lx ly lz ma bi translated">我们可以训练多标签分类器来识别不属于任何类别的图像，只需要在训练数据中有一些没有任何标签的图像。通过这种方式，多标签分类器将正确地对任何域外数据进行分类。</li><li id="f864" class="ls lt hh ko b kp mb ks mc kv md kz me ld mf lh lx ly lz ma bi translated">多标签分类是一种用于将多个标签分配给给定输入样本的技术。数据可以是具有多种风格的故事/电影，或者是其中具有不同对象的单个图像。</li></ul><p id="6b99" class="pw-post-body-paragraph km kn hh ko b kp li ii kr ks lj il ku kv lk kx ky kz ll lb lc ld lm lf lg lh ha bi translated">让我们看看多标签数据集的实际情况，以及训练多标签分类器与训练单标签分类器有何不同。</p><h1 id="cc6a" class="ju jv hh bd jw jx ln jz ka kb lo kd ke in lp io kg iq lq ir ki it lr iu kk kl bi translated">浏览数据集</h1><p id="00b6" class="pw-post-body-paragraph km kn hh ko b kp kq ii kr ks kt il ku kv kw kx ky kz la lb lc ld le lf lg lh ha bi translated">为了更好地理解，让我们使用PASCAL数据集，它的每张图片都有多种分类对象。首先，让我们安装并导入fastai，</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="f0e2" class="pw-post-body-paragraph km kn hh ko b kp li ii kr ks lj il ku kv lk kx ky kz ll lb lc ld lm lf lg lh ha bi translated">现在让我们使用<code class="du mi mj mk ml b">untar_data</code>函数下载数据集，</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="7435" class="pw-post-body-paragraph km kn hh ko b kp li ii kr ks lj il ku kv lk kx ky kz ll lb lc ld lm lf lg lh ha bi translated">在下载的路径中，我们可以看到我们有包含图像的train和test文件夹，以及一个告诉我们每个图像使用什么标签的<code class="du mi mj mk ml b">train.csv</code>文件。让我们用熊猫来观察它，</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="mg mh l"/></div></figure><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es mm"><img src="../Images/d25907585ee4a3f3dc8c2ba3338b715a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*fhkRT9ed015CmQ66KPcHFA.png"/></div></figure><p id="0196" class="pw-post-body-paragraph km kn hh ko b kp li ii kr ks lj il ku kv lk kx ky kz ll lb lc ld lm lf lg lh ha bi translated">在列车数据帧中，我们可以看到它有3列<code class="du mi mj mk ml b">filename, labels and is_valid.</code></p><p id="b973" class="pw-post-body-paragraph km kn hh ko b kp li ii kr ks lj il ku kv lk kx ky kz ll lb lc ld lm lf lg lh ha bi translated"><code class="du mi mj mk ml b">labels</code>由一个或多个类别组成的列由空格分隔的字符串分隔。<code class="du mi mj mk ml b">is_valid</code>用于确定它是用于验证还是用于培训。</p><h1 id="b036" class="ju jv hh bd jw jx ln jz ka kb lo kd ke in lp io kg iq lq ir ki it lr iu kk kl bi translated">准备好数据</h1><p id="d070" class="pw-post-body-paragraph km kn hh ko b kp kq ii kr ks kt il ku kv kw kx ky kz la lb lc ld le lf lg lh ha bi translated">现在让我们创建一个数据块对象来加载数据并创建数据加载器。DataBlock是一个高级API，它使得数据预处理和加载更加容易。让我们看看如何为我们的应用程序构建一个。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="f67e" class="pw-post-body-paragraph km kn hh ko b kp li ii kr ks lj il ku kv lk kx ky kz ll lb lc ld lm lf lg lh ha bi translated">好了，现在让我们研究一下传递给datablock对象的每个参数，看看它做了什么。</p><ul class=""><li id="7d9e" class="ls lt hh ko b kp li ks lj kv lu kz lv ld lw lh lx ly lz ma bi translated"><strong class="ko hi">块:</strong>这定义了自变量和因变量/数据，或者更准确地说，是我们提供给模型的输入类型和目标。在这种情况下，我们有图像作为输入和多个相关的类别，因此有<code class="du mi mj mk ml b">ImageBlock</code>和<code class="du mi mj mk ml b">MultiCategoryBlock</code>。</li></ul><p id="aad1" class="pw-post-body-paragraph km kn hh ko b kp li ii kr ks lj il ku kv lk kx ky kz ll lb lc ld lm lf lg lh ha bi translated">fastai库自动检测多个类别，并根据可用目标的数量执行一键编码。(但是当使用<code class="du mi mj mk ml b">CategoryBlock</code>时，对类别进行顺序编码，即用于单标签分类)</p><ul class=""><li id="daea" class="ls lt hh ko b kp li ks lj kv lu kz lv ld lw lh lx ly lz ma bi translated"><strong class="ko hi"> get_x: </strong>这定义了如何获取输入，即我们例子中的图像。在上面的代码中，我们定义了一个函数<strong class="ko hi"> get_x </strong>，它将path对象返回到相应的文件名。<code class="du mi mj mk ml b">ImageBlock</code>读取路径对象，然后执行必要的处理，将其转换为PIL图像对象。</li><li id="7cae" class="ls lt hh ko b kp mb ks mc kv md kz me ld mf lh lx ly lz ma bi translated"><strong class="ko hi"> get_y: </strong>该<strong class="ko hi"> </strong>定义了如何获取目标，即每幅图像的多个类别。在上面的<strong class="ko hi"> get_y </strong>函数中，我们返回了通过拆分<code class="du mi mj mk ml b">labels</code>列获得的与特定图像相关联的标签列表。</li><li id="fba4" class="ls lt hh ko b kp mb ks mc kv md kz me ld mf lh lx ly lz ma bi translated"><strong class="ko hi"> splitter: </strong>这定义了我们如何执行数据集的训练验证分割。在<strong class="ko hi">拆分器</strong>函数中，我们根据‘is _ valid’列拆分数据帧，然后返回所有索引的列表作为训练集和验证集。</li><li id="62bd" class="ls lt hh ko b kp mb ks mc kv md kz me ld mf lh lx ly lz ma bi translated"><strong class="ko hi"> item_tfms: </strong>定义应该应用于数据集中每个样本的转换。这里我们使用的是<code class="du mi mj mk ml b">RandomResizedCrop</code>变换，它通过在每次应用变换时保留至少35%的图像来随机地将图像的大小调整到128。</li></ul><p id="b716" class="pw-post-body-paragraph km kn hh ko b kp li ii kr ks lj il ku kv lk kx ky kz ll lb lc ld lm lf lg lh ha bi translated">现在让我们创建数据加载器并可视化我们的数据集，</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="mg mh l"/></div></figure><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mn"><img src="../Images/f47d866ad78f4ebdad863b405cb474b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ciugl0Xe5hnPhGtS6vZstA.png"/></div></div></figure><p id="8715" class="pw-post-body-paragraph km kn hh ko b kp li ii kr ks lj il ku kv lk kx ky kz ll lb lc ld lm lf lg lh ha bi translated">既然现在我们已经准备好了数据加载器，我们现在可以创建一个模型。</p><h1 id="35a2" class="ju jv hh bd jw jx ln jz ka kb lo kd ke in lp io kg iq lq ir ki it lr iu kk kl bi translated">模特培训</h1><p id="520e" class="pw-post-body-paragraph km kn hh ko b kp kq ii kr ks kt il ku kv kw kx ky kz la lb lc ld le lf lg lh ha bi translated">现在让我们使用resnet50预训练模型创建一个cnn_learner对象。但在此之前，让我们了解一下训练方法的重要区别。</p><h2 id="851e" class="mo jv hh bd jw mp mq mr ka ms mt mu ke kv mv mw kg kz mx my ki ld mz na kk nb bi translated"><strong class="ak">损失函数</strong></h2><p id="747e" class="pw-post-body-paragraph km kn hh ko b kp kq ii kr ks kt il ku kv kw kx ky kz la lb lc ld le lf lg lh ha bi translated">首先，让我们讨论一下单标签分类的一些基础知识。在二进制分类模型中，任务是将任何给定的输入分类到两类中的一类。因此可以通过应用<code class="du mi mj mk ml b">sigmoid</code>激活函数并将其传递给<code class="du mi mj mk ml b">BinaryCrossEntropy</code>损失函数来找到损失。sigmoid负责将所有值转换到范围[0–1]内。</p><p id="3256" class="pw-post-body-paragraph km kn hh ko b kp li ii kr ks lj il ku kv lk kx ky kz ll lb lc ld lm lf lg lh ha bi translated">因为我们有范围[0–1]中的所有逻辑，所以我们可以使用阈值0.5来确定输入样本的类别。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es nc"><img src="../Images/79029d07d8ec9f1ecf88a4b829120d13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HXCBO-Wx5XhuY_OwMl0Phw.png"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx">Source: Sigmoid Activation Function (<a class="ae jm" href="https://en.wikipedia.org/wiki/Sigmoid_function" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Sigmoid_function</a>)</figcaption></figure><p id="bc27" class="pw-post-body-paragraph km kn hh ko b kp li ii kr ks lj il ku kv lk kx ky kz ll lb lc ld lm lf lg lh ha bi translated">类似地，在多标签分类模型中，任务是将给定的输入分类到三个或更多类别中的一个。这里，损耗是通过首先应用<code class="du mi mj mk ml b">softmax</code>激活函数，然后通过<code class="du mi mj mk ml b">CrossEntropy</code>损耗函数获得的。</p><p id="fce6" class="pw-post-body-paragraph km kn hh ko b kp li ii kr ks lj il ku kv lk kx ky kz ll lb lc ld lm lf lg lh ha bi translated">但是在多标签分类模型中，任务是将给定的输入分类到一个以上的类别中，即分配多个标签。目标被表示为一个独热编码的数组。这看起来类似于二进制分类任务，但是唯一的区别是具有它的多个实例，即输入图像的二进制分类是针对每个可用标签进行的。</p><p id="5051" class="pw-post-body-paragraph km kn hh ko b kp li ii kr ks lj il ku kv lk kx ky kz ll lb lc ld lm lf lg lh ha bi translated">所以对于这个任务，我们使用了<code class="du mi mj mk ml b">BinaryCrossEntropy</code>损失函数和<code class="du mi mj mk ml b">sigmoid</code>激活函数。这是因为多标签分类类似于二进制分类，除了PyTorch使用其<strong class="ko hi">基于元素的操作</strong>将激活和丢失应用于独热编码的目标。</p><h2 id="6638" class="mo jv hh bd jw mp mq mr ka ms mt mu ke kv mv mw kg kz mx my ki ld mz na kk nb bi translated">韵律学</h2><p id="1721" class="pw-post-body-paragraph km kn hh ko b kp kq ii kr ks kt il ku kv kw kx ky kz la lb lc ld le lf lg lh ha bi translated">Fastai为多标签分类提供了一个名为<code class="du mi mj mk ml b">accuracy_multi</code>的度量。在我们收到来自模型的输出逻辑后，sigmoid激活被应用来将所有值转换到[0–1]的范围内。然后，通过指定一个<strong class="ko hi">阈值</strong>值来应用<code class="du mi mj mk ml b">accuracy_multi</code>函数，即高于该阈值的所有概率将为真，否则将为假。这样，我们就得到了模型的预测。</p><p id="5ff0" class="pw-post-body-paragraph km kn hh ko b kp li ii kr ks lj il ku kv lk kx ky kz ll lb lc ld lm lf lg lh ha bi translated">准确性分数是通过将预测值与目标值进行比较来计算的，通常与正常的准确性计算进行比较。要记住的重要事情是正确地确定阈值的值。如果我们选择的阈值太高，我们将只选择模型非常有把握的对象。如果我们选择的阈值太低，我们将经常无法选择正确标记的对象。</p><p id="3f52" class="pw-post-body-paragraph km kn hh ko b kp li ii kr ks lj il ku kv lk kx ky kz ll lb lc ld lm lf lg lh ha bi translated">现在让我们深入代码，看看如何训练模型。</p><h2 id="6ecb" class="mo jv hh bd jw mp mq mr ka ms mt mu ke kv mv mw kg kz mx my ki ld mz na kk nb bi translated">创建学习者</h2><p id="6664" class="pw-post-body-paragraph km kn hh ko b kp kq ii kr ks kt il ku kv kw kx ky kz la lb lc ld le lf lg lh ha bi translated">让我们使用<code class="du mi mj mk ml b">cnn_learner</code>和resnet50模型创建一个学习者对象。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="38b7" class="pw-post-body-paragraph km kn hh ko b kp li ii kr ks lj il ku kv lk kx ky kz ll lb lc ld lm lf lg lh ha bi translated">partial函数接受一个函数和该函数的关键字参数，并返回一个带有更新后的关键字参数的新函数。在上面的例子中，我们使用<code class="du mi mj mk ml b">partial</code>将默认的<strong class="ko hi"> accuracy_multi </strong>度量函数的<strong class="ko hi"> thresh </strong>值从0.5更新为0.2。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es nd"><img src="../Images/33d3df919ac13c2c502a2e6ae42f8eab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5sD5EmClM16faXlwBOva8Q.png"/></div></div></figure><p id="3c2c" class="pw-post-body-paragraph km kn hh ko b kp li ii kr ks lj il ku kv lk kx ky kz ll lb lc ld lm lf lg lh ha bi translated">我们可以看到，当我们将阈值保持为0.2时，我们实现了高达95 %的准确性。让我们看看如果改变thresh值会发生什么。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="mg mh l"/></div></figure><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es ne"><img src="../Images/a5398621cfb0e55cfb52ba784f5fdb38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*38plxoCSFIwS3WDdhWI1Zw.png"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx">Loss, accuracy when thresh = 0.1</figcaption></figure><p id="72e0" class="pw-post-body-paragraph km kn hh ko b kp li ii kr ks lj il ku kv lk kx ky kz ll lb lc ld lm lf lg lh ha bi translated">在上面的代码中，我们将模型的度量改为accuracy_multi，thresh=0.1。当我们执行<strong class="ko hi"> learn.validate() </strong>时，学习者对象计算验证数据的损失和准确性。因为我们只是改变了度量，所以不需要训练模型。从上面的输出中，我们可以看到，当thresh=0.1时，我们获得了93%的精度，这比我们之前的结果要低。现在让我们检查更高的阈值。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="mg mh l"/></div></figure><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es nf"><img src="../Images/4bfa4043ee7c7bec3c6e64e219ea9ff5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*djAmsWm7ah7K4FANDa1EhQ.png"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx">Loss, accuracy when thresh=0.99</figcaption></figure><p id="4575" class="pw-post-body-paragraph km kn hh ko b kp li ii kr ks lj il ku kv lk kx ky kz ll lb lc ld lm lf lg lh ha bi translated">当阈值较高，即thresh = 0.99时，我们可以看到精度为94%。因此，我们可以得出结论，选择一个阈值取决于我们使用的数据，而不是一个固定值。</p><p id="6bad" class="pw-post-body-paragraph km kn hh ko b kp li ii kr ks lj il ku kv lk kx ky kz ll lb lc ld lm lf lg lh ha bi translated">因此，建议试验并检查不同的thresh值，并确定一个精度更高的值。</p><h1 id="d38d" class="ju jv hh bd jw jx ln jz ka kb lo kd ke in lp io kg iq lq ir ki it lr iu kk kl bi translated">结论</h1><p id="f1a9" class="pw-post-body-paragraph km kn hh ko b kp kq ii kr ks kt il ku kv kw kx ky kz la lb lc ld le lf lg lh ha bi translated">因此，我们已经看到了多标签分类器是如何工作的，以及如何使用它来避免传统的单标签分类器所面临的一些问题。因此，即使对于正常/单标签分类任务，也总是建议训练多标签分类器，以获得更健壮的模型行为。</p><p id="6cb5" class="pw-post-body-paragraph km kn hh ko b kp li ii kr ks lj il ku kv lk kx ky kz ll lb lc ld lm lf lg lh ha bi translated">谢谢你</p><h2 id="421f" class="mo jv hh bd jw mp mq mr ka ms mt mu ke kv mv mw kg kz mx my ki ld mz na kk nb bi translated"><strong class="ak"> GitHub链接为笔记本</strong> <a class="ae jm" href="https://github.com/JNK234/100-days-of-deep-learning/blob/main/Day%203/Multi_Label_classification.ipynb" rel="noopener ugc nofollow" target="_blank"> <strong class="ak">此处</strong> </a> <strong class="ak">。领英简介</strong> <a class="ae jm" href="https://www.linkedin.com/in/narasimhakarthik/" rel="noopener ugc nofollow" target="_blank"> <strong class="ak">此处</strong> </a> <strong class="ak">。</strong></h2><div class="ng nh ez fb ni nj"><a rel="noopener follow" target="_blank" href="/mlearning-ai/mlearning-ai-submission-suggestions-b51e2b130bfb"><div class="nk ab dw"><div class="nl ab nm cl cj nn"><h2 class="bd hi fi z dy no ea eb np ed ef hg bi translated">Mlearning.ai提交建议</h2><div class="nq l"><h3 class="bd b fi z dy no ea eb np ed ef dx translated">如何成为Mlearning.ai上的作家</h3></div><div class="nr l"><p class="bd b fp z dy no ea eb np ed ef dx translated">medium.com</p></div></div><div class="ns l"><div class="nt l nu nv nw ns nx jg nj"/></div></div></a></div></div></div>    
</body>
</html>