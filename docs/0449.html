<html>
<head>
<title>Docker in Machine Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">机器学习中的Docker</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/docker-in-machine-learning-388cf1a34724?source=collection_archive---------0-----------------------#2021-04-21">https://medium.com/mlearning-ai/docker-in-machine-learning-388cf1a34724?source=collection_archive---------0-----------------------#2021-04-21</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/9bd62c0b703d1279c55eb984237896a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*SCApTAuRk2em3iLk.png"/></div></div></figure><p id="631e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">今天我们要看一个非常有趣的话题。在现代世界，人工智能在每个领域都扮演着重要的角色。比如说，零售业在传销中有着巨大的作用。像沃尔玛、亚马逊、Flipkart这样的大巨头拥有关键功能，使产品能够被使用机器学习的客户很好地接触到。</p><p id="74ae" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这种东西怎么可能到达顾客手中呢？是的，这里有一个例子，如果X从XYZ品牌买了一件新衬衫。经过一个月的市场推广，新设计的新衬衫上市了。从门户网站了解到那些基于用户购买的推荐。这是一个使用机器学习实现的例子。为了让每个人都可以访问它，我们需要将模型部署在一个集中的地方。</p><p id="300a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">单独部署云有必要吗？</strong></p><p id="114a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">从部署的角度来看，我们需要使用任何云服务，如AWS，Azure，GCP。那么，这个应用程序看起来怎么样呢？我们直接从Jupyter笔记本上部署吗？这些都是部署的问题。我们需要通过管道输送产品。对于ML项目中的每项任务，都需要实现自动化。从数据集到保存预测结果。所以最终我们可以把它看作一个产品模型。这可以交付给许多使用任何云服务的客户。</p><figure class="jo jp jq jr fd ii er es paragraph-image"><div class="er es jn"><img src="../Images/030e088c379bde7e66ed40c2882e871d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/0*Ksd-0OcW2gZpIfCD"/></div></figure><p id="7390" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">考虑这个例子，如果这个家庭把房子搬到另一个地方。他们首先想到的是打包家庭用品。让我们考虑两种换档方式，</p><p id="7b7b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">单独包装:</strong>考虑这里的情况，这里包装的物品分开放置。需要确保所有包裹项目都被移动到各自的搬运工。一旦一家人搬到另一个地方，这些事情就会发生‘嘿！“我忘了把我的私人物品放在哪里了，”，‘我把我的工作资料放在老房子里了’，‘终于！我用另一个把厨房的东西弄乱了。。如何避免那些情况，第二个场景帮你。</p><p id="3ac5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">集装箱:</strong>考虑一下这里的情况，把包装好的东西放在一个单独的集装箱里。最后，我们终于知道哪些项目是错过了。在一天结束时，我们会很高兴地转移到另一个位置，并轻松地放置各自的项目。</p><p id="ed20" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">考虑机器学习部署，产品需要部署在另一个客户位置。如果我们将单个文件转移到另一个云位置。某些文件可能会丢失。终于！客户报告说“为什么应用程序在一个地方可以工作，而在一个新的地方却不行？”此外，将会有大量的门票从客户端提出。为了解决这个问题，我们需要将应用程序容器化。这就出现了“Docker”实现的画面。</p><p id="355e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">Docker是什么？</strong></p><p id="32f0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Docker是一个工具，旨在使使用容器创建、部署和运行应用程序变得更加容易。容器用于打包应用程序，所有依赖关系都集中在一个地方。</p><p id="4013" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">架构</strong></p><figure class="jo jp jq jr fd ii er es paragraph-image"><div class="er es js"><img src="../Images/b30a2b0e7d8160dd6a6fa3132c067047.png" data-original-src="https://miro.medium.com/v2/resize:fit:1116/format:webp/0*120Pns42Mh_HKY4L.png"/></div></figure><ul class=""><li id="9212" class="jt ju hh ir b is it iw ix ja jv je jw ji jx jm jy jz ka kb bi translated">基础架构是用于托管多个虚拟机的物理服务器。</li><li id="e631" class="jt ju hh ir b is kc iw kd ja ke je kf ji kg jm jy jz ka kb bi translated">主机操作系统是基础机器，如Linux或Windows。所以这一层保持不变。</li><li id="0939" class="jt ju hh ir b is kc iw kd ja ke je kf ji kg jm jy jz ka kb bi translated">现在是新一代的Docker引擎。这用于运行操作系统，该操作系统以前是作为Docker容器的虚拟机。</li><li id="17d7" class="jt ju hh ir b is kc iw kd ja ke je kf ji kg jm jy jz ka kb bi translated">所有的应用程序现在都作为Docker容器运行。</li></ul><p id="0158" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">对接器安装</strong></p><p id="14f4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">对于操作系统的安装，需要遵循特定的步骤。</p><div class="kh ki ez fb kj kk"><a href="https://docs.docker.com/docker-for-windows/install/#system-requirements" rel="noopener  ugc nofollow" target="_blank"><div class="kl ab dw"><div class="km ab kn cl cj ko"><h2 class="bd hi fi z dy kp ea eb kq ed ef hg bi translated">在Windows上安装Docker桌面</h2><div class="kr l"><h3 class="bd b fi z dy kp ea eb kq ed ef dx translated">预计阅读时间:6分钟欢迎来到Docker桌面Windows版。本页包含关于Docker的信息…</h3></div><div class="ks l"><p class="bd b fp z dy kp ea eb kq ed ef dx translated">docs.docker.com</p></div></div><div class="kt l"><div class="ku l kv kw kx kt ky in kk"/></div></div></a></div><p id="f147" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果操作系统是Microsoft Windows 10 Professional或Enterprise 64位或Windows 10 Home 64位，请访问以下链接并下载</p><div class="kh ki ez fb kj kk"><a href="https://hub.docker.com/editions/community/docker-ce-desktop-windows/" rel="noopener  ugc nofollow" target="_blank"><div class="kl ab dw"><div class="km ab kn cl cj ko"><h2 class="bd hi fi z dy kp ea eb kq ed ef hg bi translated">Windows Docker桌面- Docker Hub</h2><div class="kr l"><h3 class="bd b fi z dy kp ea eb kq ed ef dx translated">在Windows上开始使用Docker的最快和最简单的方法</h3></div><div class="ks l"><p class="bd b fp z dy kp ea eb kq ed ef dx translated">hub.docker.com</p></div></div></div></a></div><p id="6774" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一旦安装完成，我们可以看到下面的屏幕将有容器，图像和开发环境。</p><figure class="jo jp jq jr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kz"><img src="../Images/c5ffc6afaca839fcb4032145d2eca3b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m8_fY9MfOHPOZdilGFamaw.png"/></div></div></figure><p id="bd1d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">Docker文件的重要性</strong></p><p id="9ee3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果应用程序需要docker化，需要为项目创建一个docker文件。让我们更深入地看看docker文件究竟是由什么组成的。</p><pre class="jo jp jq jr fd la lb lc ld aw le bi"><span id="dcec" class="lf lg hh lb b fi lh li l lj lk">FROM<br/><br/>ENV<br/><br/>WORKDIR<br/><br/>ENTRYPOINT<br/><br/>CMD<br/><br/>COPY<br/><br/>ADD<br/><br/>RUN<br/><br/>EXPOSE</span></pre><h1 id="d89d" class="ll lg hh bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">从</h1><pre class="jo jp jq jr fd la lb lc ld aw le bi"><span id="be1d" class="lf lg hh lb b fi lh li l lj lk">FROM &lt;image&gt; [AS &lt;name&gt;]</span></pre><p id="6cb2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">FROM用于定义启动构建过程的基础映像。每个Dockerfile文件都必须以FROM指令开头。这背后的想法是，你需要一个起点来建立你的形象。</p><pre class="jo jp jq jr fd la lb lc ld aw le bi"><span id="f000" class="lf lg hh lb b fi lh li l lj lk">FROM ubuntu</span></pre><p id="ad2e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这意味着我们的项目需要ubuntu作为父映像。</p><h1 id="ca01" class="ll lg hh bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">包封/包围（动词envelop的简写）</h1><pre class="jo jp jq jr fd la lb lc ld aw le bi"><span id="c088" class="lf lg hh lb b fi lh li l lj lk">ENV &lt;key&gt; &lt;value&gt;</span></pre><p id="4077" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">此命令用于设置运行项目所需的环境变量。</p><p id="c47d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">ENV设置环境变量，这些变量可以在Dockerfile文件及其调用的任何脚本中使用。这些对于容器来说也是持久的，可以在任何时候被引用。</p><pre class="jo jp jq jr fd la lb lc ld aw le bi"><span id="4a5b" class="lf lg hh lb b fi lh li l lj lk">ENV HTTP_PORT="9000"</span></pre><p id="6af8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们提供了HTTP_PORT作为环境变量。</p><h1 id="d15e" class="ll lg hh bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">工作方向</h1><pre class="jo jp jq jr fd la lb lc ld aw le bi"><span id="4b54" class="lf lg hh lb b fi lh li l lj lk">WORKDIR /path/to/workdir</span></pre><p id="c046" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> WORKDIR </strong>告诉Docker其余的命令将在映像中的<code class="du mi mj mk lb b">/app</code>文件夹的上下文中运行。</p><pre class="jo jp jq jr fd la lb lc ld aw le bi"><span id="f29c" class="lf lg hh lb b fi lh li l lj lk">WORKDIR /app</span></pre><p id="c587" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">它将在容器中创建<strong class="ir hi"> app </strong>目录。</p><h1 id="78b6" class="ll lg hh bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">奔跑</h1><p id="ac81" class="pw-post-body-paragraph ip iq hh ir b is ml iu iv iw mm iy iz ja mn jc jd je mo jg jh ji mp jk jl jm ha bi translated">跑步有两种形式:</p><ul class=""><li id="aaf1" class="jt ju hh ir b is it iw ix ja jv je jw ji jx jm jy jz ka kb bi translated"><code class="du mi mj mk lb b">RUN &lt;command&gt;</code> ( <em class="mq"> shell </em>形式，命令在shell中运行，默认为Linux上的<code class="du mi mj mk lb b">/bin/sh -c</code>或Windows上的<code class="du mi mj mk lb b">cmd /S /C</code></li><li id="f239" class="jt ju hh ir b is kc iw kd ja ke je kf ji kg jm jy jz ka kb bi translated"><code class="du mi mj mk lb b">RUN ["executable", "param1", "param2"]</code> ( <em class="mq"> exec </em>表单)</li></ul><p id="c7dd" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du mi mj mk lb b">RUN</code>指令将在当前图像之上的新层中执行任何命令，并提交结果。最终提交的图像将用于<code class="du mi mj mk lb b">Dockerfile</code>中的下一步。</p><p id="d601" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">RUN</strong>命令在构建时在容器内运行。</p><pre class="jo jp jq jr fd la lb lc ld aw le bi"><span id="c6b8" class="lf lg hh lb b fi lh li l lj lk">RUN /bin/bash -c 'source $HOME/.bashrc; echo $HOME'</span></pre><h1 id="c864" class="ll lg hh bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">入口点</h1><p id="8f07" class="pw-post-body-paragraph ip iq hh ir b is ml iu iv iw mm iy iz ja mn jc jd je mo jg jh ji mp jk jl jm ha bi translated">入口点有两种形式:</p><ul class=""><li id="c8de" class="jt ju hh ir b is it iw ix ja jv je jw ji jx jm jy jz ka kb bi translated"><code class="du mi mj mk lb b">ENTRYPOINT ["executable", "param1", "param2"]</code> ( <em class="mq">执行</em>形式，首选)</li><li id="135a" class="jt ju hh ir b is kc iw kd ja ke je kf ji kg jm jy jz ka kb bi translated"><code class="du mi mj mk lb b">ENTRYPOINT command param1 param2</code> ( <em class="mq">外壳</em>形式)</li></ul><p id="6243" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一个<code class="du mi mj mk lb b">ENTRYPOINT</code>允许你配置一个作为可执行文件运行的容器。</p><p id="3c9f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">ENTRYPOINT设置容器运行时将首先执行的命令和参数。传递给<code class="du mi mj mk lb b">docker run &lt;image&gt;</code>的任何命令行参数都将被附加到ENTRYPOINT命令，并覆盖所有使用<code class="du mi mj mk lb b">CMD</code>指定的元素。例如，<code class="du mi mj mk lb b">docker run &lt;image&gt; bash</code>我们将把命令参数<strong class="ir hi"> bash </strong>添加到ENTRYPOINT命令的末尾。</p><p id="0b7f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您可以使用<code class="du mi mj mk lb b"><a class="ae mr" href="https://docs.docker.com/engine/reference/run/#entrypoint-default-command-to-execute-at-runtime" rel="noopener ugc nofollow" target="_blank">docker run --entrypoint</a></code>覆盖入口点指令</p><pre class="jo jp jq jr fd la lb lc ld aw le bi"><span id="c80a" class="lf lg hh lb b fi lh li l lj lk">ENTRYPOINT [ "sh", "-c", "echo $HOME" ]</span></pre><p id="4893" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果没有指定入口点，Docker将使用/bin/sh -c作为默认的执行器。</p><h1 id="450b" class="ll lg hh bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">煤矿管理局</h1><p id="35dc" class="pw-post-body-paragraph ip iq hh ir b is ml iu iv iw mm iy iz ja mn jc jd je mo jg jh ji mp jk jl jm ha bi translated"><code class="du mi mj mk lb b">CMD</code>指令有三种形式:</p><ul class=""><li id="9e27" class="jt ju hh ir b is it iw ix ja jv je jw ji jx jm jy jz ka kb bi translated"><code class="du mi mj mk lb b">CMD ["executable","param1","param2"]</code> ( <em class="mq"> exec </em>表单，这是首选表单)</li><li id="91e4" class="jt ju hh ir b is kc iw kd ja ke je kf ji kg jm jy jz ka kb bi translated"><code class="du mi mj mk lb b">CMD ["param1","param2"]</code>(作为<em class="mq">入口点</em>的默认参数)</li><li id="afe6" class="jt ju hh ir b is kc iw kd ja ke je kf ji kg jm jy jz ka kb bi translated"><code class="du mi mj mk lb b">CMD command param1 param2</code> ( <em class="mq">外壳</em>形式)</li></ul><p id="2818" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">CMD的主要目的是在执行容器时提供默认值。这些将在入口点之后执行。</p><p id="da7d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在Dockerfiles中，您可以定义包含可执行文件的<code class="du mi mj mk lb b">CMD</code>默认值。</p><h1 id="0e77" class="ll lg hh bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">复制</h1><p id="5a26" class="pw-post-body-paragraph ip iq hh ir b is ml iu iv iw mm iy iz ja mn jc jd je mo jg jh ji mp jk jl jm ha bi translated">复制有两种形式:</p><ul class=""><li id="15b0" class="jt ju hh ir b is it iw ix ja jv je jw ji jx jm jy jz ka kb bi translated"><code class="du mi mj mk lb b">COPY &lt;src&gt;... &lt;dest&gt;</code></li><li id="0b14" class="jt ju hh ir b is kc iw kd ja ke je kf ji kg jm jy jz ka kb bi translated"><code class="du mi mj mk lb b">COPY ["&lt;src&gt;",... "&lt;dest&gt;"]</code>(包含空格的路径需要此表单)</li></ul><p id="b7c3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> COPY </strong>命令用于从源文件复制一个或多个本地文件或文件夹，并将它们添加到目标路径的容器的文件系统中。</p><p id="a49f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">它在层中构建图像，从父图像开始，使用<code class="du mi mj mk lb b">FROM</code>定义。Docker指令<strong class="ir hi"> WORKDIR </strong>为跟随其后的<strong class="ir hi"> COPY </strong>指令定义了一个工作目录。</p><p id="d2bc" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du mi mj mk lb b">&lt;dest&gt;</code>是一个绝对路径，或者是一个相对于<code class="du mi mj mk lb b">WORKDIR</code>的路径，源将被复制到目标容器中。</p><pre class="jo jp jq jr fd la lb lc ld aw le bi"><span id="2748" class="lf lg hh lb b fi lh li l lj lk">COPY test relativeDir/   # adds "test" to `WORKDIR`/relativeDir/<br/>COPY test /absoluteDir/  # adds "test" to /absoluteDir/</span></pre><h1 id="65b3" class="ll lg hh bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">注意缺陷障碍 (Attention Deficit Disorder)</h1><p id="4d42" class="pw-post-body-paragraph ip iq hh ir b is ml iu iv iw mm iy iz ja mn jc jd je mo jg jh ji mp jk jl jm ha bi translated">添加有两种形式:</p><ul class=""><li id="03bf" class="jt ju hh ir b is it iw ix ja jv je jw ji jx jm jy jz ka kb bi translated"><code class="du mi mj mk lb b">ADD &lt;src&gt;... &lt;dest&gt;</code></li><li id="86ac" class="jt ju hh ir b is kc iw kd ja ke je kf ji kg jm jy jz ka kb bi translated"><code class="du mi mj mk lb b">ADD ["&lt;src&gt;",... "&lt;dest&gt;"]</code></li></ul><p id="0fca" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> ADD </strong>命令用于从源添加一个或多个本地文件或文件夹，并将它们添加到目标路径的容器的文件系统中。</p><p id="e47a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">它类似于复制命令，但有一些附加功能:</p><ul class=""><li id="9ac9" class="jt ju hh ir b is it iw ix ja jv je jw ji jx jm jy jz ka kb bi translated">如果源文件是一个可识别压缩格式的<strong class="ir hi"> local </strong> <strong class="ir hi"> tar </strong>归档文件，那么它会作为一个目录自动解压缩到Docker映像中。</li><li id="57eb" class="jt ju hh ir b is kc iw kd ja ke je kf ji kg jm jy jz ka kb bi translated">如果源文件是一个URL，那么它将下载文件并将其复制到Docker映像中的目标位置。然而，Docker不鼓励为此使用<strong class="ir hi">添加</strong>。</li></ul><pre class="jo jp jq jr fd la lb lc ld aw le bi"><span id="dead" class="lf lg hh lb b fi lh li l lj lk">ADD rootfs.tar.xz /<br/>ADD http://example.com/big.tar.xz /usr/src/things/</span></pre><h1 id="d7ef" class="ll lg hh bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">揭露</h1><pre class="jo jp jq jr fd la lb lc ld aw le bi"><span id="3537" class="lf lg hh lb b fi lh li l lj lk">EXPOSE &lt;port&gt; [&lt;port&gt;/&lt;protocol&gt;...]</span></pre><p id="3bd5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du mi mj mk lb b">EXPOSE</code>命令通知Docker容器在运行时监听指定的网络端口。您可以指定端口是侦听TCP还是UDP，如果未指定协议，默认为TCP。</p><p id="63a7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">但是<strong class="ir hi"> EXPOSE将不</strong>允许通过定义的端口与同一网络之外的容器或主机进行通信。为了实现这一点，你需要<em class="mq">发布</em>端口。</p><p id="a2fa" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> EXPOSE </strong>命令实际上并不发布端口。要在运行容器时实际发布端口，请使用<code class="du mi mj mk lb b">-p</code>标志<code class="du mi mj mk lb b">docker run</code>来发布和映射一个或多个端口，或者使用<code class="du mi mj mk lb b">-P</code>标志来发布所有公开的端口，并将它们映射到高阶端口。</p><p id="8e54" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">佐马托价格预测</strong></p><p id="88bd" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们看一个使用docker实现来预测餐馆Zomato价格的例子。</p><p id="1ef8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">下面是为实现创建的docker文件。</p><pre class="jo jp jq jr fd la lb lc ld aw le bi"><span id="2543" class="lf lg hh lb b fi lh li l lj lk">#specify the parent base image which is the python version 3.7<br/>FROM python:3.8<br/><br/># This prevents Python from writing out pyc files<br/>ENV PYTHONDONTWRITEBYTECODE 1<br/># This keeps Python from buffering stdin/stdout<br/>ENV PYTHONUNBUFFERED 1<br/><br/># install system dependencies<br/>RUN apt-get update \<br/>    &amp;&amp; apt-get -y install gcc make \<br/>    &amp;&amp; rm -rf /var/lib/apt/lists/*<br/><br/># install dependencies<br/>RUN pip install --no-cache-dir --upgrade pip<br/><br/># set work directory<br/>WORKDIR /src/app<br/><br/># copy requirements.txt<br/>COPY ./requirements.txt /src/app/requirements.txt<br/><br/># install project requirements<br/>RUN pip install --no-cache-dir -r requirements.txt<br/><br/># copy project<br/>COPY . .<br/><br/># Generate pikle file<br/>#WORKDIR /src/app/ML_Model<br/>#RUN python model.py<br/><br/># set work directory<br/>WORKDIR /src/app<br/><br/># set app port<br/>EXPOSE 8080<br/><br/>ENTRYPOINT [ "python" ]<br/><br/># Run app.py when the container launches<br/>CMD [ "app.py","run","--host","0.0.0.0"]</span></pre><p id="a7c5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">码头工人确认</strong></p><p id="2fd8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">要验证docker安装，请尝试在命令提示符下输入docker-version</p><figure class="jo jp jq jr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ms"><img src="../Images/dbe9c431cb541bf5b7743f7874f86e8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jjGxzgFZLwgdH8jBhyXE2Q.png"/></div></div></figure><p id="a3cd" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">下一步是构建docker文件，如下所示。</p><p id="9004" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">使用Docker文件构建</strong></p><p id="5460" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">打开命令提示符，将目录指向项目工作区，如下所示，</p><figure class="jo jp jq jr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mt"><img src="../Images/ccc77254de9b0af62084be885c2934e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kgl_LogHdlWcYzbO-HaHBw.png"/></div></div></figure><p id="50cf" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">尝试使用“docker build -t &lt;<name>&gt;”命令一旦提供了命令，docker就按照DockerFile实现生成构建。</name></p><figure class="jo jp jq jr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mu"><img src="../Images/58dcda3ec2521410f64b0f561be7140c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OuQtIhiVIplu1Wa0oQ3bEA.png"/></div></div></figure><p id="c943" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">打开docker应用程序并导航到图像。验证创建的“zomato-price-predict”图像。</p><figure class="jo jp jq jr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mv"><img src="../Images/b1ae9005d4d772fd3a3c4246dfd27e49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7GKFLgNJmGokMNn92HIqlQ.png"/></div></div></figure><p id="f717" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">运行Docker </strong></p><p id="cd78" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">尝试以下命令，该命令的名称代表对应用程序的引用。这将显示在docker容器部分。</p><pre class="jo jp jq jr fd la lb lc ld aw le bi"><span id="decb" class="lf lg hh lb b fi lh li l lj lk">docker run --name deployML -p 8080:8080 zomato-price-predict</span></pre><p id="d7cb" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">执行命令后，应用程序正在运行。</p><figure class="jo jp jq jr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mw"><img src="../Images/4b2667ad7f2b482e5aee79e9f9613a84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GEL0GAxrFL3-i8p7KA1QbQ.png"/></div></div></figure><p id="2537" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">验证集装箱部分，如下所示:</p><figure class="jo jp jq jr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mx"><img src="../Images/1185860beeaab19c582b87eaca92f3d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0Ey0KfS5jtjBByUXFF-B2g.png"/></div></div></figure><p id="2f93" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">最后，我们可以看到应用程序正在运行</p><figure class="jo jp jq jr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es my"><img src="../Images/0e7f118858766b53a2d9fc87d1650307.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*74BtmbRJ278y444dxOF1iw.png"/></div></div></figure><p id="d09b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们还可以看到应用程序日志。</p><figure class="jo jp jq jr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mz"><img src="../Images/9536e400f7e0bc52465403ab122165bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BycZBm-116OpXmc45Z8_GQ.png"/></div></div></figure><p id="487e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">希望这篇文章给你一个在机器学习中实现docker的更好的想法。</p><p id="9c90" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">希望你喜欢我的文章！！</p></div></div>    
</body>
</html>