<html>
<head>
<title>Forecasting SP500 stocks with XGBoost and Python Part 2: Building the model</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用XGBoost和Python预测SP500股票第2部分:建立模型</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/forecasting-sp500-stocks-with-xgboost-and-python-part-2-building-the-model-89c9c40e49fc?source=collection_archive---------0-----------------------#2022-05-30">https://medium.com/mlearning-ai/forecasting-sp500-stocks-with-xgboost-and-python-part-2-building-the-model-89c9c40e49fc?source=collection_archive---------0-----------------------#2022-05-30</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="174c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">欢迎来到“用XGBoost和Python预测SP500股票”系列的第2部分，这是一个由两部分组成的系列，我将带您创建一个用于时间序列预测的基本XGBoost模型。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/13a6148b2a36f56f8e04aa1e501e8a3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*E1BU2OhLjAXzpedq"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Cover image (<a class="ae js" href="https://www.pexels.com/photo/high-angle-photo-of-robot-2599244/" rel="noopener ugc nofollow" target="_blank">source</a>)</figcaption></figure><p id="dcfc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">本系列的目标是向您介绍我是如何基于XGBoost的梯度提升树算法(简称XGBRegressor)创建一个基本预测模型的。</p><p id="d99c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我一开始想知道如何轻松地得到一个工作模型，现在我<strong class="ig hi">与你分享这个过程，换句话说，这个系列特别针对那些从预测开始的人。</strong></p><p id="fd5c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae js" href="https://soulsinporto.medium.com/forecasting-sp500-stocks-with-xgboost-and-python-part-1-sourcing-the-data-c43bee956e1c" rel="noopener">第1部分</a>是关于获取数据的。从2017年1月1日到2022年12月31日，我们使用pandas-datareader下载了所有SP500股票。最后，我向你展示了如何计算日收益率，以了解调整后的收盘价每天的变化。</p><p id="25e3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">像往常一样，你可以在这里找到GitHub <a class="ae js" href="https://github.com/Ze1598/medium-articles/tree/master/Forecasting%20SP500%20stocks%20with%20XGBoost%20and%20Python%20Part%202%20-%20Building%20the%20Model" rel="noopener ugc nofollow" target="_blank">上的所有支持代码。</a></p><p id="c048" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，对于这个模型，我们从…实际上，在进行机器学习之前，让我们再看一遍数据集。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jt"><img src="../Images/cd20e91508898eeaf074ccf6d0c0fb40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NsT0phCOTSshqOh_aIEDOA.png"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Dataset preview</figcaption></figure><ul class=""><li id="9ac3" class="ju jv hh ig b ih ii il im ip jw it jx ix jy jb jz ka kb kc bi translated">日期:在股票值中，每只股票每天有一行</li><li id="8e4a" class="ju jv hh ig b ih kd il ke ip kf it kg ix kh jb jz ka kb kc bi translated">高:每只股票当天的最高价值</li><li id="28e6" class="ju jv hh ig b ih kd il ke ip kf it kg ix kh jb jz ka kb kc bi translated">低:每只股票当天的最低价格</li><li id="df09" class="ju jv hh ig b ih kd il ke ip kf it kg ix kh jb jz ka kb kc bi translated">开盘:每只股票当天的开盘价</li><li id="20c5" class="ju jv hh ig b ih kd il ke ip kf it kg ix kh jb jz ka kb kc bi translated">收盘:每只股票当天的收盘价格</li><li id="dea2" class="ju jv hh ig b ih kd il ke ip kf it kg ix kh jb jz ka kb kc bi translated">成交量:当日每只股票的交易数量</li><li id="4afc" class="ju jv hh ig b ih kd il ke ip kf it kg ix kh jb jz ka kb kc bi translated">调整收盘:或调整收盘，"<a class="ae js" href="https://help.yahoo.com/kb/SLN28256.html?guccounter=1&amp;guce_referrer=aHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS8&amp;guce_referrer_sig=AQAAAGhsAVIk_x7BX5ggAUg6UvyoBM4nBrVp1aQx0jyeyKq0ISK1y_AZnacjl7Rth-qWABZbC4DjSvs67aRUFBxdP3ITEB0h2p-eTGS3-QVhKGdAnpa2QdR8xcVL9X9lPkC1yWWv8KfSZKlzqcuOG34Rb3ZjRPQaCCJu7Oqg3Vq8biZw#:~:text=Adjusted%20close%20is%20the%20closing,Security%20Prices%20(CRSP)%20standards." rel="noopener ugc nofollow" target="_blank">是所有适用拆分和股息分配调整后的收盘价</a>"</li><li id="a76f" class="ju jv hh ig b ih kd il ke ip kf it kg ix kh jb jz ka kb kc bi translated">每日回报率%:调整收盘的日增长率</li></ul><p id="ea82" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">既然您已经熟悉了这些数据，那么让我们开始研究特性工程吧。</p><h1 id="707c" class="ki kj hh bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">特征工程</h1><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es lg"><img src="../Images/4fcc905dbc25dc06c84d563960168ee8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VNgDu6xgiKFS9Fft6csDBA.png"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Feature engineering code</figcaption></figure><p id="4702" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">此模型的要素工程的主要目标是将原始数据集中的所有非数字列转换为数字要素。换句话说，我必须将代码映射成整数，并将日期部分分解成它们自己的特征。</p><p id="fc4c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第一个单元格创建一个单独的数据帧(DF ),保存Ticker列中所有不同的Ticker，并将它们映射到一个整数。这不是培训所需要的，但与以后评估模型相关。</p><p id="81c8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第二个单元格为每个日期特性创建一个单独的列:年、月和日。同样，我们只能用数字特征进行训练。</p><p id="516c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第三个单元将代码映射到整数，但这一次它是用于训练的特性，而不是像以前那样是一个单独的DF。</p><p id="8ebc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最后，第四个单元格删除不需要的列。</p><p id="58c5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我没有进一步研究这个模型的特征工程，所以这里是DF在这一点上的样子:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es lh"><img src="../Images/9de31e7b568a31f9344a1875fde44c30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v6JTwvR3FZp1seHcDOeelA.png"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Dataset after feature engineering</figcaption></figure><p id="4914" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">不要担心日期列——我们还需要它做最后一件事。</p><h1 id="57e8" class="ki kj hh bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">训练评估数据集</h1><p id="001b" class="pw-post-body-paragraph ie if hh ig b ih li ij ik il lj in io ip lk ir is it ll iv iw ix lm iz ja jb ha bi translated">下一步是将数据集分为训练数据集和评估数据集。前者用于训练模型，后者用于评估模型的性能。</p><p id="62d1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">与常规回归或分类模型相比，这里数据的顺序很重要。这是一个时间序列模型，即我们希望行按日期排序。换句话说，训练-评估分割是DF的直接分割，在这种情况下，前90%的行用于训练，剩余的10%用于评估模型。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es ln"><img src="../Images/ea024a8adc35f2459a53a512e0baa983.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e-PU6oARUvFJlQXy3yOTLQ.png"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Train-eval split</figcaption></figure><p id="460e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我计算了哪个列表索引表示可用的唯一日期的90%分割:90%分割索引处的日期是用于分割DF行的日期。</p><p id="21a1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="lo"> query </em>函数非常方便地以更pythonic化的语法过滤DFs，它甚至允许您引用带有@的变量。</p><p id="3534" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">既然每个数据集都有一个DF，我只需将要素和标注分开即可-请注意，要素中不包含日期，它保留在要素工程的最后，纯粹是为了分割数据。</p><h1 id="55f8" class="ki kj hh bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">建立模型</h1><p id="3ee4" class="pw-post-body-paragraph ie if hh ig b ih li ij ik il lj in io ip lk ir is it ll iv iw ix lm iz ja jb ha bi translated">现在是构建ML模型的时候了。我跳过了所有关于超参数调优的内容，给出了一组值，但是请记住，这些值来自实验和自动调优。我强烈推荐检查<a class="ae js" href="https://optuna.org/" rel="noopener ugc nofollow" target="_blank"> Optuna </a>，它是用于自动调整超参数的库。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es lp"><img src="../Images/6aff79524be92bcc50f0b12371b7e72a.png" data-original-src="https://miro.medium.com/v2/resize:fit:634/format:webp/1*cpM4lDzATTIol5G3DAq28w.png"/></div><figcaption class="jo jp et er es jq jr bd b be z dx">Model definition</figcaption></figure><p id="448d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">同样，经过大量的反复试验和一些自动调整，我发现这是最好的超参数集——这包括90%的训练和评估。</p><p id="fb1f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这是训练模型的代码:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es lq"><img src="../Images/c6e683b47a51fc8d254c3b630fa3dc73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nhD9pEdeOXLKVvLxDyl70Q.png"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Training the model</figcaption></figure><p id="96ea" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">输出显示了用于模型的所有参数及其默认值，除了我在前面的代码单元中定义模型时指定的四个参数。</p><p id="ce0b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">XGBoost有一个简洁的方法来绘制特征对模型的重要性，即每个训练特征对模型预测能力的贡献。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es lr"><img src="../Images/49669fbb73a01ff39e47fe0cbea09f27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aTRdjXaLsrUdUPhYD_qklQ.png"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Feature importance</figcaption></figure><p id="6b5a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">日最高值是预测的最重要特征，其次是报价器。就我个人而言，我希望顶部有股票行情和其他金融功能，但我希望每日回报率%更相关。结果我的直觉被数据证明是错的:)</p><h1 id="531a" class="ki kj hh bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">评估模型—回归度量</h1><p id="5f66" class="pw-post-body-paragraph ie if hh ig b ih li ij ik il lj in io ip lk ir is it ll iv iw ix lm iz ja jb ha bi translated">至此，模型已经完成，但我想向大家展示我是如何评估这个模型的。我分两部分来做:</p><ul class=""><li id="1243" class="ju jv hh ig b ih ii il im ip jw it jx ix jy jb jz ka kb kc bi translated">首先，我使用常见的回归指标，因为我有实际值和模型预测的值，我们称之为监督训练</li><li id="eb3c" class="ju jv hh ig b ih kd il ke ip kf it kg ix kh jb jz ka kb kc bi translated">其次，我绘制了多个报价器的预测值与实际值的对比图</li></ul><p id="e540" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">注意，我使用回归指标是因为模型预测了一个具体的数字，在本例中是美元，而不是一个数字值来给每个数据点分配一个类别。</p><p id="edae" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">首先，我必须重建评估数据。这意味着从年、月、日重新创建日期，对评估数据进行预测，并将股票代码映射回名称。</p><p id="bb18" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">此基础DF是x_eval DF，即不带标签/调整后关闭列的eval DF。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es ls"><img src="../Images/b845ede26a321a928e01b063f79da6e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dQ_NpxHKLLuWS1G4rWhcgw.png"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Create a DF for evaluation</figcaption></figure><p id="db17" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第一个单元格创建新的DF进行评估，并从单独的年、月和日特性中重新创建日期列。</p><p id="1042" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第二个单元格使用原始评估数据集来预测调整后的关闭值—请记住，x_eval和df_pred在这一点上基本相同，具有相同的行数，但x_eval具有进行预测所需的功能。这只是在正确的DF中保存预测的问题，公平地说，我可以在创建Date列之前用df_pred进行预测。</p><p id="71c3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">还记得在开头用股票代号和数字创建的单独的DF吗？它在第三个代码单元格中返回，将股票代码映射回姓名。</p><p id="df21" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">完成DF后，现在我们可以计算:</p><ul class=""><li id="5e29" class="ju jv hh ig b ih ii il im ip jw it jx ix jy jb jz ka kb kc bi translated">均方误差</li><li id="3c53" class="ju jv hh ig b ih kd il ke ip kf it kg ix kh jb jz ka kb kc bi translated">平均绝对误差</li><li id="6241" class="ju jv hh ig b ih kd il ke ip kf it kg ix kh jb jz ka kb kc bi translated">平均绝对误差百分比(MAEP)</li></ul><p id="4453" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">简而言之，所有三列都计算预测值和实际值之间的差值的聚合值，但是使用不同的单位。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es lt"><img src="../Images/a6984e53de33f958f1b72668d8e955d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Da8n3bafM-XQ6qcvn08YLQ.png"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Regression metrics</figcaption></figure><p id="2774" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">根据度量标准，该模型的预测值与真实值之间的平均差异为1.13%(MAEP)。从MAE的角度来看，每个预测平均误差为1.56美元(提供的数据以美元为单位)。</p><h1 id="0b00" class="ki kj hh bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">评估模型——绘制预测值与实际值</h1><p id="1288" class="pw-post-body-paragraph ie if hh ig b ih li ij ik il lj in io ip lk ir is it ll iv iw ix lm iz ja jb ha bi translated">好了，在这一点上，我不会用更多的代码来打扰你。完整的笔记本可以在GitHub <a class="ae js" href="https://github.com/Ze1598/medium-articles/tree/master/Forecasting%20SP500%20stocks%20with%20XGBoost%20and%20Python%20Part%202%20-%20Building%20the%20Model" rel="noopener ugc nofollow" target="_blank">这里</a>获得，这样你就可以在闲暇时阅读这些图是如何计算出来的。让我们直接进入剧情。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es lu"><img src="../Images/b4aa5d01e592c54236f6f4dbbc446713.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jKKVmdqLQBJxCWBmFjc7Gw.png"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">AMD predictions</figcaption></figure><p id="a61b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">选择AMD作为一只孤立的股票，该模型非常接近，特别是在2021年8月之前，但随着时间的推移，差异变得非常小，无法预测真实数据中的一些模式-即在2021年10月至11月期间。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es lu"><img src="../Images/bc1206b9b280a95cff7a29c6a917ddad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9_ZOn-E_Ngc1qHkykMO0ng.png"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">NVR predictions</figcaption></figure><p id="6d66" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第一个图显示了AMD，因为它是一家熟悉的公司，但在第二个图中选择了NVR，因为它是模型在初始测试中显示预测能力最弱的公司之一。这并不完全可怕，但它未能预测大多数模式随时间的变化。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es lv"><img src="../Images/42f40f42c5d968610bbe22d350e5a50c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DmbRgs5119kVYBATK_famA.png"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">AMD and INTC predictions</figcaption></figure><p id="4222" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">并排查看AMD和英特尔的预测，我们看到该模型表现相当不错。即使英特尔的股票在底部视觉中更有规律，我们也可以再次看到该模型在预测AMD股票随时间的波动方面做得不错。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es lw"><img src="../Images/66196db31b60bb19054093363acc9411.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7DqY2VW_b2Fr25YPnR_EGA.png"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">GOOG, AMZN, and GOOGL predictions</figcaption></figure><p id="e10b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了演示的目的，看看另一组不规则变化的股票，我们可以看到该模型并没有完全适应波动，特别是对于GOOG的股票。</p><p id="6562" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">好了，看看股票，总的来说，模型对哪些公司了解最少？这是MAPE最高的10家公司的条形图。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es lx"><img src="../Images/f969c92eb58caef288b0fb487debb027.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O7l7NjT_hGsmSADco2efJQ.png"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Top 10 Highest MAPE companies</figcaption></figure><p id="fc5c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">哇，NLOK有一个非常高的MAPE…不知道预测和实际看起来像什么…</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es ly"><img src="../Images/0545e1157e361528251099bd3e1bc29f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sMIiXagmFhgwz5Usy5XT1A.png"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">NLOK predictions</figcaption></figure><p id="f3c9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">嗯，我明白了，没那么好。该模型知道股票波动性很大，但不知道NLOK的波动性到底是如何工作的。</p><p id="0c4a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">好，让我们做最后一个图:MAPE随时间的演变:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es lz"><img src="../Images/b84bc3eeb232992ab387261d867e140e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1Dl2LrKVDvmKt_M7HZho2Q.png"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">MAPE over time</figcaption></figure><p id="94f3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这里没有什么出乎意料的:模型预测未来的能力越低，因为金融数据受到现实世界中如此多变量的影响。</p><h1 id="8a6f" class="ki kj hh bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">结束语</h1><p id="5e8f" class="pw-post-body-paragraph ie if hh ig b ih li ij ik il lj in io ip lk ir is it ll iv iw ix lm iz ja jb ha bi translated">首先，这是一个有趣的ML项目，可以在我的业余时间进行。如果我完全诚实的话，这几乎不涉及科学，但即使是做基本的特征工程和超参数调整，看看我可以得到多低的MAPE，以及我可以得到多接近图中的预测线和实际线，也是一个有益的迭代过程。</p><p id="abd5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">很明显，这个模型还有待改进，训练中需要包括不同的数据，甚至可能需要使用不同的模型算法。此外，这是一个适用于所有SP500股票的通用模型——显然有理由设计更具体的模型，比如针对特定行业的模型。</p><p id="4036" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然而，最终获得使用时间序列模型并使其工作的实践经验是相当冒险的，我希望分享这些经验可以帮助您开始使用XGBoost和预测。我们在开始时都会犯错误，并得到不好的结果，所以我想分享我的经验，让你在下一个项目中有一个良好的开端:)</p><div class="ma mb ez fb mc md"><a rel="noopener follow" target="_blank" href="/mlearning-ai/mlearning-ai-submission-suggestions-b51e2b130bfb"><div class="me ab dw"><div class="mf ab mg cl cj mh"><h2 class="bd hi fi z dy mi ea eb mj ed ef hg bi translated">Mlearning.ai提交建议</h2><div class="mk l"><h3 class="bd b fi z dy mi ea eb mj ed ef dx translated">如何成为Mlearning.ai上的作家</h3></div><div class="ml l"><p class="bd b fp z dy mi ea eb mj ed ef dx translated">medium.com</p></div></div><div class="mm l"><div class="mn l mo mp mq mm mr jm md"/></div></div></a></div></div></div>    
</body>
</html>