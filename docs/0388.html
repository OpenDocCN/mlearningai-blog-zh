<html>
<head>
<title>Constructing a DataBlock using Fastai</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Fastai构建数据块</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/constructing-a-datablock-using-fastai-7703752ae17a?source=collection_archive---------2-----------------------#2021-04-03">https://medium.com/mlearning-ai/constructing-a-datablock-using-fastai-7703752ae17a?source=collection_archive---------2-----------------------#2021-04-03</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/8af74e1af778c294f4322c5ed71fb31b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZMnzmYK24GRGcv9w0A2smg.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Photo by <a class="ae it" href="https://unsplash.com/@iurte?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Iker Urteaga</a> on <a class="ae it" href="https://unsplash.com/s/photos/block?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="32c6" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这些是我在阅读《程序员的深度学习》一书和参加fastai课程时做的笔记，下面的笔记将是书本内容和我对事情如何工作的理解的结合。这是来自第六章:其他计算机视觉问题。</p><p id="ee79" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们有一个DataFrame对象，如何将它转换成DataLoaders对象？我们通常构建一个数据块，然后用它创建一个DataLoaders对象。在本教程中，我们将一步一步地为多标签分类问题构建一个数据块。</p><p id="76b5" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在开始构建数据块之前，我们应该确保理解下面的4个术语。</p><h2 id="e0a7" class="js jt hh bd ju jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km bi translated">资料组</h2><p id="5dd9" class="pw-post-body-paragraph iu iv hh iw b ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn kr jp jq jr ha bi translated">返回单个项目的自变量和因变量元组的集合。</p><h2 id="5d66" class="js jt hh bd ju jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km bi translated">数据加载器</h2><p id="55bd" class="pw-post-body-paragraph iu iv hh iw b ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn kr jp jq jr ha bi translated">一个迭代器，提供一个小批量流，其中每个小批量是一对自变量和因变量</p><p id="d946" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在这些之上，fastai引入了两个类，用于将训练集和验证集结合在一起。它们被称为数据集和数据加载器。</p><h2 id="6382" class="js jt hh bd ju jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km bi translated">数据集</h2><p id="0fd0" class="pw-post-body-paragraph iu iv hh iw b ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn kr jp jq jr ha bi translated">包含训练数据集和验证数据集的迭代器→训练集和有效集的自变量和因变量的元组。</p><h2 id="63ee" class="js jt hh bd ju jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km bi translated">数据加载器</h2><p id="933c" class="pw-post-body-paragraph iu iv hh iw b ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn kr jp jq jr ha bi translated">包含定型数据加载器和验证数据加载器的对象。</p><p id="8930" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">因为<strong class="iw hi">数据加载器</strong>建立在<strong class="iw hi">数据集</strong>的基础上，并为其添加了额外的功能，(将多个项目整理成一个小批量)。通常从创建和测试<code class="du ks kt ku kv b"><strong class="iw hi">Datasets</strong></code>开始更容易，然后在知道<code class="du ks kt ku kv b"><strong class="iw hi">Datasets</strong></code>工作后再看<code class="du ks kt ku kv b"><strong class="iw hi">DataLoaders</strong></code>。</p><p id="fe5a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们从零开始创造吧！！！</p><p id="0343" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">首先，我们创建一个空的<code class="du ks kt ku kv b">DataBlock</code>对象，为了创建一个<code class="du ks kt ku kv b">Datasets</code> <strong class="iw hi"> </strong>对象，我们需要一个源，它可以是一个图像，数据帧，或者任何你想放进去的数据。</p><figure class="kx ky kz la fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kw"><img src="../Images/3cd2a98c9c14bf70c93176f69191afd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3ZYkyUs66sJ9js1tx9gHVg.png"/></div></div></figure><p id="5399" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这里有点混乱为什么要打印两次？默认情况下，数据块假设我们有两样东西:</p><figure class="kx ky kz la fd ii er es paragraph-image"><div class="er es lb"><img src="../Images/4a466268237ead8204e27dc476af4fad.png" data-original-src="https://miro.medium.com/v2/resize:fit:950/format:webp/1*fUfkyWOkkKFTA5yUZohx5g.png"/></div></figure><ul class=""><li id="7152" class="lc ld hh iw b ix iy jb jc jf le jj lf jn lg jr lh li lj lk bi translated">投入</li><li id="d0c0" class="lc ld hh iw b ix ll jb lm jf ln jj lo jn lp jr lh li lj lk bi translated">目标</li></ul><p id="3c42" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">但是我们不需要所有这些东西，所以我们将从数据帧中获取适当的字段，我们可以绕过<code class="du ks kt ku kv b">get_x</code>和<code class="du ks kt ku kv b">get_y</code>函数。</p><figure class="kx ky kz la fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lq"><img src="../Images/eda51dbbe1993630f39fdacefc50b11e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IvWB9RhneDACNZe22PKcDw.png"/></div></div></figure><p id="7bc2" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">但是自变量(x)将需要被转换成一个完整的路径，以便我们可以将其作为一个图像打开，而因变量应该在空格字符上拆分。因为它们联系在一起，但实际上，它们是两个不同的对象。</p><figure class="kx ky kz la fd ii er es paragraph-image"><div class="er es lr"><img src="../Images/71b256a3e125e32f3b712aea6c3806b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1198/format:webp/1*fIT1RiM6Xt9bnRGlwHxV6g.png"/></div></figure><p id="22f7" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">好吧。我们现在得到了路径，但是我们如何打开图像并在张量上进行转换呢？</p><p id="193f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为此，我们需要使用一组变换，块类型将为我们提供这些变换。到目前为止，我们看到的块是<code class="du ks kt ku kv b">ImageBlock</code>和<code class="du ks kt ku kv b">CategoryBlock</code>当然，我们可以使用相同的块，但有一个例外。在这个问题中我们不能使用它们<code class="du ks kt ku kv b">CategoryBlock</code>,它只需要一个整数，但是在我们的例子中，我们需要为每一项设置多个标签。</p><p id="c94b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了解决这个问题，我们使用<code class="du ks kt ku kv b">MultiCategoryBlock</code>可以得到一个字符串列表，就像在这个例子中一样。</p><figure class="kx ky kz la fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ls"><img src="../Images/619585e4b2081b671fdcfa2632cbd7ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a_409arXdhklIHhVtu7-Aw.png"/></div></div></figure><p id="a08a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果我们看一下，类别列表的编码方式与常规的<code class="du ks kt ku kv b">CategoryBlock</code>不同，在这种情况下，我们用一个整数来表示出现的类别。</p><p id="cbf9" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">例如，它是一只猫吗？(或者)这是阿比西尼亚猫吗？</p><p id="adc5" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在这种情况下，我们有一个在该类别出现的任何位置带有一个<code class="du ks kt ku kv b">1s</code>的<code class="du ks kt ku kv b">0s</code>列表。</p><p id="b1f8" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在这里，如果在第二个和第四个位置有一个<code class="du ks kt ku kv b">1</code>，这意味着<code class="du ks kt ku kv b">vocab</code>项目2和项目4出现在该图像中。这就是所谓的一键编码。</p><p id="9405" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们不能简单地使用类别索引列表的原因是每个列表都有不同的长度，Pytorch需要tensors，其中所有内容的长度都必须相同。</p><p id="b78a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">有了Numpy数组和Pytorch张量以及fastai的L类，我们可以直接使用列表或向量进行索引。</p><figure class="kx ky kz la fd ii er es paragraph-image"><div class="er es lt"><img src="../Images/923aa9272811a8e73c7a912a50c108dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:934/format:webp/1*leTbL8Ay7V47fpnV49vAKA.png"/></div></figure><p id="bae7" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">到目前为止，我们已经忽略了列<code class="du ks kt ku kv b">is_valid</code>，这意味着DataBlock在默认情况下一直使用随机分割。为了选择验证集的元素，我们需要编写一个函数，并将其传递给拆分器。</p><p id="b844" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">它将接受条目(在这里是我们的整个数据帧),并且必须返回两个(或更多)整数列表。</p><figure class="kx ky kz la fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kw"><img src="../Images/60e35eb28baaedf2af547e9fa24c4d90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7-7azDHTbPbwQXg_d9zYqA.png"/></div></div></figure><p id="a712" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">正如我们所讨论的,<code class="du ks kt ku kv b">DataLoader</code>将数据集中的项目整理成一个小批量。这是一个张量元组，其中每个张量简单地堆叠数据集项目中该位置的项目。</p><p id="645a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在我们要确保每个项目在放入<code class="du ks kt ku kv b">DataLoaders</code>之前都是相同的大小，我们使用<code class="du ks kt ku kv b">RandomResizedCrop</code>。</p><pre class="kx ky kz la fd lu kv lv lw aw lx bi"><span id="ba5d" class="js jt hh kv b fi ly lz l ma mb">dblock = DataBlock(blocks=(ImageBlock , MultiCategoryBlock) , <br/>                   splitter = splitter , <br/>                   get_x = get_x , <br/>                   get_y = get_y , <br/>                   item_tfms = RandomResizedCrop(128 , min_scale=0.353))</span><span id="a99d" class="js jt hh kv b fi mc lz l ma mb"># Putting into a Dataloader<br/>dls = dblock.dataloaders(df)</span><span id="e9f1" class="js jt hh kv b fi mc lz l ma mb"># Displaying a sample of our data<br/>dls.show_batch()</span></pre><figure class="kx ky kz la fd ii er es paragraph-image"><div class="er es md"><img src="../Images/bf28c114f71a9ccb7d65aa619db13029.png" data-original-src="https://miro.medium.com/v2/resize:fit:1074/format:webp/1*np-lkaO89KerlZB9BWG-kg.png"/></div></figure><p id="e733" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">没有太大的变化，相反我们从头开始构建了<code class="du ks kt ku kv b">DataBlock</code>，并使用了<code class="du ks kt ku kv b">MultiCategoryBlock</code>而不是<code class="du ks kt ku kv b">CategoryBlock</code>。正如我们所知，数据加载器将数据集中的项目整理成一个小批量。</p><p id="7046" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们的数据现在已经为模型做好了准备，即使使用它们也不会有任何变化<code class="du ks kt ku kv b">Learner</code>，但是这次我们将使用一个新的损失函数，它被称为<strong class="iw hi">二元交叉熵</strong>。</p></div></div>    
</body>
</html>