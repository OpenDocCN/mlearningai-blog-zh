<html>
<head>
<title>OPTICAL MUSIC RECOGNITION</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">光学音乐识别</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/optical-music-recognition-6257a9bcca52?source=collection_archive---------3-----------------------#2021-04-26">https://medium.com/mlearning-ai/optical-music-recognition-6257a9bcca52?source=collection_archive---------3-----------------------#2021-04-26</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/4aaf7ca88b033b9adf4eb1b539e8b7e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KtZ2c77SrpXairDC60y8jA.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Photo by <a class="ae it" href="https://unsplash.com/@iampatrickpilz?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Valentino Funghi</a> on <a class="ae it" href="https://unsplash.com/s/photos/music?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="ca97" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">问题陈述</h1><p id="cb64" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">给定一部分乐谱(PNG图像)作为输入，我们需要使用Hough变换、Naive和基于边缘检测的模板匹配等技术，根据test_images文件夹中的3个光学符号(预定义为模板)找到音符、四分休止符和八分休止符。下面给出了相同的github库。</p><div class="kq kr ez fb ks kt"><a href="https://github.com/ojaashampiholi/Optical_Music_Recognition" rel="noopener  ugc nofollow" target="_blank"><div class="ku ab dw"><div class="kv ab kw cl cj kx"><h2 class="bd hi fi z dy ky ea eb kz ed ef hg bi translated">ojaashampiholi/光学_音乐_识别</h2><div class="la l"><h3 class="bd b fi z dy ky ea eb kz ed ef dx translated">给定一个PNG图像(乐谱的一部分)作为输入，我们需要找到音符、四分休止符和八分休止符…</h3></div><div class="lb l"><p class="bd b fp z dy ky ea eb kz ed ef dx translated">github.com</p></div></div><div class="lc l"><div class="ld l le lf lg lc lh in kt"/></div></div></a></div><h1 id="9f76" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">算法概述</h1><figure class="lj lk ll lm fd ii er es paragraph-image"><div class="er es li"><img src="../Images/a9512476931580ba92335303c1a47cad.png" data-original-src="https://miro.medium.com/v2/resize:fit:34/format:webp/1*R8fe1Ib_fzCHIuUtihyAFw.png"/></div><figcaption class="ip iq et er es ir is bd b be z dx"><a class="ae it" href="https://github.com/ojaashampiholi/Optical_Music_Recognition/blob/main/test-images/template1.png" rel="noopener ugc nofollow" target="_blank">Template for Notes</a></figcaption></figure><figure class="lj lk ll lm fd ii er es paragraph-image"><div class="er es ln"><img src="../Images/31533de0bcd2b9d565689537ff00fa85.png" data-original-src="https://miro.medium.com/v2/resize:fit:32/format:webp/1*WhynoWAp9j7aoGDnfCQF5Q.png"/></div><figcaption class="ip iq et er es ir is bd b be z dx"><a class="ae it" href="https://github.com/ojaashampiholi/Optical_Music_Recognition/blob/main/test-images/template2.png" rel="noopener ugc nofollow" target="_blank">Template for Quarter Rest</a></figcaption></figure><figure class="lj lk ll lm fd ii er es paragraph-image"><div class="er es lo"><img src="../Images/9fae620179c3540e4e7582f426493c07.png" data-original-src="https://miro.medium.com/v2/resize:fit:36/format:webp/1*J89lJKUZL41ypH01GWAjeg.png"/></div><figcaption class="ip iq et er es ir is bd b be z dx"><a class="ae it" href="https://github.com/ojaashampiholi/Optical_Music_Recognition/blob/main/test-images/template3.png" rel="noopener ugc nofollow" target="_blank">Template for Eighth Rest</a></figcaption></figure><p id="9f4a" class="pw-post-body-paragraph js jt hh ju b jv lp jx jy jz lq kb kc kd lr kf kg kh ls kj kk kl lt kn ko kp ha bi translated">1.乐谱图像由用户输入。</p><p id="7dee" class="pw-post-body-paragraph js jt hh ju b jv lp jx jy jz lq kb kc kd lr kf kg kh ls kj kk kl lt kn ko kp ha bi translated">2.该应用程序有一个预定义的模板目录，用于检测音符、四分音符和八分音符。</p><p id="6fbe" class="pw-post-body-paragraph js jt hh ju b jv lp jx jy jz lq kb kc kd lr kf kg kh ls kj kk kl lt kn ko kp ha bi translated">3.预处理的第一步是将输入图像和所有模板转换成灰度。</p><p id="5b3b" class="pw-post-body-paragraph js jt hh ju b jv lp jx jy jz lq kb kc kd lr kf kg kh ls kj kk kl lt kn ko kp ha bi translated">4.执行霍夫变换以找到五线谱行之间的间距和每组中第一行的行坐标。</p><p id="49a3" class="pw-post-body-paragraph js jt hh ju b jv lp jx jy jz lq kb kc kd lr kf kg kh ls kj kk kl lt kn ko kp ha bi translated">5.一旦我们获得了五线谱线之间的间距，我们就可以调整模板的大小来匹配输入图像的比例。</p><p id="1c08" class="pw-post-body-paragraph js jt hh ju b jv lp jx jy jz lq kb kc kd lr kf kg kh ls kj kk kl lt kn ko kp ha bi translated">6.调整模板大小后的下一步是应用对象检测来识别音乐符号的类型。</p><p id="dd1c" class="pw-post-body-paragraph js jt hh ju b jv lp jx jy jz lq kb kc kd lr kf kg kh ls kj kk kl lt kn ko kp ha bi translated">7.已经实现了简单的模板匹配和基于边缘检测的模板匹配，并且是基于用例来选择的。</p><p id="2169" class="pw-post-body-paragraph js jt hh ju b jv lp jx jy jz lq kb kc kd lr kf kg kh ls kj kk kl lt kn ko kp ha bi translated">8.通过模板匹配算法获得匹配区域和相应的概率，然后进行非最大抑制。</p><p id="1c1e" class="pw-post-body-paragraph js jt hh ju b jv lp jx jy jz lq kb kc kd lr kf kg kh ls kj kk kl lt kn ko kp ha bi translated">9.通过绘制边界框和打印间距名称来生成输出图像。</p><p id="dcbc" class="pw-post-body-paragraph js jt hh ju b jv lp jx jy jz lq kb kc kd lr kf kg kh ls kj kk kl lt kn ko kp ha bi translated">10.生成的文本文件包含左上角的行和列、边界框的高度和宽度、符号类型、间距和概率。</p><h1 id="efb3" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">实施和设计选择</h1><p id="8c37" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated"><a class="ae it" href="https://github.com/ojaashampiholi/Optical_Music_Recognition/blob/main/omr.py" rel="noopener ugc nofollow" target="_blank"> <strong class="ju hi">主文件</strong> </a></p><p id="bfda" class="pw-post-body-paragraph js jt hh ju b jv lp jx jy jz lq kb kc kd lr kf kg kh ls kj kk kl lt kn ko kp ha bi translated">三个实用函数文件被导入到主文件omr.py中。一旦程序运行，main方法从命令行参数中读取输入音乐图像的名称。读取输入的PNG图像和所有模板。调用getResults()方法，并将输入图像、模板以及相应的模板因子传递给该方法。</p><p id="dfa6" class="pw-post-body-paragraph js jt hh ju b jv lp jx jy jz lq kb kc kd lr kf kg kh ls kj kk kl lt kn ko kp ha bi translated"><strong class="ju hi"><em class="lu">getResults()</em></strong><em class="lu">—</em>在get results()方法中创建三个实用程序文件中的类的实例。</p><p id="c63b" class="pw-post-body-paragraph js jt hh ju b jv lp jx jy jz lq kb kc kd lr kf kg kh ls kj kk kl lt kn ko kp ha bi translated">然后，输入图像被转换为numpy数组格式以进行进一步的操作，然后使用kernelOperations类中的“rgbtogray()”方法将RGB图像数组中的每个通道乘以特定权重(红色通道为0.2989，绿色通道为0.5870，蓝色通道为0.1140)以获得灰度图像。</p><p id="eaa1" class="pw-post-body-paragraph js jt hh ju b jv lp jx jy jz lq kb kc kd lr kf kg kh ls kj kk kl lt kn ko kp ha bi translated">然后在灰度图像阵列上执行霍夫变换，以检测五线谱并估计音符头的尺寸，因为五线谱线之间的间隔大约是音符头的高度，然后将其用作重新缩放的参考。</p><p id="ae94" class="pw-post-body-paragraph js jt hh ju b jv lp jx jy jz lq kb kc kd lr kf kg kh ls kj kk kl lt kn ko kp ha bi translated"><a class="ae it" href="https://github.com/ojaashampiholi/Optical_Music_Recognition/blob/main/Hough_Transform.py" rel="noopener ugc nofollow" target="_blank"> <strong class="ju hi">霍夫变换</strong> </a></p><p id="f6da" class="pw-post-body-paragraph js jt hh ju b jv lp jx jy jz lq kb kc kd lr kf kg kh ls kj kk kl lt kn ko kp ha bi translated"><strong class="ju hi"> <em class="lu">霍夫()</em> </strong> <em class="lu"> — </em>该方法以灰度图像为输入。小于128的像素值被替换为0，而剩余的像素被替换为1，从而产生二进制图像。扫描该图像中的每个像素，并创建名为“votesDict”的投票字典，将每个行索引作为关键字(x ),并且对于具有边缘像素的每对(行，高度),其值增加1。最终“votesDict”中的每个键值对都有行索引和该行中相应数量的白色像素。然后从字典中过滤出行列表，即值超过列长度(y)50%的键。该过滤假设五线谱是音乐图像中的平行、水平和连续的线，该音乐图像在行中延伸超过其列的50%。因此，如果一个行索引有超过50%的连续白色像素，它可以被认为是一个五线谱线。</p><p id="dc4b" class="pw-post-body-paragraph js jt hh ju b jv lp jx jy jz lq kb kc kd lr kf kg kh ls kj kk kl lt kn ko kp ha bi translated">板条线的行索引在过滤列表l中。从理论上我们知道，在一组板条中的任意两个板条线之间存在固定的间距，并且该间距在整个板条组中是相同的。为了找出一组中两个板条线之间的间距，确定彼此不紧邻的行索引之间的差异。这种差异给出了两条板条线之间的间距。</p><p id="f4ec" class="pw-post-body-paragraph js jt hh ju b jv lp jx jy jz lq kb kc kd lr kf kg kh ls kj kk kl lt kn ko kp ha bi translated">必须找到所有组中第一板条线的更多行坐标。我们知道过滤列表l中的第一行索引(或第一个条目)是第一个集合中第一行的行坐标。我们已经知道了行之间的间距和第一行的行坐标。我们遍历所有可能的行候选项，并查看它们是否位于第一行坐标的“space x 5”距离内。如果发现任何线不在这个界限内，那么我们可以假设该行是另一组板条线的第一行。我们不断检查列表，直到所有可能的行候选项被拒绝或用尽。</p><p id="ca67" class="pw-post-body-paragraph js jt hh ju b jv lp jx jy jz lq kb kc kd lr kf kg kh ls kj kk kl lt kn ko kp ha bi translated">现在，所有组中第一个五线谱线的空间和行坐标已经使用hough()方法确定，drawLines()方法可用于可视化预测的五线谱线。</p><p id="8137" class="pw-post-body-paragraph js jt hh ju b jv lp jx jy jz lq kb kc kd lr kf kg kh ls kj kk kl lt kn ko kp ha bi translated"><strong class="ju hi"><em class="lu">【drawLines()】</em></strong><em class="lu">—</em>该方法以灰度图像、空间和首行坐标作为输入。对于每组五线谱行，使用第一行的行坐标确定接下来四行的行坐标。对另一组第一行坐标重复这一过程。然后，与我们的灰度输入形状相同的复制图像被初始化为所有零值，并且先前找到的所有行坐标的像素值被设置为255。</p><p id="378e" class="pw-post-body-paragraph js jt hh ju b jv lp jx jy jz lq kb kc kd lr kf kg kh ls kj kk kl lt kn ko kp ha bi translated">当在getResults()方法中查看时，拷贝图像是黑白图像，只有两组五线谱线类似于输入音乐图像。此副本图像存储为“detected_staves.png”。</p><p id="00be" class="pw-post-body-paragraph js jt hh ju b jv lp jx jy jz lq kb kc kd lr kf kg kh ls kj kk kl lt kn ko kp ha bi translated">一旦检测到五线谱线，就会创建一个音高字典来查找音高类型。空格和第一行坐标被传递给一个名为getPitchDictionary()的方法。</p><p id="1e5a" class="pw-post-body-paragraph js jt hh ju b jv lp jx jy jz lq kb kc kd lr kf kg kh ls kj kk kl lt kn ko kp ha bi translated"><strong class="ju hi"><em class="lu">getPitchDictionary()</em></strong><em class="lu">—</em>该方法以灰度图像、空间和首行坐标作为输入。两个五线谱从A到G的音高类型在音高字典中根据间距定义，即五线谱中任意两行之间的间距。这个查找字典是为将来使用而创建的。</p><p id="3345" class="pw-post-body-paragraph js jt hh ju b jv lp jx jy jz lq kb kc kd lr kf kg kh ls kj kk kl lt kn ko kp ha bi translated"><strong class="ju hi"><em class="lu">resize template()</em></strong><em class="lu">——</em>通过传递模板图像和缩放因子调用resize()方法。传递给该方法的第二个参数是空间乘以一个模板特定值，该值按如下方式确定。如果要在音乐图像中检测的模板是八分之一休止符，那么它跨越任意两个五线谱线之间的两倍间距的长度。因此，模板缩放因子应该是2 *空间。如果要检测的模板是四分之一静止的，那么它跨越的长度大约是任意两条板条线之间的距离的三倍。因此，模板缩放因子应该是3 *空间。</p><p id="de47" class="pw-post-body-paragraph js jt hh ju b jv lp jx jy jz lq kb kc kd lr kf kg kh ls kj kk kl lt kn ko kp ha bi translated">重新调整大小的模板被返回供进一步使用。然后，调整大小后的模板被转换为numpy数组，并转换为灰度，就像我们为了可视化的目的对输入图像所做的那样。以上所有步骤都包括预处理，在预处理之后，调用omrApplication()方法。</p><p id="496c" class="pw-post-body-paragraph js jt hh ju b jv lp jx jy jz lq kb kc kd lr kf kg kh ls kj kk kl lt kn ko kp ha bi translated"><strong class="ju hi"/></p><p id="915b" class="pw-post-body-paragraph js jt hh ju b jv lp jx jy jz lq kb kc kd lr kf kg kh ls kj kk kl lt kn ko kp ha bi translated"><a class="ae it" href="https://github.com/ojaashampiholi/Optical_Music_Recognition/blob/main/Template_Matching.py" rel="noopener ugc nofollow" target="_blank"> <strong class="ju hi">模板匹配</strong> </a></p><p id="74e0" class="pw-post-body-paragraph js jt hh ju b jv lp jx jy jz lq kb kc kd lr kf kg kh ls kj kk kl lt kn ko kp ha bi translated"><strong class="ju hi"><em class="lu">【nonMaximalSupression()</em></strong><em class="lu">—</em>这里，我们考虑通过并集交(IoU)的方法来确定边界框之间的重叠，然后设置0.5倍面积的上限阈值。当交集高于50%时，可以安全地假设边界框包含相同的对象。</p><p id="7ead" class="pw-post-body-paragraph js jt hh ju b jv lp jx jy jz lq kb kc kd lr kf kg kh ls kj kk kl lt kn ko kp ha bi translated"><strong class="ju hi"><em class="lu">naive template matching()</em></strong><em class="lu">—</em>在这种方法中，图像和模板被转换成相应的二进制形式。阈值计算为置信区间(作为输入传递给方法)、模板高度和宽度的乘积。该分数评估图像I中的区域与模板的相似程度。需要为图像的每个m×n像素邻域计算该函数。当分数高于阈值时，分数连同图像的区域被添加到名为“scorArr”的列表中，该列表受到非最大抑制以避免边缘的重复检测。</p><p id="1103" class="pw-post-body-paragraph js jt hh ju b jv lp jx jy jz lq kb kc kd lr kf kg kh ls kj kk kl lt kn ko kp ha bi translated"><strong class="ju hi"><em class="lu">get edges()</em></strong><em class="lu">—</em>在这种方法中，使用可分离的Sobel算子来寻找X和Y方向的梯度。X和Y梯度的平方和的平方根给出了模板的边缘。这里，超过阈值的像素被替换为边缘像素。</p><p id="6fa9" class="pw-post-body-paragraph js jt hh ju b jv lp jx jy jz lq kb kc kd lr kf kg kh ls kj kk kl lt kn ko kp ha bi translated"><strong class="ju hi"><em class="lu">edgeDetectionTemplateMatching()</em></strong><em class="lu">—</em>在这个方法中，我们使用get edges()方法来获得图像和模板的边缘。定义了用于边缘检测的距离变换矩阵。该方法将getEdges()方法的结果作为输入，并返回距离矩阵。</p><p id="edc1" class="pw-post-body-paragraph js jt hh ju b jv lp jx jy jz lq kb kc kd lr kf kg kh ls kj kk kl lt kn ko kp ha bi translated">对图像边缘进行距离变换后，阈值计算为模板边缘*作为输入传递的阈值因子之和。然后，像朴素匹配一样，匹配距离矩阵的区域和模板边缘。具有最大分数的区域受到非最大抑制。</p><p id="4a73" class="pw-post-body-paragraph js jt hh ju b jv lp jx jy jz lq kb kc kd lr kf kg kh ls kj kk kl lt kn ko kp ha bi translated">一旦从朴素方法或边缘检测方法返回匹配区域，就绘制边界框，并且使用音高字典来确定音符的类型。置信度值被认为是预测音符的概率。</p><p id="03fb" class="pw-post-body-paragraph js jt hh ju b jv lp jx jy jz lq kb kc kd lr kf kg kh ls kj kk kl lt kn ko kp ha bi translated"><a class="ae it" href="https://github.com/ojaashampiholi/Optical_Music_Recognition/blob/main/Kernel_Operations.py" rel="noopener ugc nofollow" target="_blank"> <strong class="ju hi">内核操作</strong> </a></p><p id="1f91" class="pw-post-body-paragraph js jt hh ju b jv lp jx jy jz lq kb kc kd lr kf kg kh ls kj kk kl lt kn ko kp ha bi translated">名为kernel operations的实用程序文件由各种常用的可分离和不可分离内核组成，用于对灰度图像执行卷积，以进行边缘检测、模糊处理等。</p><h1 id="78c5" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">结果</h1><p id="4865" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">输入图像可以从<a class="ae it" href="https://www.kaggle.com/imsparsh/musicnet-dataset" rel="noopener ugc nofollow" target="_blank"> <em class="lu"> MusicNet数据集获得。</em> </a></p><figure class="lj lk ll lm fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lv"><img src="../Images/5e6e281f8dbc231b5f799185bf882715.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QZ_p1-cwV-ddPPkVvIL7iw.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx"><a class="ae it" href="https://github.com/ojaashampiholi/Optical_Music_Recognition/blob/main/test-images/music1.png" rel="noopener ugc nofollow" target="_blank">Input Image 1</a></figcaption></figure><figure class="lj lk ll lm fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lv"><img src="../Images/86e867c8829fdf8c46d06c9d719e9c81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1-FESa3zQtjLh9N0SylgUw.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx"><a class="ae it" href="https://github.com/ojaashampiholi/Optical_Music_Recognition/blob/main/results/result1.png" rel="noopener ugc nofollow" target="_blank">Result Image 1</a></figcaption></figure><figure class="lj lk ll lm fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lw"><img src="../Images/d8b00037ffa147d97c957a37f377c0e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D-YU7tGBqz2oB0_UALPRwA.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx"><a class="ae it" href="https://github.com/ojaashampiholi/Optical_Music_Recognition/blob/main/test-images/music2.png" rel="noopener ugc nofollow" target="_blank">Input Image 2</a></figcaption></figure><figure class="lj lk ll lm fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lw"><img src="../Images/f9d7214e1a5f2f5080c16fdcb5c4c432.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OoBZ3nwGfRzgTWp2rfVdPw.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx"><a class="ae it" href="https://github.com/ojaashampiholi/Optical_Music_Recognition/blob/main/results/result2.png" rel="noopener ugc nofollow" target="_blank">Result Image 2</a></figcaption></figure><h1 id="57bc" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">结论</h1><p id="86c8" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">上述算法在乐谱数据集的范围内运行良好。一些选择留给了用户——在模板匹配类型、更改阈值等之间进行选择。然而，在某些情况下，应用程序需要是健壮的，而不必依赖用户的决定。因此，实施后的下一步将是尝试使用高级深度学习技术进行光学音乐识别。</p></div></div>    
</body>
</html>