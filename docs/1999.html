<html>
<head>
<title>Understanding K-Nearest Neighbors Algorithm — Concept and Implementation Guidance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解K-最近邻算法——概念和实施指南</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/understanding-k-nearest-neighbors-algorithm-concept-and-implementation-guidance-98126505fe8c?source=collection_archive---------4-----------------------#2022-02-20">https://medium.com/mlearning-ai/understanding-k-nearest-neighbors-algorithm-concept-and-implementation-guidance-98126505fe8c?source=collection_archive---------4-----------------------#2022-02-20</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="d8ce" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">本文将解释K-最近邻分类器算法背后的基本概念及其在Python编程语言中的实现。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/c21efaa98a5e08a2bf933556d7e539b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mzIEpDRJtzHDMVcdWqYJ4Q.jpeg"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Photo by <a class="ae js" href="https://unsplash.com/@brenoassis?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Breno Assis</a> on <a class="ae js" href="https://unsplash.com/s/photos/neighborhood?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="f2a2" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ip ke kf kg it kh ki kj ix kk kl km kn bi translated">目录<strong class="ak"> s </strong></h2><ol class=""><li id="209f" class="ko kp hh ig b ih kq il kr ip ks it kt ix ku jb kv kw kx ky bi translated"><strong class="ig hi">监督机器学习分类器</strong></li><li id="1e52" class="ko kp hh ig b ih kz il la ip lb it lc ix ld jb kv kw kx ky bi translated"><strong class="ig hi">K-最近邻算法</strong></li><li id="8eb6" class="ko kp hh ig b ih kz il la ip lb it lc ix ld jb kv kw kx ky bi translated"><strong class="ig hi"> KNN白手起家</strong></li><li id="684a" class="ko kp hh ig b ih kz il la ip lb it lc ix ld jb kv kw kx ky bi translated"><strong class="ig hi"> KNN与Scikit-learn </strong></li><li id="8b57" class="ko kp hh ig b ih kz il la ip lb it lc ix ld jb kv kw kx ky bi translated"><strong class="ig hi">关闭</strong></li></ol></div><div class="ab cl le lf go lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ha hb hc hd he"><h2 id="7a29" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ip ke kf kg it kh ki kj ix kk kl km kn bi translated">监督机器学习分类器</h2><p id="bfd5" class="pw-post-body-paragraph ie if hh ig b ih kq ij ik il kr in io ip ll ir is it lm iv iw ix ln iz ja jb ha bi translated">监督机器学习分类器的主要任务是根据新输入对已知输出进行分类。创建受监督的机器学习分类器就是建立一个模型，用于基于特征对标签进行分类。标签的类型是离散值，而特征可以是离散或连续的数字</p><p id="a20c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">举个简单的例子，想象一下幼儿园的孩子们学习猫的样子。他们的老师会给他们看不同的动物图片，有些是猫，有些可能是狗、马等等。</p><p id="fd96" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">孩子们学会区分不同的图片是机器学习的一个简单定义。它们被“编程”来从一张新图片中识别一只猫，这是从过去给定的图片中学习来的。当他们看到一只猫时，他们说“猫！”如果不是猫，他们会说“不是猫！”。老师给他们看的图片是已知输出。术语“猫”和“不是猫”是标签<em class="lo">和动物图像是特征<em class="lo">。</em>他们试图猜测一张图片是否是猫图片，这是一项分类任务。那就是监督分类机器学习。</em></p></div><div class="ab cl le lf go lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ha hb hc hd he"><h2 id="fcc1" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ip ke kf kg it kh ki kj ix kk kl km kn bi translated">k-最近邻算法</h2><p id="396c" class="pw-post-body-paragraph ie if hh ig b ih kq ij ik il kr in io ip ll ir is it lm iv iw ix ln iz ja jb ha bi translated">K-最近邻算法——排序的KNN——是机器学习领域中最简单的分类模型之一。简单性在于以下概念:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es lp"><img src="../Images/4ce99255b17ea7860c103b985236f264.png" data-original-src="https://miro.medium.com/v2/resize:fit:704/format:webp/1*wImzA2bwTP_oP9qMshPdkg.png"/></div><figcaption class="jo jp et er es jq jr bd b be z dx">Image by the <strong class="bd jv">Author</strong></figcaption></figure><p id="f487" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">看一下上图。这里有两个标签。我们给它们贴上<strong class="ig hi">蓝色</strong>和<strong class="ig hi">橙色</strong>的标签吧(可以是猫也可以不是猫，或者别的什么)。</p><p id="10d4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们关注点<strong class="ig hi">米</strong>。不考虑其颜色，如何对点<strong class="ig hi"> m </strong>进行分类？它是蓝色的还是橙色的？仔细看看这个图，相似的点往往彼此靠近，蓝点坐在其他蓝点旁边，同样的条件也适用于绿点。KNN算法基于这一假设工作。</p><p id="087f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">相似性的概念是通过两点之间的距离来实现的。再看一下这个图，有三条线代表点<strong class="ig hi"> m </strong>到它所有三个邻居<strong class="ig hi">的距离(k=3，因此K代表KNN的距离)</strong>。从图中，你可以推断出点<strong class="ig hi"> m </strong>是<strong class="ig hi">一个蓝色</strong>标签，因为它到最近的<strong class="ig hi">蓝点的距离比最近的绿点短。</strong></p><p id="1d25" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如何测量两点之间的距离？有许多方法可以计算两点之间的距离。最流行和最熟悉的是欧几里德距离。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es lp"><img src="../Images/c78e58349329fada55119532b3785524.png" data-original-src="https://miro.medium.com/v2/resize:fit:704/format:webp/1*eEUao9fxxtkG6i4A2pcnvg.png"/></div><figcaption class="jo jp et er es jq jr bd b be z dx">Image by the <strong class="bd jv">Author</strong></figcaption></figure><p id="192d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在二维中，点被定义为两个变量(x，y)的对，两点之间的距离由下式给出:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es lq"><img src="../Images/279fcd80f9452df97df9e68c23a24452.png" data-original-src="https://miro.medium.com/v2/resize:fit:826/format:webp/1*x05sQOhl3_vXBsPu6r0b9w.png"/></div><figcaption class="jo jp et er es jq jr bd b be z dx">Image by the <strong class="bd jv">Author</strong></figcaption></figure><p id="7d2d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在N维空间中，一个点被定义为一对N个变量(q1，q2，…，qN)，两点q和p之间的距离由下式给出:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es lr"><img src="../Images/219460036ade8c04de3b79a58f827e65.png" data-original-src="https://miro.medium.com/v2/resize:fit:542/format:webp/1*lS6euHIROe96eKO-F4PfBg.png"/></div><figcaption class="jo jp et er es jq jr bd b be z dx">Image by the <strong class="bd jv">Author</strong></figcaption></figure><p id="04b3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">假设，你有一个已知特征和标签(x旧，y旧)的数据集<strong class="ig hi">，你想预测一个新特征(x) </strong>的标签(y)<strong class="ig hi">，这就是KNN分类器的工作原理:</strong></p><blockquote class="ls lt lu"><p id="7fa4" class="ie if lo ig b ih ii ij ik il im in io lv iq ir is lw iu iv iw lx iy iz ja jb ha bi translated">KNN分类器会给你一个<strong class="ig hi"> <em class="hh">标签</em></strong><em class="hh">(</em><strong class="ig hi"><em class="hh">y)</em><em class="hh">的一个<strong class="ig hi"/><strong class="ig hi"><em class="hh">新的</em></strong></em></strong><em class="hh"/>特征通过计算它与数据集中所有<strong class="ig hi"> <em class="hh">已知特征和标签</em> <em class="hh"> (x旧，y旧)</em> </strong>的距离，然后</p></blockquote><p id="0a5f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">可以推断出<strong class="ig hi"> <em class="lo">标签</em></strong>(<strong class="ig hi"><em class="lo">y)</em></strong>的一个<strong class="ig hi"> <em class="lo">新的</em> </strong> <strong class="ig hi"> <em class="lo">特征(x)是已知特征和标签</em></strong><em class="lo"/><strong class="ig hi"><em class="lo">(x旧，y旧)中k最短距离内最常见的标签(y旧)。</em>T73】</strong></p></div><div class="ab cl le lf go lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ha hb hc hd he"><h2 id="6724" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ip ke kf kg it kh ki kj ix kk kl km kn bi translated">KNN从零开始</h2><p id="f2be" class="pw-post-body-paragraph ie if hh ig b ih kq ij ik il kr in io ip ll ir is it lm iv iw ix ln iz ja jb ha bi translated">是时候用Python写KNN算法的实现了。Python编程语言因其简单性和大量用于机器学习和科学的模块而广受欢迎。流行的选择是<strong class="ig hi"> scikit-learn </strong>库，通常用于机器学习和数据分析。</p><p id="4fa9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了提高您对机器学习领域的理解水平，特别是KNN算法，我们限制使用<strong class="ig hi"> scikit-learn </strong>来分割数据集，以便仅训练和测试数据集。稍后，我们将向您展示如何使用<strong class="ig hi"> scikit-learn </strong>机器学习模块来完全实现一个机器学习模型。好了，让我们从导入模块开始</p><pre class="jd je jf jg fd ly lz ma mb aw mc bi"><span id="dbd8" class="jt ju hh lz b fi md me l mf mg">import numpy as np<br/>import pandas as pd<br/><br/>from sklearn.model_selection import train_test_split<br/>from collections import Counter</span></pre><p id="9087" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">上面导入的模块是:</p><ol class=""><li id="4d50" class="ko kp hh ig b ih ii il im ip mh it mi ix mj jb kv kw kx ky bi translated"><a class="ae js" href="https://numpy.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="ig hi"> NumPy </strong> </a>，对于向量和矩阵的数值计算，也提供了像求平方根这样的内置数学函数。</li><li id="0d66" class="ko kp hh ig b ih kz il la ip lb it lc ix ld jb kv kw kx ky bi translated"><a class="ae js" href="https://pandas.pydata.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="ig hi"> Pandas </strong> </a> <strong class="ig hi">、</strong>用于将各种来源(文件、web等)的数据集加载到一个称为data-frame的表状数据结构中，还提供了一堆统计分析工具。</li><li id="66ce" class="ko kp hh ig b ih kz il la ip lb it lc ix ld jb kv kw kx ky bi translated"><strong class="ig hi"> S </strong></li><li id="8eca" class="ko kp hh ig b ih kz il la ip lb it lc ix ld jb kv kw kx ky bi translated"><strong class="ig hi">计数器</strong>是Python标准库中的一个内置模块，就像它的名字一样，它将用于对集合数据结构中的元素进行计数。</li></ol><p id="3f45" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们鼓励你使用面向对象的编程范式写下一个模型。因此，您不必在每次问题发生变化时都重写代码。KNN类的模型模板可能如下所示。</p><pre class="jd je jf jg fd ly lz ma mb aw mc bi"><span id="35db" class="jt ju hh lz b fi md me l mf mg">class KNNClassifier:<br/>    <br/>    # Python constructor, k is number of neighbors<br/>    def __init__(self,k=3):<br/>        pass<br/>    # fit the data to a model<br/>    # X is the features, y is the labels<br/>    def fit(self,X,y):<br/>        pass<br/>    # predict the labels from features X    <br/>    def predict(self,X):<br/>        pass<br/>    # to calculate the accuracy of current prediction<br/>    def accuracy(self,test,pred):<br/>        pass</span></pre><p id="44ac" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在你必须完成这个模板中的每一部分代码。对于构造函数:</p><pre class="jd je jf jg fd ly lz ma mb aw mc bi"><span id="4bdd" class="jt ju hh lz b fi md me l mf mg">def __init__(self,k=3):<br/>    self.k=k</span></pre><p id="d8d9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">您将k(邻居的数量)设置为某个整数，k的默认值是3。当您实例化这个类时，您将编写:</p><pre class="jd je jf jg fd ly lz ma mb aw mc bi"><span id="b1ce" class="jt ju hh lz b fi md me l mf mg">knn=KNNClassifier() # default k=3<br/># or<br/>knn=KNNClassifier(k=5) # k set to 5</span></pre><p id="e406" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">要完成拟合方法，只需将参数中的X和y作为训练(已知要素和标注)传递给要素和标注的数据集。</p><pre class="jd je jf jg fd ly lz ma mb aw mc bi"><span id="11f6" class="jt ju hh lz b fi md me l mf mg">def fit(self,X,y):<br/>    self.X_train=X<br/>    self.y_train=y</span></pre><p id="fe81" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">KNN算法的工作原理是计算特征点到数据集中每个训练点的距离，离它最近的点或最短的距离将给出类别标签。所以，写一个计算欧几里德距离的方法</p><pre class="jd je jf jg fd ly lz ma mb aw mc bi"><span id="949c" class="jt ju hh lz b fi md me l mf mg">def _euclidean_distance(self,x1,x2):        <br/>    return np.sqrt(np.sum((x1-x2)**2))</span></pre><p id="142d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在将所有要素数据集应用于预测之前，您将测试单个要素点的预测，您不希望在尝试预测整个数据集时陷入<strong class="ig hi"> for… loops </strong>的锅炉中。</p><pre class="jd je jf jg fd ly lz ma mb aw mc bi"><span id="9cf6" class="jt ju hh lz b fi md me l mf mg">def _predict_one_feature(self,x):    <br/>   # calculate all the training features againt x    <br/>   distances=[self._euclidean_distance(x,x_train) for x_train in self.X_train]    <br/>   # sort the distance ascendingly then get the of top k points index number    <br/>   k_idx=np.argsort(distances)[:self.k]<br/>   # infere the label from array of k index     <br/>   k_labels=[self.y_train[i] for i in k_idx]    <br/>   # the output is the most common label<br/>   most_common=Counter(k_labels).most_common(1)    <br/>   return most_common[0][0]</span></pre><p id="3690" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">要素数据集中所有点的预测方法如下所示</p><pre class="jd je jf jg fd ly lz ma mb aw mc bi"><span id="e0c2" class="jt ju hh lz b fi md me l mf mg">def predict(self,X):<br/>    predictions=[self._predict_one_feature(x) for x in X]<br/>    return np.array(predictions)</span></pre><p id="3a86" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最后一个是精度法。这种方法将计算模型在预测某些标签时的准确性。它会将预测的标注与训练数据集中的标注进行比较，这两个标注之间相等标注的总和除以训练标注的数量</p><pre class="jd je jf jg fd ly lz ma mb aw mc bi"><span id="87f6" class="jt ju hh lz b fi md me l mf mg">def accuracy(self,y_true, y_pred):<br/>    accuracy = np.sum(y_true == y_pred) / len(y_true)<br/>    return accuracy</span></pre><p id="0ed9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在KNN模型已经完成，是时候把你的KNN模型付诸行动了，这是你的最终模型。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="b109" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了测试你的模型，你将使用来自<a class="ae js" href="https://archive.ics.uci.edu/ml/datasets/iris" rel="noopener ugc nofollow" target="_blank"> UCI机器学习库</a>的<em class="lo"> Iris </em> Flower数据集，或者如果你需要CSV版本，你可以从<a class="ae js" href="https://www.kaggle.com/uciml/iris" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>下载。下载数据集并将其保存到datasets文件夹中，之后您将加载数据集</p><pre class="jd je jf jg fd ly lz ma mb aw mc bi"><span id="45cb" class="jt ju hh lz b fi md me l mf mg">df=pd.read_csv("datasets/Iris.csv")</span></pre><p id="23df" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">上面的脚本会将数据集加载到Pandas数据框中，加载完数据后，您可能想稍微浏览一下数据</p><p id="753f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">要找到数据的形状，您需要编写以下脚本</p><pre class="jd je jf jg fd ly lz ma mb aw mc bi"><span id="f6fd" class="jt ju hh lz b fi md me l mf mg">df.shape # output: (150, 6)</span></pre><p id="411e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">数据帧包含150行和6列</p><p id="1389" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在您想看看这个数据框中有什么，但是渲染150行数据会浪费时间，您只是想从数据框的顶部查看它的数据</p><pre class="jd je jf jg fd ly lz ma mb aw mc bi"><span id="f938" class="jt ju hh lz b fi md me l mf mg">df.head()<br/># df.tail() to peek data from the bottom</span></pre><p id="7e4a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">输出将如下所示</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es mm"><img src="../Images/b1eb31942801b0071b0cc184d6dbcc4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LG2LMVWYbeDxvyN9RQPjog.jpeg"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">image by the <strong class="bd jv">Author</strong></figcaption></figure><p id="f4fd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">从输出来看，特性是以下列；“SepalLengthCm”、“SepalWidthCm”、“PetalLengthCm”和“PetalWidthCm”，标签是“物种”栏。然后，您可能想知道模型将预测多少个可能的标签</p><pre class="jd je jf jg fd ly lz ma mb aw mc bi"><span id="971f" class="jt ju hh lz b fi md me l mf mg">df.value_counts("Species")</span><span id="4eff" class="jt ju hh lz b fi mn me l mf mg">Species<br/>Iris-virginica     50<br/>Iris-versicolor    50<br/>Iris-setosa        50<br/>dtype: int64</span></pre><p id="1412" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">将从您的模型中预测三个标签。</p><p id="2387" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在使用这些数据集运行模型之前要做的最后一件事是可视化，您将获得关于数据集中的点以及它们之间的相似性的提示，为了实现这一点，导入可视化模块:<strong class="ig hi"> Matplotlib </strong>和<strong class="ig hi"> Seaborn </strong></p><pre class="jd je jf jg fd ly lz ma mb aw mc bi"><span id="f439" class="jt ju hh lz b fi md me l mf mg">import seaborn as sns<br/>import matplotlib.pyplot as plt</span></pre><p id="1d70" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">比方说，您想要绘制“SepalLengthCm”与“SepalWidthCm”的图形，以查看它们之间的关系</p><pre class="jd je jf jg fd ly lz ma mb aw mc bi"><span id="e903" class="jt ju hh lz b fi md me l mf mg">sns.scatterplot(x='SepalLengthCm', y='SepalWidthCm',<br/>                hue='Species', data=df, )<br/>plt.legend(bbox_to_anchor=(1, 1), loc=2)</span></pre><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es mo"><img src="../Images/5dd6c6dcfeaac1006c28fe7cc40deff8.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/1*yh9gUQDax412sv9n7dWbsw.png"/></div><figcaption class="jo jp et er es jq jr bd b be z dx">image by <strong class="bd jv">Author</strong></figcaption></figure><p id="eeb7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">从图中，你可以看出:</p><ol class=""><li id="58bf" class="ko kp hh ig b ih ii il im ip mh it mi ix mj jb kv kw kx ky bi translated">刚毛鸢尾的萼片宽度较大，长度较小</li><li id="860c" class="ko kp hh ig b ih kz il la ip lb it lc ix ld jb kv kw kx ky bi translated">鸢尾-海滨鸢尾具有较长的萼片长度和较短的萼片长度</li><li id="5484" class="ko kp hh ig b ih kz il la ip lb it lc ix ld jb kv kw kx ky bi translated">杂色鸢尾的萼片长度和宽度适中</li><li id="a6af" class="ko kp hh ig b ih kz il la ip lb it lc ix ld jb kv kw kx ky bi translated">绿色鸢尾和杂色鸢尾略有相似，这两个种的作图数据似乎更接近</li></ol><p id="570d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，您已经有了通过研究数据集获得的信息，是时候运行您的模型了。第一步是通过从数据框中提取数据，将数据框划分为要素和标注数据集。对于特征值，我们从“SepalLengthCm”、“SepalWidthCm”、“PetalLengthCm”和“PetalWidthCm”列中提取数据。为此，只需从数据框中删除“Id”和“Species”列，原始数据框保持不变。对于标签值，只需提取“物种”列。这些数据集然后被转换成numpy数组。</p><pre class="jd je jf jg fd ly lz ma mb aw mc bi"><span id="e9a1" class="jt ju hh lz b fi md me l mf mg">X=np.array(df.drop(['Id','Species'],axis=1))# features<br/>y=np.array(df['Species'])#labels</span></pre><p id="af6c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">要从数据集中获取训练和测试数据，必须使用Sklearn模块中的train_test_split函数。这将把原始数据集的20%(或您想要的任何百分比)分割成测试数据集(X_test，y_test)，剩余的80%将成为训练(X_train，y_train)集。</p><pre class="jd je jf jg fd ly lz ma mb aw mc bi"><span id="f955" class="jt ju hh lz b fi md me l mf mg">X_test,X_train,y_test,y_train=train_test_split(X,y,test_size=0.2,random_state=1234) #random state ensure you'll get same result every time you re-run this script</span></pre><p id="fcac" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">不要对这些变量的命名感到困惑，它们是这样的:</p><pre class="jd je jf jg fd ly lz ma mb aw mc bi"><span id="35d6" class="jt ju hh lz b fi md me l mf mg">X_test =&gt; Acted as new features (x)<br/>X_train =&gt; Acted as known features (x_old)<br/>y_test =&gt; kept for the measurement of accuracy<br/>y_train=&gt; Acted as known label (y_old) of known features (x_old)<br/>later on..<br/>predictions=&gt; Acted as predicted labels (y) of new features (x)</span></pre><p id="028b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在是你的模型执行预测的时候了</p><pre class="jd je jf jg fd ly lz ma mb aw mc bi"><span id="032d" class="jt ju hh lz b fi md me l mf mg">clf=KNNClassifier()<br/>clf.fit(X_train,y_train)<br/>predictions=clf.predict(X_test)</span></pre><p id="3c1d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们看看你的模型有多精确:</p><pre class="jd je jf jg fd ly lz ma mb aw mc bi"><span id="b861" class="jt ju hh lz b fi md me l mf mg">accuracy=clf.accuracy(y_test,predictions)<br/>accuracy</span><span id="e1e1" class="jt ju hh lz b fi mn me l mf mg">0.9416666666666667</span></pre><p id="f032" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">精度0.94，挺好的。当然，你已经看到了来自<em class="lo">鸢尾数据集</em>的一些非常相似的特征，鸢尾-绿色鸢尾和鸢尾-杂色鸢尾之间的距离非常接近，所以错误可能来自试图预测这些物种的模型。</p><p id="4e44" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">恭喜你。你做到了！你创造了你自己的KNN模型。这是您的完整代码</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="mk ml l"/></div></figure></div><div class="ab cl le lf go lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ha hb hc hd he"><h2 id="abff" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ip ke kf kg it kh ki kj ix kk kl km kn bi translated"><strong class="ak"> KNN与Scikit-learn </strong></h2><p id="a7e8" class="pw-post-body-paragraph ie if hh ig b ih kq ij ik il kr in io ip ll ir is it lm iv iw ix ln iz ja jb ha bi translated">要使用Scikit-learn实现KNN算法，您必须从sklearn模块导入和<strong class="ig hi"> KNeighborsClassifier </strong></p><pre class="jd je jf jg fd ly lz ma mb aw mc bi"><span id="beb4" class="jt ju hh lz b fi md me l mf mg">from sklearn import neighbors<br/></span></pre><p id="8f0d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">其余的步骤与您已经完成的类似</p><pre class="jd je jf jg fd ly lz ma mb aw mc bi"><span id="3062" class="jt ju hh lz b fi md me l mf mg">clf=neighbors.KNeighborsClassifier(n_neighbors=3)<br/>clf.fit(X_train,y_train)<br/>predictions=clf.predict(X_test)</span></pre><p id="4a89" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，让我们看看准确性</p><pre class="jd je jf jg fd ly lz ma mb aw mc bi"><span id="0d19" class="jt ju hh lz b fi md me l mf mg">clf.score(X_test,y_test)</span><span id="5622" class="jt ju hh lz b fi mn me l mf mg">0.9416666666666667</span></pre><p id="945c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">sklearn实现的精度等于你的模型。</p><h2 id="f74c" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ip ke kf kg it kh ki kj ix kk kl km kn bi translated">关闭</h2><p id="c1d6" class="pw-post-body-paragraph ie if hh ig b ih kq ij ik il kr in io ip ll ir is it lm iv iw ix ln iz ja jb ha bi translated">通过理解距离的概念，你已经成功地实现了KNN算法。您还将结果与常用的机器学习模块Scikit-Learn进行了比较。尽管结果相当令人满意，但本指南的目的是让您对KNN算法的工作原理有一个基本的了解，而不是验证您创建的模型的正确性。您的模型在某些情况下可能无法执行，然后您会尝试寻找分类问题的其他解决方案，如SVM算法或朴素贝叶斯分类器。</p><div class="mp mq ez fb mr ms"><a rel="noopener follow" target="_blank" href="/mlearning-ai/mlearning-ai-submission-suggestions-b51e2b130bfb"><div class="mt ab dw"><div class="mu ab mv cl cj mw"><h2 class="bd hi fi z dy mx ea eb my ed ef hg bi translated">Mlearning.ai提交建议</h2><div class="mz l"><h3 class="bd b fi z dy mx ea eb my ed ef dx translated">如何成为Mlearning.ai上的作家</h3></div><div class="na l"><p class="bd b fp z dy mx ea eb my ed ef dx translated">medium.com</p></div></div><div class="nb l"><div class="nc l nd ne nf nb ng jm ms"/></div></div></a></div></div></div>    
</body>
</html>