<html>
<head>
<title>AI Sudoku Solver</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">人工智能数独求解器</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/ai-sudoku-solver-cb41b36e446b?source=collection_archive---------1-----------------------#2021-03-21">https://medium.com/mlearning-ai/ai-sudoku-solver-cb41b36e446b?source=collection_archive---------1-----------------------#2021-03-21</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="f56a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">数独是一种益智游戏，玩家将数字1到9插入到由9个正方形组成的网格中，9个正方形再细分为9个更小的正方形，每个数字在每个水平线、垂直线和正方形中出现一次。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/b57a7f7e42feeba65f637163b65ad9e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*C1i_h_b3LcSO_oY1.jpg"/></div></div></figure><h1 id="78e5" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">目录</h1><ol class=""><li id="a3bf" class="km kn hh ig b ih ko il kp ip kq it kr ix ks jb kt ku kv kw bi translated">人工智能数独求解器</li><li id="5f35" class="km kn hh ig b ih kx il ky ip kz it la ix lb jb kt ku kv kw bi translated">方法</li><li id="88fd" class="km kn hh ig b ih kx il ky ip kz it la ix lb jb kt ku kv kw bi translated">结论</li></ol><h2 id="7598" class="lc jp hh bd jq ld le lf ju lg lh li jy ip lj lk kc it ll lm kg ix ln lo kk lp bi translated">人工智能数独求解器</h2><p id="0ca2" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip lq ir is it lr iv iw ix ls iz ja jb ha bi translated">使用OpenCV、深度学习和回溯算法，我们可以解决数独难题。首先，建立字符识别模型，该模型可以从数独网格图像中提取数字，然后使用回溯方法来解决这个问题。基于深度学习的AI_Sudoku_Solver架构使用<a class="ae lt" href="https://opencv.org/" rel="noopener ugc nofollow" target="_blank"> OpenCV </a> (opencv==4.2.0)和Python (python==3.7)。模型卷积神经网络(CNN)在<a class="ae lt" href="https://www.tensorflow.org/" rel="noopener ugc nofollow" target="_blank"> Tensorflow </a>上使用<a class="ae lt" href="https://keras.io/" rel="noopener ugc nofollow" target="_blank"> Keras </a> (keras==2.3.1)进行数字识别。</p><h2 id="2b3c" class="lc jp hh bd jq ld le lf ju lg lh li jy ip lj lk kc it ll lm kg ix ln lo kk lp bi translated">方法</h2><p id="4c71" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip lq ir is it lr iv iw ix ls iz ja jb ha bi translated">这里，我们可以将流程分为3个部分:</p><p id="04eb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">1.在图像中寻找数独谜题。<br/> 2。从数独中提取数字。<br/> 3。用回溯法解决数独。</p><p id="7930" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">在图像中寻找数独谜题:</strong>在这一部分，我们将关注如何从输入图像中提取数独网格，即我们的感兴趣区域(ROI)。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es lu"><img src="../Images/948d14f19b96146678a6c246a18df4ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*onb0z9PHDPGmGRHx.png"/></div></div></figure><ol class=""><li id="4d8a" class="km kn hh ig b ih ii il im ip lv it lw ix lx jb kt ku kv kw bi translated"><strong class="ig hi">将输入图像转换为二进制图像</strong>:该步骤包括将输入图像转换为灰度图像，对灰度图像应用高斯模糊，然后进行阈值处理、逐位非运算和图像扩张。</li><li id="1d26" class="km kn hh ig b ih kx il ky ip kz it la ix lb jb kt ku kv kw bi translated"><strong class="ig hi">检测图像中最大的多边形:</strong>该步骤包括寻找轮廓和选择最大的轮廓。现在从最大的轮廓，选择最极端的点，将是4个角落。函数cv2.findContours返回它在图像中找到的所有轮廓。在按区域对从图像返回的轮廓进行分类之后，可以容易地选择最大的轮廓。</li><li id="2ac1" class="km kn hh ig b ih kx il ky ip kz it la ix lb jb kt ku kv kw bi translated"><strong class="ig hi">裁剪和扭曲最大的轮廓:<br/> </strong>这种方法很简单，因为我们有4个角的坐标，我们可以使用扭曲，这给了图像更好的透视效果。</li></ol><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ly lz l"/></div></figure><p id="43bf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">从数独中提取数字:</strong>提取较小的网格，<strong class="ig hi"> </strong>由于我们已经知道一个数独网格有81个相似维度的单元格(9行9列)。我们可以简单地迭代图像的行长和列长，并将每个单元格传递给CNN模型进行数字识别。请浏览这篇<a class="ae lt" href="https://github.com/kurapan/CNN-MNIST" rel="noopener ugc nofollow" target="_blank">文章</a>以了解使用CNN进行数字识别的更多细节。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ly lz l"/></div></figure><p id="e783" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">提取数字后，我们的数独网格将看起来像…</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es ma"><img src="../Images/53ae46b510b36526061b66517b5bffbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/format:webp/0*lPhzC_xuFu2wiLMZ.png"/></div></div></figure><p id="1112" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">用回溯法解数独:</strong>现在我们已经把图像转换成了数组，我们只需要根据数独的规则，做一个能有效填充空格的函数。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es mb"><img src="../Images/75dd80b54f71ba9b492922acd003b503.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hW_t_LSOCM91a5CJ.png"/></div></div></figure><blockquote class="mc md me"><p id="92ee" class="ie if mf ig b ih ii ij ik il im in io mg iq ir is mh iu iv iw mi iy iz ja jb ha bi translated">让我们通过一个使用3x3数独的例子来理解回溯是如何工作的。假设我们要解决给定约束的网格-</p><p id="8f89" class="ie if mf ig b ih ii ij ik il im in io mg iq ir is mh iu iv iw mi iy iz ja jb ha bi translated">每列都有从1到“n”的唯一数字或空格。</p><p id="c09e" class="ie if mf ig b ih ii ij ik il im in io mg iq ir is mh iu iv iw mi iy iz ja jb ha bi translated">每列都有从1到“n”的唯一数字或空格。</p></blockquote><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es mj"><img src="../Images/d348d407a07521406a1dce770153db14.png" data-original-src="https://miro.medium.com/v2/resize:fit:456/format:webp/0*fDMhr8TmRVALjvcg.png"/></div></figure><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es mk"><img src="../Images/a17adcbc0d90aa8063c6e0285afc2398.png" data-original-src="https://miro.medium.com/v2/resize:fit:440/format:webp/0*Qq4FzQN_q981_NuN.png"/></div></figure><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es ml"><img src="../Images/44fe9c33c9ace5f53239ba5042aca104.png" data-original-src="https://miro.medium.com/v2/resize:fit:844/format:webp/0*aJIn2W8zurntcBAk.png"/></div></figure><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es mm"><img src="../Images/de3ed08dec2ef441a08eb2a2f1224850.png" data-original-src="https://miro.medium.com/v2/resize:fit:60/0*g3dX3kVLDTI4ck9H"/></div></figure><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es mn"><img src="../Images/add0389a6e41e3e70aa3042a238a8c70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1126/format:webp/0*JsuxIvrhLN2KWh7T.png"/></div></figure><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es mo"><img src="../Images/eec94714c51c8ab45a0d6bfbb2bb4cf4.png" data-original-src="https://miro.medium.com/v2/resize:fit:438/format:webp/0*Ja3B7vprJ9NSGdFl.png"/></div></figure><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es mp"><img src="../Images/806855711f4b735bf432aeea15607dc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:444/format:webp/0*9h2X_v7NCjB_s1ZR.png"/></div></figure><p id="2516" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> 1。</strong>我们需要填充5个空格，让我们从从左到右和从上到下遍历空格开始。</p><p id="282e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> 2 </strong>。让我们将1放入第一个遇到的空间，并检查是否满足所有约束。这里似乎1很好，因为它在行和列中都是唯一的。</p><p id="d2a0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> 3。</strong>移动到下一个网格，我们再次从保留1开始，但是我们可以看到它在列中不是唯一的，因此我们检查2，2满足所有约束</p><p id="6cfa" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> 4。</strong>对于第三个空网格，我们可以看到3个数字1、2、3都不满足约束。</p><p id="9e18" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> 5。</strong>为了解决这个问题，我们后退一步，在我们填充的最后一个网格中增加数字，并确保满足约束条件。现在我们继续下一个格里格，我们可以看到2适合它。</p><p id="e248" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> 6。</strong>同样，我们填充剩余的网格，达到最优解。</p><p id="34a7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在我们已经了解了回溯是如何工作的，让我们使用解决9x9数独时使用的约束来创建一个函数，并在我们从上一步获得的数组上测试它。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ly lz l"/></div></figure><h2 id="3f86" class="lc jp hh bd jq ld le lf ju lg lh li jy ip lj lk kc it ll lm kg ix ln lo kk lp bi translated">结论</h2><p id="eac8" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip lq ir is it lr iv iw ix ls iz ja jb ha bi translated">在这篇文章中，我们了解到</p><ol class=""><li id="ae14" class="km kn hh ig b ih ii il im ip lv it lw ix lx jb kt ku kv kw bi translated">轮廓和翘曲的概念。</li><li id="df5b" class="km kn hh ig b ih kx il ky ip kz it la ix lb jb kt ku kv kw bi translated">数字识别的深度学习模型。</li><li id="c7a8" class="km kn hh ig b ih kx il ky ip kz it la ix lb jb kt ku kv kw bi translated">回溯算法。</li></ol><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="mq lz l"/></div></figure><h1 id="dd91" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">参考</h1><ol class=""><li id="ea56" class="km kn hh ig b ih ko il kp ip kq it kr ix ks jb kt ku kv kw bi translated"><a class="ae lt" href="https://github.com/murtazahassan/OpenCV-Sudoku-Solver" rel="noopener ugc nofollow" target="_blank">数独求解器</a></li><li id="91c5" class="km kn hh ig b ih kx il ky ip kz it la ix lb jb kt ku kv kw bi translated"><a class="ae lt" href="https://github.com/kurapan/CNN-MNIST" rel="noopener ugc nofollow" target="_blank">数字识别</a></li><li id="d0d6" class="km kn hh ig b ih kx il ky ip kz it la ix lb jb kt ku kv kw bi translated"><a class="ae lt" href="https://techwithtim.net/tutorials/python-programming/sudoku-solver-backtracking/" rel="noopener ugc nofollow" target="_blank">回溯算法</a></li><li id="dc16" class="km kn hh ig b ih kx il ky ip kz it la ix lb jb kt ku kv kw bi translated"><a class="ae lt" rel="noopener" href="/swlh/how-to-solve-sudoku-using-artificial-intelligence-8d5d3841b872">中型文章</a></li></ol><p id="2765" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">该代码可在<a class="ae lt" href="https://github.com/Devashi-Choudhary/AI_Sudoku_Solver" rel="noopener ugc nofollow" target="_blank"><strong class="ig hi">https://github.com/Devashi-Choudhary/AI_Sudoku_Solver</strong></a>获得。如有任何问题或疑问，请直接联系我，电话:<a class="ae lt" href="https://github.com/Devashi-Choudhary" rel="noopener ugc nofollow" target="_blank"><strong class="ig hi">github.com/Devashi-Choudhary</strong>。</a></p><p id="16d7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在LinkedIn上找我:<a class="ae lt" href="https://www.linkedin.com/in/devashi-choudhary-84677b109/" rel="noopener ugc nofollow" target="_blank"><strong class="ig hi">https://www.linkedin.com/in/devashi-choudhary-84677b109/</strong></a></p><p id="313c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="mf">谢谢！</em></p></div></div>    
</body>
</html>