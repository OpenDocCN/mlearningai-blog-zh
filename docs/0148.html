<html>
<head>
<title>Science Shorts #1: Functional Programming, Nomad &amp; Pylance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">科学短片#1:函数式编程、Nomad &amp; Pylance</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/science-shorts-1-functional-programming-nomad-pylance-906e238ed725?source=collection_archive---------3-----------------------#2021-02-21">https://medium.com/mlearning-ai/science-shorts-1-functional-programming-nomad-pylance-906e238ed725?source=collection_archive---------3-----------------------#2021-02-21</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/aaec8be2b543f909925f266731ca80de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*avne1PJLxf_cJK5djy7pbA.png"/></div></div></figure><div class=""/><p id="62f1" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">有用的<code class="du jn jo jp jq b">python</code>函数为“大数据”处理做准备，<em class="jr"> Nomad </em>相对于<em class="jr"> Kubernetes </em>和<em class="jr"> Visual Studio Codes </em>的下一代代码完成<em class="jr"> Python </em>的优势。</p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><h1 id="effc" class="jz ka hs bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">范围</h1><p id="ce84" class="pw-post-body-paragraph ip iq hs ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated">链接到关于<em class="jr">数据科学</em>的三个有趣而广泛的主题，从理解<code class="du jn jo jp jq b">python</code>的关键特性作为一种准备处理“大数据”的方法，到使用<em class="jr"> Dask </em>和<em class="jr"> PySpark </em>等库。<em class="jr"> Nomad </em>作为<em class="jr">的替代产品，Kubernetes </em>作为容器编排器，涵盖了<em class="jr">数据科学</em>的全部活动，从<em class="jr">数据摄取</em>到模型部署再到<em class="jr">数据可视化</em>。最后，介绍一下<em class="jr">微软</em>的下一代<em class="jr">代码</em>完成引擎，它是对之前<em class="jr">语言服务器协议</em> (LSP)的扩展。</p><h1 id="240e" class="jz ka hs bd kb kc lc ke kf kg ld ki kj kk le km kn ko lf kq kr ks lg ku kv kw bi translated">介绍</h1><p id="2b93" class="pw-post-body-paragraph ip iq hs ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated">以下三篇文章是从我的<em class="jr">袖珍</em>清单中随机选取的，这份清单是我过去5年在<em class="jr">数据科学</em>领域策划的；动机和背景在以前的帖子中讨论过:<a class="ae lh" href="https://aero-data-science.medium.com/science-shorts-an-introduction-to-my-pocket-list-fb915c4569f2" rel="noopener"> <em class="jr">数据科学短片</em>:我的<em class="jr">口袋</em>清单</a>介绍。</p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><h1 id="9a7a" class="jz ka hs bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">用Python进行函数式编程</h1><figure class="lj lk ll lm fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es li"><img src="../Images/26e65f5ea5507f09164aa102a3dbda2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-ra1m-pbptQITs3UEt5u-A.png"/></div></div><figcaption class="ln lo et er es lp lq bd b be z dx">Real Python article on Functional Programming | Screenshot by Author | Article and Artwork by Real python</figcaption></figure><h2 id="1c6e" class="lr ka hs bd kb ls lt lu kf lv lw lx kj ja ly lz kn je ma mb kr ji mc md kv me bi translated">摘要</h2><p id="cb7c" class="pw-post-body-paragraph ip iq hs ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated"><a class="ae lh" href="https://realpython.com/" rel="noopener ugc nofollow" target="_blank"> <em class="jr"> RealPython </em> </a>(万物<code class="du jn jo jp jq b">python</code>的优秀资源)最近发表了一篇关于Python  中<a class="ae lh" href="https://realpython.com/python-functional-programming/" rel="noopener ugc nofollow" target="_blank"> <em class="jr">函数式编程的文章。我并不提倡在<em class="jr">数据科学</em>中使用函数式方法，但是这篇文章详细讨论了<code class="du jn jo jp jq b">python</code>的特性，了解这些特性是很有用的，比如<code class="du jn jo jp jq b">lambda</code>函数、<code class="du jn jo jp jq b">map</code>、<code class="du jn jo jp jq b">filter</code>和<code class="du jn jo jp jq b">reduce.</code>的使用</em></a></p><h2 id="e7cd" class="lr ka hs bd kb ls lt lu kf lv lw lx kj ja ly lz kn je ma mb kr ji mc md kv me bi translated">语境</h2><p id="b688" class="pw-post-body-paragraph ip iq hs ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated">这些函数本身很有用，但是它们也是对使用<em class="jr"> Spark </em>尤其是<em class="jr"> PySpark </em>进行分布式计算的一个很好的介绍。例如，<code class="du jn jo jp jq b">map</code>将函数应用于可迭代或可迭代集合中的每个项目:</p><figure class="lj lk ll lm fd hj"><div class="bz dy l di"><div class="mf mg l"/></div></figure><p id="3fbc" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">假设每个iterable(一个<code class="du jn jo jp jq b">set</code>、<code class="du jn jo jp jq b">list</code>或其他iterable)驻留在不同的节点上，并且您需要对每个项应用一个函数。这很容易成为潜在的并行操作，因为该函数可以独立地应用于每个节点，并且如果需要，可以在最后收集。类似地，<code class="du jn jo jp jq b">filter</code>函数可以应用于每个节点，如果需要合并结果，它类似于<code class="du jn jo jp jq b">reduce</code>函数。</p><p id="ac44" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">用<a class="ae lh" href="https://spark.apache.org/docs/0.9.0/python-programming-guide.html" rel="noopener ugc nofollow" target="_blank"> <em class="jr"> PySpark </em> </a>分发数据的行为是通过一个<em class="jr"> SparkContext </em> ( <code class="du jn jo jp jq b">sc</code>)及其<code class="du jn jo jp jq b">parallelize</code>函数来完成的，如下例所示:</p><figure class="lj lk ll lm fd hj"><div class="bz dy l di"><div class="mf mg l"/></div></figure><p id="73bd" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这两个例子之间有许多关键的变化；首先创建了一个局部<code class="du jn jo jp jq b">SparkContext</code>，细节将在以后的帖子中展开。和前面的例子一样，定义了一个函数将数字3加到一个示例数组中。<em class="jr"> Spark </em>的优势在于将计算分布在许多节点上，在本例中，它是通过<code class="du jn jo jp jq b">sc.parrallelize</code>函数完成的，该函数返回一个<em class="jr">弹性分布式数据集</em> (RDD)。这实际上将数据分布在可用的节点上。</p><p id="8bca" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du jn jo jp jq b">rdd.map()</code>功能与<code class="du jn jo jp jq b">python</code>中的<code class="du jn jo jp jq b">map()</code>功能完全相同。关键区别在于iterable仍然是分布式的，这就是为什么在<code class="du jn jo jp jq b">for</code>循环中打印之前必须使用<code class="du jn jo jp jq b">.collect()</code>来收集它。这表明理解和利用分布式计算的敲门砖是理解<code class="du jn jo jp jq b">python</code>的内置函数<code class="du jn jo jp jq b">map</code>、<code class="du jn jo jp jq b">filter</code>和<code class="du jn jo jp jq b">reduce</code>(技术上必须从<code class="du jn jo jp jq b">functools</code>导入)。</p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><h1 id="5cf5" class="jz ka hs bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">使用Nomad进行容器编排</h1><figure class="lj lk ll lm fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mh"><img src="../Images/b71b37d16c91f60c9e106d9c0cfad433.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_1jqQRQLW1lAy87yHtb42g.png"/></div></div><figcaption class="ln lo et er es lp lq bd b be z dx">Container Orchestration with Nomad | Screenshot by Author | Article and Artwork by HashiCorp</figcaption></figure><h2 id="2325" class="lr ka hs bd kb ls lt lu kf lv lw lx kj ja ly lz kn je ma mb kr ji mc md kv me bi translated">摘要</h2><p id="f1f7" class="pw-post-body-paragraph ip iq hs ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated"><a class="ae lh" href="https://www.nomadproject.io/" rel="noopener ugc nofollow" target="_blank"> <em class="jr"> Nomad </em> </a>是类似于<a class="ae lh" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"><em class="jr">Kubernetes</em></a><em class="jr"/>(K8s)的工作负载和容器编制器。有专门的文档来<a class="ae lh" href="https://www.nomadproject.io/docs/nomad-vs-kubernetes" rel="noopener ugc nofollow" target="_blank">解释差异</a>。本质上，<em class="jr"> Kubernetes </em>主要使用基于<code class="du jn jo jp jq b">docker</code>的容器，提供工作负载协调、服务发现、秘密管理和其他相关服务来实现端到端能力。<em class="jr">相比之下，Nomad </em>支持广泛的容器和虚拟机架构，但只专注于工作负载协调。它使用相关技术，例如用于服务网格的<a class="ae lh" href="https://www.consul.io/" rel="noopener ugc nofollow" target="_blank"> <em class="jr"> Consul </em> </a>和用于秘密管理的<a class="ae lh" href="https://www.vaultproject.io/" rel="noopener ugc nofollow" target="_blank"> <em class="jr"> Vault </em> </a>，但是这些是独立的实体，没有捆绑在一起。</p><h2 id="d7a6" class="lr ka hs bd kb ls lt lu kf lv lw lx kj ja ly lz kn je ma mb kr ji mc md kv me bi translated">语境</h2><p id="0264" class="pw-post-body-paragraph ip iq hs ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated">当前的“行业标准”平台基于<em class="jr"> Kubernetes </em>，由<em class="jr"> Google </em>创建，目前由<a class="ae lh" href="https://www.cncf.io/" rel="noopener ugc nofollow" target="_blank"> <em class="jr">云本地计算基金会</em> </a> (CNCF)管理。重要的是要注意其他容器编排器的存在，在<em class="jr"> Nomad </em>的情况下，它尊重<em class="jr"> Unix </em>单一目的程序的哲学。在实践中，这意味着单个二进制文件可以用于生产、开发甚至“边缘”。</p><p id="b545" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">相比之下，有大量的<em class="jr"> Kubernetes </em>发行版，其中一些使用了<a class="ae lh" href="https://www.hashicorp.com/" rel="noopener ugc nofollow" target="_blank"> <em class="jr"> Hashicorp </em> </a>元素，如<em class="jr"> Consul </em>和<em class="jr"> Vault </em>，由来自<em class="jr">Canonical</em>(<em class="jr">Ubuntu</em>的开发者)的<a class="ae lh" href="https://ubuntu.com/kubernetes/features" rel="noopener ugc nofollow" target="_blank"><em class="jr">Charmed Kubernetes</em></a>等多个提供者提供。边缘设备(即<em class="jr">物联网</em> (IoT))有<em class="jr">牧场主</em>(最近被<em class="jr"> SUSE </em>收购)的<code class="du jn jo jp jq b"><a class="ae lh" href="https://k3s.io/" rel="noopener ugc nofollow" target="_blank">k3s</a></code>或<em class="jr"> Canonical的<code class="du jn jo jp jq b"><a class="ae lh" href="https://microk8s.io/" rel="noopener ugc nofollow" target="_blank">microk8s</a></code>。</em>对于开发，相同的工具可以在本地机器或<a class="ae lh" href="https://www.docker.com/products/docker-desktop" rel="noopener ugc nofollow" target="_blank"><em class="jr">Docker Desktop</em></a>(仅用于<em class="jr"> Windows </em>和<em class="jr"> MacOS </em>)上使用，这提供了单个<em class="jr"> K8s </em>节点。对于<em class="jr"> Nomad </em>，所有用例只有一个二进制文件。</p><p id="335e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">虽然，对于数据科学本身来说，平台本身可能不是首要考虑的问题，但是理解高级系统是一个好的实践，T42数据科学家必须与之集成。在这种情况下，<em class="jr"> Nomad </em>提供了扩展到10，000个节点的能力，而<em class="jr"> Google </em>和<em class="jr"> Kubernetes </em>只能实现集群规模的五分之一。</p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><h1 id="6d36" class="jz ka hs bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">pylance:Visual Studio代码中的下一代Python支持</h1><figure class="lj lk ll lm fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mi"><img src="../Images/fa18261409958bfbfde11fb4dbee78df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iGbrQ3ZOMPXXS-PGgDrIww.png"/></div></div><figcaption class="ln lo et er es lp lq bd b be z dx">Pylance GitHub Repo README.md | Screenshot by Author</figcaption></figure><h2 id="c7f4" class="lr ka hs bd kb ls lt lu kf lv lw lx kj ja ly lz kn je ma mb kr ji mc md kv me bi translated">摘要</h2><p id="7685" class="pw-post-body-paragraph ip iq hs ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated">2020年6月，<em class="jr"> Visual Studio Code </em>团队宣布发布他们的<a class="ae lh" href="https://github.com/microsoft/pylance-release" rel="noopener ugc nofollow" target="_blank"> <em class="jr"> Pylance语言服务器</em> </a> (PLS)，作为对长期支持<em class="jr"> Python </em>和<a class="ae lh" href="https://microsoft.github.io/language-server-protocol/" rel="noopener ugc nofollow" target="_blank"> <em class="jr">语言服务器协议</em> </a> (LSP)的最终替代。它的优势已经在<em class="jr">媒体</em>上<a class="ae lh" href="https://towardsdatascience.com/pylance-the-best-python-extension-for-vs-code-ae299f35548c" rel="noopener" target="_blank"> <em class="jr">对数据科学</em> </a>和其他地方进行了广泛的讨论。值得注意的是，最初的LSP被其他编辑器通过插件广泛使用。</p><p id="c3dd" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="jr"> Pylance </em>和LSP之间的关键区别是在存根文件(<a class="ae lh" href="https://www.python.org/dev/peps/pep-0561/" rel="noopener ugc nofollow" target="_blank"> PEP-0561 </a>)中使用了<em class="jr"> Python </em>类型信息，存根文件具有扩展名<code class="du jn jo jp jq b">.pyi</code>，可以包含关于函数或类的丰富信息。这使得<em class="jr"> Pylance </em>能够支持严格的类型检查和潜在的模块自动导入。</p><h2 id="72ac" class="lr ka hs bd kb ls lt lu kf lv lw lx kj ja ly lz kn je ma mb kr ji mc md kv me bi translated">语境</h2><p id="5fde" class="pw-post-body-paragraph ip iq hs ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated">LSP的当前实现是有效的，但是不支持一些常见的<em class="jr">数据科学</em>到<em class="jr"> Python </em>的方法。对存根文件的支持意味着社区可以以一种标准的方式提供其中的一些特性，编辑器可以利用这些特性。很高兴看到<em class="jr"> VS代码</em>回应来自<em class="jr">人工智能</em> (AI)的代码完成引擎的挑战，如<a class="ae lh" href="https://www.kite.com/" rel="noopener ugc nofollow" target="_blank"> <em class="jr">风筝</em> </a>。</p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><h1 id="2548" class="jz ka hs bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">结论</h1><p id="7e3a" class="pw-post-body-paragraph ip iq hs ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated">我的袖珍列表中的三篇文章已经被分享、总结并提供了背景。在<code class="du jn jo jp jq b">python</code>中使用<code class="du jn jo jp jq b">map</code>、<code class="du jn jo jp jq b">filter</code>和<code class="du jn jo jp jq b">reduce</code>，为分布式计算做好准备。当前无处不在的<em class="jr"> Kubernetes </em>平台的替代方案，使用一个潜在的更轻、更简单和更可扩展的系统，使用<em class="jr"> Nomad </em>。最后，一篇关于<em class="jr"> Pylance </em>优于LSP的有趣文章。</p></div></div>    
</body>
</html>