<html>
<head>
<title>Comparing different types of top-N recommendation engines on a single numerical scale</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在单个数字尺度上比较不同类型的前N名推荐引擎</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/comparing-different-types-of-top-n-recommendation-engines-on-a-single-numerical-scale-a0c883ae1f0a?source=collection_archive---------1-----------------------#2021-01-08">https://medium.com/mlearning-ai/comparing-different-types-of-top-n-recommendation-engines-on-a-single-numerical-scale-a0c883ae1f0a?source=collection_archive---------1-----------------------#2021-01-08</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><h1 id="0029" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">介绍</h1><p id="2d93" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated"><strong class="je hi"> <em class="ka">推荐引擎</em> </strong>多年来一直是一个被大量研究的话题。大量的文献综述表明，可以使用许多方法来得出前N条建议。从用户-用户相似性(人口统计过滤、协作过滤)来寻找相似的客户，到项目-项目相似性(基于内容、基于文本、基于评级)来寻找与客户喜爱的项目相似的项目，<strong class="je hi"> <em class="ka">每种方法都使用不同的度量标准</em> </strong>以不同的尺度对顶级产品进行排名。</p><p id="fb83" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">现在，每个算法都有自己的评估KPI，它通常基于它试图估计/优化的内容。但是，如果我们想要<strong class="je hi"> <em class="ka">比较非常不同的方法</em> </strong>的结果，比如关联规则挖掘和矩阵分解，该怎么办呢？我们肯定可以在真实场景中测试它们，但有时<strong class="je hi"> <em class="ka"> A/B测试一切是不可行的</em> </strong>。在本文中，我们将探索一种简单的<strong class="je hi"> <em class="ka">理论方法来比较不同推荐算法的</em> </strong>(基于不同的KPI)。</p><h1 id="eaa9" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">概念演示</h1><p id="c1d3" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">任何为每个客户给出产品排名的<strong class="je hi"> <em class="ka">逻辑都有可能成为推荐引擎</em> </strong>。即使中间的步骤不够好，最终的排名才是最重要的。在协同过滤的情况下，<strong class="je hi"> <em class="ka">即使预测的评分不准确，只要这些能够对产品进行合适的排名</em> </strong>(它们的相对位置准确)我们就是好的。这个想法构成了进一步论证的逻辑的基础。</p><p id="f631" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">假设我们有一些<strong class="je hi"> <em class="ka">客户，他们每个人都在1到10 </em> </strong>的范围内对一定数量的产品进行了评分。产品的数量可能因客户而异，但让我们假设他们每个人都给出了最低数量的评级<strong class="je hi"> <em class="ka">。下图显示了几个客户的评级示例，他们对一些常见产品和一些不同产品进行了评级。</em></strong></p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es kg"><img src="../Images/5547b0eede95bb2d69f1e34fa999fa92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1036/format:webp/1*_gCf-Iq3ZAZGsZFp2Mr1Xg.png"/></div><figcaption class="ko kp et er es kq kr bd b be z dx">Sample ratings of products by two customers</figcaption></figure><p id="5694" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">现在，对于每个客户，我们将从<strong class="je hi"> <em class="ka">中挑选固定数量的产品，用于测试</em> </strong>，并将它们分开。假设我们每个人拿五个，但是这些因顾客而异。然后，我们<strong class="je hi"> <em class="ka">按照每位客户</em> </strong>的评分降序排列。为了让我们<strong class="je hi"> <em class="ka">能够对它们进行排名，我们应该确保选择不同评级的产品</em> </strong>。下图显示了同样的两个客户，所选产品附有排名。实际上，通过python这样的编程语言来实现这一点要方便得多。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es ks"><img src="../Images/a64db2b414373d3ab9ab1baa0235287a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1376/format:webp/1*ajMmbZ_jwtlmvQ5SF9YmBw.png"/></div><figcaption class="ko kp et er es kq kr bd b be z dx">Original ranking of products by the two customers</figcaption></figure><p id="9751" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">现在，我们运行我们的推荐算法。大多数<strong class="je hi"> <em class="ka">算法会对每个产品</em> </strong>附加某种评分，用于对它们进行优先排序，并挑选出前几个。基于这个分数，我们可以为每个客户的每个产品附加一个<strong class="je hi"> <em class="ka">相对排名</em> </strong>。然后，可以将该算法的排名与实际评级的原始排名进行比较。让我们假设下面的图像显示了来自相同的两个客户的3种不同算法的排名。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es kt"><img src="../Images/5ab810ead1a97b3bf1d3d64411c4b9a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/format:webp/1*lHKA9JsL5s0b7C5RxjNFJw.png"/></div><figcaption class="ko kp et er es kq kr bd b be z dx">Hypothetical rankings of products for each customer from three algorithms</figcaption></figure><p id="e1b1" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">现在，来自算法的产品的<strong class="je hi"> <em class="ka">排名应该尽可能地类似于使用产品的实际评级的产品的原始排名</em> </strong>。对于每个算法，我们可以计算每个客户的排名差距，如下所示。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es ku"><img src="../Images/25bba8fae7de6d09213973ef4e0dccbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/format:webp/1*2H54N42uoJK2Sgp5RyReYg.png"/></div><figcaption class="ko kp et er es kq kr bd b be z dx">Gap calculation for customer 1, algorithm 3</figcaption></figure><p id="9be4" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">现在，我们可以为每个算法 计算<strong class="je hi"> <em class="ka">跨客户的平均总差距。这个最终值<strong class="je hi"> <em class="ka">可以针对任何SKU优先级算法进行计算，而不考虑其使用的度量</em> </strong>，作为我们的比较KPI。<strong class="je hi"> <em class="ka">数值越低，算法越好</em> </strong>。如果我们仅基于这两个客户做出决策，下面的两幅图展示了KPI对于每个算法的表现。</em></strong></p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es kv"><img src="../Images/b566ef04e13339ffcd5fc47c6e55fb38.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/1*KasDMEVh5HD0OvQWCan3Qw.png"/></div><figcaption class="ko kp et er es kq kr bd b be z dx">Total gaps in rankings, for each customer, for each algorithm</figcaption></figure><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es kw"><img src="../Images/6d1261401a845310b43ec79f6b3953c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:496/format:webp/1*k6mZWPEtlrmT14nJNsM3lw.png"/></div><figcaption class="ko kp et er es kq kr bd b be z dx">Average gap (final KPI) for each algorithm</figcaption></figure><p id="841b" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">我们可以看到<strong class="je hi"> <em class="ka">算法2的差距</em> </strong>平均值最小。因此，按照我们的方法，这是最好的算法。在实际问题中，这一平均值将适用于更多的客户。</p><h1 id="41d2" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">结论</h1><p id="2c97" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">比较基于不同算法的推荐引擎就像<strong class="je hi"> <em class="ka">比较苹果和橘子。</em> </strong>每种算法都有自己的度量标准，并且总是<strong class="je hi"> <em class="ka"> </em> </strong>棘手地试探性地猜测哪种更好。但是在市场上测试每一种也是不可行的。因此，在本文中，我们通过一种简单的方法得出了一个<strong class="je hi"> <em class="ka"> KPI，该KPI可以通过任何提供产品排名</em> </strong>的统计或启发式方法来计算。由于这个KPI是<strong class="je hi"> <em class="ka">与任何一个top N推荐引擎的最终结果</em> </strong>直接相关，所以可以用它来把所有算法带到一个共同的尺度上，最终选出最好的一个。</p></div></div>    
</body>
</html>