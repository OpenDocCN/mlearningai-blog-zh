<html>
<head>
<title>Clustering — Simple Explanation and Implementation in Python .</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">聚类Python中的简单解释和实现。</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/clustering-simple-explanation-and-implementation-in-python-3b68ca83bfc?source=collection_archive---------0-----------------------#2021-04-30">https://medium.com/mlearning-ai/clustering-simple-explanation-and-implementation-in-python-3b68ca83bfc?source=collection_archive---------0-----------------------#2021-04-30</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="8c52" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在本文中，我详细解释了两种流行的聚类算法，K-Means聚类和层次聚类，以及它们在Python中的实现。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es jc"><img src="../Images/f1d9f2de82e9b91adf82732cf53427f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*-s8UjB4fUSUcetElJSgfGA.jpeg"/></div><figcaption class="jk jl et er es jm jn bd b be z dx">Photo credits — <a class="ae jo" href="https://unsplash.com/@shlomo99" rel="noopener ugc nofollow" target="_blank">Shlomo Shalev</a> on Unsplash</figcaption></figure><p id="b3e6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">无监督算法是一种不使用带有标签的过去数据来进行预测的算法。</p><p id="a893" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">聚类是一种流行的无监督机器学习算法。这里，具有相似性的观察值被分组在一起，形成一个<strong class="ig hi">簇</strong>。聚类的基本思想包括对数据进行分段，这样，具有相似性的观察值被分组在一起。如此形成的片段应该是稳定的；这意味着两组不能包含相同的观察值或相同的数据点。</p><p id="4ddf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们将看到聚类如何工作，它的类型(K表示聚类算法和层次聚类算法)以及它如何帮助得出有用的结论，进一步，借助一个非政府组织的数据集。</p><h1 id="76dc" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">k表示聚类</h1><p id="2f1e" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">我们先来了解一些重要的概念。</p><h2 id="c741" class="ks jq hh bd jr kt ku kv jv kw kx ky jz ip kz la kd it lb lc kh ix ld le kl lf bi translated">欧几里得距离</h2><p id="22bc" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">观察结果之间的相似性是通过一种叫做<strong class="ig hi">欧几里德距离的度量来衡量的。</strong></p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es lg"><img src="../Images/6560a82747246dc3d18ae2293b8b399f.png" data-original-src="https://miro.medium.com/v2/resize:fit:974/format:webp/1*gCiZ75QYooDr-GeTlGZ5aw.jpeg"/></div><figcaption class="jk jl et er es jm jn bd b be z dx">Euclidean Distance between 2 points in a 2-D Cartesian system</figcaption></figure><p id="438b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">两点(x1，y1)和(x2，y2)之间的欧几里德距离计算如下:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es lh"><img src="../Images/f1d84073024b651bee5722ca35387dcd.png" data-original-src="https://miro.medium.com/v2/resize:fit:666/format:webp/1*_K5zrzdiE7FiWjw0gcZqQQ.png"/></div></figure><p id="6aa8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">所以在上图中，两点(1，4)和(4，1)之间的欧氏距离为:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es li"><img src="../Images/0cb3e4e205330a9e9185a530df07687f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1106/format:webp/1*rVQQEKnTx0wWrfQp4QO-Ow.png"/></div></figure><h2 id="3a98" class="ks jq hh bd jr kt ku kv jv kw kx ky jz ip kz la kd it lb lc kh ix ld le kl lf bi translated">图心</h2><p id="c401" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">一个星团的中心叫做<strong class="ig hi">质心。</strong>通过取一个聚类中所有数据点的坐标的平均值来计算。例如，假设我们在一个集群中有3个数据点，(x1，y1)，(x2，y2)，(x3，y3)。质心(X，Y)的坐标计算如下:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es lj"><img src="../Images/daea450b41b0daa6eea88b61a0dfc17c.png" data-original-src="https://miro.medium.com/v2/resize:fit:670/format:webp/1*cWJqztSwipWOQbWFE54scA.png"/></div></figure><p id="0217" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，假设您有一组数据点要分成两个组。<strong class="ig hi"> K均值聚类</strong>算法工作如下:</p><ol class=""><li id="b8ac" class="lk ll hh ig b ih ii il im ip lm it ln ix lo jb lp lq lr ls bi translated">为给定的点集任意选择两个质心，因为我们想要两个聚类。</li><li id="343c" class="lk ll hh ig b ih lt il lu ip lv it lw ix lx jb lp lq lr ls bi translated">将每个数据点分配给每个质心，这意味着计算每个数据点到每个质心的欧几里德距离。这一步叫做<strong class="ig hi">赋值</strong>。</li><li id="48b3" class="lk ll hh ig b ih lt il lu ip lv it lw ix lx jb lp lq lr ls bi translated">现在，根据欧几里德距离，每个点属于聚类1或聚类2。基于这个分组，用上面提到的质心公式计算新的质心。这个步骤被称为<strong class="ig hi">优化</strong>。</li><li id="7d6c" class="lk ll hh ig b ih lt il lu ip lv it lw ix lx jb lp lq lr ls bi translated">基于上述质心坐标重新形成聚类。</li></ol><p id="9e4d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">分配</strong>和<strong class="ig hi">优化</strong>步骤重复进行(称为迭代),直到质心坐标保持不变或算法收敛。</p><h2 id="50de" class="ks jq hh bd jr kt ku kv jv kw kx ky jz ip kz la kd it lb lc kh ix ld le kl lf bi translated">k均值++算法</h2><p id="cabb" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">在K-Means算法中，我们根据想要形成的簇的数量任意选择初始质心。K-Means++算法是决定这些初始质心的一个更聪明的方法。涉及的步骤如下:</p><ol class=""><li id="8081" class="lk ll hh ig b ih ii il im ip lm it ln ix lo jb lp lq lr ls bi translated">决定要形成的聚类的期望数量(假设3个)，并选择数据点集中的任意点作为第一个质心。</li><li id="bd22" class="lk ll hh ig b ih lt il lu ip lv it lw ix lx jb lp lq lr ls bi translated">从第一个质心开始计算每个数据点的欧几里德距离，并将它们平方。</li><li id="4a8a" class="lk ll hh ig b ih lt il lu ip lv it lw ix lx jb lp lq lr ls bi translated">根据获得的值，选择最远的数据点作为第二质心。</li><li id="92cd" class="lk ll hh ig b ih lt il lu ip lv it lw ix lx jb lp lq lr ls bi translated">重复步骤2中的过程，这一次对两个质心，并决定最远的点作为第三个质心。</li></ol><p id="0076" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">K Means++算法有助于K Means算法更快地收敛，即与随机确定初始质心相比，获得最终质心所需的迭代次数更少。</p><p id="b015" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用K均值算法时要考虑的一些缺点是:</p><ol class=""><li id="d360" class="lk ll hh ig b ih ii il im ip lm it ln ix lo jb lp lq lr ls bi translated">要形成的集群的数量应该在一开始就决定。</li><li id="98f9" class="lk ll hh ig b ih lt il lu ip lv it lw ix lx jb lp lq lr ls bi translated">所选的初始质心定义了最终将如何形成簇。</li><li id="30ee" class="lk ll hh ig b ih lt il lu ip lv it lw ix lx jb lp lq lr ls bi translated">此外，由于K均值算法对离群值敏感，直观上，离群值将抑制最佳聚类的形成。</li></ol><h2 id="cf5b" class="ks jq hh bd jr kt ku kv jv kw kx ky jz ip kz la kd it lb lc kh ix ld le kl lf bi translated">肘法和剪影评分法</h2><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="er es ly"><img src="../Images/6c42469417c3d95dc6a4d501a42c9e4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0_G8m7dx_-PwfuW0jzFNQA.png"/></div></div></figure><p id="3fd5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">仅仅通过查看数据来决定集群的数量有时很困难。为了找到K均值聚类的最优聚类数，有两种方法派上了用场:肘形法和剪影评分法。根据我们的数据，这两种方法都给出了可以形成的簇的数量。</p><p id="2256" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">肘图</strong>是从每个点到其指定中心的SSD(距离的平方和)和集群数量之间的图形。它是一个臂状图，在特定的簇数值处弯曲。该值应该是K均值聚类中要考虑的初始聚类数的最佳估计值。</p><p id="8e9c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">轮廓分数</strong>显示了一个聚类中的每个点与相邻聚类中的点的接近程度。基本上，它衡量所形成的集群的好坏。如果有2个聚类，理想地，两个聚类的数据点之间的<strong class="ig hi">聚类间</strong>距离应该高，而一个聚类内的数据点之间的<strong class="ig hi">聚类内</strong>距离应该低。使用以下公式计算轮廓分数:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es md"><img src="../Images/e378d77068f638d720ef692f3d7a21fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:634/format:webp/1*ffls8ziEqMZ3x2uIlyU5qg.png"/></div></figure><p id="d737" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">其中:</p><p id="83bb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> a </strong>是数据点到该数据点不属于的最近聚类中的点的平均距离。</p><p id="377c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> b </strong>是到其自身聚类中所有点的平均聚类内距离。</p><p id="a28a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">所以理想情况下，<strong class="ig hi"> a </strong>应该最大，<strong class="ig hi"> b </strong>应该最小。</p><p id="b690" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">轮廓得分范围的值介于-1到1之间。分数越接近1，表示该数据点与聚类中的其他数据点非常相似。接近-1的分数表示该数据点与其聚类中的数据点不相似。</p><h1 id="06ca" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">分层聚类</h1><p id="cd94" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">我们看到，在K均值聚类算法中，要形成的聚类的数量必须在开始时自己决定。在分层聚类中，情况并非如此。这里有一系列数据点的合并或划分，这取决于我们所遵循的层次聚类的类型。有两种类型的层次聚类:<strong class="ig hi">凝聚型</strong>和<strong class="ig hi">分裂型。</strong></p><p id="b397" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">系统聚类的输出称为<strong class="ig hi">树状图。</strong>凝聚法是自下而上的方法，而分裂法是自上而下的方法。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es me"><img src="../Images/b224942d8baeaaf4c35988ac1c938fb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1052/format:webp/1*BU2RBSWK-6ahK4cToXr2tg.png"/></div><figcaption class="jk jl et er es jm jn bd b be z dx">Dendrogram in Hierarchical Clustering</figcaption></figure><p id="05ec" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们详细讨论一下凝聚法。分裂方法与凝聚方法正好相反。</p><p id="1ce4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">假设我们有<strong class="ig hi"> N </strong>个数据点。凝聚层次聚类的步骤如下:</p><ol class=""><li id="1d09" class="lk ll hh ig b ih ii il im ip lm it ln ix lo jb lp lq lr ls bi translated">最初，每个点本身都被视为一个簇。所以我们有N个集群。</li><li id="e0f6" class="lk ll hh ig b ih lt il lu ip lv it lw ix lx jb lp lq lr ls bi translated">计算每个点与其他点之间的距离，并形成<strong class="ig hi"> NxN </strong>矩阵。</li><li id="89c6" class="lk ll hh ig b ih lt il lu ip lv it lw ix lx jb lp lq lr ls bi translated">具有最小距离的两个点被组合在一起。</li><li id="4874" class="lk ll hh ig b ih lt il lu ip lv it lw ix lx jb lp lq lr ls bi translated">然后合并两个具有最小距离的聚类。</li><li id="70ae" class="lk ll hh ig b ih lt il lu ip lv it lw ix lx jb lp lq lr ls bi translated">重复步骤4，直到形成一个包含所有数据点的大聚类。</li></ol><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es mf"><img src="../Images/e9259209f65bbd0ed3efd72d99be53b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1010/format:webp/1*7JfQMo44lVS24ZBk7kKiDA.png"/></div><figcaption class="jk jl et er es jm jn bd b be z dx">Agglomerative Hierarchical Clustering</figcaption></figure><p id="dda5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这种群集的合并取决于所遵循的链接类型。有3种类型的链接:</p><ol class=""><li id="acfd" class="lk ll hh ig b ih ii il im ip lm it ln ix lo jb lp lq lr ls bi translated"><strong class="ig hi">单个链接:</strong>根据两个聚类中的点之间的最短距离来合并两个聚类。</li><li id="6b03" class="lk ll hh ig b ih lt il lu ip lv it lw ix lx jb lp lq lr ls bi translated"><strong class="ig hi">完全链接:</strong>根据两个聚类中的点之间的最长距离来合并两个聚类。</li><li id="cb72" class="lk ll hh ig b ih lt il lu ip lv it lw ix lx jb lp lq lr ls bi translated"><strong class="ig hi">平均链接:</strong>根据一个聚类的每个点到另一个聚类的每个其他点之间的平均距离来合并两个聚类。</li></ol><p id="87be" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一旦形成了树状图，下一步就是在适当的层次上切割树状图。这条切割线与树状图相交的点的数量给出了形成的簇的数量。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es mg"><img src="../Images/b3865c7bb9d1592d9dd8f4de50e6a577.png" data-original-src="https://miro.medium.com/v2/resize:fit:1154/format:webp/1*IAjQBR6mNV0rrdWyDbjfvA.png"/></div><figcaption class="jk jl et er es jm jn bd b be z dx">Cutting Line intersecting Dendrogram forming 4 clusters</figcaption></figure><p id="bfd2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这里我们可以看到切割线与树状图相交于4个点，所以我们有4个聚类。如果我们在第5行或以上的位置切割树状图，我们将得到2个聚类。</p><p id="e775" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">层次聚类的主要优点是我们不必一开始就决定聚类的数量。缺点是，它既复杂又耗时。</p><h1 id="a9f4" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">K均值聚类和层次聚类的Python实现。</h1><p id="fbf8" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">我们有一个非政府组织的数据集。这个非政府组织已经筹集了一些资金，并打算捐给那些急需援助的国家。我们需要使用一些决定国家整体发展的社会经济和健康因素对国家进行分类，并找出最需要帮助的5个国家。我的GitHub个人资料上有完整的Python代码和图表，文章末尾有链接。</p><p id="6f2b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们的目标是使用K-Means和层次聚类算法建立聚类模型，找出最需要援助的5个国家。</p><p id="0868" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们从导入必要的库开始。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es mh"><img src="../Images/76b337ed0d982bb728062e40617579ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:912/format:webp/1*uweOegv9MtfSiq-llUMTEQ.png"/></div></figure><p id="47db" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们将数据加载到熊猫数据框中，并将其命名为“ngo”。我们将此数据框架用于EDA(探索性数据分析)。</p><p id="17a0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">基本分析显示数据帧有167行和10列。此外，数据是干净的，没有丢失的值。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es mi"><img src="../Images/92345128238966cb2aa72ae161ca55da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/1*HfnjkPbKfMF2vZ2BWIO5rQ.png"/></div></figure><p id="ad55" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">离群值分析显示child_mort、gdpp和income列存在离群值。我们剔除异常值。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="er es mj"><img src="../Images/7bd84b89cc1a5ae8b2f10e5d0c6c6e02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qbUuxvUveZH99V7qGHRxKg.png"/></div></div></figure><p id="05a7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们执行单变量、双变量和多变量分析，如图所示。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="er es mk"><img src="../Images/c08a4e123d7cba25a6ffc6d43926c17e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-no8k0PwbGhRJ7xw-FresQ.png"/></div></div></figure><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="er es ml"><img src="../Images/0c614cdaf694afd9322c952e626e3771.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ronKWAYI5TFrRXaKRST5ZA.png"/></div></div></figure><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es mm"><img src="../Images/634cbd03a745cf7ee2fd224cec909975.png" data-original-src="https://miro.medium.com/v2/resize:fit:1128/format:webp/1*cnqPMSGiVHxKtfyltXviWA.png"/></div></figure><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es mn"><img src="../Images/31891aaa2b10ba339d6988f2b502b71a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1116/format:webp/1*C-xRpOOrAJ0wAjxzM_CFDQ.png"/></div></figure><h2 id="928f" class="ks jq hh bd jr kt ku kv jv kw kx ky jz ip kz la kd it lb lc kh ix ld le kl lf bi translated">构建聚类模型</h2><p id="81b8" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">我们需要通过比较每个国家集群的变量——<strong class="ig hi">国内生产总值</strong>、<strong class="ig hi">儿童死亡率</strong>和<strong class="ig hi">收入</strong>如何变化来形成集群，以识别和区分发达国家集群和不发达国家集群。</p><p id="ca68" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们通过过滤掉上面提到的列来形成新的数据帧new_df。此外，使用sklearn包中的<strong class="ig hi">标准缩放器</strong>对该数据帧进行缩放。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es md"><img src="../Images/043589417a69cf5092164459709e43df.png" data-original-src="https://miro.medium.com/v2/resize:fit:634/format:webp/1*eXuHtfnPgxmm6F1upaJo_A.png"/></div></figure><p id="457c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对于构建任何聚类模型，首先重要的是检查是否可以利用现有的数据形成有效的聚类。这是通过使用<strong class="ig hi">霍普金的分数</strong>确定的。分数越高，在数据中形成聚类的趋势越好。对于我们的数据，霍普金的得分为91%或0.91%。所以这些数据可以用来形成好的聚类。</p><ol class=""><li id="7c52" class="lk ll hh ig b ih ii il im ip lm it ln ix lo jb lp lq lr ls bi translated"><strong class="ig hi"> K表示聚类</strong></li></ol><p id="3608" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们需要在一开始就决定要形成的星系团的数量。我们使用肘法和剪影评分法来确定相同。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es mo"><img src="../Images/f3973b8c4ceee2d3d835375de1368535.png" data-original-src="https://miro.medium.com/v2/resize:fit:746/format:webp/1*LmNq69qnLPI5RQ34kbPu_Q.png"/></div><figcaption class="jk jl et er es jm jn bd b be z dx">Elbow curve shows optimal clusters value as 3</figcaption></figure><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es mp"><img src="../Images/92c0df1377a9e031d13afb37033b8090.png" data-original-src="https://miro.medium.com/v2/resize:fit:968/format:webp/1*Sz5DGKXqz1v8DQTxwkhzbw.png"/></div></figure><p id="7217" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">根据这两种方法，我们决定使用<strong class="ig hi"> 3 </strong>作为最佳聚类数。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es mq"><img src="../Images/c27cce56223598419882887eb342792f.png" data-original-src="https://miro.medium.com/v2/resize:fit:890/format:webp/1*IFJrpJS4T_-f88h-2MTfhw.png"/></div></figure><p id="db27" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">根据K均值算法，我们得到以下3个聚类:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="er es mr"><img src="../Images/74f5c6f49fc620c43861227b01dc6f10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E_y3Xdn5L4ei9DayP25lUA.png"/></div></div><figcaption class="jk jl et er es jm jn bd b be z dx">3 clusters given by K Means algorithm</figcaption></figure><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="er es mr"><img src="../Images/36cb6491afc24a771229873f5554e806.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ayzPovIg5v2tNBcKwZ1gLg.png"/></div></div><figcaption class="jk jl et er es jm jn bd b be z dx">Swarm plot showing 3 clusters data</figcaption></figure><p id="430f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如此形成的集群如下:</p><ul class=""><li id="4e80" class="lk ll hh ig b ih ii il im ip lm it ln ix lo jb ms lq lr ls bi translated">第0组:中等儿童死亡率，中等收入，中等国内生产总值。</li><li id="97a1" class="lk ll hh ig b ih lt il lu ip lv it lw ix lx jb ms lq lr ls bi translated">第一组:低儿童死亡率、高收入、高GDP。</li><li id="6c60" class="lk ll hh ig b ih lt il lu ip lv it lw ix lx jb ms lq lr ls bi translated">第二组:高儿童死亡率、低收入、低GDP。</li></ul><p id="cb71" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第二组将给我们想要的结果。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="er es mt"><img src="../Images/0645ef319b6173a684b21713c5e24ead.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1D3rlai74MmbOL0wKGpdwA.png"/></div></div></figure><p id="ceb4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">所以急需援助的国家是:</p><ul class=""><li id="11ac" class="lk ll hh ig b ih ii il im ip lm it ln ix lo jb ms lq lr ls bi translated">布隆迪</li><li id="b7a4" class="lk ll hh ig b ih lt il lu ip lv it lw ix lx jb ms lq lr ls bi translated">利比里亚</li><li id="752c" class="lk ll hh ig b ih lt il lu ip lv it lw ix lx jb ms lq lr ls bi translated">刚果民主共和国。代表</li><li id="508e" class="lk ll hh ig b ih lt il lu ip lv it lw ix lx jb ms lq lr ls bi translated">尼日尔</li><li id="84a7" class="lk ll hh ig b ih lt il lu ip lv it lw ix lx jb ms lq lr ls bi translated">马达加斯加</li></ul><p id="18dc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在让我们看看使用层次聚类会得到什么结果。</p><p id="1660" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> 2。层次聚类</strong></p><p id="d160" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们在new_df_scaled中已经有了缩放后的数据。利用完全连锁我们生成了树状图。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es mu"><img src="../Images/60a4f01b6c4b6dd227c9961958af1eaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1330/format:webp/1*RQpg4jr2te4xNToVfK9fAA.png"/></div></figure><p id="b809" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们在第4行切割树状图，得到<strong class="ig hi"> 4 </strong>作为最佳聚类值。我们得到以下集群:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="er es mr"><img src="../Images/c600edb37b9c05ce0bf88462a4a08506.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7b6DlTsa4kqgZu8vFGiK8g.png"/></div></div></figure><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="er es mr"><img src="../Images/afff2fbbe5a392f9c50fbe1f61655956.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c12YwiTtJDzzu0riRvA3nw.png"/></div></div></figure><p id="91a1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这样形成的四个集群是:</p><ul class=""><li id="1c50" class="lk ll hh ig b ih ii il im ip lm it ln ix lo jb ms lq lr ls bi translated">第0组:儿童死亡率高，收入范围最低，国内生产总值范围最低。</li><li id="d4ba" class="lk ll hh ig b ih lt il lu ip lv it lw ix lx jb ms lq lr ls bi translated">第1组:中等儿童死亡率，中低收入范围，中低国内生产总值范围。</li><li id="65a2" class="lk ll hh ig b ih lt il lu ip lv it lw ix lx jb ms lq lr ls bi translated">第二组:低儿童死亡率，中等收入范围，中等国内生产总值</li><li id="b34c" class="lk ll hh ig b ih lt il lu ip lv it lw ix lx jb ms lq lr ls bi translated">第3组:最低的儿童死亡率范围，非常高的收入范围，非常高的国内生产总值</li></ul><p id="5326" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第0组将给出我们想要的结果。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="er es mv"><img src="../Images/4536dc7853c817ce1ba01c9788e1dce7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rlAdTSI4gHEUu4WW4eXKvA.png"/></div></div></figure><p id="92bd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，最需要援助的5个国家是:</p><ul class=""><li id="d890" class="lk ll hh ig b ih ii il im ip lm it ln ix lo jb ms lq lr ls bi translated">布隆迪</li><li id="bd84" class="lk ll hh ig b ih lt il lu ip lv it lw ix lx jb ms lq lr ls bi translated">利比里亚</li><li id="efac" class="lk ll hh ig b ih lt il lu ip lv it lw ix lx jb ms lq lr ls bi translated">刚果民主共和国。代表</li><li id="bc36" class="lk ll hh ig b ih lt il lu ip lv it lw ix lx jb ms lq lr ls bi translated">尼日尔</li><li id="7801" class="lk ll hh ig b ih lt il lu ip lv it lw ix lx jb ms lq lr ls bi translated">马达加斯加</li></ul><p id="ed85" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="mw">结论:我们可以看到，虽然K-Means聚类和层次聚类形成的聚类数目不同，但两种算法给出的结果是相同的。</em>T3】</strong></p><p id="6213" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="mw">希望这篇文章内容翔实，易于理解。我也希望你喜欢分析中的彩色图表。</em></p><p id="a032" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">请随时评论并给出您的反馈。</p><p id="ff7f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="mw">可以在LinkedIn上联系我:</em></strong><a class="ae jo" href="https://www.linkedin.com/in/pathakpuja/" rel="noopener ugc nofollow" target="_blank"><strong class="ig hi"><em class="mw">https://www.linkedin.com/in/pathakpuja/</em></strong></a></p><p id="5ee7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="mw">请访问我的GitHub简介获取python代码:</em></strong><a class="ae jo" href="https://github.com/pujappathak" rel="noopener ugc nofollow" target="_blank"><strong class="ig hi"><em class="mw">https://github.com/pujappathak</em></strong></a></p></div></div>    
</body>
</html>