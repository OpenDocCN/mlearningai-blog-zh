<html>
<head>
<title>Build a model using — k-Nearest Neighbours</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用-k-最近邻构建模型</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/build-a-model-using-k-nearest-neighbours-91925bcc83bb?source=collection_archive---------7-----------------------#2022-12-08">https://medium.com/mlearning-ai/build-a-model-using-k-nearest-neighbours-91925bcc83bb?source=collection_archive---------7-----------------------#2022-12-08</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="6a78" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">k-最近邻(k-NN)算法是一种简单的监督机器学习算法，可用于解决分类和回归问题。它被称为“懒惰学习者”，因为它不从训练数据中学习判别函数，而是简单地存储训练数据，并将其作为分类的基础。</p><h1 id="c77e" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">它是如何工作的</h1><p id="8653" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">k-NN算法通过计算测试点和训练数据集中所有点之间的距离来工作。距离可以是任何度量单位，如欧几里德距离、曼哈顿距离或闵可夫斯基距离。一旦计算出距离，该算法就选择k个最近邻，其中k是由用户指定的正整数。</p><p id="c11a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">接下来，该算法查看k个最近邻的标签(或输出值),并使用它们对测试点进行预测。在分类问题中，预测只是k个最近邻中最常见的标签。在回归问题中，预测是k个最近邻的输出值的平均值。</p><p id="12c1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">k-NN算法的主要优点之一是它非常容易实现和理解。此外，它是一个非参数算法，这意味着它对底层数据分布不做任何假设。这使得它非常适用于数据可能具有非线性模式或要素数量较大的问题。</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="er es kf"><img src="../Images/6903e4df3d595b41278c325327de1838.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*aPqNjd5ET4oRnra0.jpg"/></div></div></figure><p id="7516" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然而，k-NN算法也有一些缺点。一个主要的缺点是计算量很大，尤其是当训练数据集很大时。此外，该算法可能对k的选择敏感，这使得难以找到最优值。此外，该算法不适用于高维数据，因为距离度量在高维中可能变得不可靠。</p><h1 id="590c" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">为“k”优化</h1><p id="eb55" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">优化k-最近邻(k-NN)算法中k的选择的一种方法是使用一种称为交叉验证的技术。交叉验证包括将训练数据集分成多个折叠，通常为10个，然后运行k-NN算法k次，每次使用不同的折叠作为测试集，剩余的折叠作为训练集。</p><p id="c2b1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对于k的每个值，算法计算测试集的准确度(或误差)。然后选择产生最高准确度(或最低误差)的k值作为k的最佳值。这种方法允许客观地评估算法并选择k的最佳值，而不需要单独的验证数据集。</p><p id="f928" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">另一种优化k选择的方法是使用一种叫做网格搜索的技术。在网格搜索中，用户指定k的可能值的范围，算法尝试k的每个值，并使用性能度量(如精度或误差)来评估k-NN算法的性能。然后选择产生最佳性能的k值作为k的最佳值</p><p id="f018" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">还需要注意的是，k的最佳值可能会因数据集和所解决的问题而异。因此，可能有必要试验不同的k值，并使用交叉验证或网格搜索来找到给定数据集的最佳值。</p><h1 id="a94f" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">用k-NN预测房价</h1><p id="709b" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">假设我们得到了一个城市中房子的数据集，目标是根据房子的大小、卧室数量和位置来预测房子的价格。这是一个回归问题，因为产出变量(房价)是连续的。</p><p id="a9f7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了使用k-NN算法解决这个问题，我们首先需要将数据集分成训练集和测试集。训练集用于训练k-NN算法，而测试集用于评估其性能。</p><p id="9570" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">接下来，我们需要为k选择一个值。如前所述，这可以使用交叉验证或网格搜索来完成。为了这个例子，假设我们选择k = 5。</p><p id="86c2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了应用k-NN算法，我们首先需要计算每个测试点和训练集中所有点之间的距离。这通常使用欧几里德距离来完成，欧几里德距离是欧几里德空间中两点之间的直线距离。</p><p id="4c8b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">计算出距离后，该算法会根据距离选择每个测试点的5个最近邻居。然后，它查看5个最近邻居的输出值(房价),并将这些值的平均值作为测试点的预测房价。对每个测试点重复这个过程，将预测的房价收集到一个列表中。</p><p id="9251" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了评估k-NN算法的性能，我们可以将预测的房价与测试集中的实际房价进行比较。这可以通过一个性能指标来实现，比如均方根误差(RMSE)，它衡量预测值和实际值之间的差异。RMSE越低，算法的性能越好。</p><p id="44aa" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">总之，要使用k-NN算法进行回归，我们需要:</p><ol class=""><li id="7ae2" class="kr ks hh ig b ih ii il im ip kt it ku ix kv jb kw kx ky kz bi translated">将数据集拆分为训练集和测试集。</li><li id="f2a3" class="kr ks hh ig b ih la il lb ip lc it ld ix le jb kw kx ky kz bi translated">使用交叉验证或网格搜索选择k值。</li><li id="fbab" class="kr ks hh ig b ih la il lb ip lc it ld ix le jb kw kx ky kz bi translated">计算每个测试点和训练集中所有点之间的距离。</li><li id="ae94" class="kr ks hh ig b ih la il lb ip lc it ld ix le jb kw kx ky kz bi translated">选择每个测试点的k个最近邻。</li><li id="1ea1" class="kr ks hh ig b ih la il lb ip lc it ld ix le jb kw kx ky kz bi translated">取k个最近邻的输出值的平均值作为测试点的预测值。</li><li id="a23b" class="kr ks hh ig b ih la il lb ip lc it ld ix le jb kw kx ky kz bi translated">使用性能度量标准(如RMSE)评估算法的性能。k-NN算法的结果可以解释如下:</li></ol><p id="2283" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">a.如果RMSE较低，则说明预测房价接近实际房价，算法表现良好。</p><p id="188e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">b.如果RMSE高，说明预测房价与实际房价相差甚远，算法执行效果不好。在这种情况下，可能需要尝试不同的k值或使用不同的算法。</p></div><div class="ab cl lf lg go lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ha hb hc hd he"><p id="a17d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下面是如何用Python实现这段代码的两个例子。首先，使用sklearn的算法。其次，编写数学计算并手动执行。这两者都有助于您理解该方法的内部工作原理。</p><h1 id="aa2f" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">使用Sklearn包</h1><pre class="kg kh ki kj fd lm ln lo bn lp lq bi"><span id="7998" class="lr jd hh ln b be ls lt l lu lv">from sklearn.neighbors import KNeighborsRegressor<br/>from sklearn.metrics import mean_squared_error<br/><br/># load the dataset<br/>X = ... # input variables (size, number of bedrooms, location)<br/>y = ... # output variable (house price)<br/><br/># split the dataset into a training set and a test set<br/>train_set = ...<br/>train_labels = ...<br/>test_set = ...<br/>test_labels = ...<br/><br/># create the k-NN regressor<br/>regressor = KNeighborsRegressor(n_neighbors=5)<br/><br/># train the k-NN regressor on the training set<br/>regressor.fit(train_set, train_labels)<br/><br/># make predictions for the test set<br/>predictions = regressor.predict(test_set)<br/><br/># evaluate the performance of the k-NN regressor using RMSE<br/>rmse = np.sqrt(mean_squared_error(test_labels, predictions))<br/>print(rmse)<br/><br/># compare the predicted values to the actual values<br/>for i in range(len(test_set)):<br/>  print("Actual:", test_labels[i], "Predicted:", predictions[i])</span></pre><p id="15ee" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这段代码使用sklearn包中的KNeighborsRegressor类来实现回归的k-NN算法。n_neighbors参数指定用于k-NN算法的k值。</p><p id="249d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">要使用k-NN回归器，我们首先需要创建KNeighborsRegressor类的一个实例，并指定要使用的k值。接下来，我们使用拟合方法在训练集上训练k-NN回归器。</p><p id="9e49" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了进行预测，我们使用predict方法并传递测试集。predict方法返回预测值列表，然后我们可以使用sklearn.metrics模块中的mean_squared_error函数来评估k-NN回归器的性能。</p><p id="eaee" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最后，我们将预测值与测试集中的实际值进行比较，以了解k-NN回归器的表现如何。</p><h1 id="998a" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">手动计算距离</h1><pre class="kg kh ki kj fd lm ln lo bn lp lq bi"><span id="a76c" class="lr jd hh ln b be ls lt l lu lv">import numpy as np<br/><br/># calculate Euclidean distance between two points<br/>def euclidean_distance(x1, x2):<br/>  return np.sqrt(np.sum((x1 - x2)**2))<br/><br/># calculate the distances between a test point and all points in the training set<br/>def calculate_distances(test_point, train_set):<br/>  distances = []<br/>  for train_point in train_set:<br/>    distance = euclidean_distance(test_point, train_point)<br/>    distances.append(distance)<br/>  return distances<br/><br/># select the k-nearest neighbors to a test point<br/>def select_neighbors(distances, k):<br/>  sorted_distances = np.argsort(distances)<br/>  neighbors = sorted_distances[:k]<br/>  return neighbors<br/><br/># predict the output value for a test point using the k-nearest neighbors<br/>def predict(train_set, train_labels, test_point, k):<br/>  distances = calculate_distances(test_point, train_set)<br/>  neighbors = select_neighbors(distances, k)<br/>  neighbor_labels = train_labels[neighbors]<br/>  predicted_label = np.mean(neighbor_labels)<br/>  return predicted_label<br/><br/># evaluate the performance of the k-NN algorithm using RMSE<br/>def evaluate(test_set, test_labels, train_set, train_labels, k):<br/>  predictions = []<br/>  for test_point in test_set:<br/>    predicted_label = predict(train_set, train_labels, test_point, k)<br/>    predictions.append(predicted_label)<br/>  predictions = np.array(predictions)<br/>  rmse = np.sqrt(np.mean((predictions - test_labels)**2))<br/>  return rmse<br/><br/># example usage<br/><br/># load the dataset<br/>X = ... # input variables (size, number of bedrooms, location)<br/>y = ... # output variable (house price)<br/><br/># split the dataset into a training set and a test set<br/>train_set = ...<br/>train_labels = ...<br/>test_set = ...<br/>test_labels = ...<br/><br/># choose the value of k<br/>k = 5<br/><br/># evaluate the performance of the k-NN algorithm using RMSE<br/>rmse = evaluate(test_set, test_labels, train_set, train_labels, k)<br/>print(rmse)</span></pre><p id="59bb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">此代码实现了用于回归的k-NN算法，如下所示:</p><ol class=""><li id="a34b" class="kr ks hh ig b ih ii il im ip kt it ku ix kv jb kw kx ky kz bi translated">euclidean_distance函数计算两点之间的欧氏距离。</li><li id="8fc9" class="kr ks hh ig b ih la il lb ip lc it ld ix le jb kw kx ky kz bi translated">calculate_distances函数计算测试点和训练集中所有点之间的距离。</li><li id="6220" class="kr ks hh ig b ih la il lb ip lc it ld ix le jb kw kx ky kz bi translated">select_neighbors函数选择测试点的k个最近邻点。</li><li id="80f1" class="kr ks hh ig b ih la il lb ip lc it ld ix le jb kw kx ky kz bi translated">预测函数使用k-最近邻预测测试点的输出值。</li><li id="237b" class="kr ks hh ig b ih la il lb ip lc it ld ix le jb kw kx ky kz bi translated">评估函数使用RMSE评估k-NN算法的性能。</li></ol></div><div class="ab cl lf lg go lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ha hb hc hd he"><p id="e45f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">总的来说，k-最近邻算法是解决分类和回归问题的强大工具，对于许多应用程序来说是一个不错的选择。</p><div class="lw lx ez fb ly lz"><a rel="noopener follow" target="_blank" href="/mlearning-ai/mlearning-ai-submission-suggestions-b51e2b130bfb"><div class="ma ab dw"><div class="mb ab mc cl cj md"><h2 class="bd hi fi z dy me ea eb mf ed ef hg bi translated">Mlearning.ai提交建议</h2><div class="mg l"><h3 class="bd b fi z dy me ea eb mf ed ef dx translated">如何成为Mlearning.ai上的作家</h3></div><div class="mh l"><p class="bd b fp z dy me ea eb mf ed ef dx translated">medium.com</p></div></div><div class="mi l"><div class="mj l mk ml mm mi mn kp lz"/></div></div></a></div></div></div>    
</body>
</html>