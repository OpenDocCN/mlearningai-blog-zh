<html>
<head>
<title>Things you don’t know about train_test_split</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于train_test_split你不知道的事</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/things-you-dont-know-about-train-test-split-41df76cb5dc9?source=collection_archive---------1-----------------------#2021-08-26">https://medium.com/mlearning-ai/things-you-dont-know-about-train-test-split-41df76cb5dc9?source=collection_archive---------1-----------------------#2021-08-26</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/6cc108be707feffe42afd6f3be6d19c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uUYNX2OSO7LfTTnxa2NdRA.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Connect with me: <a class="ae it" href="https://www.linkedin.com/in/ashmal-vayani/" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/in/ashmal-vayani/</a></figcaption></figure><blockquote class="iu iv iw"><p id="0ada" class="ix iy iz ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated"><strong class="ja hi">什么是训练和测试数据？</strong></p></blockquote><p id="27ea" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv ha bi translated">几乎在每一个机器学习问题或深度学习问题中，都给了你要处理的数据集。你清理数据，执行强制性的EDA，试图通过查看你的数据找到基本的见解，处理分类的、缺失的、不相关的、不必要的数据，然后应用各自的解决方案来解决你的问题。</p><p id="cbf0" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv ha bi translated">如果您正在阅读本文，我希望您知道如何清理和处理原始数据，因为这超出了本主题的范围，所以我们现在不讨论它。</p><p id="1686" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv ha bi translated">由于幸运的技术进步，修复的技术，我们现在有大量的数据可供我们使用。这都要感谢开源平台和公司让我们与<a class="ae it" href="https://www.sas.com/en_us/insights/big-data/what-is-big-data.html#:~:text=Big%20data%20is%20a%20term,day%2Dto%2Dday%20basis.&amp;text=It's%20what%20organizations%20do%20with,decisions%20and%20strategic%20business%20moves." rel="noopener ugc nofollow" target="_blank">大数据合作。</a></p><figure class="ka kb kc kd fd ii er es paragraph-image"><div class="er es jz"><img src="../Images/4d28f6532594aeb1d2695aa7e202c773.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*BdGvuLSsko1noghibPZ7Vw.png"/></div></figure><p id="cc60" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv ha bi translated">出于机器学习的目的，我们提供模型从中学习的良好数据块，然后根据看不见的数据预测您的因变量。机器和模型学习的数据称为<strong class="ja hi">训练数据</strong>，我们为机器保存的用于预测或测试未知的数据称为<strong class="ja hi">测试数据。</strong>一个好的分析通常涉及80/20%的训练和测试数据，但这完全取决于您的问题和您正在处理的场景。</p><blockquote class="iu iv iw"><p id="1161" class="ix iy iz ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated"><strong class="ja hi">我们为什么需要拆分？</strong></p></blockquote><p id="2290" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv ha bi translated">每当数据科学家/分析师/工程师工作时，他都要确保他的模型不会根据提供的所有数据进行训练。它可能在训练数据上给出极好的准确性，但是它在以前没有见过的数据上工作得很差。这被称为<a class="ae it" href="https://www.ibm.com/cloud/learn/overfitting#:~:text=Overfitting%20is%20a%20concept%20in,exactly%20against%20its%20training%20data.&amp;text=When%20the%20model%20memorizes%20the,generalize%20well%20to%20new%20data." rel="noopener ugc nofollow" target="_blank"> <strong class="ja hi">过拟合，</strong> </a>当统计模型完全符合其训练数据时，或者可能因为您的数据集很小，就会发生这种情况。模型学习模式，让你的结果一般化，这是不够的。</p><figure class="ka kb kc kd fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ke"><img src="../Images/40cc981eb4802ac67f55fc0d95a5218c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xvjmXQBeHsM4cYNIHLibuQ.png"/></div></div></figure><p id="2998" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv ha bi translated">为了解决这个问题，我们需要将我们的数据集分为训练集和测试集，以在看不见的数据上测试机器，看看结果有多准确。</p><blockquote class="iu iv iw"><p id="28ae" class="ix iy iz ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated"><strong class="ja hi">如何应用列车测试拆分？</strong></p></blockquote><p id="faff" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv ha bi translated">有两种方法可以分割实际数据集。</p><ol class=""><li id="3981" class="kf kg hh ja b jb jc jf jg jw kh jx ki jy kj jv kk kl km kn bi translated">创建您的用户定义函数。</li><li id="bcad" class="kf kg hh ja b jb ko jf kp jw kq jx kr jy ks jv kk kl km kn bi translated">使用sklearn.model_selection的API train_test_split。</li></ol><p id="5a01" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv ha bi translated"><strong class="ja hi">制作您的自定义函数:</strong></p><p id="9425" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv ha bi translated">使用用户定义的函数不是拆分数据的最流行的方法，您可能不会随时使用它，但这是一种帮助您了解sklearn的API参数的方法。让我们看看进展如何，然后我们再讨论。</p><pre class="ka kb kc kd fd kt ku kv kw aw kx bi"><span id="52c8" class="ky kz hh ku b fi la lb l lc ld"><strong class="ku hi">import</strong> <strong class="ku hi">numpy</strong> <strong class="ku hi">as</strong> <strong class="ku hi">np</strong><br/><strong class="ku hi">def</strong> split_train_test(data,test_ratio):<br/>    #np.random.seed(42)<br/>    shuffled = np.random.permutation(len(data))<br/>    test_set_size = int(len(data)*test_ratio)<br/>    test_indices = shuffled[:test_set_size]<br/>    train_indices = shuffled[test_set_size:]<br/>    <strong class="ku hi">return</strong> data.iloc[train_indices], data.iloc[test_indices]</span></pre><p id="acf5" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv ha bi translated">这些参数包括您的实际数据集和您想要分割的测试比率。我们暂时忽略np.random.seed(42)。我们一会儿就回来。</p><pre class="ka kb kc kd fd kt ku kv kw aw kx bi"><span id="2bf8" class="ky kz hh ku b fi la lb l lc ld">print(f"Rows in Training Set : <strong class="ku hi">{</strong>len(train_set)<strong class="ku hi">}\n</strong>Rows in Test Set : <br/><strong class="ku hi">{</strong>len(test_set)<strong class="ku hi">}</strong>")</span><span id="156e" class="ky kz hh ku b fi le lb l lc ld">#Expected output:<br/>#Rows in Training Set : 405<br/>#Rows in Test Set : 101</span></pre><p id="4070" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv ha bi translated">np.random.permutation随机排列序列或返回数据的排列范围。</p><p id="0fc0" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv ha bi translated">现在，我们通过简单地将我们的数据长度乘以测试比率来设置测试大小，并且我们将我们的数据分成test _ indices和train _ indices并返回它们。让我们看看注释np.random.seed行的运行情况，看看它在这段代码中返回了什么:</p><pre class="ka kb kc kd fd kt ku kv kw aw kx bi"><span id="4ccc" class="ky kz hh ku b fi la lb l lc ld">train_set, test_set = split_train_test(housing,0.2)</span></pre><p id="a872" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv ha bi translated">如果我们打印我们的混洗矩阵，这就是我们的输出看起来像:</p><figure class="ka kb kc kd fd ii er es paragraph-image"><div class="er es lf"><img src="../Images/65a7d6390b14b097899560bdab50dac4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/format:webp/1*-y-CKlZ8qgnTe-tOGdx3aw.png"/></div></figure><p id="8145" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv ha bi translated">如果我们重新运行该单元格，我们的输出可能如下所示:</p><figure class="ka kb kc kd fd ii er es paragraph-image"><div class="er es lg"><img src="../Images/d56fd6b8b37aefcd2faa87c0136da4fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/1*9QC2ToMVc-20s_n7pVu-6Q.png"/></div></figure><p id="bbf2" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv ha bi translated">这意味着启动随机排列的基值没有设置，如果我们多次运行我们的笔记本，您的模型可能会看到您的所有实际数据，这将导致过度拟合，并且在训练集上工作不佳。</p><p id="5455" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv ha bi translated"><strong class="ja hi">解决方案:</strong></p><p id="0c0d" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv ha bi translated">让我们取消random.seed行的注释，并设置参数random_state=42，看看我们的输出如何变化。random_state=42是一种常规做法，您可以设置一个不同的范围，但这将控制在应用拆分之前应用于数据的混排。您还可以在多个函数调用之间传递一个int以获得可再现的输出。</p><pre class="ka kb kc kd fd kt ku kv kw aw kx bi"><span id="5a8a" class="ky kz hh ku b fi la lb l lc ld"><strong class="ku hi">import</strong> <strong class="ku hi">numpy</strong> <strong class="ku hi">as</strong> <strong class="ku hi">np</strong><br/><strong class="ku hi">def</strong> split_train_test(data,test_ratio):<br/>    np.random.seed(42)<br/>    shuffled = np.random.permutation(len(data))<br/>    test_set_size = int(len(data)*test_ratio)<br/>    test_indices = shuffled[:test_set_size]<br/>    train_indices = shuffled[test_set_size:]<br/>    <strong class="ku hi">return</strong> data.iloc[train_indices], data.iloc[test_indices]</span></pre><p id="4126" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv ha bi translated">输出:</p><figure class="ka kb kc kd fd ii er es paragraph-image"><div class="er es lh"><img src="../Images/70ac7071d0a17e9d66e5393c75a37db7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1184/format:webp/1*XoCwbpyM_UczpyBESeSn2w.png"/></div></figure><p id="490e" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv ha bi translated">每次运行该单元时，您将获得相同的矩阵，并且不再有过度拟合的问题，因为您的训练模型将永远不会看到完整的数据，并且将在测试数据上工作良好。</p><p id="5654" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv ha bi translated">学到了新东西？如果你已经知道这些，那就太好了。我们继续吧。</p><p id="a22e" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv ha bi translated"><strong class="ja hi">使用sklearn.model_selection的API train_test_split: </strong></p><p id="220b" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv ha bi translated">这是我们几乎所有人用来分割数据的技术；不言自明，我们使用sklearn.model_selection的API train_test_split传递参数，它返回数据。</p><pre class="ka kb kc kd fd kt ku kv kw aw kx bi"><span id="e846" class="ky kz hh ku b fi la lb l lc ld"><em class="iz">#we will use train test splitting from sklearn</em><br/><strong class="ku hi">from</strong> <strong class="ku hi">sklearn.model_selection</strong> <strong class="ku hi">import</strong> train_test_split<br/>train_set, test_set = train_test_split(housing, test_size=0.2, random_state = 42)</span><span id="33a2" class="ky kz hh ku b fi le lb l lc ld">print(train_set.shape, test_set.shape)</span><span id="ca83" class="ky kz hh ku b fi le lb l lc ld">#Output:(404, 14) (102, 14)</span></pre><p id="a8fa" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv ha bi translated">我们可以看到，两种方法的数据集大小几乎相同，只有1条记录的差异。这是因为每种方法处理舍入值的方式都不同。例如:如果您有506条记录，80%的训练数据意味着404.8条记录。一个当作404，另一个四舍五入到405。</p><blockquote class="iu iv iw"><p id="b587" class="ix iy iz ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated"><strong class="ja hi">stratifedshufflesplit</strong></p></blockquote><p id="228e" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv ha bi translated">在离开之前，我们将最后讨论一个基本特性，但在此之前，让我们通过一个例子来讨论它。</p><p id="6b85" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv ha bi translated">假设您的数据集中有一个非常重要的属性，或者与您可能不想操纵的因变量有很强的正相关性。假设您有一个具有value_counts的属性，如下所示:</p><figure class="ka kb kc kd fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es li"><img src="../Images/8c210e5cbf5eccd65627eaff60ee8177.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*76Yc0AdYJe5l6iWhQ_HVnQ.png"/></div></div></figure><p id="6a63" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv ha bi translated">现在想象一下，如果您的test_data有101条记录，test_data可能有0条记录，其中“CHAS”值为1，training_data也是如此。您的模型尚未使用数据进行训练，因此如果任何测试数据的属性值为“1”，可能会给出不确定的结果并导致不准确。</p><p id="2438" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv ha bi translated">你如何处理这个？</p><p id="1696" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv ha bi translated"><strong class="ja hi">解决方案:</strong></p><p id="ed78" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv ha bi translated">为了避免这种情况，或者使某个特定变量在训练集和测试集中均匀分布，我们使用StratifiedShuffleSplit来实现这一点。</p><pre class="ka kb kc kd fd kt ku kv kw aw kx bi"><span id="80d1" class="ky kz hh ku b fi la lb l lc ld"><strong class="ku hi">from</strong> <strong class="ku hi">sklearn.model_selection</strong> <strong class="ku hi">import</strong> StratifiedShuffleSplit<br/>split = StratifiedShuffleSplit(n_splits = 1, test_size = 0.2, random_state = 42)<br/><br/><strong class="ku hi">for</strong> train_index, test_index <strong class="ku hi">in</strong> split.split(housing, housing['CHAS']):<br/>    strat_train_set = housing.loc[train_index]<br/>    strat_test_set = housing.loc[test_index]</span></pre><p id="005b" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv ha bi translated">您可能会发现参数非常相似，for循环将为我们平均分配数据。让我们检查一下:</p><figure class="ka kb kc kd fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lj"><img src="../Images/fe59f14fd7af28472ca5ee53ae230c0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xJ96ArYNGkzdqZ7yrBUHQQ.png"/></div></div></figure><p id="1bc7" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv ha bi translated">我们来看看比例:</p><figure class="ka kb kc kd fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lk"><img src="../Images/e6a0cb46bdb564894e7d98379b5fcab6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rbbp0GxZhhPPCmeuNjlzyA.png"/></div></div></figure><p id="57d7" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv ha bi translated">我们已经解决了这个问题。</p></div><div class="ab cl ll lm go ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ha hb hc hd he"><p id="9aad" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv ha bi translated">关于train_test_split你就知道这么多了。如果您认为我还需要补充什么，请随时联系我:</p><div class="ls lt ez fb lu lv"><a href="https://www.linkedin.com/in/ashmal-vayani/" rel="noopener  ugc nofollow" target="_blank"><div class="lw ab dw"><div class="lx ab ly cl cj lz"><h2 class="bd hi fi z dy ma ea eb mb ed ef hg bi translated">Ashmal Vayani -作家-机器学习| LinkedIn</h2><div class="mc l"><h3 class="bd b fi z dy ma ea eb mb ed ef dx translated">我只是一个普通人，追随他对学习不同层次的编码和逻辑构建的热情…</h3></div><div class="md l"><p class="bd b fp z dy ma ea eb mb ed ef dx translated">www.linkedin.com。</p></div></div><div class="me l"><div class="mf l mg mh mi me mj in lv"/></div></div></a></div></div></div>    
</body>
</html>