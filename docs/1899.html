<html>
<head>
<title>Strategy Design Pattern for Effective ML Pipeline</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">有效ML管道的策略设计模式</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/strategy-design-pattern-for-effective-ml-pipeline-1099c5131553?source=collection_archive---------2-----------------------#2022-02-09">https://medium.com/mlearning-ai/strategy-design-pattern-for-effective-ml-pipeline-1099c5131553?source=collection_archive---------2-----------------------#2022-02-09</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="5f78" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Python <strong class="ig hi">策略</strong>和<strong class="ig hi">工厂</strong>设计模式帮助我们将复杂的问题构造成更小的部分，更容易扩展和修改，因此是有效的ML管道。</p><h1 id="8cb5" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated"><strong class="ak">动机</strong></h1><p id="bb61" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">给定手边的ML问题，作为数据科学家，你可能想要试验ML管道的不同方面，例如特征工程、学习算法。对于每个方面，你也可以做很多不同的事情。例如，如果您决定尝试学习算法，您可以尝试使用不同的算法，从最简单的算法(如线性模型)到最复杂的算法(如神经网络、梯度推进)。如果您决定试验特征工程，有许多可能的特征组合，您也需要评估它们如何影响模型性能。更不用说如果你想同时尝试学习算法和特征工程。</p><blockquote class="kf kg kh"><p id="44cf" class="ie if ki ig b ih ii ij ik il im in io kj iq ir is kk iu iv iw kl iy iz ja jb ha bi translated">在ML训练中做实验是一个复杂的问题。</p></blockquote><figure class="kn ko kp kq fd kr er es paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="er es km"><img src="../Images/dbb60f022385569276b986d3422f646e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZwxPm_FtydxFwA3o"/></div></div><figcaption class="ky kz et er es la lb bd b be z dx">Photo by <a class="ae lc" href="https://unsplash.com/@markuswinkler?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Markus Winkler</a> on <a class="ae lc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="8c98" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">学习目标</h1><p id="c8d9" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">我们将学习在数据科学项目中派上用场的两种Python设计模式，即<strong class="ig hi">策略</strong>和<strong class="ig hi">工厂</strong>。</p><blockquote class="kf kg kh"><p id="1f8e" class="ie if ki ig b ih ii ij ik il im in io kj iq ir is kk iu iv iw kl iy iz ja jb ha bi translated">这篇博文中使用的代码是<a class="ae lc" href="https://github.com/ajisamudra/strategy-pattern-for-effective-ml-pipeline" rel="noopener ugc nofollow" target="_blank">这里是</a></p></blockquote><h1 id="dd97" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated"><strong class="ak"> Python设计模式</strong></h1><h2 id="256a" class="ld jd hh bd je le lf lg ji lh li lj jm ip lk ll jq it lm ln ju ix lo lp jy lq bi translated"><strong class="ak">工厂</strong></h2><blockquote class="kf kg kh"><p id="140b" class="ie if ki ig b ih ii ij ik il im in io kj iq ir is kk iu iv iw kl iy iz ja jb ha bi translated">抽象工厂是一种创造性的设计模式，它解决了在不指定具体类的情况下创建整个产品族的问题。工厂定义了一个创建所有不同产品的接口，但是将实际的产品创建留给了具体的工厂类。<a class="ae lc" href="https://refactoring.guru/design-patterns/abstract-factory/python/example#lang-features" rel="noopener ugc nofollow" target="_blank">重构大师</a></p></blockquote><p id="4d35" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">换句话说，Factory中有两个类，抽象类和具体类。具体类是抽象类的子类。我们在抽象类中定义接口，而不指定它的具体实现。该接口被定义为<strong class="ig hi">抽象方法</strong>。接口的实现在具体的类中提供。abstractmethod强制要求具体的类必须实现接口。有了这个，我们就可以创建尽可能多的具体类的不同实现，而不用担心实现是否会破坏代码。为什么？因为所有不同的具体类都有相同的接口。</p><p id="eb79" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">符合工厂模式的案例:</strong></p><p id="183f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">例1: <br/> </strong> Scikit-learn著名接口<strong class="ig hi"> `fit` </strong>和<strong class="ig hi"> `predict` </strong>方法。这是一个例子，有很好的标准接口跨越库中可用的算法。</p><figure class="kn ko kp kq fd kr er es paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="er es lr"><img src="../Images/ac0287851174f26adcc09b042625c640.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tIE9gmYz-V4ETOaoSdQ37g.png"/></div></div></figure><p id="1f40" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">示例2: <br/> </strong>假设您想要为两个不同的库创建一个训练管道，即Scikit-learn和lightgbm/xgboost/catboost。尽管它们具有相同的“拟合”和“预测”方法，但它们并不相同。在lightgbm/xgboost/catboost中，“fit”方法具有附加参数，如“early_stopping_round”和“eval_set ”,这些参数有助于防止模型过度拟合。另一方面，Scikit-learn线性模型(LinearRegression、LogisticRegression等)要求我们在调用“fit”方法之前执行特征缩放。这将有助于线性模型加快训练过程以达到最优解。只有两种不同的算法(线性模型和梯度推进)，我们需要区分管道中的过程。</p><p id="7000" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">梯度推进</strong> : (1)读取训练数据(2)分割数据进行训练和测试(3)拟合模型(4)预测(5)评估模型<br/> <strong class="ig hi">线性模型</strong> : (1)读取训练数据(2)分割数据进行训练和测试(3)尺度特征(4)拟合模型(5)预测(6)评估模型</p><p id="99f4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">通过在<strong class="ig hi">包装器方法‘fit’和‘predict’</strong>中包装不同的过程，工厂对于我们创建不同ML库的标准接口是有用的。</p><h2 id="4df4" class="ld jd hh bd je le lf lg ji lh li lj jm ip lk ll jq it lm ln ju ix lo lp jy lq bi translated"><strong class="ak">策略</strong></h2><blockquote class="kf kg kh"><p id="7f01" class="ie if ki ig b ih ii ij ik il im in io kj iq ir is kk iu iv iw kl iy iz ja jb ha bi translated">策略是一种行为设计模式，它将一组行为转化为对象，并使它们在原始上下文对象中可以互换。称为context的原始对象包含对策略对象的引用，并委托它执行行为。为了更改上下文执行其工作的方式，其他对象可能会用另一个对象替换当前链接的策略对象。<a class="ae lc" href="https://refactoring.guru/design-patterns/strategy/python/example#lang-features" rel="noopener ugc nofollow" target="_blank">重构大师</a></p></blockquote><p id="655a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">换句话说，我们在策略模式中使用不同的具体类实现。它使我们能够在相同的问题背景下互换行为/策略。</p><p id="d63b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">符合策略模式的示例案例:<br/> </strong>在ML训练管道问题中，我们把训练管道分成几个部分:(1)管道(2)数据(3)算法(4)特征工程等。</p><ol class=""><li id="eb43" class="ls lt hh ig b ih ii il im ip lu it lv ix lw jb lx ly lz ma bi translated">如果我们将管道设计成一个上下文对象。</li><li id="61ba" class="ls lt hh ig b ih mb il mc ip md it me ix mf jb lx ly lz ma bi translated">我们可以有不同的算法作为不同的行为/策略。</li><li id="56e3" class="ls lt hh ig b ih mb il mc ip md it me ix mf jb lx ly lz ma bi translated">我们可以将不同的特征工程或数据集作为不同的策略。</li></ol><figure class="kn ko kp kq fd kr er es paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="er es mg"><img src="../Images/1f3454c0b5a6a9cc5336c8c2ac5057f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*znnSNHqQywNe0ta26rHjFg.png"/></div></div></figure><p id="f818" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，以后如果我们想要添加新的算法或功能工程或数据集，我们只需为算法或功能工程创建一个新的具体类，而无需修改管道或上下文对象。简而言之，我们的代码很容易修改和扩展。</p><h1 id="bdb7" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">履行</h1><p id="f1bf" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">我们去编码吧！在本例中，我们使用虹膜数据集。它有3个类，我们把这个问题框架为一个多类分类问题。为此，我们使用不同库中的两种算法:</p><ol class=""><li id="9216" class="ls lt hh ig b ih ii il im ip lu it lv ix lw jb lx ly lz ma bi translated">来自Scikit-learn的<strong class="ig hi">logistics regression</strong></li><li id="2122" class="ls lt hh ig b ih mb il mc ip md it me ix mf jb lx ly lz ma bi translated"><strong class="ig hi">light GBM的LGBMClassifier </strong></li></ol><p id="1763" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如前所述，我们需要为每个算法实现不同的过程。<br/> <strong class="ig hi"> LGBMClassifier </strong> : (1)读取训练数据(2)分割数据以进行训练和测试(3)拟合模型(4)预测(5)评估模型<br/> <strong class="ig hi">逻辑回归</strong> : (1)读取训练数据(2)分割数据以进行训练和测试(3)尺度特征(4)拟合模型(5)预测(6)评估模型</p><h2 id="2cec" class="ld jd hh bd je le lf lg ji lh li lj jm ip lk ll jq it lm ln ju ix lo lp jy lq bi translated">以前</h2><p id="5b92" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">我们如何创建一个能够训练不同算法的管道？最简单的方法是以函数式编程的方式使用if-else语句。对于每个if-else块，我们为一个算法定义了唯一的过程。这就是我们的代码看起来的样子。</p><figure class="kn ko kp kq fd kr"><div class="bz dy l di"><div class="mh mi l"/></div></figure><figure class="kn ko kp kq fd kr"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="13de" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">您可能会注意到，我们在这里没有遵循DRY原则，因为我们重复了步骤(5)评估模型。但是我们不能合并步骤(5 ),因为在LogisticRegression中我们需要进行特征缩放，而在GradientBoosting中我们不需要。想象一下，如果您需要在管道中添加一个新的算法。您需要为这个算法添加一个新的if-else块，并且可能为不同的算法重复相同的代码。如果你有很多算法，也很难维护。我们将以一个非常长的函数结束，这不是一个好的实践。让我们看看策略和工厂模式能做什么。</p><h2 id="fbd9" class="ld jd hh bd je le lf lg ji lh li lj jm ip lk ll jq it lm ln ju ix lo lp jy lq bi translated">在...之后</h2><p id="1f03" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">为了实现策略和工厂模式，我们需要从函数式编程切换到面向对象编程。我们需要两个高级对象:<strong class="ig hi">上下文</strong>和<strong class="ig hi">策略</strong>。在我们的例子中，训练管道是我们的上下文对象。上下文可以采用工厂模式中定义的各种<strong class="ig hi">策略对象。</strong></p><p id="a8c4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">上下文对象将如下所示。它采用不同的算法(即策略对象)作为输入。算法策略是可以互换的，所以如果我们想在管道中添加一个新的算法，我们不需要改变上下文对象。</p><figure class="kn ko kp kq fd kr"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="dc3c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">注意，现在算法对象只有包装器“fit”和“predict”。“适应”和“预测”背后的不同过程将在工厂模式中定义。</p><figure class="kn ko kp kq fd kr"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="522e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">用工厂模式实现算法策略怎么样？<br/>在这里，我们需要定义抽象类和具体类。抽象类只定义接口。我们将包装器“fit”和“predict”定义为抽象方法。</p><figure class="kn ko kp kq fd kr"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="68c6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">具体的类为每个算法定义了不同的实现。例如，在LogisticRegression中，我们需要在拟合模型之前先缩放X上的要素。然后，我们需要保存scaler对象，我们稍后将在predict方法中使用它。上下文对象不知道这个不同的实现，因为它只需要包装器“fit”和“predict”。</p><figure class="kn ko kp kq fd kr"><div class="bz dy l di"><div class="mh mi l"/></div></figure><figure class="kn ko kp kq fd kr er es paragraph-image"><div class="er es mj"><img src="../Images/f61ab804d3e2170db993aa50f7bb7255.png" data-original-src="https://miro.medium.com/v2/resize:fit:790/format:webp/1*DU2FKPrmzITzT6g86UvyAA.png"/></div></figure><p id="b381" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们现在已经实现了不同的算法策略。在此设置中，我们可以为特征工程/数据集添加新的策略对象。现在可以更容易地在管道(上下文对象)周围添加新的策略块。</p></div><div class="ab cl mk ml go mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ha hb hc hd he"><h1 id="4803" class="jc jd hh bd je jf mr jh ji jj ms jl jm jn mt jp jq jr mu jt ju jv mv jx jy jz bi translated">结论</h1><p id="bfeb" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">策略和工厂模式是有用的，尤其是当你在特定的环境中有很多可能的“策略”时。</p><h1 id="26ca" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">参考</h1><ol class=""><li id="49ca" class="ls lt hh ig b ih ka il kb ip mw it mx ix my jb lx ly lz ma bi translated">重构大师:<a class="ae lc" href="https://refactoring.guru/" rel="noopener ugc nofollow" target="_blank">https://refactoring.guru/</a></li><li id="6770" class="ls lt hh ig b ih mb il mc ip md it me ix mf jb lx ly lz ma bi translated">Arjan代码——写出更好的Python代码:【https://github.com/ArjanCodes/betterpython T2】</li></ol><div class="mz na ez fb nb nc"><a rel="noopener follow" target="_blank" href="/mlearning-ai/mlearning-ai-submission-suggestions-b51e2b130bfb"><div class="nd ab dw"><div class="ne ab nf cl cj ng"><h2 class="bd hi fi z dy nh ea eb ni ed ef hg bi translated">Mlearning.ai提交建议</h2><div class="nj l"><h3 class="bd b fi z dy nh ea eb ni ed ef dx translated">如何成为Mlearning.ai上的作家</h3></div><div class="nk l"><p class="bd b fp z dy nh ea eb ni ed ef dx translated">medium.com</p></div></div><div class="nl l"><div class="nm l nn no np nl nq kw nc"/></div></div></a></div><p id="712b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae lc" rel="noopener" href="/mlearning-ai/mlearning-ai-submission-suggestions-b51e2b130bfb">成为ML作家</a></p></div></div>    
</body>
</html>