<html>
<head>
<title>Intelligent Portfolio Construction: Prediction of Stock Direction</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">智能投资组合构建:股票方向预测</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/intelligent-portfolio-construction-prediction-of-stock-direction-e1c71f4a725a?source=collection_archive---------0-----------------------#2021-07-30">https://medium.com/mlearning-ai/intelligent-portfolio-construction-prediction-of-stock-direction-e1c71f4a725a?source=collection_archive---------0-----------------------#2021-07-30</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="0667" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在网上搜索关于金融领域机器学习模型的有趣内容时，我看到了一篇提交给伦敦帝国理工学院数学和金融硕士的论文。这被命名为智能投资组合构建:机器学习支持均值-方差优化，我发现它非常酷。特别是，我喜欢第二部分，在那里学生使用随机森林模型来预测股票方向。我决定尝试用Python复制他的步骤(这里是<a class="ae jc" href="https://github.com/RiccardoHub/Intelligent-Portfolio-Construction-Prediction-of-Stock-Direction" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>)。</p><p id="5182" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这篇文章中，我将展示我是如何实现并扩展论文中提出的想法的(<a class="ae jc" href="https://www.imperial.ac.uk/media/imperial-college/faculty-of-natural-sciences/department-of-mathematics/math-finance/Ghali_Tadlaoui_01427211.pdf" rel="noopener ugc nofollow" target="_blank">链接此处</a>)。</p><p id="52ba" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用随机森林预测股票方向的任务列表如下:</p><ol class=""><li id="112f" class="jd je hh ig b ih ii il im ip jf it jg ix jh jb ji jj jk jl bi translated">输入数据</li><li id="dc4f" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb ji jj jk jl bi translated">数据加工</li><li id="b999" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb ji jj jk jl bi translated">特征推导</li><li id="89b1" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb ji jj jk jl bi translated">随机森林分类器</li></ol><h1 id="5564" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">输入数据</h1><p id="c73d" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">该项目所需的数据是OHLC和8只股票的成交量，即苹果、亚马逊、花旗集团、CVS Health、3M、星巴克、嘉信理财公司和埃克森美孚。样本时间跨度为2000年6月1日—2016年4月25日，用于训练和测试模型，2016年4月25日—2021年7月26日，用于验证。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="b0a8" class="ld js hh kz b fi le lf l lg lh">import yfinance as yf<br/><br/>tickers = ['AAPL', 'AMZN', 'C', 'CVS', 'MMM', 'SBUX', 'SCHW', 'XOM']<br/>start = '2000-06-02'<br/>end = '2016-04-26'<br/><br/>AdjClose = yf.download(tickers, start=start, end=end)['Adj Close']<br/>Volume = yf.download(tickers, start=start, end=end)['Volume']<br/>High = yf.download(tickers, start=start, end=end)['High']<br/>Low = yf.download(tickers, start=start, end=end)['Low']<br/>Close = yf.download(tickers, start=start, end=end)['Close']</span></pre><h1 id="32ae" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">数据加工</h1><p id="81f6" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">金融数据通常非常嘈杂，这意味着一段数据携带了一些实际上并不有用的信息。解决这个问题的一个方法是数据平滑，这是一种试图抑制短期可变性，同时保持长期趋势可见的方法。本文使用的方法是指数平滑法，它使用一个常数𝛼.将t+1时的平滑调整后的收盘值确定为t+1时的观测值和t时的平滑数据之间的加权平均值</p><figure class="ku kv kw kx fd lj er es paragraph-image"><div class="er es li"><img src="../Images/6538de37c7c0ed768c67b56d12080c50.png" data-original-src="https://miro.medium.com/v2/resize:fit:808/format:webp/1*gM8sZx8lKuBPG_CserQgxA.png"/></div></figure><p id="9009" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">论文中使用的𝛼常数为0.20。</p><p id="235a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对于这个项目，我决定不使用任何预制函数来提高我的编程技能。因此，这些代码远不是最高效或最优雅的。然而，如果你能提供一个更有效/优雅的代码，请这样做！</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="8536" class="ld js hh kz b fi le lf l lg lh">def exponential_smoothing(df, alpha):<br/>    DF = df.copy().reset_index(drop=True) <br/>    DF.loc[1] = (DF.loc[1]*alpha)+(DF.loc[0]*(1-alpha))<br/>    <br/>    for i in range(2, len(DF)-1):<br/>        DF[i] = (DF[i]*alpha)+(DF[i-1]*(1-alpha))<br/>    <br/>    return DF<br/><br/># Apply the function to all tickers<br/>E = {}<br/>for n in AdjClose.columns:<br/>    E[f'{n}']= exponential_smoothing(AdjClose[n], 0.2)</span></pre><p id="33fd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">结果如图1所示。正如我们在左侧看到的，很难注意到整个数据集的任何差异。然而，通过放大一点，我们可以看到指数平滑的效果。</p><figure class="ku kv kw kx fd lj er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es lm"><img src="../Images/b4e2678c40684410d9aa06e38d52bcc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*93YpTSpJ8CiuNJql-ma2VA.png"/></div></div><figcaption class="lr ls et er es lt lu bd b be z dx">Figure 1: Exponential Smoothing on AAPL</figcaption></figure><h1 id="7ab2" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">特征推导</h1><p id="efd9" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">下一步是创建将在随机森林分类器中用作解释变量的指标。</p><p id="8844" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第一个指标叫做On Balance Volume，这是一个技术性的交易动量指标，用成交量来预测股价的变化。</p><figure class="ku kv kw kx fd lj er es paragraph-image"><div class="er es lv"><img src="../Images/0b6d52ee984f23486322a233d9c7b126.png" data-original-src="https://miro.medium.com/v2/resize:fit:1370/format:webp/1*0KfKcSGrc-h7y_FLPBK7dQ.png"/></div></figure><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="b2f2" class="ld js hh kz b fi le lf l lg lh">def OBV(df_price, df_volume):<br/>    OBV_df = pd.DataFrame(index=range(len(df_volume.index)), columns=['OBV'])<br/>    OBV_df.iloc[0] = 0<br/>    <br/>    for i in range(1, len(df_price)):<br/>        if df_price[i] &gt; df_price[i-1]:<br/>            OBV_df.loc[i] = (OBV_df.loc[i-1] + df_volume[i])<br/>        elif df_price[i] &lt; df_price[i-1]:<br/>            OBV_df.loc[i] = (OBV_df.loc[i-1] - df_volume[i])<br/>        else:<br/>            OBV_df.loc[i] = (OBV_df.loc[i-1] + 0)<br/>    <br/>    OBV_df.index = df_volume.index<br/>    return OBV_df<br/><br/># Apply the function to all tickers<br/>O = {}<br/>for n in AdjClose.columns:<br/>    O[f'{n}']= OBV(E[n], Volume[n])</span></pre><p id="865d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">图2显示了正常化的OBV和平滑调整后的AAPL收盘价。我们稍后会发现，OBV是模型中信息量最少的特征。</p><figure class="ku kv kw kx fd lj er es paragraph-image"><div class="er es lw"><img src="../Images/58693f061a85adec636409e2ea3a5b53.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*teRs-uq_7wNgu9uvoIBHjw.png"/></div><figcaption class="lr ls et er es lt lu bd b be z dx">Figure 2: OBV and Smoothed AdjClose (AAPL)</figcaption></figure><p id="341a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第二个指标是随机振荡器%K，它将平滑价格与给定时间段K内的高低价格范围进行比较。它用于生成超买和超卖交易信号，利用0-100的有界值范围。</p><figure class="ku kv kw kx fd lj er es paragraph-image"><div class="er es lx"><img src="../Images/30eafe887e4746d1b0d9aa6b51aa6dbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:742/format:webp/1*KOlDiEU_gL8QNDO8YHbFwA.png"/></div></figure><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="91e9" class="ld js hh kz b fi le lf l lg lh">def stochastic_oscillator(close, df_low, df_high, K):<br/>    low = df_low.rolling(K).min().reset_index(drop=True)<br/>    high = df_high.rolling(K).max().reset_index(drop=True)<br/>    <br/>    stoch_oscillator = pd.DataFrame()<br/>    stoch_oscillator['Oscillator'] = 100*((close - low)/(high - low))<br/>    <br/>    return stoch_oscillator<br/><br/># Apply the function to all tickers<br/>S = {}<br/>for n in AdjClose.columns:<br/>    S[f'{n}']= stochastic_oscillator(close=E[n], df_low=E[n], df_high=E[n], K=14)</span></pre><p id="032f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第三个也是最后一个指标是移动平均线收敛背离。这导致了两个特征。第一个是MACD，定义为12期均线和26期均线之差。第二个是MACD的信号，也就是MACD的9期均线。</p><figure class="ku kv kw kx fd lj er es paragraph-image"><div class="er es lx"><img src="../Images/a08478b2b2f357788b72270cf461dd35.png" data-original-src="https://miro.medium.com/v2/resize:fit:742/format:webp/1*1ZlsenRriWcqTqsArF79oQ.png"/></div></figure><figure class="ku kv kw kx fd lj er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es ly"><img src="../Images/bf74ed9a4247d9adf12d25d90cdd7ba8.png" data-original-src="https://miro.medium.com/v2/resize:fit:826/format:webp/1*-Rl3IG-60rBdithe7RduXw.png"/></div></div></figure><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="7766" class="ld js hh kz b fi le lf l lg lh">def MACD(data):<br/>    MA_Fast = data.ewm(span=12,min_periods=12).mean()<br/>    MA_Slow = data.ewm(span=26,min_periods=26).mean()<br/>    MACD = MA_Fast - MA_Slow<br/>    Signal = MACD.ewm(span=9,min_periods=9).mean()<br/><br/>    return pd.DataFrame(index=['MACD', 'Signal'], data [MACD,Signal]).T<br/><br/># Apply the function to all tickers<br/>M = {}<br/>for n in AdjClose.columns:<br/>    M[f'{n}'] = MACD(data=E[n])z</span></pre><p id="b45c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最后，我将所有变量连接在一个字典中。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="16e3" class="ld js hh kz b fi le lf l lg lh">dict_data = {}<br/>for n in AdjClose.columns:<br/>    dict_data[f'{n}'] = (pd.concat([E[n], <br/>                                    O[n].reset_index(drop=True), <br/>                                    S[n], <br/>                                    M[n]],<br/>                                   axis=1)).set_index(O[n].index)</span></pre><h1 id="e9d3" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">随机森林分类器</h1><p id="4d34" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">本文训练了一个随机森林分类器来预测股票方向。后者由一个二进制变量表示，如果股票价格在m期后下跌，取值为-1；如果股票价格上涨，取值为1。如果你想了解更多关于随机森林的知识，可以看看我的另一篇文章。</p><p id="be01" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">简而言之，随机森林是如图3所示的决策树的集合。树中的每个分裂都是为了优化一个使杂质最小化的标准，也就是说，它试图找到使模型尽可能明显地决定数据应该对应于特定类别的阈值。随机森林分类器由任意数量的树组成，这些树进行预测，获得更多投票的类被选为最终预测。</p><figure class="ku kv kw kx fd lj er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es lz"><img src="../Images/ff27f8b22d07e21ee0fb0bb33d5c09bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lqJYlcV-TAUmtG1ERXlZog.png"/></div></div><figcaption class="lr ls et er es lt lu bd b be z dx">Figure 3: Decision Tree Example</figcaption></figure><p id="5444" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在训练模型之前，应该使用以下逻辑将平滑价格转换为分类变量。</p><figure class="ku kv kw kx fd lj er es paragraph-image"><div class="er es ma"><img src="../Images/cb3c1cc2c90c42e4fcc05486040e14a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1072/format:webp/1*DCO1YAt3JSeWX61S6Itz2Q.png"/></div></figure><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="75be" class="ld js hh kz b fi le lf l lg lh">def finalise_data(DF, column, n):<br/>    df = copy.deepcopy(DF)<br/>    df[column][column] = np.sign(np.log(df[column][column]/df[column][column].shift(n-1)))<br/>    <br/>    return df[column]</span></pre><p id="30f6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，创建模型的一切都准备好了。这是使用Scikit-learn训练、测试和验证的。该模型拟合了从2000年1月6日到2016年4月25日的数据，其中80%用于训练，20%用于测试。2021年7月26日之前的剩余数据用于验证。用于评估预测的指标是准确度、精确度、召回率和f1_score。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="1688" class="ld js hh kz b fi le lf l lg lh">def RFClassifier(DF, column, n, validation=False, validation_DF=None, feature_importance=False):<br/>    data = finalise_data(DF=DF, column=column, n=n)<br/>    data.dropna(axis=0, inplace=True)<br/>    <br/>    X = data[['OBV', 'Oscillator', 'MACD', 'Signal']]<br/>    y = data[column]<br/>    <br/>    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)<br/>    model = RandomForestClassifier(n_estimators=100)<br/>    model.fit(X_train,y_train)<br/>    prediction= model.predict(X_test)<br/>    <br/>    Accuracy = metrics.accuracy_score(y_test, prediction)<br/>    Precision = metrics.average_precision_score(y_test, prediction)<br/>    Recall = metrics.recall_score(y_test, prediction)<br/>    F1_score = metrics.f1_score(y_test, prediction)<br/>    <br/>    if validation ==  True:<br/>        validation_data = finalise_data(DF=validation_DF, column=column, n=n)<br/>        validation_data.dropna(axis=0, inplace=True)<br/>        <br/>        X_validation = validation_data[['OBV', 'Oscillator', 'MACD', 'Signal']]<br/>        y_validation = validation_data[column]<br/>        validation_prediction = model.predict(X_validation)<br/>        <br/>        Accuracy_validation = metrics.accuracy_score(y_validation, validation_prediction)<br/>        Precision_validation = metrics.average_precision_score(y_validation, validation_prediction)<br/>        Recall_validation = metrics.recall_score(y_validation, validation_prediction)<br/>        F1_score_validation = metrics.f1_score(y_validation, validation_prediction)<br/>        <br/>        return n, column,Accuracy_validation, Precision_validation, Recall_validation, F1_score_validation<br/>    <br/>    elif feature_importance == True:<br/>        return pd.Series(model.feature_importances_,(X).columns)<br/>        <br/>    else:<br/>        return n, column, Accuracy, Precision, Recall, F1_score</span></pre><p id="215c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">该模型预测每个股票未来2到30天的走势。</p><p id="be4e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">验证集的总体结果如下:</p><figure class="ku kv kw kx fd lj er es paragraph-image"><div class="er es mb"><img src="../Images/073190b83d769c2159605d536f632ca4.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/format:webp/1*sKZ_DVc4nxkMXtvz7pLs_Q.png"/></div><figcaption class="lr ls et er es lt lu bd b be z dx">Figure 4: Validation Set Statistics</figcaption></figure><p id="80f2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们可以看到，所有报价机的平均准确率为0.90。查看每个n的结果，我们可以观察到预测线性提高，直到n=11，然后在由n=[11，12，13，14]组成的最佳表现区域波动，然后急剧下降到平均值约为0.90的值。</p><figure class="ku kv kw kx fd lj er es paragraph-image"><div class="er es lw"><img src="../Images/be939d1a46bcd1f1b045bedf1a54cb08.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*4QjYQFmR-eTZ_C3uET9izA.png"/></div><figcaption class="lr ls et er es lt lu bd b be z dx">Figure 5: Accuracy</figcaption></figure><p id="2cc3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">此外，调查变量的重要性表明，他们的解释能力随n变化。</p><figure class="ku kv kw kx fd lj er es paragraph-image"><div class="er es lw"><img src="../Images/4f951fa85fd794cd5e8dc93786c83cf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*tulezsSe_0EbePSUrXhzjA.png"/></div><figcaption class="lr ls et er es lt lu bd b be z dx">Figure 6: Feature Importances</figcaption></figure><p id="3e1d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在n = 18之前，随机振荡器是最有帮助的变量，在n = 18之后，它不断下降，最终成为最不具解释力的变量。相反，在短期内，MACD和OBV的预测能力大致相当，然而，它逐渐成为最有用的变量。MACD信号遵循具有较低幅度的类似路径。</p><h1 id="40c8" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">结论</h1><p id="22fd" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">这篇文章展示了训练、测试和验证一个随机森林模型的步骤，该模型用于预测8只股票的走向。所获得的结果是令人满意的，验证集的预测的平均准确度为90%。此外，该模型在预测未来13天的方向时达到了最高的精确度。</p></div></div>    
</body>
</html>