<html>
<head>
<title>Regression Tree From Scratch Using Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python从头开始构建回归树</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/regression-tree-from-scratch-using-python-a74dba2bba5f?source=collection_archive---------2-----------------------#2022-05-28">https://medium.com/mlearning-ai/regression-tree-from-scratch-using-python-a74dba2bba5f?source=collection_archive---------2-----------------------#2022-05-28</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="362c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这个故事中，我深入到回归树的主题及其基本的数学背景。我将尽可能简单地解释它，并从头开始使用python创建一个工作模型。</p><p id="e0fd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我将使用递归来创建树节点，所以如果你不熟悉的话，我建议你在网上看一些例子和解释(尽管我还是会简单解释一下它的逻辑)。</p></div><div class="ab cl jc jd go je" role="separator"><span class="jf bw bk jg jh ji"/><span class="jf bw bk jg jh ji"/><span class="jf bw bk jg jh"/></div><div class="ha hb hc hd he"><p id="abc5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jj">进口</em></p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="3b54" class="jt ju hh jp b fi jv jw l jx jy">import pandas as pd<br/>import numpy as np<br/>import matplotlib.pyplot as plt</span></pre><h2 id="2296" class="jt ju hh bd jz ka kb kc kd ke kf kg kh ip ki kj kk it kl km kn ix ko kp kq kr bi translated">创建数据</h2><p id="4038" class="pw-post-body-paragraph ie if hh ig b ih ks ij ik il kt in io ip ku ir is it kv iv iw ix kw iz ja jb ha bi translated">从创建一个数字数据开始，该数据将有一个自变量(x)和一个因变量(y)。使用numpy，我将向依赖值添加一个高斯噪声，数学上可以表示为</p><figure class="jk jl jm jn fd ky er es paragraph-image"><div class="er es kx"><img src="../Images/3f807e5fe0f8e42cd2ded9d620f55288.png" data-original-src="https://miro.medium.com/v2/resize:fit:222/format:webp/1*wFNzH0-Pi_9E0awveb0YmA.png"/></div></figure><p id="d52e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">其中<em class="jj"> 𝜖 </em>是噪音。</p><p id="636d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用numpy创建一个数据，我们可以计算因变量和添加噪声一步如下。</p><figure class="jk jl jm jn fd ky"><div class="bz dy l di"><div class="lb lc l"/></div></figure><figure class="jk jl jm jn fd ky er es paragraph-image"><div class="er es ld"><img src="../Images/dbb4100be5de5e654856495c9c0cec4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:754/format:webp/1*uKwmeQ5MRVjME2EjOckpvg.png"/></div></figure><h1 id="c9d2" class="le ju hh bd jz lf lg lh kd li lj lk kh ll lm ln kk lo lp lq kn lr ls lt kq lu bi translated">回归树</h1><h2 id="314e" class="jt ju hh bd jz ka kb kc kd ke kf kg kh ip ki kj kk it kl km kn ix ko kp kq kr bi translated">树形结构</h2><p id="fa18" class="pw-post-body-paragraph ie if hh ig b ih ks ij ik il kt in io ip ku ir is it kv iv iw ix kw iz ja jb ha bi translated">在回归树中，我们通过创建多个节点的树来预测数值数据，其中每个训练点都在一个节点中结束。下图显示了回归树的树结构示例，其中每个节点都有用于划分数据的阈值。</p><figure class="jk jl jm jn fd ky er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es lv"><img src="../Images/507800560d1ab0a4fa206fb80ff6aa46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*glSJ1VByIsIgD5s6HLMZ9A.png"/></div></div><figcaption class="ma mb et er es mc md bd b be z dx">Every node stores its threshold and predictions</figcaption></figure><p id="468e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">给定一组数据，输入值将到达叶子。到达节点m的X的所有输入值可以用X的子集来表示。数学上，让我们用一个函数来表示这种情况，如果给定的输入值到达节点m，该函数给出1，否则给出0。</p><figure class="jk jl jm jn fd ky er es paragraph-image"><div class="er es me"><img src="../Images/89ca740b29bbf914ad6fc1572ffc3aea.png" data-original-src="https://miro.medium.com/v2/resize:fit:426/format:webp/1*H9Uo_z2bCQ5FpOenYpa0_A.png"/></div></figure><h2 id="5964" class="jt ju hh bd jz ka kb kc kd ke kf kg kh ip ki kj kk it kl km kn ix ko kp kq kr bi translated">寻找分割数据的阈值</h2><p id="9895" class="pw-post-body-paragraph ie if hh ig b ih ks ij ik il kt in io ip ku ir is it kv iv iw ix kw iz ja jb ha bi translated">我们首先通过在每一步选取2个连续点来迭代经过排序的训练数据，并计算它们的平均值。我们计算的平均值是将数据一分为二的阈值。</p><p id="ad0f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们随机取一个阈值来考虑任何给定的情况。</p><figure class="jk jl jm jn fd ky"><div class="bz dy l di"><div class="lb lc l"/></div></figure><figure class="jk jl jm jn fd ky er es paragraph-image"><div class="er es ld"><img src="../Images/0f8cfc369999f3a57520c6b38d129a03.png" data-original-src="https://miro.medium.com/v2/resize:fit:754/format:webp/1*Sh1PfHUKA-_tSWk66RKvuQ.png"/></div><figcaption class="ma mb et er es mc md bd b be z dx">A random threshold value, with its and children node’s predictions</figcaption></figure><p id="3889" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">蓝色垂直线代表单个阈值，我们假设它是任何给定两点的平均值。稍后将使用它来划分数据。</p><p id="eb3e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们对该问题的第一个预测是所有训练数据(绿色水平线)的平均值(y轴)。2条红线是对将要创建的子节点的预测。</p><p id="ccbc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">虽然很明显，这些平均值都不能很好地代表我们的数据，但它显示了差异；主节点预测(绿线)获得所有训练数据的平均值，但我们将其分为2个子节点，这2个子节点有自己的预测(红线)，与绿线相比，这2个子节点更好地表示了其相应的训练数据。我们将不断地将数据分成2份，从每个节点创建2个子节点，直到达到给定的停止值，这是一个节点可以拥有的最小数据量。这被称为<em class="jj">预修剪</em>树，它提前停止树的构建过程。</p><p id="eb81" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">记住</strong>:如果我们继续分割直到我们达到一个单一值，它将创建一个过度拟合的场景，对于每个训练数据，它的预测将是它自己。</p><p id="198c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">剧透预警:</strong>模型完成后，不会使用根或任何中间节点预测任何值；它将使用回归树的叶子(将是树的最后节点)进行预测。</p><p id="7b02" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了获得最能代表给定阈值数据的阈值，我们使用<em class="jj">残差平方和</em>。它在数学上可以定义为</p><figure class="jk jl jm jn fd ky er es paragraph-image"><div class="er es mf"><img src="../Images/fd7651446eaea207eb2aaaf51a0743ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:554/format:webp/1*-Td7WqkEoIqjf5SY7uUwuw.png"/></div><figcaption class="ma mb et er es mc md bd b be z dx">Sum of squared residuals</figcaption></figure><p id="650e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们看看这一步是如何操作的。</p><figure class="jk jl jm jn fd ky er es paragraph-image"><div class="er es mg"><img src="../Images/a8e9be0d580cfe94a98f44e4f580c2b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*qNhThE_KVJcb2bQTQuTxNQ.gif"/></div><figcaption class="ma mb et er es mc md bd b be z dx">Animation code available below in appendix</figcaption></figure><p id="e2e1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">既然我们已经计算了阈值的SSR值，我们可以采用具有最小SSR值的阈值。该阈值将用于将训练数据分成两部分——低部分和高部分，其中低部分将用于创建<em class="jj">左</em>子节点，高部分将有助于创建<em class="jj">右</em>子节点。</p><figure class="jk jl jm jn fd ky"><div class="bz dy l di"><div class="lb lc l"/></div></figure><figure class="jk jl jm jn fd ky er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es mh"><img src="../Images/e16b4ced16f3809fffdd7357157995f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:676/format:webp/1*TFG3vI8uRgP97b8cuuKuYg.png"/></div></div></figure><p id="69a2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在进入下一步之前，我将使用pandas创建一个数据框架，并创建一个寻找最佳阈值的方法。所有这些步骤都可以在没有熊猫的情况下完成，使用它只是个人的选择。</p><figure class="jk jl jm jn fd ky"><div class="bz dy l di"><div class="lb lc l"/></div></figure><h2 id="27e6" class="jt ju hh bd jz ka kb kc kd ke kf kg kh ip ki kj kk it kl km kn ix ko kp kq kr bi translated">创建子节点</h2><p id="0246" class="pw-post-body-paragraph ie if hh ig b ih ks ij ik il kt in io ip ku ir is it kv iv iw ix kw iz ja jb ha bi translated">既然我们已经将数据一分为二，我们可以为低值和高值找到单独的阈值。尽管我们需要一个停止条件。因为对于每个节点，属于一个节点的数据集中的点变得更小，所以我们为每个节点定义最小数量的数据点。如果我们不这样做，每个节点将只使用1个训练值进行预测，导致过度拟合。</p><p id="0f82" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们可以递归地创建节点。为此，我们定义了一个名为TreeNode的类，它将存储节点应该存储的每个值。之后，我们首先创建根，同时计算它的阈值和预测值。然后我们递归地创建它的子节点，其中每个子节点类都存储为其父类的属性，或者命名为<em class="jj"> left </em>或者<em class="jj"> right </em>。</p><p id="2d27" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在create_nodes方法中，我们首先将给定的数据帧分成两部分；低和高，使用该节点的阈值。然后，我们检查是否有足够的数据点来使用相应的数据帧在单独的if条件下创建左右节点。如果有足够的数据点，我们计算它的数据帧的阈值，用它创建一个子节点，并使用这个新节点作为我们的树再次调用create_nodes方法。</p><figure class="jk jl jm jn fd ky"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="2dcc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">注意，这个方法在提供给它的第一棵树上进行修改，所以它不需要返回任何东西。</p><p id="f37d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">还要注意，虽然递归函数通常不是这样编写的(no <em class="jj"> return </em>)，但我们并不要求<em class="jj"> return </em>，因为当no <em class="jj"> if </em>语句被激活时，方法将返回自身。</p><p id="7653" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们现在可以检查这个树结构，看看它是否创建了一些节点来更好地适应数据。我将手动选择前2个节点及其对根阈值的预测。</p><figure class="jk jl jm jn fd ky"><div class="bz dy l di"><div class="lb lc l"/></div></figure><figure class="jk jl jm jn fd ky er es paragraph-image"><div class="er es ld"><img src="../Images/4cd9be1120beea60d2e6c26f200af107.png" data-original-src="https://miro.medium.com/v2/resize:fit:754/format:webp/1*YQxmrdxoLbq8kpIThHf6_A.png"/></div></figure><p id="d27c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们在这里看到两个预测:</p><ul class=""><li id="aa39" class="mi mj hh ig b ih ii il im ip mk it ml ix mm jb mn mo mp mq bi translated">第一个左侧节点对高值(高于其阈值)的预测</li><li id="319e" class="mi mj hh ig b ih mr il ms ip mt it mu ix mv jb mn mo mp mq bi translated">第一个右侧节点对低值(低于其阈值)的预测</li></ul><p id="c252" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我已经手动削减了预测线的宽度，这是因为如果给定的x值到达这些节点中的任何一个，它将由属于该节点的所有x值的平均值来表示，这也意味着没有其他x值参与该节点的预测(希望这有意义)。</p><p id="e43e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当然，这种树形结构比两个节点要深得多。事实上，我们可以通过如下调用它的子节点来检查一个特定的叶子。</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="9f30" class="jt ju hh jp b fi jv jw l jx jy">tree.left.right.left.left</span></pre><figure class="jk jl jm jn fd ky er es paragraph-image"><div class="er es mw"><img src="../Images/8dede20f3d2eeb03634b56a1b2e1d172.png" data-original-src="https://miro.medium.com/v2/resize:fit:624/format:webp/1*ortNB-fQApM6qH4tD99k7A.png"/></div></figure><p id="a440" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这当然意味着这里有一个向下4个孩子长的分支，但它可以在树的不同分支上更深。</p><h2 id="da07" class="jt ju hh bd jz ka kb kc kd ke kf kg kh ip ki kj kk it kl km kn ix ko kp kq kr bi translated">预测</h2><p id="24e9" class="pw-post-body-paragraph ie if hh ig b ih ks ij ik il kt in io ip ku ir is it kv iv iw ix kw iz ja jb ha bi translated">我们可以创建一个预测方法来预测任何给定值。</p><figure class="jk jl jm jn fd ky"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="109c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们在这里做的是通过比较每一片叶子的阈值和我们的输入来沿着树往下走。如果输入大于阈值，我们就转到右边的叶子，如果输入小于阈值，我们就转到左边，依此类推，直到我们到达任何一个<em class="jj">底部</em>叶子。最后，我们使用该节点自己的预测值进行预测，并最终与其阈值进行比较。</p><p id="bd81" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">用x = 3进行测试(实际值可以使用我们上面写的函数来计算，同时创建我们的数据。-3**2+3+5 = -1，这是期望值)，我们得到:</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="fe69" class="jt ju hh jp b fi jv jw l jx jy">predict(3)</span></pre><figure class="jk jl jm jn fd ky er es paragraph-image"><div class="er es mx"><img src="../Images/aa3979ef7f8fae02a17f7f9b1c544c1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:322/format:webp/1*5pGdSTFmkuHmu03q5uxVCw.png"/></div></figure><h2 id="6c7b" class="jt ju hh bd jz ka kb kc kd ke kf kg kh ip ki kj kk it kl km kn ix ko kp kq kr bi translated">计算误差</h2><p id="aa6c" class="pw-post-body-paragraph ie if hh ig b ih ks ij ik il kt in io ip ku ir is it kv iv iw ix kw iz ja jb ha bi translated">我们可以用相对平方误差</p><figure class="jk jl jm jn fd ky er es paragraph-image"><div class="er es my"><img src="../Images/893047e6df27d98eb2db9ca164c73c21.png" data-original-src="https://miro.medium.com/v2/resize:fit:486/format:webp/1*x-FAqvnAoZqHcwQ2HhUGvQ.png"/></div><figcaption class="ma mb et er es mc md bd b be z dx">Relative squared error</figcaption></figure><p id="9198" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">并使用相同的函数创建如上的验证数据。</p><figure class="jk jl jm jn fd ky"><div class="bz dy l di"><div class="lb lc l"/></div></figure><figure class="jk jl jm jn fd ky er es paragraph-image"><div class="er es mz"><img src="../Images/01f05d9c1add0a7d016d45187545055e.png" data-original-src="https://miro.medium.com/v2/resize:fit:422/format:webp/1*yGhQ9_JAX4Ftry9ZyXj7SA.png"/></div></figure><p id="1d7d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这可以说是一个小错误。</p><h2 id="38e0" class="jt ju hh bd jz ka kb kc kd ke kf kg kh ip ki kj kk it kl km kn ix ko kp kq kr bi translated">概括步骤</h2><figure class="jk jl jm jn fd ky er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es na"><img src="../Images/351d895c85ea58b1f48025a655bc1554.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xqfGe_ENJNWyQZZ-0PiLwQ.png"/></div></div></figure><h1 id="3625" class="le ju hh bd jz lf lg lh kd li lj lk kh ll lm ln kk lo lp lq kn lr ls lt kq lu bi translated">附录</h1><ol class=""><li id="7045" class="mi mj hh ig b ih ks il kt ip nb it nc ix nd jb ne mo mp mq bi translated">更适合回归树模型的数据</li></ol><p id="88a7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我选择的数据是一个多项式，它可以更好地拟合使用多项式回归模型。虽然我们可以很容易地看到一个数据集，其中回归树模型比标准回归效果好得多。让我把我们的新功能看作</p><figure class="jk jl jm jn fd ky er es paragraph-image"><div class="er es nf"><img src="../Images/c273c0b7d4ad73692e4ae7314b6f7587.png" data-original-src="https://miro.medium.com/v2/resize:fit:446/format:webp/1*inxBuijhRyQvYIrdSGyztQ.png"/></div></figure><p id="7fc8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">实施和可视化:</p><figure class="jk jl jm jn fd ky"><div class="bz dy l di"><div class="lb lc l"/></div></figure><figure class="jk jl jm jn fd ky er es paragraph-image"><div class="er es ng"><img src="../Images/bb4b8b8338517563bd8cc969315788df.png" data-original-src="https://miro.medium.com/v2/resize:fit:736/format:webp/1*2xbOYASTU7-4i8uKekZRKg.png"/></div></figure><p id="9e17" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我对这个数据集运行了上面所有相同的过程，得到的错误值为</p><figure class="jk jl jm jn fd ky er es paragraph-image"><div class="er es nh"><img src="../Images/d1ee500388e30cf5d68cbb61dadaaf6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:416/format:webp/1*tGyjbVmMMsSDta8hoZ0Hrg.png"/></div></figure><p id="5430" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">比我们从多项式数据中得到的误差要低。</p><p id="6708" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">2.动画情节的代码</p><figure class="jk jl jm jn fd ky"><div class="bz dy l di"><div class="lb lc l"/></div></figure><div class="ni nj ez fb nk nl"><a rel="noopener follow" target="_blank" href="/mlearning-ai/mlearning-ai-submission-suggestions-b51e2b130bfb"><div class="nm ab dw"><div class="nn ab no cl cj np"><h2 class="bd hi fi z dy nq ea eb nr ed ef hg bi translated">Mlearning.ai提交建议</h2><div class="ns l"><h3 class="bd b fi z dy nq ea eb nr ed ef dx translated">如何成为Mlearning.ai上的作家</h3></div><div class="nt l"><p class="bd b fp z dy nq ea eb nr ed ef dx translated">medium.com</p></div></div><div class="nu l"><div class="nv l nw nx ny nu nz kz nl"/></div></div></a></div></div></div>    
</body>
</html>