<html>
<head>
<title>Why you should be careful using FAISS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么你应该小心使用FAISS</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/why-you-should-be-careful-using-faiss-c44996eda9ee?source=collection_archive---------3-----------------------#2022-07-20">https://medium.com/mlearning-ai/why-you-should-be-careful-using-faiss-c44996eda9ee?source=collection_archive---------3-----------------------#2022-07-20</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/ae6ae289efc4e53fdfa3dc791009b17a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tOSrcEvFWQuETF8ISAo2gg.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">The image was generated using <a class="ae it" href="https://openai.com/dall-e-2/" rel="noopener ugc nofollow" target="_blank">DALL·E</a></figcaption></figure><p id="40fb" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi js translated">AISS(脸书的相似性搜索库)是来自脸书的一个非常有名的库，用于对非常大的数据集进行相似性搜索。由于搜索速度和GPU实现的可用性，这个库很有吸引力。</p><p id="6a0d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">然而，FAISS的优势并不是本文的主题。你可以在<a class="ae it" href="https://github.com/facebookresearch/faiss" rel="noopener ugc nofollow" target="_blank">官方文档</a>或者<a class="ae it" href="https://towardsdatascience.com/understanding-faiss-619bb6db2d1a" rel="noopener" target="_blank">这篇惊人的文章</a>中读到更多。</p><p id="18ec" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">今天，我想更深入地探讨一下基本FAISS指数的原理。当您需要使用<em class="kb">欧几里德距离</em>进行精确搜索时，该索引非常有用。这种类型的索引不会压缩或聚集你的向量。然而，它有一些特性可能会恶化你的体验。让我们看一个有趣的例子。</p><blockquote class="kc kd ke"><p id="87c8" class="iu iv kb iw b ix iy iz ja jb jc jd je kf jg jh ji kg jk jl jm kh jo jp jq jr ha bi translated">关于这些向量的一点历史。</p><p id="77fc" class="iu iv kb iw b ix iy iz ja jb jc jd je kf jg jh ji kg jk jl jm kh jo jp jq jr ha bi translated">在我工作的公司，我们有一个项目，我们一直致力于威胁检测和响应。所以最近我试图在已经标记的数据中找到相似的命令行来对不同的事件进行分组。但是，令人惊讶的是，我发现了一件奇怪的事情…</p></blockquote><p id="54e1" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">想象一下，我们有两个不同的向量，第一个在索引中，第二个在数组中，我们想和索引中的向量进行比较。</p><p id="07c3" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们详细解释一下我们的计划:</p><ol class=""><li id="56cc" class="ki kj hh iw b ix iy jb jc jf kk jj kl jn km jr kn ko kp kq bi translated">创建要写入索引的向量数组</li><li id="c934" class="ki kj hh iw b ix kr jb ks jf kt jj ku jn kv jr kn ko kp kq bi translated">创建向量数组以在索引向量中进行搜索</li><li id="f5bd" class="ki kj hh iw b ix kr jb ks jf kt jj ku jn kv jr kn ko kp kq bi translated">创建FAISS<strong class="iw hi">index flat 2</strong></li><li id="5a84" class="ki kj hh iw b ix kr jb ks jf kt jj ku jn kv jr kn ko kp kq bi translated">进行搜索并检查我们的结果</li></ol><h2 id="5a2f" class="kw kx hh bd ky kz la lb lc ld le lf lg jf lh li lj jj lk ll lm jn ln lo lp lq bi translated">1.创建要写入索引的向量数组</h2><p id="a543" class="pw-post-body-paragraph iu iv hh iw b ix lr iz ja jb ls jd je jf lt jh ji jj lu jl jm jn lv jp jq jr ha bi translated">正如我们之前注意到的，我们有两个不同的向量，其中一个在索引中。让我们声明第一个向量<code class="du lw lx ly lz b">a</code>，这里我们应该记住FAISS只处理<code class="du lw lx ly lz b">float32</code>数据并返回距离的平方。</p><blockquote class="kc kd ke"><p id="4ae3" class="iu iv kb iw b ix iy iz ja jb jc jd je kf jg jh ji kg jk jl jm kh jo jp jq jr ha bi translated">这个数组的前两个元素是两个值的类的数量，用<strong class="iw hi"> LabelEncoder </strong>编码。剩下的就是从<strong class="iw hi"> fastText </strong>中获取的字符串(<strong class="iw hi">C:\ Program Files(x86)\ Yandex \ Yandex browser \ Application \ browser . exe</strong>)的嵌入(有剪切，但不影响实验结果)。</p></blockquote><figure class="ma mb mc md fd ii"><div class="bz dy l di"><div class="me mf l"/></div></figure><p id="7096" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">仅仅使用<code class="du lw lx ly lz b">filecmdline</code>的向量并不重要。我们可以生成我们的<code class="du lw lx ly lz b">train</code>数组，然后加入向量<code class="du lw lx ly lz b">a</code>。</p><figure class="ma mb mc md fd ii"><div class="bz dy l di"><div class="me mf l"/></div></figure><h2 id="3ad8" class="kw kx hh bd ky kz la lb lc ld le lf lg jf lh li lj jj lk ll lm jn ln lo lp lq bi translated">2.创建向量数组以在索引向量中进行搜索</h2><p id="250a" class="pw-post-body-paragraph iu iv hh iw b ix lr iz ja jb ls jd je jf lt jh ji jj lu jl jm jn lv jp jq jr ha bi translated">声明第二个向量<code class="du lw lx ly lz b">b</code>。</p><blockquote class="kc kd ke"><p id="c78c" class="iu iv kb iw b ix iy iz ja jb jc jd je kf jg jh ji kg jk jl jm kh jo jp jq jr ha bi translated">这个向量的最后10个元素是从<strong class="iw hi"> fastText </strong>获得的字符串(<strong class="iw hi">c:\ windows \ explorer . exe</strong>)的嵌入。</p></blockquote><figure class="ma mb mc md fd ii"><div class="bz dy l di"><div class="me mf l"/></div></figure><p id="3f74" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">然后创建一个随机的<code class="du lw lx ly lz b">test</code>数组来进行相似性搜索。然后加入我们的向量<code class="du lw lx ly lz b">b</code>。</p><figure class="ma mb mc md fd ii"><div class="bz dy l di"><div class="me mf l"/></div></figure><h2 id="0f98" class="kw kx hh bd ky kz la lb lc ld le lf lg jf lh li lj jj lk ll lm jn ln lo lp lq bi translated">3.创建FAISS<strong class="ak">index flat 2</strong></h2><p id="5d23" class="pw-post-body-paragraph iu iv hh iw b ix lr iz ja jb ls jd je jf lt jh ji jj lu jl jm jn lv jp jq jr ha bi translated">这里我们创建了索引。我们使用IndexFlatL2。</p><figure class="ma mb mc md fd ii"><div class="bz dy l di"><div class="me mf l"/></div></figure><h2 id="b034" class="kw kx hh bd ky kz la lb lc ld le lf lg jf lh li lj jj lk ll lm jn ln lo lp lq bi translated">4.进行搜索并检查我们的结果</h2><p id="04d0" class="pw-post-body-paragraph iu iv hh iw b ix lr iz ja jb ls jd je jf lt jh ji jj lu jl jm jn lv jp jq jr ha bi translated">最后，搜索并检查我们的矢量<code class="du lw lx ly lz b">b</code>的结果。我们想要得到3个最近的向量，所以设置<code class="du lw lx ly lz b">k = 3</code>。</p><figure class="ma mb mc md fd ii"><div class="bz dy l di"><div class="me mf l"/></div></figure><p id="f6cd" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这里我们得到:</p><pre class="ma mb mc md fd mg lz mh mi aw mj bi"><span id="f9ac" class="kw kx hh lz b fi mk ml l mm mn">The 3 nearest indices for the vector b: [   0  758 7946]<br/>These distances are: [ 0.       52.73952  52.905334]</span></pre><p id="b66a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们看到最接近的向量是向量<code class="du lw lx ly lz b">a</code>(我们首先将它添加到<code class="du lw lx ly lz b">train</code>数组中)。但是距离为什么是<code class="du lw lx ly lz b">0.</code>？</p><h2 id="aa86" class="kw kx hh bd ky kz la lb lc ld le lf lg jf lh li lj jj lk ll lm jn ln lo lp lq bi translated">欧几里得距离</h2><p id="1198" class="pw-post-body-paragraph iu iv hh iw b ix lr iz ja jb ls jd je jf lt jh ji jj lu jl jm jn lv jp jq jr ha bi translated">让我们使用<code class="du lw lx ly lz b">scipy</code>来检查<em class="kb">欧几里德距离</em>:</p><figure class="ma mb mc md fd ii"><div class="bz dy l di"><div class="me mf l"/></div></figure><pre class="ma mb mc md fd mg lz mh mi aw mj bi"><span id="d0cb" class="kw kx hh lz b fi mk ml l mm mn">Euclidean distance between a and b: 0.0019346786430105567</span></pre><blockquote class="kc kd ke"><p id="dbd8" class="iu iv kb iw b ix iy iz ja jb jc jd je kf jg jh ji kg jk jl jm kh jo jp jq jr ha bi translated"><strong class="iw hi"> IndexFlatL2功能</strong></p><p id="2751" class="iu iv kb iw b ix iy iz ja jb jc jd je kf jg jh ji kg jk jl jm kh jo jp jq jr ha bi translated">当数组中有≥ 20个向量用于搜索时，FAISS使用另一个公式:d(x，y) = ||x|| + ||y|| — 2xy。</p><p id="90ac" class="iu iv kb iw b ix iy iz ja jb jc jd je kf jg jh ji kg jk jl jm kh jo jp jq jr ha bi translated">你可以找到更多的<a class="ae it" href="https://github.com/facebookresearch/faiss/issues/297" rel="noopener ugc nofollow" target="_blank">信息</a>。</p></blockquote><p id="84af" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们来看看:</p><figure class="ma mb mc md fd ii"><div class="bz dy l di"><div class="me mf l"/></div></figure><p id="1110" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">并且它返回<code class="du lw lx ly lz b">0.0</code>。</p><h1 id="d801" class="mo kx hh bd ky mp mq mr lc ms mt mu lg mv mw mx lj my mz na lm nb nc nd lp ne bi translated">为什么会这样？</h1><p id="7fd5" class="pw-post-body-paragraph iu iv hh iw b ix lr iz ja jb ls jd je jf lt jh ji jj lu jl jm jn lv jp jq jr ha bi translated">先说第一步:<code class="du lw lx ly lz b">a * a</code>。它给了我们</p><pre class="ma mb mc md fd mg lz mh mi aw mj bi"><span id="dfc4" class="kw kx hh lz b fi mk ml l mm mn">array([2.5000000e+01, 3.1360000e+03, 9.3236319e-10, 5.1964488e-08,<br/>       1.1749649e-08, 1.1432079e-08, 1.6719305e-07, 7.7145108e-09,<br/>       4.6266206e-07, 1.1049407e-07, 2.8362024e-09, 1.5480767e-08],<br/>      dtype=float32)</span></pre><p id="3a68" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">然后算出<code class="du lw lx ly lz b">sum()</code>。这里我们得到以下输出:</p><pre class="ma mb mc md fd mg lz mh mi aw mj bi"><span id="2d47" class="kw kx hh lz b fi mk ml l mm mn">3161.0</span></pre><p id="76cd" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在让我们逐个元素地计算总和:</p><figure class="ma mb mc md fd ii"><div class="bz dy l di"><div class="me mf l"/></div></figure><pre class="ma mb mc md fd mg lz mh mi aw mj bi"><span id="24a3" class="kw kx hh lz b fi mk ml l mm mn">25.0<br/>3161.0<br/>3161.0000000009322<br/>3161.0000000528967<br/>3161.0000000646464<br/>3161.0000000760783<br/>3161.000000243271<br/>3161.0000002509855<br/>3161.0000007136478<br/>3161.000000824142<br/>3161.000000826978<br/>3161.000000842459</span></pre><h2 id="e84c" class="kw kx hh bd ky kz la lb lc ld le lf lg jf lh li lj jj lk ll lm jn ln lo lp lq bi translated">Float32</h2><p id="08ae" class="pw-post-body-paragraph iu iv hh iw b ix lr iz ja jb ls jd je jf lt jh ji jj lu jl jm jn lv jp jq jr ha bi translated">为了找到问题的根源，我们需要记住如何将十进制数转换成浮点数。</p><figure class="ma mb mc md fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nf"><img src="../Images/93dbd6f66dbc3b2939ab581c4a2c30d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zmAcl0D_xilv22SwDWeiVg.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Image from the <a class="ae it" href="https://www.puntoflotante.net/FLOATING-POINT-FORMAT-IEEE-754.htm" rel="noopener ugc nofollow" target="_blank">puntoflotante.net</a></figcaption></figure><p id="2021" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们取第3个数<code class="du lw lx ly lz b">3161.0000000009322</code>换算成<code class="du lw lx ly lz b">float32</code>。</p><ol class=""><li id="fa14" class="ki kj hh iw b ix iy jb jc jf kk jj kl jn km jr kn ko kp kq bi translated">首先，我们需要将整数部分(<code class="du lw lx ly lz b">3161</code>)转换成二进制。这里我们会得到<code class="du lw lx ly lz b">110001011001</code>。s <em class="kb"> ign </em>等于<code class="du lw lx ly lz b">0</code>，因为数字是正数。在这种情况下，我们需要将小数点向左移动11位，使其以单个<code class="du lw lx ly lz b">1</code>开始，就像这样:<code class="du lw lx ly lz b">1.10001011001</code>。由于左移了11位，记录的<em class="kb">指数</em>等于<code class="du lw lx ly lz b">11</code>。<strong class="iw hi"> IEEE短实数</strong> (32位)指数存储为偏差为<code class="du lw lx ly lz b">127</code>的8位无符号整数。所以在这一步，我们需要将<code class="du lw lx ly lz b">127</code>加到上一步的归一化指数值上。而这一步的结果应该是<code class="du lw lx ly lz b">138</code> ( <code class="du lw lx ly lz b">11 + 127 = 138</code>)。将其转换成二进制，我们将得到<code class="du lw lx ly lz b">10001010</code>。因此，作为最终结果，我们将拥有<code class="du lw lx ly lz b">0 10001010 10001011001000000000000</code>。</li><li id="eb15" class="ki kj hh iw b ix kr jb ks jf kt jj ku jn kv jr kn ko kp kq bi translated">在下一步中，我们需要将分数转换成二进制。背后的数学很简单:我们应该继续乘以2，直到得到一个等于零的小数部分。所以这里我们会得到<code class="du lw lx ly lz b">00000000000000000000000000000100000000001...</code>。而且由于我们需要把它加到我们数的整数部分的<em class="kb">尾数</em>上，我们就得到<code class="du lw lx ly lz b">1000101100100000000000000000000000000000100000000001...</code>。我们记得<code class="du lw lx ly lz b">float32</code>对于<em class="kb">尾数</em>只有23位。这就是为什么我们需要将它限制为<code class="du lw lx ly lz b">10001011001000000000000</code>，这样我们就得到了<code class="du lw lx ly lz b">3161.0</code>。</li></ol><h1 id="af1a" class="mo kx hh bd ky mp mq mr lc ms mt mu lg mv mw mx lj my mz na lm nb nc nd lp ne bi translated">我们如何解决这个问题？</h1><p id="ac8c" class="pw-post-body-paragraph iu iv hh iw b ix lr iz ja jb ls jd je jf lt jh ji jj lu jl jm jn lv jp jq jr ha bi translated">你必须记住，FAISS使用的公式会在添加不同大小的浮点时导致灾难性的抵消。</p><p id="87f6" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">使用以下方法可以避免这种情况:</p><ul class=""><li id="0556" class="ki kj hh iw b ix iy jb jc jf kk jj kl jn km jr ng ko kp kq bi translated">制作批量&lt; 20</li></ul><figure class="ma mb mc md fd ii"><div class="bz dy l di"><div class="me mf l"/></div></figure><pre class="ma mb mc md fd mg lz mh mi aw mj bi"><span id="8381" class="kw kx hh lz b fi mk ml l mm mn">The 3 nearest indices for the vector b: [   0 4680 5188]<br/>These distances are: [1.9346786e-03 5.2794106e+01 5.2798298e+01]</span></pre><ul class=""><li id="d074" class="ki kj hh iw b ix iy jb jc jf kk jj kl jn km jr ng ko kp kq bi translated">Set  【T17】  equals to number of vectors inside your array + 1</li></ul><figure class="ma mb mc md fd ii"><div class="bz dy l di"><div class="me mf l"/></div></figure><pre class="ma mb mc md fd mg lz mh mi aw mj bi"><span id="85ce" class="kw kx hh lz b fi mk ml l mm mn">The 3 nearest indices for the vector b: [   0 1225 4361]<br/>These distances are: [1.9346786e-03 5.2317425e+01 5.2593662e+01]</span></pre><ul class=""><li id="dc5b" class="ki kj hh iw b ix iy jb jc jf kk jj kl jn km jr ng ko kp kq bi translated">We can also avoid it by using <em class="kb">双精度浮点格式(float64)。</em>然而，这里我们应该记住FAISS只适用于<em class="kb"> float32 </em>格式。所以我们需要编写自己的索引。</li><li id="757c" class="ki kj hh iw b ix kr jb ks jf kt jj ku jn kv jr ng ko kp kq bi translated">看起来，调整公式可能会让我们减少灾难性取消的数量。这里我们使用<em class="kb"> d(x，y) = ||x|| + ||y|| — 2xy </em>，但是我们也可以使用<em class="kb"> d(x，y) = ||x — xy||+||y — xy||。让我们试一试并检查输出:</em></li></ul><figure class="ma mb mc md fd ii"><div class="bz dy l di"><div class="me mf l"/></div></figure><pre class="ma mb mc md fd mg lz mh mi aw mj bi"><span id="ddb6" class="kw kx hh lz b fi mk ml l mm mn">0.0019346786</span></pre><p id="e6ff" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">因此，我们看到，通过使用<em class="kb">欧几里德距离</em>公式，我们得到了相同的结果。</p><p id="ba02" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在这里，我们看到这个意想不到的特性在研究过程中给我们带来了许多问题，甚至可能导致我们出错。这就是为什么没有什么比早期测试更好的了:)</p><p id="03dc" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果我忘记了什么，或者你对这篇文章有任何有价值的补充，请考虑在下面添加你的评论。</p></div><div class="ab cl nh ni go nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ha hb hc hd he"><h2 id="71e3" class="kw kx hh bd ky kz la lb lc ld le lf lg jf lh li lj jj lk ll lm jn ln lo lp lq bi translated">感谢您的阅读！</h2><p id="5e7f" class="pw-post-body-paragraph iu iv hh iw b ix lr iz ja jb ls jd je jf lt jh ji jj lu jl jm jn lv jp jq jr ha bi translated">我希望这篇文章的阅读对你和它的写作对我一样有用。如果你想联系我，请随时添加我的<a class="ae it" href="https://www.linkedin.com/in/ekrupenina/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>。</p><div class="no np ez fb nq nr"><a rel="noopener follow" target="_blank" href="/mlearning-ai/mlearning-ai-submission-suggestions-b51e2b130bfb"><div class="ns ab dw"><div class="nt ab nu cl cj nv"><h2 class="bd hi fi z dy nw ea eb nx ed ef hg bi translated">Mlearning.ai提交建议</h2><div class="ny l"><h3 class="bd b fi z dy nw ea eb nx ed ef dx translated">如何成为Mlearning.ai上的作家</h3></div><div class="nz l"><p class="bd b fp z dy nw ea eb nx ed ef dx translated">medium.com</p></div></div><div class="oa l"><div class="ob l oc od oe oa of in nr"/></div></div></a></div></div></div>    
</body>
</html>