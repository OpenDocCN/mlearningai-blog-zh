<html>
<head>
<title>Insurance Quote Conversion : Binary Classification Problem</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">保险报价转换:二元分类问题</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/insurance-quote-conversion-binary-classification-problem-554aa62d4c62?source=collection_archive---------0-----------------------#2021-04-28">https://medium.com/mlearning-ai/insurance-quote-conversion-binary-classification-problem-554aa62d4c62?source=collection_archive---------0-----------------------#2021-04-28</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/daf8c493a263d1175ce26bd82de0fab7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RjvOAlTDi_i9trBlNtgwrg.jpeg"/></div></div></figure><div class=""/><div class=""><h2 id="de45" class="pw-subtitle-paragraph ip hr hs bd b iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg dx translated">哪些客户会购买报价的保险计划？</h2></div><p id="b629" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这是一个过去的Kaggle竞赛，参与者面临的挑战是发现我们要联系的客户是否会接受或拒绝电话营销人员的报价。尽管这种情况下的数据集是由保险公司提供的，但这是一个适用于许多行业领域的一般性问题。基本上，如果我们有一个水晶球，并准确地知道谁将成为我们未来的客户，那么通过执行有针对性的优惠来分配营销预算和策略将非常容易。不幸的是，现实世界是混乱的，我们需要找到自己的路。</p><p id="8f99" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这就是机器学习模型可以帮助和指导我们的地方。在这篇文章中，我将通过在给定的数据上训练一个机器学习模型来分享我处理这个问题的方法。我会试着解释每一步为什么我会做出某个决定。</p><p id="1e59" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">在机器学习领域，在两个选择之间进行预测通常被称为监督二进制分类问题，在这种情况下，我们需要在积极和消极两种结果之间进行预测(客户转化或客户未转化)。</p><p id="8331" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated"><strong class="jj ht">数据集。和评估指标</strong></p><p id="efec" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">提供的数据集是一个巨大的260，000个样本，每个样本有299个特征。为了应对这一挑战，每个特征都被匿名化了。这阻止了创建任何有意义的特征。从问题陈述中，我意识到这个模型可能会以接近实时的方式部署，我们可能需要更快的预测，因此我决定建立一个具有最少特征和最大可能准确性的模型光模型。此外，提供的数据集是不平衡的，没有购买报价的人比购买报价的人多，因此我决定设置一个验证指标作为ROC-AUC得分。</p><figure class="ke kf kg kh fd hj er es paragraph-image"><div class="er es kd"><img src="../Images/d38417916cf6ef7ba5a3ff973d832f94.png" data-original-src="https://miro.medium.com/v2/resize:fit:722/format:webp/1*_eito-Nu8l7wfbvan-U3RQ.png"/></div><figcaption class="ki kj et er es kk kl bd b be z dx">AUC-ROC curve</figcaption></figure><p id="a887" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">AUC-ROC曲线是在各种阈值设置下对分类问题的性能测量。ROC是概率曲线，AUC代表可分性的程度或度量。它告诉我们这个模型在多大程度上能够区分不同的类。AUC越高，模型预测0为0和1为1的能力越强。以此类推，AUC越高，模型在区分两个类别方面就越好。随机模型的ROC-AUC得分为0.5，我们的目标应该是让模型的ROC-AUC得分为1。</p><p id="0907" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated"><strong class="jj ht">功能选择:</strong></p><p id="154c" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这是开发任何机器学习模型的重要一步。真实世界的数据杂乱而嘈杂。如果我们训练这样一个噪声数据的模型，我们很可能不会得到一个非常好的模型，所以过滤掉数据中的噪声非常重要。同样，我的目标是有一个快速的推理模型，因此从最少的特征中提取最多的信息是很重要的。从我的探索性数据分析中，我发现很少有列带有大量的空值，比如close 50% where null，所以我决定删除它们。很少有列只有一个值，所以我也删除了这样的列。</p><p id="1a81" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">在此之后，我开始实施以下特征选择策略。我决定从给定的299个特性中保留50个最佳特性和目标列。</p><ul class=""><li id="3585" class="km kn hs jj b jk jl jn jo jq ko ju kp jy kq kc kr ks kt ku bi translated"><strong class="jj ht">互信息:</strong>两个随机变量之间的互信息(MI)是非负值，它度量变量之间的依赖关系。当且仅当两个随机变量独立时，它等于零，更高的值意味着更高的依赖性。</li><li id="5212" class="km kn hs jj b jk kv jn kw jq kx ju ky jy kz kc kr ks kt ku bi translated"><strong class="jj ht">递归特征消除:</strong>给定一个给特征分配权重(例如，线性模型的系数)的外部估计器，递归特征消除(RFE)的目标是通过递归地考虑越来越小的特征集来选择特征。首先，在初始特征集上训练估计器，每个特征的重要性通过任何特定属性或可调用属性获得。然后，从当前特征集中删除最不重要的特征。该过程在删减集上递归重复，直到最终达到要选择的特征的期望数量。</li></ul><p id="1415" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">在经过缩小的列后，我决定将它们视为分类的，因为它们中的所有值都有差异，并且它们中的唯一值从2到26不等。</p><h1 id="5efa" class="la lb hs bd lc ld le lf lg lh li lj lk iy ll iz lm jb ln jc lo je lp jf lq lr bi translated">模型结构</h1><p id="b961" class="pw-post-body-paragraph jh ji hs jj b jk ls it jm jn lt iw jp jq lu js jt ju lv jw jx jy lw ka kb kc ha bi translated">看到问题的本质，我决定尝试逻辑回归作为我的基线模型和提升树算法之一，以击败我的基线分数。在三个著名的boosting算法实现中，我决定使用<a class="ae lx" href="https://github.com/microsoft/LightGBM" rel="noopener ugc nofollow" target="_blank"> LightGBM </a>，因为它训练速度更快，推理时内存效率更高。</p><p id="1500" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">对于逻辑回归，我不得不将我的50个特征转换成一个热编码，它创建了一个接近900列的稀疏矩阵，这需要很长时间来训练，也需要很长时间来预测。即使使用这样一个简单而低效的模型，我也能够使用5重交叉验证得到0.95的平均ROC-AUC分数。同样，由于数据集是不平衡的，我的5个折叠都是以相同的比例分层的。</p><p id="c916" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">梯度推进方法有许多参数要调整，如果不小心处理，可能会过度拟合数据集，并使用我们的模型泛化的错误图像。因此，我决定将数据分为训练集和验证集。我使用了<a class="ae lx" href="https://github.com/optuna/optuna" rel="noopener ugc nofollow" target="_blank"> Optuna </a>来调整my Light-GBM模型的超参数。Optuna是一个自动超参数优化软件框架，专门为机器学习而设计。它有一个命令式的，<em class="ly">运行定义</em>风格的用户API。用Optuna编写的代码具有高度的模块化，Optuna的用户可以动态地构造超参数的搜索空间。它还允许使用设置标准，以在几个时期后取消没有希望的优化运行，这允许使用搜索更大的超参数空间。</p><p id="cddf" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">在通过互信息获得的特征上运行和优化Light-GBM给了我0.93的ROC-AUC分数，而隐居特征消除(RFE)特征给了我0.9641的ROC-AUC分数。因为我能够击败我的逻辑回归基线，所以我决定在隐藏测试集上使用带有RFE选择特征的Light-GBM模型。</p><figure class="ke kf kg kh fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lz"><img src="../Images/82d908ea0269ded4486ec9528023e3b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pdxKVhpA5IXdHcMpmAPL8w.jpeg"/></div></div><figcaption class="ki kj et er es kk kl bd b be z dx">Pipeline code</figcaption></figure><p id="f02e" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">我实现了一个Sk-learn管道，能够处理在训练集中没有遇到的特性。这将防止模型在生产中遇到未知值时被破坏。上图显示了在训练和验证中拆分数据的代码行，然后通过管道传递训练数据，然后对保留数据集的验证进行预测。</p><p id="6edf" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">我能够得到0.962的私人测试集分数，这非常接近我的训练集分数0.9641</p><p id="0c2d" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated"><strong class="jj ht">点改进模型</strong></p><p id="0c19" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">我决定去掉一个日期栏。但是在我的下一次迭代中，我计划在它的基础上创建更多的特性，并安装同样的轻型GBM模型，看看它是否能增加我的分数</p><p id="11ae" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated"><strong class="jj ht">最终模型实现</strong> : <a class="ae lx" href="https://www.kaggle.com/sumeetsawant/insurance-quote-xgboost-and-pipeline-auc-0-9627" rel="noopener ugc nofollow" target="_blank">链接到我的笔记本</a></p><p id="d906" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated"><strong class="jj ht">笔记本显示EDA和优化上述代码</strong>:将很快添加到这个职位</p><p id="a220" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">如果你觉得这个帖子有用，请给它投票。</p><p id="5fc8" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">关注我:<a class="ae lx" href="https://www.linkedin.com/in/sawantsumeet/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a></p></div></div>    
</body>
</html>