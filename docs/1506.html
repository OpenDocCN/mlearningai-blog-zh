<html>
<head>
<title>The Unreasonable Effectiveness of Training With Jitter (i.e, How to Reduce Overfitting)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">抖动训练的不合理效果(例如，如何减少过度拟合)</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/the-unreasonable-effectiveness-of-training-with-jitter-i-e-how-to-reduce-overfitting-2aaefc3cbfa9?source=collection_archive---------7-----------------------#2021-12-27">https://medium.com/mlearning-ai/the-unreasonable-effectiveness-of-training-with-jitter-i-e-how-to-reduce-overfitting-2aaefc3cbfa9?source=collection_archive---------7-----------------------#2021-12-27</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="2646" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在许多情况下，我们从一个小数据集学习，一个过度拟合的模型是一个可能的结果。我们的意思是，该模型可能在训练数据上表现良好，但不能很好地推广到测试数据。</p><p id="6cfb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这篇文章中，我们强调了一个简单而有效的方法来减少过度拟合。对于没有耐心的人，<a class="ae jc" href="https://github.com/aurotripathy/training-with-noise-reduces-overfitting" rel="noopener ugc nofollow" target="_blank">请直接进入代码</a>。</p><h2 id="6410" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">数据集</h2><p id="433f" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">我们的数据集只有31个二维点，平均分布在两个类中。我在拉塞尔·里德的开创性著作《T4神经锻造》(第282页)中偶然发现了这个数据集。据我所知，互联网上没有这些数据，所以我不得不手工重新创建(用尺子和铅笔工作很有趣)。请看下面我的作品。这两个类别由“+”和“o”符号表示。</p><figure class="kf kg kh ki fd kj er es paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="er es ke"><img src="../Images/f1130cf018280bf8a27c8039ad0ae6b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*468I-E-3gdNlYiu-"/></div></div></figure><p id="5603" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">从模拟域(纸张)到数字域(文件)的转换给了我们分布在两个类中的31个点。</p><figure class="kf kg kh ki fd kj er es paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="er es kq"><img src="../Images/61ad70aa5b3a7587fedadca4d45fbd50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Wva7dPo9kHjVlkhZ"/></div></div></figure><h1 id="13f0" class="kr je hh bd jf ks kt ku jj kv kw kx jn ky kz la jq lb lc ld jt le lf lg jw lh bi translated">模型</h1><p id="7fd4" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">该模型是一个非常简单的2/50/10/1多层感知器(MLP)网络，与Russell Reed的书中使用的相同。注意，我已经(无意中)切换了隐藏层；到<code class="du li lj lk ll b">2/10/50/1</code>而不是<code class="du li lj lk ll b">2/50/10/1</code>，这可能是决策边界看起来与书中相似的原因。</p><p id="f115" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">该模型如下图所示。</p><figure class="kf kg kh ki fd kj"><div class="bz dy l di"><div class="lm ln l"/></div></figure><h1 id="d5a0" class="kr je hh bd jf ks kt ku jj kv kw kx jn ky kz la jq lb lc ld jt le lf lg jw lh bi translated">被训练成故意过度适应</h1><p id="c58a" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">按照Russell Reed的说法，“拥有671个权重，但只有31个训练点，网络的约束非常不足，选择了一个非常非线性的边界”。事实确实如此，正如你在下面看到的。</p><figure class="kf kg kh ki fd kj er es paragraph-image"><div class="er es lo"><img src="../Images/3f60bb129374dc5f5e38a6e5fc956360.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/0*E9z2aTTOYOxrAfIC"/></div></figure><h1 id="4f3a" class="kr je hh bd jf ks kt ku jj kv kw kx jn ky kz la jq lb lc ld jt le lf lg jw lh bi translated">抖动平滑</h1><p id="484b" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">根据这本书，“使用抖动数据进行训练会阻止训练点附近响应的急剧变化，从而阻止网络出现过于复杂的边界。”按照书中的指导，我们不改变任何训练超参数，除了在训练期间，我们在将数据输入网络时抖动数据。</p><p id="5bd9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">抖动输入的功能如下所示。</p><figure class="kf kg kh ki fd kj"><div class="bz dy l di"><div class="lm ln l"/></div></figure><p id="19b7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们注意到，对于相同的时期数和相同的批量大小(实际上，相同的超参数)，训练机制无法在贫乏的数据集上过度拟合(无论我们如何努力)。</p><figure class="kf kg kh ki fd kj er es paragraph-image"><div class="er es lo"><img src="../Images/6475623f145d23b35cdf9c7975c192ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/0*w-qRuKWoz5Xevzl9"/></div></figure><h1 id="b79f" class="kr je hh bd jf ks kt ku jj kv kw kx jn ky kz la jq lb lc ld jt le lf lg jw lh bi translated">摘要</h1><p id="fc1b" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">总而言之，通过向输入数据添加少量抖动，我们从左侧的有意过拟合情形转向了右侧的更一般情形。</p><figure class="kf kg kh ki fd kj er es paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="er es lp"><img src="../Images/429c2661f64cc5cc9022712f96692ce8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*kh-fXYzALB4yDOqw.png"/></div></div></figure><h1 id="a402" class="kr je hh bd jf ks kt ku jj kv kw kx jn ky kz la jq lb lc ld jt le lf lg jw lh bi translated">代码，重复我的结果，和进一步的实验</h1><p id="e0ae" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">代码<a class="ae jc" href="https://github.com/aurotripathy/training-with-noise-reduces-overfitting" rel="noopener ugc nofollow" target="_blank"> repo </a>有两个脚本，classify.py和utils.py。默认模式是简单地在小数据集上训练一个分类器，故意过度拟合(输入数据中没有抖动)。</p><pre class="kf kg kh ki fd lq ll lr ls aw lt bi"><span id="a557" class="jd je hh ll b fi lu lv l lw lx">python3 classify.py</span></pre><p id="e4be" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">训练产生决策边界图<code class="du li lj lk ll b">Known-Overfit.png</code>。</p><p id="8b9d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">要抖动输入，请键入:</p><pre class="kf kg kh ki fd lq ll lr ls aw lt bi"><span id="bf82" class="jd je hh ll b fi lu lv l lw lx">python3 classify.py  --jitter</span></pre><p id="1789" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">抖动训练产生了判定边界图<code class="du li lj lk ll b">Noise-Added-to-Smooth-boundary.png</code>。</p><h1 id="c3ff" class="kr je hh bd jf ks kt ku jj kv kw kx jn ky kz la jq lb lc ld jt le lf lg jw lh bi translated">参考</h1><p id="19f1" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated"><em class="kd">神经锻造:前馈人工神经网络中的监督学习(Bradford图书)图解版，</em>Russell Reed著</p><div class="ly lz ez fb ma mb"><a rel="noopener follow" target="_blank" href="/mlearning-ai/mlearning-ai-submission-suggestions-b51e2b130bfb"><div class="mc ab dw"><div class="md ab me cl cj mf"><h2 class="bd hi fi z dy mg ea eb mh ed ef hg bi translated">Mlearning.ai提交建议</h2><div class="mi l"><h3 class="bd b fi z dy mg ea eb mh ed ef dx translated">如何成为Mlearning.ai上的作家</h3></div><div class="mj l"><p class="bd b fp z dy mg ea eb mh ed ef dx translated">medium.com</p></div></div><div class="mk l"><div class="ml l mm mn mo mk mp ko mb"/></div></div></a></div></div></div>    
</body>
</html>