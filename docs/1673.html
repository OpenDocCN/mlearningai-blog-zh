<html>
<head>
<title>Reusable Python Functions in my repo to quickly develop any Machine Learning Models</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我的repo中的可重用Python函数可以快速开发任何机器学习模型</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/reusable-python-functions-in-my-repo-to-quickly-develop-any-machine-learning-models-7b9a3db0aef3?source=collection_archive---------4-----------------------#2022-01-18">https://medium.com/mlearning-ai/reusable-python-functions-in-my-repo-to-quickly-develop-any-machine-learning-models-7b9a3db0aef3?source=collection_archive---------4-----------------------#2022-01-18</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="4b06" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一次建成多次使用</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/cf3e6a516ab9e838e99a582903776486.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vxhk6aPz0806HAarOIAqqw.png"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Build Once Use Many</figcaption></figure><p id="49ff" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi js translated"><span class="l jt ju jv bm jw jx jy jz ka di"> W </span>在执行任何端到端数据科学项目时，任何<em class="kb">数据科学专业人员或学生</em>都必须主要关注问题定义、数据收集、数据调查、清理、统计和可视化分析、特征工程、决策和模型构建。在一个数据科学项目的整个<em class="kb">周期中，一个<em class="kb"> </em>不应该投入太多时间的一个步骤就是编写构建任何ML模型的代码。</em></p><p id="de56" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">本文假设读者已经很好地理解了ML模型以及如何使用python中的“scikit-learn(<a class="ae kc" href="https://scikit-learn.org/stable/" rel="noopener ugc nofollow" target="_blank"><em class="kb">sk learn</em></a><em class="kb">)</em>”库来构建/实现它们。这是关于使我们的代码可重用，以便我们可以开发任何模型，而不用浪费太多时间编码，并避免编写重复的代码。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es kd"><img src="../Images/8eca4dfb4e0a3cc444dd8941c70597a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:450/format:webp/1*g_gq3URorsYZpVZlbRRl8A.png"/></div><figcaption class="jo jp et er es jq jr bd b be z dx">Always try to write reusable codes wherever possible</figcaption></figure><p id="c911" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在对给定数据集进行 <a class="ae kc" href="https://en.wikipedia.org/wiki/Exploratory_data_analysis#:~:text=In+statistics%2C+exploratory+data+analysis,and+other+data+visualization+methods." rel="noopener ugc nofollow" target="_blank"> <em class="kb">探索性数据分析</em> </a> <em class="kb">的漫长而必要的<em class="kb">过程之后，我们使用<strong class="ig hi"> train_test_split将数据集(<em class="kb"> X —自变量，y —目标变量)</em>拆分成训练集和测试集。</strong>现在我们有4个由函数返回的变量— <em class="kb"> X_train、X_test、y_train和y_test。</em></em></em></p><pre class="jd je jf jg fd ke kf kg kh aw ki bi"><span id="ebd7" class="kj kk hh kf b fi kl km l kn ko">from sklearn.model_selection import train_test_split</span><span id="ecea" class="kj kk hh kf b fi kp km l kn ko">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.25, random_state=0)</span><span id="545d" class="kj kk hh kf b fi kp km l kn ko">print(X_train.shape)<br/>print(y_train.shape)</span><span id="23ed" class="kj kk hh kf b fi kp km l kn ko">print(X_test.shape)<br/>print(y_test.shape)</span></pre><p id="ac6b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">注</strong>:所有的<em class="kb">特征工程和特征选择</em>过程都应该在下面给出的步骤之前进行。</p><p id="f5b6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了实现任何ML模型，我在我的代码库中保存了以下函数，我重用这些函数来开发任何cl <em class="kb">辅助器</em>或<em class="kb">回归器</em>模型。</p><h2 id="dc6b" class="kj kk hh bd kq kr ks kt ku kv kw kx ky ip kz la lb it lc ld le ix lf lg lh li bi translated"><strong class="ak"> <em class="lj">代码片段1 </em> </strong> <em class="lj"> : </em></h2><p id="9e7c" class="pw-post-body-paragraph ie if hh ig b ih lk ij ik il ll in io ip lm ir is it ln iv iw ix lo iz ja jb ha bi translated"><strong class="ig hi"> <em class="kb">初始化数据帧以存储和比较模型的性能指标。</em>T45】</strong></p><p id="b2ce" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我用下面的代码片段将模型性能分数存储在一个数据框中，以便在预测后比较不同的模型。</p><pre class="jd je jf jg fd ke kf kg kh aw ki bi"><span id="7c44" class="kj kk hh kf b fi kl km l kn ko"><strong class="kf hi"><em class="kb"> # For Classifier</em></strong></span><span id="fd23" class="kj kk hh kf b fi kp km l kn ko">import pandas as pd<br/>import numpy as np</span><span id="2c36" class="kj kk hh kf b fi kp km l kn ko">#This dataframe stores the scores from classifier models<br/>df_model=pd.DataFrame(columns=['Model','Accuracy Score' ,'F1 Score', 'Precision Score' , 'Recall Score' ,'ROC AUC'])<br/><strong class="kf hi">df_model_performance </strong>=df_model</span><span id="b347" class="kj kk hh kf b fi kp km l kn ko">#This dataframe stores the train and test accuracy from classifier models to compare at the end of the model building. This can also be further modified to compare the other scores such as F1 score etc<br/>df_model_test_train_acc = pd.DataFrame(columns=['Model' , 'Train Accuracy Score' ,'Test Accuracy Score'])<br/><strong class="kf hi">df_model_accuracy </strong>=df_model_test_train_acc</span></pre></div><div class="ab cl lp lq go lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ha hb hc hd he"><pre class="ke kf kg kh aw ki bi"><span id="696f" class="kj kk hh kf b fi lw lx ly lz ma km l kn ko"><strong class="kf hi"><em class="kb"># For Regressor</em></strong></span><span id="da73" class="kj kk hh kf b fi kp km l kn ko">import pandas as pd<br/>import numpy as np</span><span id="aa7d" class="kj kk hh kf b fi kp km l kn ko">#This dataframe stores the scores from regressor models<br/>df_model=pd.DataFrame(columns=['Model', 'MAE' ,'RMSE', 'R2 Score' , 'Adjusted R2 Score'])<br/><strong class="kf hi">df_model_performance </strong>=df_model</span><span id="d623" class="kj kk hh kf b fi kp km l kn ko">#This data frame stores the train and test "adjusted R2 scores" from regressor models to compare at the end of the model building. This can also be further modified to compare the other score such as MSE , RMSE  etc<br/>df_model_test_train_r2 = pd.DataFrame(columns=['Model' , 'Train Adjusted R2 Score' ,'Test Adjusted R2 Score'])<br/><strong class="kf hi">df_model_r2 </strong>=df_model_test_train_r2</span></pre><h2 id="9795" class="kj kk hh bd kq kr ks kt ku kv kw kx ky ip kz la lb it lc ld le ix lf lg lh li bi translated">代码片段<em class="lj"> 2 : </em></h2><p id="b4fb" class="pw-post-body-paragraph ie if hh ig b ih lk ij ik il ll in io ip lm ir is it ln iv iw ix lo iz ja jb ha bi translated"><strong class="ig hi"> <em class="kb">功能通过使用</em></strong><a class="ae kc" href="https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.GridSearchCV.html" rel="noopener ugc nofollow" target="_blank"><strong class="ig hi"><em class="kb">GridSearchCV</em></strong></a><strong class="ig hi"><em class="kb">执行超参数调整来获得最佳模型。</em> </strong></p><p id="9e94" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我定义了一个函数"<strong class="ig hi">get _ best _ hyperparameters "</strong>，它通过将分类器或回归器模型作为输入，使用GridSearchCV进行超参数调整。此函数返回可用于拟合和预测的最佳模型。如果只想构建一个基本模型而不执行任何超参数调整，可以跳过这一步。</p><pre class="jd je jf jg fd ke kf kg kh aw ki bi"><span id="0cc4" class="kj kk hh kf b fi kl km l kn ko"><strong class="kf hi"><em class="kb"># For both Classifier and Regressor</em></strong></span><span id="efe6" class="kj kk hh kf b fi kp km l kn ko">from sklearn.model_selection import GridSearchCV <br/><strong class="kf hi">def get_best_hyperparameters</strong>(model, params, cv_value , X_train, y_train ): <br/>    search = GridSearchCV(estimator=model, param_grid=params, n_jobs=-1, verbose=1,cv=cv_value) <br/>    search.fit(X_train, y_train)  <br/>    print("Best Accuracy    :",  search.best_score_) <br/>    print("Best Parameters  : ", search.best_params_)<br/>    print("Best Estimators : ",  search.best_estimator_)  <br/>    best_grid = search.best_estimator_<br/>    <strong class="kf hi">return </strong>best_grid</span></pre><h2 id="a9de" class="kj kk hh bd kq kr ks kt ku kv kw kx ky ip kz la lb it lc ld le ix lf lg lh li bi translated">代码片段3:</h2><p id="442a" class="pw-post-body-paragraph ie if hh ig b ih lk ij ik il ll in io ip lm ir is it ln iv iw ix lo iz ja jb ha bi translated"><strong class="ig hi"> <em class="kb">函数拟合和预测模型:</em> </strong></p><p id="3895" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">此函数(用于分类器和回归器)<strong class="ig hi">get _ classifier _ predictions/get _ regressor _ predictions</strong>将模型作为输入，并返回预测的训练和测试结果。在分类器的情况下，它还返回预测的训练和测试概率。</p><pre class="jd je jf jg fd ke kf kg kh aw ki bi"><span id="9374" class="kj kk hh kf b fi kl km l kn ko"><strong class="kf hi"><em class="kb">#For Classifier</em></strong></span><span id="cdc9" class="kj kk hh kf b fi kp km l kn ko"><strong class="kf hi">def get_classifier_predictions</strong>(classifier, X_train, y_train, X_test): <br/>    classifier.fit(X_train,y_train)<br/>    y_pred_train =classifier.predict(X_train)<br/>    y_pred_test = classifier.predict(X_test)<br/>    y_pred_prob_train = classifier.predict_proba(X_train)<br/>    y_pred_prob_test = classifier.predict_proba(X_test)<br/>    <strong class="kf hi">return </strong>y_pred_train, y_pred_test, y_pred_prob_train,y_pred_prob_test</span></pre></div><div class="ab cl lp lq go lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ha hb hc hd he"><pre class="ke kf kg kh aw ki bi"><span id="b650" class="kj kk hh kf b fi lw lx ly lz ma km l kn ko"><strong class="kf hi"><em class="kb">#For Regressor</em></strong></span><span id="cb01" class="kj kk hh kf b fi kp km l kn ko"><strong class="kf hi">def get_regressor_predictions</strong>(regressor, X_train, y_train, X_test):  <br/>    regressor.fit(X_train,y_train)<br/>    y_pred_train =regressor.predict(X_train)<br/>    y_pred_test = regressor.predict(X_test)<br/>    <strong class="kf hi">return </strong>y_pred_train, y_pred_test</span></pre><h2 id="f683" class="kj kk hh bd kq kr ks kt ku kv kw kx ky ip kz la lb it lc ld le ix lf lg lh li bi translated">代码片段4:</h2><p id="d421" class="pw-post-body-paragraph ie if hh ig b ih lk ij ik il ll in io ip lm ir is it ln iv iw ix lo iz ja jb ha bi translated"><strong class="ig hi"> <em class="kb">函数计算并打印训练和测试数据集的性能指标</em> </strong></p><p id="8600" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">函数<strong class="ig hi">print _ classifier _ scores/print _ regressor _ scores</strong>计算并返回分别与分类/回归算法相关的所有性能指标分数的数据集。</p><pre class="jd je jf jg fd ke kf kg kh aw ki bi"><span id="b41e" class="kj kk hh kf b fi kl km l kn ko"><strong class="kf hi"><em class="kb"># For Classifier</em></strong></span><span id="690a" class="kj kk hh kf b fi kp km l kn ko">from sklearn.metrics import accuracy_score ,confusion_matrix ,precision_score , recall_score , f1_score, plot_confusion_matrix ,roc_auc_score<br/>import matplotlib.pyplot as plt                                     # Importing pyplot interface to use matplotlib<br/>%matplotlib inline</span><span id="31b2" class="kj kk hh kf b fi kp km l kn ko"><strong class="kf hi">def print_classifier_scores</strong>(classifier, X_train, X_test, y_train ,y_test,y_pred_train, y_pred_test,y_pred_prob_train, y_pred_prob_test,algorithm):<br/># store classifier scores for Training Dataset<br/>    v_recall_score_train =  recall_score(y_train,y_pred_train)<br/>    v_precision_score_train = precision_score(y_train,y_pred_train)<br/>    v_f1_score_train =  f1_score(y_train,y_pred_train)<br/>    v_accuracy_score_train = accuracy_score(y_train,y_pred_train)<br/>    v_roc_auc_train = roc_auc_score(y_train, y_pred_prob_train[:,1])<br/>    <br/># print classifier scores for Training Dataset<br/>    print('Train-Set Confusion Matrix:\n', confusion_matrix(y_train,y_pred_train)) <br/>    print("Recall Score    : ", v_recall_score_train)<br/>    print("Precision Score : ", v_precision_score_train)<br/>    print("F1 Score        : ", v_f1_score_train)<br/>    print("Accuracy Score  : ", v_accuracy_score_train)<br/>    print("ROC AUC         :  {}".format(v_roc_auc_train))<br/>    print("Predict Probability  :" , y_pred_prob_train)<br/>    plot_confusion_matrix(classifier, X_train , y_train , display_labels = ["1" , "0"])<br/>    plt.grid(b=None)<br/># store classifier scores for Testing Dataset <br/>   <br/>    v_recall_score_test =  recall_score(y_test,y_pred_test)<br/>    v_precision_score_test = precision_score(y_test,y_pred_test)<br/>    v_f1_score_test =  f1_score(y_test,y_pred_test)<br/>    v_accuracy_score_test = accuracy_score(y_test,y_pred_test)<br/>    v_roc_auc_test = roc_auc_score(y_test, y_pred_prob_test[:,1])<br/># Print classifier scores for Testing Dataset    <br/>    print('Test-Set Confusion Matrix:\n', confusion_matrix(y_test,y_pred_test)) <br/>    print("Recall Score    : ", v_recall_score_test)<br/>    print("Precision Score : ", v_precision_score_test)<br/>    print("F1 Score        : ", v_f1_score_test)<br/>    print("Accuracy Score  : ", v_accuracy_score_test)<br/>    print("ROC AUC         :  {}".format(v_roc_auc_test))<br/>    print("Predict Probability  :" , y_pred_prob_test)<br/>    plot_confusion_matrix(classifier, X_test , y_test , display_labels = ["1" , "0"])<br/>    plt.grid(b=None)<br/># store to append the results in dataframe for final comparison of performance <br/>    df_model_test_train_acc = dict({'Model' : algorithm, 'Train Accuracy Score' :v_accuracy_score_train,'Test Accuracy Score' :v_accuracy_score_test })<br/>    df_model_performance = dict({'Model' : algorithm, 'Accuracy Score' :v_accuracy_score_test, 'F1 Score' : v_f1_score_test, 'Precision Score' : v_precision_score_test, 'Recall Score' :v_recall_score_test, 'ROC AUC' : v_roc_auc_test})<br/>    <br/>    <strong class="kf hi">return </strong>df_model_test_train_acc , df_model_performance</span></pre></div><div class="ab cl lp lq go lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ha hb hc hd he"><pre class="ke kf kg kh aw ki bi"><span id="a513" class="kj kk hh kf b fi lw lx ly lz ma km l kn ko"><strong class="kf hi"># For regressor </strong></span><span id="b247" class="kj kk hh kf b fi kp km l kn ko">from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score<br/><strong class="kf hi">def print_regressor_scores</strong>(regressor, X_train, X_test, y_train ,y_test,y_pred_train, y_pred_test,algorithm):<br/>    <br/>    # store regressor scores for Training Dataset<br/>    MAE_train = mean_absolute_error(y_train, y_pred_train)<br/>    RMSE_train = np.sqrt( mean_squared_error(y_train, y_pred_train))<br/>    r2_score_train = r2_score(y_train, y_pred_train)<br/>    # Calculating Adjusted R2 for training set<br/>    SS_Residual_train = sum((y_train-y_pred_train)**2)<br/>    SS_Total_train = sum((y_train-np.mean(y_train))**2)<br/>    r_squared_train = 1 - (float(SS_Residual_train))/SS_Total_train<br/>    adj_r_sq_train = 1 - (1-r_squared_train)*(len(y_train)-1)/(len(y_train)-X_train.shape[1]-1)<br/>    <br/>    # print regressor scores for Training Dataset<br/>    print('MAE for training set is {}'.format(MAE_train))<br/>    print('RMSE for training set is {}'.format(RMSE_train))<br/>    print('R squared score for training set is {}'.format(r2_score_train))<br/>    print('Adjusted R squared score for training set is {}'.format(adj_r_sq_train))<br/>    <br/>    # store regressor scores for Test Dataset<br/>    MAE_test = mean_absolute_error(y_test, y_pred_test)<br/>    RMSE_test = np.sqrt(mean_squared_error(y_test, y_pred_test))<br/>    r2_score_test = r2_score(y_test, y_pred_test)<br/>    # Calculating Adjusted R2 for test set<br/>    SS_Residual_test = sum((y_test-y_pred_test)**2)<br/>    SS_Total_test = sum((y_test-np.mean(y_test))**2)<br/>    r_squared_test = 1 - (float(SS_Residual_test))/SS_Total_test<br/>    adj_r_sq_test = 1 - (1-r_squared_test)*(len(y_test)-1)/(len(y_test)-X_test.shape[1]-1)<br/>    <br/>    # print regressor scores for Test Dataset <br/>    print('MAE for test set is {}'.format(MAE_test))<br/>    print('RMSE for test set is {}'.format(RMSE_test))<br/>    print('R squared score for test set is {}'.format(r2_score_test))<br/>    print('Adjusted R squared score for testing set is {}'.format(adj_r_sq_test))<br/>    <br/>    # store to append the results in dataframe for final comparison of performance<br/>    df_model_test_train_r2= dict({'Model' : algorithm, 'Train Adjusted R2 Score' :adj_r_sq_train,'Test Adjusted R2 Score' :adj_r_sq_test })<br/>    df_model_performance = dict({'Model' : algorithm, 'MAE' : MAE_test, 'RMSE' : RMSE_test, 'R2 Score' : r2_score_test, 'Adjusted R2 Score' :adj_r_sq_test})<br/>    <strong class="kf hi">return</strong> df_model_test_train_r2 , df_model_performance</span></pre><p id="5cff" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在那里！</p><p id="c892" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，我可以开发任何ML模型，我可以进行预测，计算分数，并比较模型性能，只需为上述函数提供正确的模型和参数。</p><h2 id="179b" class="kj kk hh bd kq kr ks kt ku kv kw kx ky ip kz la lb it lc ld le ix lf lg lh li bi translated">分类器示例:</h2><p id="d3fc" class="pw-post-body-paragraph ie if hh ig b ih lk ij ik il ll in io ip lm ir is it ln iv iw ix lo iz ja jb ha bi translated">下面的例子展示了如何使用这些函数建立一个<strong class="ig hi">逻辑回归模型</strong> (GitHub链接<a class="ae kc" href="https://github.com/gayathrig21/Medium_Examples/tree/main/ML_Code_Repo_Article" rel="noopener ugc nofollow" target="_blank">此处</a>):</p><ol class=""><li id="b9c7" class="mb mc hh ig b ih ii il im ip md it me ix mf jb mg mh mi mj bi translated">设置超参数调整的参数，并将初始化的模型传递给函数<strong class="ig hi">get _ best _ hyperparameters</strong>以获得最佳网格。这一步是可选的，也可以传递一个空的参数列表。</li></ol><pre class="jd je jf jg fd ke kf kg kh aw ki bi"><span id="5b41" class="kj kk hh kf b fi kl km l kn ko">from sklearn.linear_model import LogisticRegression<br/>logreg_params = {'penalty' : ['l2'],<br/>                 'C' : np.logspace(-1, 2, 100),<br/>                 'solver' :['liblinear'],<br/>                 'random_state' :[42,99]<br/>                 }<br/>lr_best_grid= <strong class="kf hi">get_best_hyperparameters</strong>(LogisticRegression(), logreg_params, 5, X_train, y_train)</span></pre><p id="3f59" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">2.将最佳模型传递给函数<strong class="ig hi">get _ classifier _ predictions</strong>以获得预测结果和概率。</p><pre class="jd je jf jg fd ke kf kg kh aw ki bi"><span id="1581" class="kj kk hh kf b fi kl km l kn ko">y_pred_train, y_pred_test, y_pred_prob_train, y_pred_prob_test = <strong class="kf hi">get_classifier_predictions</strong>(lr_best_grid, X_train, y_train, X_test )</span></pre><p id="80db" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">3.将预测结果输入到函数<strong class="ig hi">print _ classifier _ scores</strong>中，计算性能指标得分并打印结果。</p><pre class="jd je jf jg fd ke kf kg kh aw ki bi"><span id="ea09" class="kj kk hh kf b fi kl km l kn ko">df_model_test_train_acc1, df_model_performance1=<strong class="kf hi">print_classifier_scores</strong>(lr_best_grid, X_train, X_test, y_train , y_test, y_pred_train, y_pred_test, y_pred_prob_train, y_pred_prob_test , 'Logistic Regression')</span></pre><p id="ce05" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">4.将结果附加到数据帧，以比较所有构建的模型性能</p><pre class="jd je jf jg fd ke kf kg kh aw ki bi"><span id="f874" class="kj kk hh kf b fi kl km l kn ko">df_model=df_model.append(df_model_performance1,ignore_index=True )<br/>df_model_test_train_acc= df_model_test_train_acc.append(df_model_test_train_acc1, ignore_index=True)</span></pre><h2 id="ac0a" class="kj kk hh bd kq kr ks kt ku kv kw kx ky ip kz la lb it lc ld le ix lf lg lh li bi translated">回归变量示例:</h2><p id="6349" class="pw-post-body-paragraph ie if hh ig b ih lk ij ik il ll in io ip lm ir is it ln iv iw ix lo iz ja jb ha bi translated">下面的例子展示了如何使用这些函数建立一个<strong class="ig hi">线性回归模型</strong> (GitHub链接<a class="ae kc" href="https://github.com/gayathrig21/Medium_Examples/tree/main/ML_Code_Repo_Article" rel="noopener ugc nofollow" target="_blank">此处为</a>):</p><ol class=""><li id="6aae" class="mb mc hh ig b ih ii il im ip md it me ix mf jb mg mh mi mj bi translated">设置超参数调整的参数，并将初始化的模型传递给函数<strong class="ig hi">get _ best _ hyperparameters</strong>以获得最佳网格。这一步是可选的，也可以传递一个空的参数列表。</li></ol><pre class="jd je jf jg fd ke kf kg kh aw ki bi"><span id="7300" class="kj kk hh kf b fi kl km l kn ko">from sklearn.linear_model import LinearRegression<br/>parameters = {'fit_intercept':[True,False],  'copy_X':[True, False]}<br/>lr_best_grid= <strong class="kf hi">get_best_hyperparameters</strong>(LinearRegression(), parameters, 5, X_train, y_train)</span></pre><p id="5206" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">2.将最佳模型传递给函数<strong class="ig hi">get _ regressor _ predictions</strong>以获得预测结果。</p><pre class="jd je jf jg fd ke kf kg kh aw ki bi"><span id="d8b3" class="kj kk hh kf b fi kl km l kn ko">y_pred_train, y_pred_test = <strong class="kf hi">get_regressor_predictions</strong>(lr_best_grid, X_train, y_train, X_test )</span></pre><p id="f829" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">3.将预测结果输入到函数<strong class="ig hi"> print_regressor_scores </strong>中，以计算性能指标分数并打印结果。</p><pre class="jd je jf jg fd ke kf kg kh aw ki bi"><span id="3531" class="kj kk hh kf b fi kl km l kn ko">df_model_test_train_r2_1, df_model_performance1=<strong class="kf hi">print_regressor_scores</strong>(lr_best_grid, X_train, X_test, y_train , y_test, y_pred_train, y_pred_test , 'Linear Regression')</span></pre><p id="8d85" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">4.将结果附加到数据帧，以比较所有构建的模型性能</p><pre class="jd je jf jg fd ke kf kg kh aw ki bi"><span id="1da4" class="kj kk hh kf b fi kl km l kn ko">df_model=df_model.append(df_model_performance1,ignore_index=True )<br/>df_model_r2= df_model_r2.append(df_model_test_train_r2_1, ignore_index=True)</span></pre><p id="736d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，我们可以使用这些函数，通过传递模型特定参数来开发任何模型，如上例中对<em class="kb">线性回归</em>和<em class="kb">逻辑回归</em>所做的那样。</p><p id="358d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">耶……快乐模型建筑！！！</p><div class="mk ml ez fb mm mn"><a rel="noopener follow" target="_blank" href="/mlearning-ai/mlearning-ai-submission-suggestions-b51e2b130bfb"><div class="mo ab dw"><div class="mp ab mq cl cj mr"><h2 class="bd hi fi z dy ms ea eb mt ed ef hg bi translated">Mlearning.ai提交建议</h2><div class="mu l"><h3 class="bd b fi z dy ms ea eb mt ed ef dx translated">如何成为Mlearning.ai上的作家</h3></div><div class="mv l"><p class="bd b fp z dy ms ea eb mt ed ef dx translated">medium.com</p></div></div><div class="mw l"><div class="mx l my mz na mw nb jm mn"/></div></div></a></div></div></div>    
</body>
</html>