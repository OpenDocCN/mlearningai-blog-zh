<html>
<head>
<title>Image Classification for beginner</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">初学者的图像分类</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/image-classification-for-beginner-a6de7a69bc78?source=collection_archive---------0-----------------------#2022-06-04">https://medium.com/mlearning-ai/image-classification-for-beginner-a6de7a69bc78?source=collection_archive---------0-----------------------#2022-06-04</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/32e6f0131be3f90feed78a412d0f134b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ShbCcoA9rVy_NAMeHtWaGQ.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">source: <a class="ae it" href="https://www.freepik.com/vectors/computer'" rel="noopener ugc nofollow" target="_blank">https://www.freepik.com/vectors/computer</a></figcaption></figure><p id="e433" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">计算机视觉是人工智能(AI)的一个领域，它使计算机和系统能够从数字图像、视频和其他视觉输入中获取有意义的信息，并根据这些信息采取行动或提出建议。(来源:<a class="ae it" href="https://www.ibm.com/" rel="noopener ugc nofollow" target="_blank">https://www.ibm.com/</a>)</p><p id="021d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">机器学习就像一个从输入中提取信息的计算机大脑。机器学习模型的输入越多，它就越准确(就像我们教孩子一样)。</p><p id="885a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">图像分类是计算机视觉中最重要的应用之一。当使用机器学习进行图像分类任务时，计算机可以自动对输入图像进行分类。图像分类的例子是将x射线标记为癌症与否，以及对手写数字进行分类。</p><p id="87e5" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在本文中，您将了解如何使用<strong class="iw hi"> Python </strong>和<strong class="iw hi"> Keras </strong>库来执行图像分类。这将是一个简单的指南，可以在以后添加更多的高级功能。</p><h1 id="be23" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">📔步骤摘要</h1><ol class=""><li id="b34c" class="kq kr hh iw b ix ks jb kt jf ku jj kv jn kw jr kx ky kz la bi translated">读取数据集</li><li id="9a80" class="kq kr hh iw b ix lb jb lc jf ld jj le jn lf jr kx ky kz la bi translated">数据探索</li><li id="58ee" class="kq kr hh iw b ix lb jb lc jf ld jj le jn lf jr kx ky kz la bi translated">数据预处理</li><li id="f3b9" class="kq kr hh iw b ix lb jb lc jf ld jj le jn lf jr kx ky kz la bi translated">创建模型</li><li id="42ea" class="kq kr hh iw b ix lb jb lc jf ld jj le jn lf jr kx ky kz la bi translated">训练模特</li><li id="6169" class="kq kr hh iw b ix lb jb lc jf ld jj le jn lf jr kx ky kz la bi translated">模型评估</li></ol><h1 id="9935" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">💽资料组</h1><p id="ab80" class="pw-post-body-paragraph iu iv hh iw b ix ks iz ja jb kt jd je jf lg jh ji jj lh jl jm jn li jp jq jr ha bi translated">示例数据集是<strong class="iw hi">大米图像</strong>。土耳其通常种植五种不同的水稻品种:Arborio、Basmati、Ipsala、Jasmine和Karacadag。有75000张图片；每个品种15000元。</p><div class="lj lk ez fb ll lm"><a href="https://www.kaggle.com/datasets/muratkokludataset/rice-image-dataset" rel="noopener  ugc nofollow" target="_blank"><div class="ln ab dw"><div class="lo ab lp cl cj lq"><h2 class="bd hi fi z dy lr ea eb ls ed ef hg bi translated">水稻图像数据集</h2><div class="lt l"><h3 class="bd b fi z dy lr ea eb ls ed ef dx translated">五个不同的水稻图像数据集。Arborio，Basmati，Ipsala，Jasmine，Karacadag</h3></div><div class="lu l"><p class="bd b fp z dy lr ea eb ls ed ef dx translated">www.kaggle.com</p></div></div><div class="lv l"><div class="lw l lx ly lz lv ma in lm"/></div></div></a></div><h1 id="4b03" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">步骤1:读取数据集</h1><p id="56ad" class="pw-post-body-paragraph iu iv hh iw b ix ks iz ja jb kt jd je jf lg jh ji jj lh jl jm jn li jp jq jr ha bi translated">图像分类任务数据集通常以图像文件的形式存在于多个文件夹中，每个文件夹包含来自1个类别的图像。</p><figure class="mc md me mf fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mb"><img src="../Images/8910d4f79925826d423b28a20d0b9c3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JWGOgC7t6dnIZdeqqjQMSA.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">The folder structure of the rice image example</figcaption></figure><p id="e8d1" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi"> 1。定义主文件夹位置</strong></p><pre class="mc md me mf fd mg mh mi mj aw mk bi"><span id="862e" class="ml jt hh mh b fi mm mn l mo mp">img_path = "C:/Project/Rice_Classification/Rice_Image_Dataset/"</span></pre><p id="644a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">⚠️别忘了在路径的末尾加上/</p><p id="0f35" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi"> 2。列出图像的所有类别/种类/标签</strong></p><pre class="mc md me mf fd mg mh mi mj aw mk bi"><span id="b7b0" class="ml jt hh mh b fi mm mn l mo mp">rice_label = ['Arborio','Basmati','Ipsala','Jasmine','Karacadag']</span></pre><p id="020c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们将使用该列表遍历所有子文件夹。确保标签名称与子文件夹名称相同。</p><p id="f074" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi"> 3。创建图像路径的数据帧，并标记</strong></p><pre class="mc md me mf fd mg mh mi mj aw mk bi"><span id="f27e" class="ml jt hh mh b fi mm mn l mo mp">import pandas as pd<br/>import os</span><span id="e484" class="ml jt hh mh b fi mq mn l mo mp">img_list = []<br/>label_list = []<br/>for label in rice_label:<br/>    for img_file in os.listdir(img_path+label):<br/>        img_list.append(img_path+label+'/'+img_file)<br/>        label_list.append(label)<br/>        <br/>df = pd.DataFrame({'img':img_list, 'label':label_list})</span></pre><p id="f435" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">代码解释</strong></p><ul class=""><li id="e912" class="kq kr hh iw b ix iy jb jc jf mr jj ms jn mt jr mu ky kz la bi translated">img_list:图像文件位置<br/> label_list:每张图像的标签</li><li id="341b" class="kq kr hh iw b ix lb jb lc jf ld jj le jn lf jr mu ky kz la bi translated">遍历所有子文件夹(img_path+label)</li><li id="402e" class="kq kr hh iw b ix lb jb lc jf ld jj le jn lf jr mu ky kz la bi translated">找到每个子文件夹中的所有图像文件，并将文件位置添加到img_list中</li><li id="c35c" class="kq kr hh iw b ix lb jb lc jf ld jj le jn lf jr mu ky kz la bi translated">然后根据子文件夹名称添加标签</li><li id="d2fe" class="kq kr hh iw b ix lb jb lc jf ld jj le jn lf jr mu ky kz la bi translated">从img_list和label_list列创建数据帧</li></ul><pre class="mc md me mf fd mg mh mi mj aw mk bi"><span id="6b1c" class="ml jt hh mh b fi mm mn l mo mp">df.head()</span></pre><figure class="mc md me mf fd ii er es paragraph-image"><div class="er es mv"><img src="../Images/3b982413e3b96ed7f28d8a19b328e8b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:686/format:webp/1*QRN2I2nWJy7fd2VSDtSHZA.png"/></div></figure><p id="103b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们会得到这样的数据帧。</p><h1 id="dcf2" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">步骤2:数据探索</h1><p id="e832" class="pw-post-body-paragraph iu iv hh iw b ix ks iz ja jb kt jd je jf lg jh ji jj lh jl jm jn li jp jq jr ha bi translated"><strong class="iw hi"> 1。统计每个大米类别的图像数量</strong></p><pre class="mc md me mf fd mg mh mi mj aw mk bi"><span id="7ba7" class="ml jt hh mh b fi mm mn l mo mp">df['label'].value_counts()</span></pre><figure class="mc md me mf fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mw"><img src="../Images/ebd829492077eeee1befa105fa688a81.png" data-original-src="https://miro.medium.com/v2/resize:fit:298/format:webp/1*ScISG6ViCfUkHkOGALmxEA.png"/></div></div></figure><p id="f8c1" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">每个类别有15，000张图片。好吧！</p><p id="3e92" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi"> 2。显示样本图像</strong></p><pre class="mc md me mf fd mg mh mi mj aw mk bi"><span id="45f5" class="ml jt hh mh b fi mm mn l mo mp">import matplotlib.pyplot as plt</span><span id="c3e8" class="ml jt hh mh b fi mq mn l mo mp">fig, ax = plt.subplots(ncols=len(rice_label), figsize=(20,4))<br/>fig.suptitle('Rice Category')</span><span id="eb0b" class="ml jt hh mh b fi mq mn l mo mp">random_num = 12</span><span id="ba84" class="ml jt hh mh b fi mq mn l mo mp">for i,label in enumerate(rice_label):<br/>    ax[i].set_title(label)<br/>    ax[i].imshow(plt.imread(df[df['label']==label]['img'].iloc[random_num]))</span></pre><figure class="mc md me mf fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mx"><img src="../Images/c9682c28f30d89c59566a4630f54d7a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pYdYVooCcgspr4IJgVL2Aw.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">results after running code</figcaption></figure><p id="4cf2" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">使用matplotlib显示样本图像(你可以只打开文件夹中的图像文件，但这种方法更酷。开玩笑的。用matplotlib显示图像可以适配成图像增强后的图解图像，建议学习用matplotlib显示图像。</p><p id="94f4" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">代码解释</strong></p><ul class=""><li id="8b1c" class="kq kr hh iw b ix iy jb jc jf mr jj ms jn mt jr mu ky kz la bi translated">创建一个子情节，其列数等于类别数</li><li id="a8bc" class="kq kr hh iw b ix lb jb lc jf ld jj le jn lf jr mu ky kz la bi translated">random_num用于随机选择要显示的图像。您可以更改此变量来更改显示的图像。</li><li id="8e10" class="kq kr hh iw b ix lb jb lc jf ld jj le jn lf jr mu ky kz la bi translated">遍历rice_label以显示每个rice标签的1个图像</li></ul><p id="628e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><a class="ae it" href="https://www.geeksforgeeks.org/matplotlib-pyplot-imread-in-python/" rel="noopener ugc nofollow" target="_blank"> plt.imread </a>用于将图像从文件读入数组</p><p id="fc6e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">imshow用于使用图像数组作为输入来打印图像</p><figure class="mc md me mf fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es my"><img src="../Images/40dce51cd4b22eb2dfa33febb37eb495.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vo-PyJvRcZXsJPHJ9JZU3Q.png"/></div></div></figure><p id="46b5" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">⚠️如果你使用OpenCV读取图像，图像颜色可能是错误的，因为OpenCV使用BGR作为图像的默认颜色顺序，而matplotlib使用RGB。当你在matplotlib中显示用OpenCv加载的图像时，通道将从后向前。(点击可以阅读更多<a class="ae it" href="https://stackoverflow.com/questions/39316447/opencv-giving-wrong-color-to-colored-images-on-loading" rel="noopener ugc nofollow" target="_blank"/></p><p id="76c3" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi"> 3。了解图像形状</strong></p><p id="288f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">图像形状在计算机视觉编程中至关重要，因为深度学习模型将被定义为所需的图像大小。在将图像输入到模型中之前，我们必须调整图像的大小以匹配所需的大小。</p><pre class="mc md me mf fd mg mh mi mj aw mk bi"><span id="e6fd" class="ml jt hh mh b fi mm mn l mo mp">plt.imread(df['img'][0]).shape</span></pre><p id="c058" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">。shape与图像数组一起使用来了解图像大小。</p><p id="c257" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">结果是(250，250，3)。</p><figure class="mc md me mf fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mz"><img src="../Images/c9a8785186721d0866ea1dda84ccf49c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y7jawBNUtY3LncKDMJdvtQ.png"/></div></div></figure><h1 id="fb24" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">步骤3:数据预处理</h1><p id="2bae" class="pw-post-body-paragraph iu iv hh iw b ix ks iz ja jb kt jd je jf lg jh ji jj lh jl jm jn li jp jq jr ha bi translated"><strong class="iw hi"> 1。编码标签</strong></p><p id="ae7e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">深度学习模型需要预测结果是一个数字，因此在模型训练之前，标签必须从分类值编码(更改)为数值。</p><pre class="mc md me mf fd mg mh mi mj aw mk bi"><span id="3767" class="ml jt hh mh b fi mm mn l mo mp"># Create a dataframe for mapping label<br/>df_labels = {<br/>    'Arborio' : 0,<br/>    'Basmati' : 1,<br/>    'Ipsala' : 2,<br/>    'Jasmine' : 3,<br/>    'Karacadag': 4<br/>}</span><span id="e15c" class="ml jt hh mh b fi mq mn l mo mp"># Encode<br/>df['encode_label'] = df['label'].map(df_labels)<br/>df.head()</span></pre><p id="660f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">代码解释</strong></p><ul class=""><li id="23ff" class="kq kr hh iw b ix iy jb jc jf mr jj ms jn mt jr mu ky kz la bi translated">创建一个字典df_labels，其中键是大米类别，值是订单号。</li><li id="9238" class="kq kr hh iw b ix lb jb lc jf ld jj le jn lf jr mu ky kz la bi translated">使用。映射到用df_labels编码数据帧列“label”</li><li id="5fc5" class="kq kr hh iw b ix lb jb lc jf ld jj le jn lf jr mu ky kz la bi translated">df将有一个新的列encode_label，它是标签列的编码数。</li></ul><p id="428f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi"> 2。准备模型训练数据集</strong></p><p id="07a1" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">输入(X): </strong>图像</p><pre class="mc md me mf fd mg mh mi mj aw mk bi"><span id="10bd" class="ml jt hh mh b fi mm mn l mo mp">import cv2</span><span id="36d0" class="ml jt hh mh b fi mq mn l mo mp">X = []<br/>for img in df['img']:<br/>    img = cv2.imread(str(img))<br/>    # img = augment_function(img)<br/>    img = cv2.resize(img, (96, 96))<br/>    img = img/255<br/>    X.append(img)</span></pre><p id="fd40" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在输入图像用于模型训练之前，必须将其转换为模型的特定大小的数组，并缩放为0到1之间的值。</p><p id="fc6d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">您可以创建一个增强功能来调整图像，如改变对比度和亮度，并将该功能应用于此步骤。</p><p id="cce9" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">输出(y): </strong>每个图像的编码标签</p><pre class="mc md me mf fd mg mh mi mj aw mk bi"><span id="7d76" class="ml jt hh mh b fi mm mn l mo mp">y = df['encode_label']</span></pre><p id="6ea0" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi"> 3。培训/验证/测试分割</strong></p><pre class="mc md me mf fd mg mh mi mj aw mk bi"><span id="db47" class="ml jt hh mh b fi mm mn l mo mp">from sklearn.model_selection import train_test_split</span><span id="c2c4" class="ml jt hh mh b fi mq mn l mo mp">X_train, X_test_val, y_train, y_test_val = train_test_split(X, y)<br/>X_test, X_val, y_test, y_val = train_test_split(X_test_val, y_test_val)</span></pre><p id="8ae3" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">培训80%，模型调整验证4%，测试集16%</p><h1 id="e561" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">步骤4:创建一个模型</h1><p id="9152" class="pw-post-body-paragraph iu iv hh iw b ix ks iz ja jb kt jd je jf lg jh ji jj lh jl jm jn li jp jq jr ha bi translated"><strong class="iw hi"> 1。使用VGG16作为基本型号</strong></p><p id="06f7" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">VGG16是著名的卷积神经网络(CNN)架构，由卡伦·西蒙扬和安德鲁·齐泽曼于2014年发明。</p><p id="fca2" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我不是从零开始训练一个深度学习模型，而是使用迁移学习的方法，以一个预先训练好的模型(VGG16)为起点，添加一些层来匹配我们的任务。</p><p id="8d6d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">首先，导入VGG16模型，将输入形状设置为(96，96，3)。</p><pre class="mc md me mf fd mg mh mi mj aw mk bi"><span id="3e97" class="ml jt hh mh b fi mm mn l mo mp">from keras.applications.vgg16 import VGG16</span><span id="c2d0" class="ml jt hh mh b fi mq mn l mo mp"><br/>base_model = VGG16(input_shape=(96,96,3), include_top=False, weights='imagenet')<br/><br/>base_model.summary()</span></pre><figure class="mc md me mf fd ii er es paragraph-image"><div class="er es na"><img src="../Images/4d143255a8e6a56742fcb9f596272628.png" data-original-src="https://miro.medium.com/v2/resize:fit:1062/format:webp/1*uXngALXo_h-ig6v4S95b_g.png"/></div><figcaption class="ip iq et er es ir is bd b be z dx">VGG16 model summary</figcaption></figure><p id="7935" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">然后，冻结VGG16模型参数，只允许调整最后一层的参数，以减少计算工作量。</p><pre class="mc md me mf fd mg mh mi mj aw mk bi"><span id="01f5" class="ml jt hh mh b fi mm mn l mo mp">for layer in base_model.layers:<br/>    layer.trainable = False</span><span id="d902" class="ml jt hh mh b fi mq mn l mo mp">base_model.layers[-2].trainable = True<br/>base_model.layers[-3].trainable = True<br/>base_model.layers[-4].trainable = True</span></pre><p id="6a2c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi"> 2。给模型添加图层</strong></p><p id="fba9" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在是时候为我们的任务向基础模型添加自定义层了。</p><pre class="mc md me mf fd mg mh mi mj aw mk bi"><span id="fe30" class="ml jt hh mh b fi mm mn l mo mp">from tensorflow.keras.models import *<br/>from tensorflow.keras.layers import *</span><span id="678e" class="ml jt hh mh b fi mq mn l mo mp">model = Sequential()<br/>model.add(Input(shape=(96,96,3)))<br/>model.add(base_model)<br/>model.add(Flatten())<br/>model.add(Dropout(0.2))<br/>model.add(Dense(256, activation='relu'))<br/>model.add(Dropout(0.2))<br/>model.add(Dense(len(rice_label), activation='softmax'))</span><span id="b5fc" class="ml jt hh mh b fi mq mn l mo mp">model.summary()</span></pre><figure class="mc md me mf fd ii er es paragraph-image"><div class="er es nb"><img src="../Images/cc51526b55e9effe25d77af0420e9936.png" data-original-src="https://miro.medium.com/v2/resize:fit:1050/format:webp/1*QbPwi0dRjGwprpfdREGZCw.png"/></div><figcaption class="ip iq et er es ir is bd b be z dx">Model summary</figcaption></figure><p id="3c9d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在型号总结中可以看到，VGG16是起点。然后，添加图层展平、缺失和密集。</p><p id="7375" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在这篇文章中，我不会深入讨论每一层的细节。你必须关注的重要层是最后一个致密层。该层将产生图像分类的结果。它被设置为输出形状等于len(rice_label ),在本例中为5，因此结果将是5个rice类别的概率，softmax函数将汇总概率最高的类别。</p><h1 id="0bcf" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">第五步:训练一个模型</h1><p id="93ee" class="pw-post-body-paragraph iu iv hh iw b ix ks iz ja jb kt jd je jf lg jh ji jj lh jl jm jn li jp jq jr ha bi translated">让我们训练模型！！</p><pre class="mc md me mf fd mg mh mi mj aw mk bi"><span id="a754" class="ml jt hh mh b fi mm mn l mo mp">model.compile(<br/>  optimizer="adam",<br/>  loss='sparse_categorical_crossentropy',<br/>  metrics=['acc'])</span><span id="bc59" class="ml jt hh mh b fi mq mn l mo mp">history = model.fit(X_train, y_train, epochs=5, validation_data=(X_val, y_val))</span></pre><p id="0e9a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这一步可能需要很长时间。</p><p id="c3a3" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">你会看到每个纪元的准确性。</p><figure class="mc md me mf fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nc"><img src="../Images/fb74db9ccea14a4d6181db862533ed68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6ygjljtC2AMGfBaEVmXIyQ.png"/></div></div></figure><p id="e251" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">注意:</strong>为了更快的模型训练，我只使用每个类别的5000张图像进行训练，所以精度没有那么高。</p><h1 id="f696" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">第六步:模型评估</h1><p id="8996" class="pw-post-body-paragraph iu iv hh iw b ix ks iz ja jb kt jd je jf lg jh ji jj lh jl jm jn li jp jq jr ha bi translated"><strong class="iw hi"> 1。用测试装置</strong>测试模型</p><pre class="mc md me mf fd mg mh mi mj aw mk bi"><span id="0bd8" class="ml jt hh mh b fi mm mn l mo mp">model.evaluate(X_test,y_test)</span></pre><figure class="mc md me mf fd ii er es paragraph-image"><div class="er es nd"><img src="../Images/82acb287327e8bc8f30b36f4b5579be0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1278/format:webp/1*fwmXbMrlM-vmsBxXigACeg.png"/></div></figure><p id="5bc8" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">准确率为91.49%(如果使用全部75，000张图像，准确率可高达99%)</p><p id="78af" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi"> 2。可视化模型</strong></p><p id="378a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">每个历元的绘图精度。您可能会从更高的历元看到更高的精度(模型更好)。</p><pre class="mc md me mf fd mg mh mi mj aw mk bi"><span id="8067" class="ml jt hh mh b fi mm mn l mo mp">plt.plot(history.history['acc'], marker='o')<br/>plt.plot(history.history['val_acc'], marker='o')<br/>plt.title('model accuracy')<br/>plt.ylabel('accuracy')<br/>plt.xlabel('epoch')<br/>plt.legend(['train', 'val'], loc='lower right')<br/>plt.show()</span></pre><figure class="mc md me mf fd ii er es paragraph-image"><div class="er es ne"><img src="../Images/6004947b141112e04ff225bf968e6284.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/format:webp/1*NHDqjb8fPfVDuNrSdcUx-w.png"/></div><figcaption class="ip iq et er es ir is bd b be z dx">model accuracy plot</figcaption></figure><p id="d8e1" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">每个历元的图损失。你可能会看到一个较高时期的较低损失。</p><pre class="mc md me mf fd mg mh mi mj aw mk bi"><span id="aa86" class="ml jt hh mh b fi mm mn l mo mp">plt.plot(history.history['loss'], marker='o')<br/>plt.plot(history.history['val_loss'], marker='o')<br/>plt.title('model loss')<br/>plt.ylabel('loss')<br/>plt.xlabel('epoch')<br/>plt.legend(['train', 'val'], loc='upper right')<br/>plt.show()</span></pre><figure class="mc md me mf fd ii er es paragraph-image"><div class="er es nf"><img src="../Images/4d261c075343b53f715185c07aaeb623.png" data-original-src="https://miro.medium.com/v2/resize:fit:762/format:webp/1*FcBqSnQbNfPS9QGwPpK8qg.png"/></div><figcaption class="ip iq et er es ir is bd b be z dx">model loss plot</figcaption></figure><p id="0df5" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">通过绘制这两个图，可以更容易地决定应该使用多少个历元来训练模型，因为更多的历元意味着更多的计算时间。</p><h1 id="9270" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">结论</h1><p id="7eb1" class="pw-post-body-paragraph iu iv hh iw b ix ks iz ja jb kt jd je jf lg jh ji jj lh jl jm jn li jp jq jr ha bi translated">在本文中，您将学习如何使用Python和Keras库执行影像分类任务。从读取数据集、数据探索和数据预处理开始。然后，创建并训练一个模型，并评估该模型。</p><p id="0727" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">感谢您的阅读。如果你喜欢这些内容，请关注我，获取更多数据科学相关文章。如果有什么推荐，随时告诉我。</p><div class="lj lk ez fb ll lm"><a rel="noopener follow" target="_blank" href="/mlearning-ai/mlearning-ai-submission-suggestions-b51e2b130bfb"><div class="ln ab dw"><div class="lo ab lp cl cj lq"><h2 class="bd hi fi z dy lr ea eb ls ed ef hg bi translated">Mlearning.ai提交建议</h2><div class="lt l"><h3 class="bd b fi z dy lr ea eb ls ed ef dx translated">如何成为Mlearning.ai上的作家</h3></div><div class="lu l"><p class="bd b fp z dy lr ea eb ls ed ef dx translated">medium.com</p></div></div><div class="lv l"><div class="ng l lx ly lz lv ma in lm"/></div></div></a></div></div></div>    
</body>
</html>