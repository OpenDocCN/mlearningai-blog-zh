<html>
<head>
<title>My first data science hackathon</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我的第一次数据科学黑客马拉松</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/my-first-data-science-hackathon-1d13e47f0edb?source=collection_archive---------6-----------------------#2022-06-15">https://medium.com/mlearning-ai/my-first-data-science-hackathon-1d13e47f0edb?source=collection_archive---------6-----------------------#2022-06-15</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/cd2a158b91e74b0d54afd89858a93273.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ebWPwwBD2bReFMH3QoxXsQ.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx"><a class="ae it" href="https://www.theinnovationmode.com/the-innovation-blog/how-to-run-a-successful-corporate-hackathon" rel="noopener ugc nofollow" target="_blank">How to set up a successful Hackathon — A manager’s guide | The Innovation Mode</a></figcaption></figure><p id="9d87" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">2022年6月14日星期二，我参加了EMEA数据科学黑客马拉松。<br/>目标:预测可寻址电视数据的广告类型类别<br/>我们从美国多个城市/地区收集了20万行设备级别(移动/平板/桌面)的数据，用于构建涵盖20种类型的模型(训练数据集),其中4万行用于测试和提交我们的答案。我们被告知需要预测的10个类别，测试集中的每个设备都可以在训练数据集中找到。模型性能将基于一个微型F1分数。选择微观F1评分的原因是因为我们在这种情况下的多个类别流派。</p><p id="243d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">训练和测试数据集具有以下列:<br/> Row_number，UserID64_sha1，SiteDomain，Datetime，OperatingSystem，Browser，PublisherID，DeviceUniqueID_sha1，DeviceID，CarrierID，DealID，DeviceType，PostalCode，Application，LeafName</p><p id="573f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">正如您所看到的，有大量有用的和可预测的信息，所以让我们从我如何解决这个问题开始吧。</p><ol class=""><li id="670a" class="js jt hh iw b ix iy jb jc jf ju jj jv jn jw jr jx jy jz ka bi translated">快速计数和数据类型检查</li></ol><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="b523" class="kk kl hh kg b fi km kn l ko kp">train.nunique()</span><span id="9f11" class="kk kl hh kg b fi kq kn l ko kp">train.dtypes</span></pre><p id="63f5" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">2.意识到我最感兴趣的变量是datetime，因此将datetime字段转换为pandas datetime类型，因为它当前是一个对象</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="4fec" class="kk kl hh kg b fi km kn l ko kp">train[‘c_datetime’]=pd.to_datetime(train[‘Datetime’])</span></pre><p id="1f91" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">3.创建一组从datetime派生的变量，如星期几、工作日/周末(二进制变量)、小时、日部分(小时的聚合)和月</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="2308" class="kk kl hh kg b fi km kn l ko kp">train[‘c_dow’] = train[‘c_datetime’].dt.dayofweek</span><span id="1a57" class="kk kl hh kg b fi kq kn l ko kp">def weekday(row):<br/> if row[‘c_dow’] &gt; 4:<br/> return 1<br/> else:<br/> return 0</span><span id="c2ff" class="kk kl hh kg b fi kq kn l ko kp">train[‘c_weekend’]= train.apply(weekday, axis=1)</span><span id="e22d" class="kk kl hh kg b fi kq kn l ko kp">train[‘c_hour’] = train[‘c_datetime’].dt.hour</span><span id="0827" class="kk kl hh kg b fi kq kn l ko kp">def daypart(row):<br/> if row[‘c_hour’] &gt; 20:<br/> return ‘20’<br/> elif row[‘c_hour’] &gt; 15 and row[‘c_hour’] &lt;20 :<br/> return ‘16’<br/> elif row[‘c_hour’] &gt; 11 and row[‘c_hour’] &lt;16 :<br/> return ‘12’<br/> elif row[‘c_hour’] &gt; 7 and row[‘c_hour’] &lt;12 :<br/> return ‘8’<br/> elif row[‘c_hour’] &lt;7 :<br/> return ‘0’<br/> else:<br/> return 0</span><span id="f5e3" class="kk kl hh kg b fi kq kn l ko kp">train[‘c_daypart’]= train.apply(daypart, axis=1)</span><span id="ec98" class="kk kl hh kg b fi kq kn l ko kp">train[‘c_month’] = train[‘c_datetime’].dt.month</span></pre><p id="4ec5" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">4.保留需要为测试集预测的内容类别(20个中的10个)。</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="20b0" class="kk kl hh kg b fi km kn l ko kp">rows_to_keep = [‘GR10’,’GR20',’GR23',’GR25',’GR30'<br/> ,’GR31',’GR32',’GR34',’GR5',’GR7']</span><span id="8796" class="kk kl hh kg b fi kq kn l ko kp">train = train[train.LeafName.isin(rows_to_keep) == True].copy()</span></pre><p id="9a62" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">就是这样。我的数据准备工作完成了。我想保持简单，因为我将选择一种基于树的方法来预测内容类别(也称为leafname ),所以如果我对热编码进行任何操作，我可能会过度拟合数据</p></div><div class="ab cl kr ks go kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ha hb hc hd he"><p id="ef9b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我选择的预测内容类别的方法是<a class="ae it" href="https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.ExtraTreesClassifier.html" rel="noopener ugc nofollow" target="_blank">额外的树</a>，因为这是一个分类问题，基于树的方法比基于概率的方法更合适。</p><ol class=""><li id="6545" class="js jt hh iw b ix iy jb jc jf ju jj jv jn jw jr jx jy jz ka bi translated">导入必要的库以创建模型并执行交叉验证</li></ol><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="3896" class="kk kl hh kg b fi km kn l ko kp">from sklearn.ensemble import ExtraTreesClassifier<br/>from sklearn.model_selection import cross_val_score<br/>from sklearn.model_selection import RepeatedStratifiedKFold<br/>from numpy import mean<br/>from numpy import std</span></pre><p id="de32" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">2.基于只浮动的列设置X，y矩阵(我删除了用户和设备散列，因为它看起来不相关，可能只是在模型中添加了噪声)。y变量是数据集中的内容类别aka leafname。</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="5653" class="kk kl hh kg b fi km kn l ko kp">X_train =train[[‘OperatingSystem’<br/> , ‘Browser’, ‘PublisherID’,<br/> ‘DeviceID’, ‘CarrierID’, ‘DealID’, ‘DeviceType’, ‘PostalCode’,<br/> ‘c_dow’, ‘c_weekend’, ‘c_hour’,<br/> ‘c_daypart’, ‘c_month’]]<br/>y_train = train.LeafName</span></pre><p id="b800" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">3.创建模型并评估kfold交叉验证。我更喜欢重复次数为3的10次拆分。然而，我的机器没有足够的内存，所以8分裂是我能做的最好的。我还将评分方法设置为f1_micro，因为这是测试的评判标准。</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="2267" class="kk kl hh kg b fi km kn l ko kp"># Fit/predict<br/>etc = ExtraTreesClassifier()<br/>_ = etc.fit(X_train, y_train)</span><span id="b176" class="kk kl hh kg b fi kq kn l ko kp"># evaluate the model<br/>cv = RepeatedStratifiedKFold(n_splits=8, n_repeats=3, random_state=1)<br/>n_scores = cross_val_score(etc, X_train, y_train, scoring=’f1_micro’, cv=cv, n_jobs=-1, error_score=’raise’)<br/># report performance<br/>print(‘f1 micro: %.3f (%.3f)’ % (mean(n_scores), std(n_scores)))</span></pre><p id="43d4" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当我回顾我的分数时，在0.80和0.84之间，平均0.83，对于一个我很少与之相处的模特来说，这是相当令人印象深刻的。我还使用组合和额外的树做了一些<a class="ae it" href="https://bilalmussa.medium.com/using-combinations-to-model-all-possible-models-in-python-with-pandas-statsmodels-969aee159fd0" rel="noopener">数据挖掘，看看哪些变量提高了微观f1的分数。这些变量是“操作系统”、“邮政编码”、“c_weekend”和“PublisherID”。然而，当我添加其余变量时，只有这4个变量的额外树模型的平均微观f1分数为0.80比0.83。</a></p><p id="05ec" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">4.使用我训练的模型预测测试数据集的内容类别</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="464d" class="kk kl hh kg b fi km kn l ko kp">y_pred = etc.predict(X_test)</span></pre><p id="1d3c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">5.创建提交文件</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="fed6" class="kk kl hh kg b fi km kn l ko kp">submission=pd.concat({‘Row_number’: test.Row_number,<br/> ‘LeafName’: pd.Series(y_pred)},axis=1)<br/>submission.to_csv(‘bm_submission_file.csv’, index=False)</span></pre><p id="dd93" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">搞定了。这是我完成的第一次数据科学黑客马拉松。我花了大约4-5个小时完成，因为我的机器有点慢，我在挖掘数据，看看我能找到什么信息来获得最高的微f1分数。</p><div class="ky kz ez fb la lb"><a rel="noopener follow" target="_blank" href="/mlearning-ai/mlearning-ai-submission-suggestions-b51e2b130bfb"><div class="lc ab dw"><div class="ld ab le cl cj lf"><h2 class="bd hi fi z dy lg ea eb lh ed ef hg bi translated">Mlearning.ai提交建议</h2><div class="li l"><h3 class="bd b fi z dy lg ea eb lh ed ef dx translated">如何成为Mlearning.ai上的作家</h3></div><div class="lj l"><p class="bd b fp z dy lg ea eb lh ed ef dx translated">medium.com</p></div></div><div class="lk l"><div class="ll l lm ln lo lk lp in lb"/></div></div></a></div></div></div>    
</body>
</html>