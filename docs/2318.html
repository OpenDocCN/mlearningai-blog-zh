<html>
<head>
<title>Tackle the problem of small datasets in the medical domain using DCGANs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用DCGANs解决医学领域的小数据集问题</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/tackle-the-problem-of-small-datasets-in-the-medical-domain-using-dcgans-eef990f8a5f6?source=collection_archive---------3-----------------------#2022-04-13">https://medium.com/mlearning-ai/tackle-the-problem-of-small-datasets-in-the-medical-domain-using-dcgans-eef990f8a5f6?source=collection_archive---------3-----------------------#2022-04-13</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="6c29" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">从现有数据中合成新的CT扫描、核磁共振成像和x光</h2></div><p id="6d8f" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">医疗领域缺乏足够大的数据集是使用ML和深度学习模型处理医疗人工智能解决方案时面临的最常见问题之一。这是因为临床数据通常是私人的，医院很少向公众发布数据集。在临床试验过程中，患者经常被放弃，由此导致数据缺失或不完整，这是另一个主要障碍。</p><p id="0ee1" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在研究脑瘤分类问题时，我遇到了类似的障碍。肿瘤的MRI扫描很容易获得，但非肿瘤扫描与肿瘤扫描相比要少得多。</p><p id="1982" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这造成了数据集中的不平衡，所以为了克服这一点，我最初想到了图像放大和放大非肿瘤扫描。但这里的问题是，增强图像不是非常多样化，我的模型需要新的扫描来有效地训练。</p><p id="03f1" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这时，我偶然发现了DCGANs和亚历克·拉德福德和卢克·梅茨的“用深度卷积生成对抗网络实现无监督表示学习”的教程。</p><h1 id="742d" class="js jt hh bd ju jv jw jx jy jz ka kb kc in kd io ke iq kf ir kg it kh iu ki kj bi translated">介绍</h1><p id="6ac3" class="pw-post-body-paragraph iw ix hh iy b iz kk ii jb jc kl il je jf km jh ji jj kn jl jm jn ko jp jq jr ha bi translated">GANs是一个框架，用于教导DL模型捕获训练数据的分布，以便我们可以从相同的分布中生成新数据。</p><p id="814b" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">DCGAN是GAN的直接扩展，只是它在鉴别器和生成器中分别显式使用了卷积和卷积转置层。</p><p id="339d" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">DCGANs由两个不同的模型组成，一个<em class="kp">发生器</em>和一个<em class="kp">鉴别器</em>。生成器本质上产生了看起来像训练图像的“假”图像。而鉴别器查看图像并给出来自发生器的输出是真实的训练图像还是虚假的图像。在训练过程中，生成器不断试图通过生成更好的假货来击败鉴别器，而鉴别器则在努力正确地对真假图像进行分类。</p><p id="fbaf" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我利用论文中提到的技术，从现有的数据中合成了新的MRI扫描，结果看起来很有希望。由于这是基于现有数据的伪MRI扫描，因此在将这些扫描灌输给实际现实世界医疗人工智能解决方案的培训之前，让实际医生验证这些扫描是合适的。</p><h1 id="aee4" class="js jt hh bd ju jv jw jx jy jz ka kb kc in kd io ke iq kf ir kg it kh iu ki kj bi translated">导入必要的库</h1><p id="ee87" class="pw-post-body-paragraph iw ix hh iy b iz kk ii jb jc kl il je jf km jh ji jj kn jl jm jn ko jp jq jr ha bi translated">这里的输入是一个3x64x64的RGB图像，作为大脑MRI扫描。</p><figure class="kr ks kt ku fd kv er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es kq"><img src="../Images/4ed3bcc481237f469f5f1b0ca8d3d97b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zkTsLvVQzpDW59s4-lH3Fw.png"/></div></div><figcaption class="lc ld et er es le lf bd b be z dx">Imports</figcaption></figure><h1 id="d66c" class="js jt hh bd ju jv jw jx jy jz ka kb kc in kd io ke iq kf ir kg it kh iu ki kj bi translated">定义输入和加载数据</h1><p id="b74d" class="pw-post-body-paragraph iw ix hh iy b iz kk ii jb jc kl il je jf km jh ji jj kn jl jm jn ko jp jq jr ha bi translated">在这里，我们定义了运行所需的一些输入，如dataroot，它是数据集文件夹的根目录的路径、工人数量、批处理大小、图像大小等。</p><figure class="kr ks kt ku fd kv er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es lg"><img src="../Images/d5a37e700f995af606a927ac40e936b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z0qqyZeRx6KaYYi7GO1hBQ.png"/></div></div><figcaption class="lc ld et er es le lf bd b be z dx">Defining Inputs</figcaption></figure><p id="3931" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在，我们使用ImageFolder dataset类加载数据集，这要求数据集的根文件夹中有子目录，因此要确保这一点。</p><p id="77c1" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们可以创建数据集，创建数据加载器，设置要运行的设备，最后可视化一些训练数据，如下所示:</p><figure class="kr ks kt ku fd kv er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es lh"><img src="../Images/2f47c4f43270d908dee9c7e44e93b215.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YCj0OSe3uxdxwgJmHFLRMA.png"/></div></div></figure><p id="3f87" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">它的输出看起来像这样:</p><figure class="kr ks kt ku fd kv er es paragraph-image"><div class="er es li"><img src="../Images/099ec32ac1afff271bbdd9a580f2ded5.png" data-original-src="https://miro.medium.com/v2/resize:fit:898/format:webp/1*fUHlgX7W3_2gCfZfHxSE5A.png"/></div></figure><p id="b47a" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这些基本上是来自我们DCGAN训练数据的一组图像。</p><h1 id="d8f2" class="js jt hh bd ju jv jw jx jy jz ka kb kc in kd io ke iq kf ir kg it kh iu ki kj bi translated">重量初始化</h1><p id="4fa2" class="pw-post-body-paragraph iw ix hh iy b iz kk ii jb jc kl il je jf km jh ji jj kn jl jm jn ko jp jq jr ha bi translated">从上面提到的论文中，作者规定所有的模型权重应该从均值=0，标准偏差=0.02的正态分布中随机初始化。<code class="du lj lk ll lm b">weights_init</code>函数将初始化的模型作为输入，并重新初始化我们将在训练中使用的所有卷积、卷积转置和批量归一化层，以满足该标准。该功能在初始化后立即应用于模型。</p><figure class="kr ks kt ku fd kv er es paragraph-image"><div class="er es ln"><img src="../Images/fa4448ec51b00a767eb46cd049679eeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1044/format:webp/1*3obhim00upYNoIcmUIbxBA.png"/></div></figure><h1 id="a031" class="js jt hh bd ju jv jw jx jy jz ka kb kc in kd io ke iq kf ir kg it kh iu ki kj bi translated">发电机</h1><p id="00ad" class="pw-post-body-paragraph iw ix hh iy b iz kk ii jb jc kl il je jf km jh ji jj kn jl jm jn ko jp jq jr ha bi translated">生成器<em class="kp"> G </em>被设计成将潜在空间向量(<em class="kp"> z </em>)映射到数据空间。由于我们的数据是图像，将<em class="kp"> z </em>转换到数据空间意味着最终创建一个与训练图像大小相同的RGB图像(即3x64x64)。</p><p id="4af6" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">下面是描述上述论文中的生成器的图像:</p><figure class="kr ks kt ku fd kv er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es lo"><img src="../Images/1b1efd4b0f8bf3c8c14652fcf5b2f034.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oRZC5Q9o5BxpsVgMm3JO8Q.png"/></div></div><figcaption class="lc ld et er es le lf bd b be z dx">source: pytorch.org</figcaption></figure><p id="4c01" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">上述架构的代码在这里实现:</p><figure class="kr ks kt ku fd kv er es paragraph-image"><div class="er es lp"><img src="../Images/e300b0ee57474b40446c64423c580abf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1272/format:webp/1*X5FM1kmM1tyXKrsYR32Odg.png"/></div><figcaption class="lc ld et er es le lf bd b be z dx">Generator G</figcaption></figure><p id="b367" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">请注意图像的大小是如何决定生成器(和鉴别器)的架构的，这里使用的是3x64x64图像，但是如果您希望使用其他大小，必须对生成器和鉴别器进行相应的更改。</p><p id="0842" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在，我们可以实例化生成器并应用<code class="du lj lk ll lm b">weights_init</code>函数。</p><figure class="kr ks kt ku fd kv er es paragraph-image"><div class="er es lq"><img src="../Images/2cf12797592129bdf8be8de8c5f24720.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*__x7uVuG7O7NiTYo8MHstg.png"/></div></figure><h1 id="538d" class="js jt hh bd ju jv jw jx jy jz ka kb kc in kd io ke iq kf ir kg it kh iu ki kj bi translated">鉴别器</h1><p id="f988" class="pw-post-body-paragraph iw ix hh iy b iz kk ii jb jc kl il je jf km jh ji jj kn jl jm jn ko jp jq jr ha bi translated">如前所述，鉴别器D是一个二进制分类网络，它将图像作为输入，并输出输入图像是真实图像(而不是伪造图像)的标量概率。这里，D获取一个3x64x64的输入图像，通过一系列Conv2d、BatchNorm2d和LeakyReLU层对其进行处理，并通过一个Sigmoid激活函数输出最终概率。</p><figure class="kr ks kt ku fd kv er es paragraph-image"><div class="er es lq"><img src="../Images/2fba133dc5550310da443a8d5ec790a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*GRw81jyLPqHai-qfYBe_WA.png"/></div><figcaption class="lc ld et er es le lf bd b be z dx">Discriminator D</figcaption></figure><p id="73d2" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">实例化鉴别器，</p><figure class="kr ks kt ku fd kv er es paragraph-image"><div class="er es lr"><img src="../Images/a79856521cac1f19916f92a0cac4187e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*msO0a0IW7A8j11pmgVroNQ.png"/></div></figure><h1 id="d9cf" class="js jt hh bd ju jv jw jx jy jz ka kb kc in kd io ke iq kf ir kg it kh iu ki kj bi translated">训练我们的DCGAN</h1><p id="a460" class="pw-post-body-paragraph iw ix hh iy b iz kk ii jb jc kl il je jf km jh ji jj kn jl jm jn ko jp jq jr ha bi translated">在我们开始训练之前，必须编写一小段代码来定义损失函数和优化器。本文中使用了相同的BCELoss函数。</p><figure class="kr ks kt ku fd kv er es paragraph-image"><div class="er es ls"><img src="../Images/a421cd14ee3ca78a64653a8533bf373c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1258/format:webp/1*vML6XI9hmXY0CDhT1gs7Ng.png"/></div></figure><p id="fd46" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">损失函数的公式为:</p><figure class="kr ks kt ku fd kv er es paragraph-image"><div class="er es lt"><img src="../Images/2b626fe2f8e6e200c4549e4d823466f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1390/format:webp/1*9AHtUwidwwQqrixSth2FkQ.png"/></div></figure><p id="23db" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">培训分为两个主要部分。第1部分更新鉴别器，第2部分更新生成器。</p><p id="df2c" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">首先，来自我们的训练集的一批真实样本向前通过鉴别器D，计算损失，然后计算向后通过的梯度。第二，用电流发生器产生一批假样本，并使这批样本正向通过D，再次计算损耗，并且<em class="kp">用反向通过累积</em>梯度。现在，随着所有真实批次和所有虚假批次的梯度累积，我们称之为鉴别器优化器的一个步骤。</p><p id="3fb5" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">正如在原始论文中所述，我们理想地想要通过最小化<em class="kp">log</em>(1—<em class="kp">D</em>(<em class="kp">G</em>(<em class="kp">z</em>))来训练生成器G，以努力生成更好的假货。这不能提供足够的梯度，尤其是在早期学习过程中。为了解决这个问题，我们转而关注最大化<em class="kp">log</em>(<em class="kp">D</em>(<em class="kp">G</em>(<em class="kp">z</em>))。</p><figure class="kr ks kt ku fd kv er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es lu"><img src="../Images/51581db11ed8419bf9d7af66651161cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WBktE5rsy2I0Gexy3IT1_g.png"/></div></div></figure><p id="17b3" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在训练循环中，我们将周期性地将这个固定噪声输入到<em class="kp"> G </em>中，并且在迭代过程中，我们将看到来自噪声的图像。</p><figure class="kr ks kt ku fd kv er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es lv"><img src="../Images/6abb10b6fcdaeb7723ccbd66166552d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lpSso7-Nk1YSwTqazrAu8Q.png"/></div></div></figure><h1 id="14d4" class="js jt hh bd ju jv jw jx jy jz ka kb kc in kd io ke iq kf ir kg it kh iu ki kj bi translated">结果</h1><p id="6f3a" class="pw-post-body-paragraph iw ix hh iy b iz kk ii jb jc kl il je jf km jh ji jj kn jl jm jn ko jp jq jr ha bi translated">正如我上面所说的，从一个正常人的角度来看，结果看起来足够有希望，但只有一个合适的医生才能为现实世界的医疗人工智能解决方案奠定基础。</p><figure class="kr ks kt ku fd kv er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es lw"><img src="../Images/9b475bdba689f52ec76c97db086d3cbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Aurb2wAJGMtf9FmnQnHYtg.png"/></div></div><figcaption class="lc ld et er es le lf bd b be z dx">The output of our DCGAN</figcaption></figure><p id="c337" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">本文中的代码受到了Nathan inka的DCGAN教程的启发，Nathan inka为上面提到的论文撰写了关于pytorch.org的教程。</p><div class="ly lz ez fb ma mb"><a rel="noopener follow" target="_blank" href="/mlearning-ai/mlearning-ai-submission-suggestions-b51e2b130bfb"><div class="mc ab dw"><div class="md ab me cl cj mf"><h2 class="bd hi fi z dy mg ea eb mh ed ef hg bi translated">Mlearning.ai提交建议</h2><div class="mi l"><h3 class="bd b fi z dy mg ea eb mh ed ef dx translated">如何成为Mlearning.ai上的作家</h3></div><div class="mj l"><p class="bd b fp z dy mg ea eb mh ed ef dx translated">medium.com</p></div></div><div class="mk l"><div class="ml l mm mn mo mk mp la mb"/></div></div></a></div></div></div>    
</body>
</html>