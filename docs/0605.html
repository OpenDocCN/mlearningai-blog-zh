<html>
<head>
<title>PyCaret</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PyCaret</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/pycaret-73b519e2d4d6?source=collection_archive---------1-----------------------#2021-05-24">https://medium.com/mlearning-ai/pycaret-73b519e2d4d6?source=collection_archive---------1-----------------------#2021-05-24</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><h2 id="582d" class="hf hg hh bd b fp hi hj hk hl hm hn dx ho translated" aria-label="kicker paragraph">开源机器学习库。</h2><div class=""/><div class=""><h2 id="a19a" class="pw-subtitle-paragraph in hq hh bd b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je dx translated">自动化评估和比较机器学习算法的关键步骤。</h2></div><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es jf"><img src="../Images/09609b2e62d900767b8f5c4252fc89be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EtnTL_xgKtkahi79J_sT-Q.png"/></div></div><figcaption class="jr js et er es jt ju bd b be z dx">ML-Classification Study with PyCaret</figcaption></figure><p id="5537" class="pw-post-body-paragraph jv jw hh jx b jy jz ir ka kb kc iu kd ke kf kg kh ki kj kk kl km kn ko kp kq ha bi kr translated">处理数据的人曾经说过，他们花了大部分时间清理数据。有时候我们会抱怨没有时间实现机器学习模型。我们试图找到许多问题的答案，例如，我应该使用哪种机器学习模型，哪种模型能给我最佳结果，哪些参数能给出最高结果，如何调整它们…等等。<br/>在这篇文章中，我将写一个神奇的python库，它将帮助你解决所有这些问题，并用几行代码节省大量时间。你已经注意到了文章的标题，并且猜到我会提到<strong class="jx hr"> PyCaret。</strong></p><p id="5544" class="pw-post-body-paragraph jv jw hh jx b jy jz ir ka kb kc iu kd ke kf kg kh ki kj kk kl km kn ko kp kq ha bi translated"><a class="ae la" href="https://pycaret.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx hr"> PyCaret </strong> </a>是一个开源的python机器学习库，灵感来自<a class="ae la" href="https://topepo.github.io/caret/" rel="noopener ugc nofollow" target="_blank"> caret R包</a>。我们可以从PyCaret自己的主页上简单说以下内容。</p><p id="23fb" class="pw-post-body-paragraph jv jw hh jx b jy jz ir ka kb kc iu kd ke kf kg kh ki kj kk kl km kn ko kp kq ha bi translated"><em class="lb"> "PyCaret是一个开源的、Python中的</em> <strong class="jx hr"> <em class="lb">低代码</em> </strong> <em class="lb">机器学习库，允许您在自己选择的笔记本电脑环境中，在几分钟内从准备数据到部署模型...这是一个简单易用的机器学习库，将帮助您用更少的代码行执行端到端的ML实验...”</em><a class="ae la" href="https://pycaret.org/" rel="noopener ugc nofollow" target="_blank"><em class="lb"/>T22】</a></p><p id="9212" class="pw-post-body-paragraph jv jw hh jx b jy jz ir ka kb kc iu kd ke kf kg kh ki kj kk kl km kn ko kp kq ha bi translated">该库的优点是，用很少的代码行和很少的手动配置就可以完成很多工作。PyCaret库自动化了机器学习项目的许多步骤，例如定义要执行的数据转换、评估和比较标准模型、调整模型超参数等等。</p><p id="760b" class="pw-post-body-paragraph jv jw hh jx b jy jz ir ka kb kc iu kd ke kf kg kh ki kj kk kl km kn ko kp kq ha bi translated">PyCaret基本上是几个机器学习库和框架的python包装器，如scikit-learn、XGBoost、CatBoost、LightGBM、spaCy、Optuna、Hyperopt、Ray等等。此外，所有这些图书馆都被很好地组织在一起。</p><p id="87c8" class="pw-post-body-paragraph jv jw hh jx b jy jz ir ka kb kc iu kd ke kf kg kh ki kj kk kl km kn ko kp kq ha bi translated">现在让我们测试一下这个python库可以在一个示例数据集上做什么。我将把所有模型应用到由Allison Horst 作为R包发布的帕尔默企鹅数据集上。它也成为了可爱的虹膜数据集的替代品。</p><p id="6f40" class="pw-post-body-paragraph jv jw hh jx b jy jz ir ka kb kc iu kd ke kf kg kh ki kj kk kl km kn ko kp kq ha bi translated">一如往常首先我们<a class="ae la" href="https://pycaret.readthedocs.io/en/latest/installation.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jx hr">安装pycaret </strong> </a>和<strong class="jx hr">导入</strong>必要的<strong class="jx hr">库</strong>。</p><pre class="jg jh ji jj fd lc ld le lf aw lg bi"><span id="ed02" class="lh li hh ld b fi lj lk l ll lm">#!pip install pycaret[full]</span><span id="316e" class="lh li hh ld b fi ln lk l ll lm">import numpy as np<br/>import pandas as pd<br/>from pycaret.regression import *</span></pre><p id="2d62" class="pw-post-body-paragraph jv jw hh jx b jy jz ir ka kb kc iu kd ke kf kg kh ki kj kk kl km kn ko kp kq ha bi translated">下一步是用python熊猫库加载企鹅数据集。</p><pre class="jg jh ji jj fd lc ld le lf aw lg bi"><span id="2847" class="lh li hh ld b fi lj lk l ll lm">df = pd.read_csv('penguins.csv')<br/>df.info()</span><span id="06b2" class="lh li hh ld b fi ln lk l ll lm">RangeIndex: 333 entries, 0 to 332<br/>Data columns (total 7 columns):<br/> #   Column             Non-Null Count  Dtype  <br/>---  ------             --------------  -----  <br/> 0   species            333 non-null    object <br/> 1   island             333 non-null    object <br/> 2   bill_length_mm     333 non-null    float64<br/> 3   bill_depth_mm      333 non-null    float64<br/> 4   flipper_length_mm  333 non-null    int64  <br/> 5   body_mass_g        333 non-null    int64  <br/> 6   sex                333 non-null    object <br/>dtypes: float64(2), int64(2), object(3)</span></pre><p id="7c20" class="pw-post-body-paragraph jv jw hh jx b jy jz ir ka kb kc iu kd ke kf kg kh ki kj kk kl km kn ko kp kq ha bi translated">数据集由4个数值特征、2个分类特征和1个目标特征组成。</p><p id="859f" class="pw-post-body-paragraph jv jw hh jx b jy jz ir ka kb kc iu kd ke kf kg kh ki kj kk kl km kn ko kp kq ha bi translated">PyCaret工作流总是从准备整个机器学习管道环境的<strong class="jx hr">设置功能</strong>开始。因此，<strong class="jx hr">设置</strong>必须在任何其他功能之前执行。</p><pre class="jg jh ji jj fd lc ld le lf aw lg bi"><span id="0f83" class="lh li hh ld b fi lj lk l ll lm">clf = <strong class="ld hr">setup(</strong><br/>            data=df, <br/>            target='sex', <br/>            session_id=44, <br/>            train_size=0.8<br/>           <strong class="ld hr">)</strong></span></pre><p id="b540" class="pw-post-body-paragraph jv jw hh jx b jy jz ir ka kb kc iu kd ke kf kg kh ki kj kk kl km kn ko kp kq ha bi translated">我们可以按照您的意愿定制设置功能，它有许多参数。默认值也很好，所以我只是通过给出必要的参数来启动这个函数。setup函数执行所有的数据预处理步骤。它还将数据分成训练集和测试集。</p><p id="fa9b" class="pw-post-body-paragraph jv jw hh jx b jy jz ir ka kb kc iu kd ke kf kg kh ki kj kk kl km kn ko kp kq ha bi translated">在这之后，PyCaret的魔力就开始了，一行代码<code class="du lo lp lq ld b"><strong class="jx hr">compare_models()</strong></code>中的<strong class="jx hr">比较了</strong>近20个模型，并以表格的形式返回结果。</p><pre class="jg jh ji jj fd lc ld le lf aw lg bi"><span id="7506" class="lh li hh ld b fi lj lk l ll lm"><strong class="ld hr">best_model =</strong> <strong class="ld hr">compare_models()</strong></span></pre><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es lr"><img src="../Images/a86185d7b2d67201822fe2f47488f13e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*htN76xAcZow1123dFL5pYw.jpeg"/></div></div><figcaption class="jr js et er es jt ju bd b be z dx">Results of compared models</figcaption></figure><p id="c95d" class="pw-post-body-paragraph jv jw hh jx b jy jz ir ka kb kc iu kd ke kf kg kh ki kj kk kl km kn ko kp kq ha bi translated">该功能训练模型库中的所有模型，并使用度量评估的<strong class="jx hr"> k倍交叉验证</strong>对其进行评分。输出会打印一个评分表，显示所有折叠的平均结果(默认为10)以及训练时间。</p><h2 id="ef06" class="lh li hh bd ls lt lu lv lw lx ly lz ma ke mb mc md ki me mf mg km mh mi mj hn bi translated">创建最佳模型</h2><p id="edb0" class="pw-post-body-paragraph jv jw hh jx b jy mk ir ka kb ml iu kd ke mm kg kh ki mn kk kl km mo ko kp kq ha bi translated">在任何模块中创建模型就像编写<strong class="jx hr"> create_model一样简单。<em class="lb"> </em> </strong>它只有一个参数，即型号名称作为字符串。</p><pre class="jg jh ji jj fd lc ld le lf aw lg bi"><span id="6193" class="lh li hh ld b fi lj lk l ll lm"><em class="lb"># create an Extreme Gradient Boosting model</em><br/>xgboost = create_model("xgboost")</span></pre><h2 id="64b1" class="lh li hh bd ls lt lu lv lw lx ly lz ma ke mb mc md ki me mf mg km mh mi mj hn bi translated">超参数调谐</h2><p id="2832" class="pw-post-body-paragraph jv jw hh jx b jy mk ir ka kb ml iu kd ke mm kg kh ki mn kk kl km mo ko kp kq ha bi translated"><em class="lb">当使用create_model函数创建模型时，它使用默认超参数来训练模型。</em> <strong class="jx hr"> <em class="lb">要调整超参数</em> </strong> <em class="lb">，使用</em> <code class="du lo lp lq ld b"><strong class="jx hr">tune_model()</strong></code> <em class="lb">功能。</em></p><pre class="jg jh ji jj fd lc ld le lf aw lg bi"><span id="b095" class="lh li hh ld b fi lj lk l ll lm">tuned_xgboost = <strong class="ld hr">tune_model(</strong>xgboost<strong class="ld hr">)</strong></span></pre><figure class="jg jh ji jj fd jk er es paragraph-image"><div class="er es mp"><img src="../Images/c8a7a4c76c4c5ef9b335e355ac48159f.png" data-original-src="https://miro.medium.com/v2/resize:fit:968/format:webp/1*vjZXozTAPquzYwuVa7rCOQ.jpeg"/></div><figcaption class="jr js et er es jt ju bd b be z dx">Results after tuning the parameters</figcaption></figure><p id="7271" class="pw-post-body-paragraph jv jw hh jx b jy jz ir ka kb kc iu kd ke kf kg kh ki kj kk kl km kn ko kp kq ha bi translated">该功能使用<code class="du lo lp lq ld b">Random Grid Search</code>预定义的搜索空间自动调整模型的超参数。输出打印一个得分网格，按折叠显示结果。要使用定制的搜索网格，您可以在<code class="du lo lp lq ld b">tune_model</code>函数中传递<code class="du lo lp lq ld b">custom_grid</code>参数。</p><h2 id="7c28" class="lh li hh bd ls lt lu lv lw lx ly lz ma ke mb mc md ki me mf mg km mh mi mj hn bi translated">分析模型</h2><p id="7cdc" class="pw-post-body-paragraph jv jw hh jx b jy mk ir ka kb ml iu kd ke mm kg kh ki mn kk kl km mo ko kp kq ha bi translated">分析经过训练的机器学习模型的性能是任何机器学习工作流程中不可或缺的一步。分析模型性能就像写<code class="du lo lp lq ld b"><strong class="jx hr">plot_model()</strong></code>一样简单。该函数将训练好的模型对象和绘图类型作为函数<code class="du lo lp lq ld b">plot_model()</code>中的字符串。</p><pre class="jg jh ji jj fd lc ld le lf aw lg bi"><span id="82d6" class="lh li hh ld b fi lj lk l ll lm">plot_model(tuned_xgboost, plot = 'confusion_matrix'</span></pre><figure class="jg jh ji jj fd jk er es paragraph-image"><div class="er es mq"><img src="../Images/499ac8408ac63abe86f244e0405d55ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1128/format:webp/1*3UBPwSHRc2oKprV8oqIhng.png"/></div></figure><pre class="jg jh ji jj fd lc ld le lf aw lg bi"><span id="a230" class="lh li hh ld b fi lj lk l ll lm">plot_model(tuned_xgboost, plot = 'boundary')</span></pre><figure class="jg jh ji jj fd jk er es paragraph-image"><div class="er es mr"><img src="../Images/d3328293883b67bcc1199cf44409de96.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/format:webp/1*Fvx1acoBOw9n2ThZGwRDSg.png"/></div></figure><pre class="jg jh ji jj fd lc ld le lf aw lg bi"><span id="80f4" class="lh li hh ld b fi lj lk l ll lm">pplot_model(tuned_xgboost, plot = 'class_report')</span></pre><figure class="jg jh ji jj fd jk er es paragraph-image"><div class="er es ms"><img src="../Images/170b643c76b54cb1b24bb9eb76858250.png" data-original-src="https://miro.medium.com/v2/resize:fit:1044/format:webp/1*JWtpXmYixH5CnJ8RquqkLQ.png"/></div></figure><h2 id="1b74" class="lh li hh bd ls lt lu lv lw lx ly lz ma ke mb mc md ki me mf mg km mh mi mj hn bi translated">预测并最终确定模型</h2><p id="bf35" class="pw-post-body-paragraph jv jw hh jx b jy mk ir ka kb ml iu kd ke mm kg kh ki mn kk kl km mo ko kp kq ha bi translated">测试由PyCaret在设置中自动分割的剩余20%的数据组成，重要的是要看到模型没有过度拟合。现在我们将使用<code class="du lo lp lq ld b"><strong class="jx hr">predict_model()</strong></code>函数，该函数用于对未知数据集进行预测。</p><pre class="jg jh ji jj fd lc ld le lf aw lg bi"><span id="2706" class="lh li hh ld b fi lj lk l ll lm"><em class="lb"># Make predictions on the test set</em><br/>predict_model(tuned_xgboost)</span></pre><figure class="jg jh ji jj fd jk er es paragraph-image"><div class="er es mt"><img src="../Images/ea6ab90d4c2c5619546e73415c0ed46e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1272/format:webp/1*XnflQYxrj3ED8UntU9NwvQ.jpeg"/></div><figcaption class="jr js et er es jt ju bd b be z dx">Results of unseen data</figcaption></figure><p id="c33e" class="pw-post-body-paragraph jv jw hh jx b jy jz ir ka kb kc iu kd ke kf kg kh ki kj kk kl km kn ko kp kq ha bi translated"><code class="du lo lp lq ld b"><strong class="jx hr">finalize_model()</strong></code>函数将模型拟合到完整的数据集上，包括测试/保留样本(本例中为20%)。该函数旨在将模型部署到生产环境之前，在完整的数据集上对其进行训练。</p><pre class="jg jh ji jj fd lc ld le lf aw lg bi"><span id="abf9" class="lh li hh ld b fi lj lk l ll lm"><em class="lb"># Finalize the model</em><br/>finalized_xgboost = finalize_model(tuned_xgboost)</span></pre><p id="1077" class="pw-post-body-paragraph jv jw hh jx b jy jz ir ka kb kc iu kd ke kf kg kh ki kj kk kl km kn ko kp kq ha bi translated">当使用最终确定模型时，包括测试/保留集在内的整个数据集将用于定型。如果在使用了<code class="du lo lp lq ld b">finalize_model()</code>后，该模型用于对拒绝集的预测，结果将会误导，因为您试图预测的数据与用于训练的数据相同。</p><h2 id="df8f" class="lh li hh bd ls lt lu lv lw lx ly lz ma ke mb mc md ki me mf mg km mh mi mj hn bi translated">保存并加载模型</h2><p id="2fe4" class="pw-post-body-paragraph jv jw hh jx b jy mk ir ka kb ml iu kd ke mm kg kh ki mn kk kl km mo ko kp kq ha bi translated">PyCaret的内置函数<code class="du lo lp lq ld b"><strong class="jx hr">save_model()</strong></code>允许我们<strong class="jx hr">将模型</strong>以及整个转换管道和经过训练的模型对象保存为可转移的二进制<strong class="jx hr"> pickle </strong>文件以备后用。</p><pre class="jg jh ji jj fd lc ld le lf aw lg bi"><span id="9ba7" class="lh li hh ld b fi lj lk l ll lm"><em class="lb"># Save the final model</em><br/><strong class="ld hr">save_model(</strong>finalized_xgboost, 'penguins_xgboost_v4'<strong class="ld hr">)</strong></span></pre><p id="245b" class="pw-post-body-paragraph jv jw hh jx b jy jz ir ka kb kc iu kd ke kf kg kh ki kj kk kl km kn ko kp kq ha bi translated"><strong class="jx hr">为了在将来的某一天在同一个或另一个环境中加载一个已保存的模型</strong>，我们将使用PyCaret的<code class="du lo lp lq ld b"><strong class="jx hr">load_model()</strong></code>函数，然后轻松地将已保存的模型应用于新的未知数据进行预测。</p><pre class="jg jh ji jj fd lc ld le lf aw lg bi"><span id="acae" class="lh li hh ld b fi lj lk l ll lm">(Pipeline(memory=None,<br/>          steps=[('dtypes',<br/>                  DataTypes_Auto_infer(categorical_features=[],<br/>                                       display_types=True, features_todrop=[],<br/>                                       id_columns=[],<br/>                                       ml_usecase='classification',<br/>                                       numerical_features=[], target='species',<br/>                                       time_features=[])),<br/>                 ('imputer',<br/>                  Simple_Imputer(categorical_strategy='not_available',<br/>                                 fill_value_categorical=None,<br/>                                 fill_value_numerical=None,<br/>                                 numeric_stra...<br/>                                interaction_constraints='', learning_rate=0.4,<br/>                                max_delta_step=0, max_depth=8,<br/>                                min_child_weight=3, missing=nan,<br/>                                monotone_constraints='()', n_estimators=140,<br/>                                n_jobs=-1, num_parallel_tree=1,<br/>                                objective='multi:softprob', random_state=44,<br/>                                reg_alpha=0.1, reg_lambda=1e-07,<br/>                                scale_pos_weight=12.100000000000001, subsample=1,<br/>                                tree_method='auto', use_label_encoder=True,<br/>                                validate_parameters=1, verbosity=0)]],<br/>          verbose=False),<br/> 'finalized_xgboost_model_2021-04-11 12:39.pkl')</span></pre><p id="1177" class="pw-post-body-paragraph jv jw hh jx b jy jz ir ka kb kc iu kd ke kf kg kh ki kj kk kl km kn ko kp kq ha bi translated">如果你有时间和高计算处理系统(GPU或TPUs)，你可以很容易地用PyCaret尝试和应用系综和堆栈模型。</p><p id="6aa0" class="pw-post-body-paragraph jv jw hh jx b jy jz ir ka kb kc iu kd ke kf kg kh ki kj kk kl km kn ko kp kq ha bi translated">您可以从<a class="ae la" href="https://github.com/pycaret/pycaret/blob/master/docs/source/index.rst" rel="noopener ugc nofollow" target="_blank">资源</a>中访问所有这些测试以及更多内容。开心点，继续用PyCaret编码…</p><p id="098c" class="pw-post-body-paragraph jv jw hh jx b jy jz ir ka kb kc iu kd ke kf kg kh ki kj kk kl km kn ko kp kq ha bi translated"><strong class="jx hr">T14】资源:T16】</strong></p><ul class=""><li id="d262" class="mu mv hh jx b jy jz kb kc ke mw ki mx km my kq mz na nb nc bi translated"><a class="ae la" href="https://www.pycaret.org/" rel="noopener ugc nofollow" target="_blank">https://www.pycaret.org</a></li><li id="6483" class="mu mv hh jx b jy nd kb ne ke nf ki ng km nh kq mz na nb nc bi translated"><a class="ae la" href="https://pycaret.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">https://pycaret.readthedocs.io/en/latest/</a></li><li id="3602" class="mu mv hh jx b jy nd kb ne ke nf ki ng km nh kq mz na nb nc bi translated">【https://www.kaggle.com/ml-classification-study-with-pycaret】</li></ul></div></div>    
</body>
</html>