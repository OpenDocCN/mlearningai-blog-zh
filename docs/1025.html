<html>
<head>
<title>Modified Genetic Algorithm to solve the Zero-One Knapsack Problem: Implementation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">求解0-1背包问题的改进遗传算法:实现</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/modified-genetic-algorithm-to-solve-the-zero-one-knapsack-problem-implementation-72d85c1c72?source=collection_archive---------3-----------------------#2021-09-17">https://medium.com/mlearning-ai/modified-genetic-algorithm-to-solve-the-zero-one-knapsack-problem-implementation-72d85c1c72?source=collection_archive---------3-----------------------#2021-09-17</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/03c9084bc86edd676b3a503c6c9a9c5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_JgW7MR5Osg5PqSX.jpg"/></div></div></figure><p id="5711" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi jn translated">这篇文章是我关于用遗传算法解决0-1背包问题的系列文章的第四部分，也是最后一部分。</p><p id="d919" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><a class="ae jw" href="https://shashank3199.medium.com/genetic-algorithms-to-solve-the-zero-one-knapsack-problem-d38856beaa35" rel="noopener">的第一篇文章</a>向我们介绍了一般的遗传算法，以及它们如何适用于0-1背包问题。<br/><a class="ae jw" href="https://shashank3199.medium.com/genetic-algorithms-to-solve-the-zero-one-knapsack-problem-implementation-26c1982f44b3" rel="noopener">第二篇文章</a>然后带我们通过传统的遗传算法来解决这个问题。<br/><a class="ae jw" href="https://shashank3199.medium.com/modified-genetic-algorithm-to-solve-the-zero-one-knapsack-problem-cc2f76d0050f" rel="noopener">第三篇文章</a>讲述了解决该问题的新方法，该方法使用了一种受其他两种变体启发的遗传算法的修改版本，即基于重启的遗传算法和孤岛遗传算法。<br/>请在继续之前阅读这些文章，以便更好地理解这个概念。</p><figure class="jy jz ka kb fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es jx"><img src="../Images/a7e909ec75ec6e60c2433581abbebeb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*8KDX-AuW0FHiioInmUZKMw.gif"/></div></div></figure><p id="c8cc" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">改进的遗传算法工作原理概述:上图有多个局部极小值，这对传统方法构成了威胁。为了解决这个问题，我们首先将图的x轴(即搜索空间)分成“M”个子集，每个子集具有“subM”个群体大小。接下来，我们对每个子集运行“M”个并行遗传算法。这给了我们每个“M”子集的局部最小值。然后，我们使用这些“M”个获胜者作为我们的种群，并在这个“优势种群”上运行外部遗传算法，以找到全局最小值。</p><p id="8daf" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这篇文章中，我们将把重点放在实现基于重启、孤岛和修改版本的遗传算法上。在继续之前，如果你不习惯Python和Numpy，我推荐下面的Youtube播放列表和视频-</p><ul class=""><li id="849d" class="kc kd hh ir b is it iw ix ja ke je kf ji kg jm kh ki kj kk bi translated"><a class="ae jw" href="https://www.youtube.com/playlist?list=PLi01XoE8jYohWFPpC17Z-wWhPOSuh8Er-" rel="noopener ugc nofollow" target="_blank"> Python编程教程播放列表</a> by <a class="ae jw" href="https://www.youtube.com/c/Socratica" rel="noopener ugc nofollow" target="_blank">苏格拉底</a>。</li><li id="dabf" class="kc kd hh ir b is kl iw km ja kn je ko ji kp jm kh ki kj kk bi translated"><a class="ae jw" href="https://youtu.be/QUT1VHiLmmI" rel="noopener ugc nofollow" target="_blank"> Python Numpy教程</a>作者<a class="ae jw" href="https://www.youtube.com/channel/UC8butISFwT-Wl7EV0hUK0BQ" rel="noopener ugc nofollow" target="_blank">freecodecamp.org</a></li></ul><p id="c669" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您可以在本系列文章的第二部分找到对效用函数的解释，即“获取基因组序列”、“获取基因组值”和“适应度函数”。你可以在这里找到文章<a class="ae jw" href="https://faun.pub/genetic-algorithms-to-solve-the-zero-one-knapsack-problem-implementation-26c1982f44b3" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="1766" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">所以事不宜迟，让我们从代码开始…</p><h1 id="afe8" class="kq kr hh bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">重启-基本遗传算法类-</h1><figure class="jy jz ka kb fd ii"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="67aa" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">该类由以下成员变量组成，这些变量使用“<strong class="ir hi"> super()进行初始化。__词典_ _。</strong>(kwargs)更新“声明——</p><ul class=""><li id="d3e0" class="kc kd hh ir b is it iw ix ja ke je kf ji kg jm kh ki kj kk bi translated"><em class="lq">循环:</em>迭代的最大代数。</li><li id="f274" class="kc kd hh ir b is kl iw km ja kn je ko ji kp jm kh ki kj kk bi translated"><em class="lq">基因组大小:</em>基因型的大小即背包中物品的数量。</li><li id="4a66" class="kc kd hh ir b is kl iw km ja kn je ko ji kp jm kh ki kj kk bi translated"><em class="lq">种群规模:</em>每一代的个体数量。</li><li id="5b1f" class="kc kd hh ir b is kl iw km ja kn je ko ji kp jm kh ki kj kk bi translated"><em class="lq">交叉方案:</em>要执行的交叉操作的类型。</li><li id="3f29" class="kc kd hh ir b is kl iw km ja kn je ko ji kp jm kh ki kj kk bi translated"><em class="lq">变异方案:</em>要执行的变异操作的类型。</li><li id="3a9f" class="kc kd hh ir b is kl iw km ja kn je ko ji kp jm kh ki kj kk bi translated"><em class="lq">适应度函数:</em>用于评估个人素质的函数。</li><li id="728f" class="kc kd hh ir b is kl iw km ja kn je ko ji kp jm kh ki kj kk bi translated"><em class="lq">种子范围:</em>基因组值范围即个体的最小十进制值和个体的最大十进制值。</li><li id="a2e2" class="kc kd hh ir b is kl iw km ja kn je ko ji kp jm kh ki kj kk bi translated"><em class="lq">编码功能:</em>用于将基因组序列编码为基因组值的功能。</li><li id="8a9e" class="kc kd hh ir b is kl iw km ja kn je ko ji kp jm kh ki kj kk bi translated"><em class="lq">解码功能:</em>用于将基因组值解码为基因组序列的功能。</li></ul><h1 id="4a3b" class="kq kr hh bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">驱动方法-</h1><figure class="jy jz ka kb fd ii"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="56ee" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">“<strong class="ir hi">驱动</strong>方法就像是我们类的主要函数。这就是遗传算法各阶段的方法被调用的地方。对于每个周期，初始化一个新的种群，然后我们运行一个"<strong class="ir hi"><em class="lq"/></strong><em class="lq">"</em><strong class="ir hi"><em class="lq">而循环</em> </strong> <em class="lq"> </em>，执行"<strong class="ir hi">选择</strong>"、"<strong class="ir hi">交叉</strong>"和"<strong class="ir hi">突变</strong>"直到只剩下一个幸存者。</p><p id="9e75" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在<strong class="ir hi"> <em class="lq">【生存】</em> </strong>循环内，我们有重启-基础条件，即-</p><ul class=""><li id="aad8" class="kc kd hh ir b is it iw ix ja ke je kf ji kg jm kh ki kj kk bi translated">我们生成一个介于0和1之间的随机浮点值，对照设置的阈值重启率(默认为0.995)进行检查；或者</li><li id="765d" class="kc kd hh ir b is kl iw km ja kn je ko ji kp jm kh ki kj kk bi translated">我们检查这个群体的获胜者基因组是否满足一个阈值。</li></ul><p id="f220" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">注意:</strong>阈值条件可以基于权重向量或值向量来计算。当我们看函数调用时，我们会更好地理解这一点。</p><p id="845a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果上述任何标准评估为真，我们用随机生成的群体增加群体，并继续生存循环。当这个<em class="lq">生存循环</em>结束时，我们将胜利者的基因组保存在一个单独的列表中。<br/>这种生存循环重复了几代，每个获胜者的基因组都被添加到列表中。然后，我们返回具有最高适应值的基因组，遗传算法循环结束。</p><h1 id="00ed" class="kq kr hh bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">主运行-</h1><figure class="jy jz ka kb fd ii"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="8bff" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这里，我们将JSON文件中的值加载到背包对象中，并初始化基于重启的遗传算法对象。然后我们调用驱动方法，打印出胜利者的基因组。</p><p id="9377" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">注:</strong>在第24行，我们使用背包对象的权重作为阈值向量，背包容量的75%作为阈值。这意味着，如果我们的赢家基因组在任何循环迭代中没有填满背包的至少75%,那么我们在向种群中添加更多成员后继续生存循环。</p><h1 id="7d88" class="kq kr hh bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated"><strong class="ak">输出- </strong></h1><pre class="jy jz ka kb fd lr ls lt lu aw lv bi"><span id="991b" class="lw kr hh ls b fi lx ly l lz ma">Capacity: 4098</span><span id="91b9" class="lw kr hh ls b fi mb ly l lz ma">Number of Items: 15</span><span id="1b83" class="lw kr hh ls b fi mb ly l lz ma">Weights: [29, 75, 118, 215, 311, 330, 334, 368, 431, 536, 697, 935, 1059, 1170, 1366]</span><span id="22c9" class="lw kr hh ls b fi mb ly l lz ma">Values: [71, 155, 217, 324, 431, 493, 499, 543, 609, 752, 936, 1189, 1349, 1479, 1693]</span><span id="4f8e" class="lw kr hh ls b fi mb ly l lz ma">100%|███████████████████████████████| 5/5 [00:01&lt;00:00, 4.21it/s]</span><span id="e4e8" class="lw kr hh ls b fi mb ly l lz ma">Sequence: [1 1 1 1 0 1 1 1 1 1 1 1 0 0 0]</span><span id="a89d" class="lw kr hh ls b fi mb ly l lz ma">Genome Value: 31736</span><span id="fe49" class="lw kr hh ls b fi mb ly l lz ma">Profit: 5788</span><span id="b453" class="lw kr hh ls b fi mb ly l lz ma">Capacity Used: 4068</span></pre></div><div class="ab cl mc md go me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ha hb hc hd he"><h1 id="c673" class="kq kr hh bd ks kt mj kv kw kx mk kz la lb ml ld le lf mm lh li lj mn ll lm ln bi translated">岛屿遗传算法类-</h1><figure class="jy jz ka kb fd ii"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="2782" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">该类由与基于重启的遗传算法相同的成员变量组成，该算法使用“<strong class="ir hi"> super()初始化。__词典_ _。</strong>【更新(kwargs)】语句。</p><p id="751b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">注意:</strong>我们使用的是<strong class="ir hi"> ThreadPoolExecutor </strong>和<strong class="ir hi">而不是</strong><strong class="ir hi">ProcessPoolExecutor</strong>，因为前者在主进程内的<em class="lq">单独线程中运行你的每个工作线程，而后者在它们自己单独的<em class="lq">子进程</em>中运行你的每个工作线程。<br/>这在某种意义上影响了我们的程序，如果我们为程序使用不同的子进程，我们不能在子进程之间共享对象变量，这会导致pickling错误异常。</em></p><h1 id="50b0" class="kq kr hh bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">交叉变异成员-</h1><figure class="jy jz ka kb fd ii"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="ecf1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">该函数充当交叉和变异步骤的组合函数。这样做是为了简化穿线过程。组合器函数充当每个线程需要执行的函数的串行管道。</p><h1 id="af72" class="kq kr hh bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">驱动方法-</h1><figure class="jy jz ka kb fd ii"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="8e39" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">“<strong class="ir hi">驱动</strong>”方法是我们类的主要函数。这就是遗传算法各阶段的方法被调用的地方。对于每个周期，初始化一个新的种群，然后我们运行一个“<strong class="ir hi"><em class="lq"/></strong><em class="lq"/><strong class="ir hi"><em class="lq">while循环</em> </strong> <em class="lq"> </em>，它执行“<strong class="ir hi">选择</strong>”、“<strong class="ir hi">交叉</strong> _ <strong class="ir hi">突变</strong>”和<strong class="ir hi">种群联合</strong>，直到只剩下一个幸存者。让我们来探讨一下“<strong class="ir hi">交叉</strong> _ <strong class="ir hi">变异</strong>逐步”的线程</p><ul class=""><li id="c2f6" class="kc kd hh ir b is it iw ix ja ke je kf ji kg jm kh ki kj kk bi translated"><strong class="ir hi"> <em class="lq">第一步:</em> </strong>我们创建一个ThreadPoolExecutor对象。</li><li id="d867" class="kc kd hh ir b is kl iw km ja kn je ko ji kp jm kh ki kj kk bi translated"><strong class="ir hi"> <em class="lq">步骤2: </em> </strong>接下来我们创建一个线程列表，其中每个线程都被提供了一个管道方法及其输入参数。</li><li id="f6f9" class="kc kd hh ir b is kl iw km ja kn je ko ji kp jm kh ki kj kk bi translated"><strong class="ir hi"> <em class="lq">第三步:</em> </strong>然后，我们在线程列表上运行"<strong class="ir hi"> as_completed </strong>"方法，这是一个阻塞操作，当线程完成时产生线程。</li><li id="b132" class="kc kd hh ir b is kl iw km ja kn je ko ji kp jm kh ki kj kk bi translated"><strong class="ir hi"> <em class="lq">第四步:</em> </strong>每个线程完成后使用“<strong class="ir hi"> result </strong>”方法返回其结果，然后将其添加到一个列表中。</li></ul><p id="1803" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">种群并集</strong>操作基本上是对“<strong class="ir hi">交叉_变异</strong>的并行线程产生的种群的并集操作。</p><h1 id="07ce" class="kq kr hh bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">主运行-</h1><figure class="jy jz ka kb fd ii"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="dd47" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这里，我们将JSON文件中的值加载到背包对象中，并初始化孤岛遗传算法对象。然后我们调用驱动方法，打印出胜利者的基因组。</p><p id="70b4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">注意:</strong>在第24行，第一个参数对应于“<strong class="ir hi"> selection_rate </strong>”，即从一个生存循环迭代向前移动的人口百分比。第二个参数对应于要创建的线程数量，即要并行执行的“<strong class="ir hi"> crossover_mutation </strong>”操作的数量。数字越大，进化的多样性就越大。但是这伴随着由于人口增长而引起的较小的开销。</p><h1 id="b996" class="kq kr hh bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">输出-</h1><pre class="jy jz ka kb fd lr ls lt lu aw lv bi"><span id="20c6" class="lw kr hh ls b fi lx ly l lz ma">Capacity: 4098</span><span id="4589" class="lw kr hh ls b fi mb ly l lz ma">Number of Items: 15</span><span id="9a6f" class="lw kr hh ls b fi mb ly l lz ma">Weights: [29, 75, 118, 215, 311, 330, 334, 368, 431, 536, 697, 935, 1059, 1170, 1366]</span><span id="b390" class="lw kr hh ls b fi mb ly l lz ma">Values: [71, 155, 217, 324, 431, 493, 499, 543, 609, 752, 936, 1189, 1349, 1479, 1693]</span><span id="6138" class="lw kr hh ls b fi mb ly l lz ma">100%|███████████████████████████████| 20/20 [00:00&lt;00:00, 27.56it/s]</span><span id="5567" class="lw kr hh ls b fi mb ly l lz ma">Sequence: [1 1 1 1 0 1 1 1 1 1 1 1 0 0 0]</span><span id="7e9d" class="lw kr hh ls b fi mb ly l lz ma">Genome Value: 31736</span><span id="944b" class="lw kr hh ls b fi mb ly l lz ma">Profit: 5788</span><span id="21d9" class="lw kr hh ls b fi mb ly l lz ma">Capacity Used: 4068</span></pre></div><div class="ab cl mc md go me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ha hb hc hd he"><h1 id="a126" class="kq kr hh bd ks kt mj kv kw kx mk kz la lb ml ld le lf mm lh li lj mn ll lm ln bi translated">改进的遗传算法类</h1><p id="890b" class="pw-post-body-paragraph ip iq hh ir b is mo iu iv iw mp iy iz ja mq jc jd je mr jg jh ji ms jk jl jm ha bi translated">在继续看代码之前，让我们看一下这个算法的伪代码。</p><figure class="jy jz ka kb fd ii er es paragraph-image"><div class="er es mt"><img src="../Images/f0e9fea052ce8ef04626d6635a01da78.png" data-original-src="https://miro.medium.com/v2/resize:fit:732/format:webp/1*akz80Vdrx3ntG3eB0esoGw.png"/></div></figure><p id="163d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在让我们继续编码-</p><figure class="jy jz ka kb fd ii"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="ffae" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">该类由以下成员变量组成，这些变量使用“<strong class="ir hi"> self”进行初始化。__词典_ _。更新(kwargs) </strong>"声明-</p><ul class=""><li id="a302" class="kc kd hh ir b is it iw ix ja ke je kf ji kg jm kh ki kj kk bi translated"><em class="lq">循环:</em>迭代的最大代数。</li><li id="a1fe" class="kc kd hh ir b is kl iw km ja kn je ko ji kp jm kh ki kj kk bi translated">m并行:要执行的并行线程的数量，即搜索空间的划分数量。</li><li id="c1e2" class="kc kd hh ir b is kl iw km ja kn je ko ji kp jm kh ki kj kk bi translated"><em class="lq">基因组大小:</em>基因型的大小，即背包中物品的数量。</li><li id="e68c" class="kc kd hh ir b is kl iw km ja kn je ko ji kp jm kh ki kj kk bi translated">内部遗传算法数据:用于初始化子遗传算法的数据成员值，与用于重启基本、孤立和传统遗传算法的数据成员值相同。</li></ul><p id="ff11" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们运行一个循环来初始化遗传算法对象，同时指定它们各自搜索空间的范围。</p><h1 id="5e8f" class="kq kr hh bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">生成超级人口方法-</h1><figure class="jy jz ka kb fd ii"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="0df7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这个方法是一个迭代器。它通过运行每个子种群线程返回优势种群，每个子种群线程在它们各自的搜索空间分区上运行独立的遗传算法。这以类似于岛遗传算法驱动程序方法的方式实现。</p><h2 id="e12c" class="lw kr hh bd ks mu mv mw kw mx my mz la ja na nb le je nc nd li ji ne nf lm ng bi translated">驱动方法-</h2><figure class="jy jz ka kb fd ii"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="de68" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">“<strong class="ir hi">驱动</strong>方法是我们类的主要函数。这就是遗传算法各阶段的方法被调用的地方。对于每一个循环，一个新的种群被初始化，然后我们运行一个“<strong class="ir hi"><em class="lq"/></strong><em class="lq"/><strong class="ir hi"><em class="lq">而循环</em> </strong> <em class="lq"> </em>执行“<strong class="ir hi">选择</strong>”、“<strong class="ir hi">交叉</strong>”和“<strong class="ir hi">变异</strong>”，直到只剩下一个幸存者。这是一个基于重启的遗传算法的精确实现，唯一的区别是，不是运行“<strong class="ir hi"> init_population </strong>方法，而是使用一个新的优势种群，如前所述，通过使用“<strong class="ir hi">generate _ superior _ population</strong>方法生成。</p><p id="4513" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">主运行- </strong></p><figure class="jy jz ka kb fd ii"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="2523" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这里，我们将JSON文件中的值加载到背包对象中，并用外部遗传算法数据和内部遗传算法数据初始化修改后的遗传算法对象。然后我们调用驱动方法，打印出胜利者的基因组。</p><h1 id="7f93" class="kq kr hh bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">输出-</h1><pre class="jy jz ka kb fd lr ls lt lu aw lv bi"><span id="dcb3" class="lw kr hh ls b fi lx ly l lz ma">Capacity: 4098</span><span id="317a" class="lw kr hh ls b fi mb ly l lz ma">Number of Items: 15</span><span id="4756" class="lw kr hh ls b fi mb ly l lz ma">Weights: [29, 75, 118, 215, 311, 330, 334, 368, 431, 536, 697, 935, 1059, 1170, 1366]</span><span id="fed7" class="lw kr hh ls b fi mb ly l lz ma">Values: [71, 155, 217, 324, 431, 493, 499, 543, 609, 752, 936, 1189, 1349, 1479, 1693]</span><span id="d76f" class="lw kr hh ls b fi mb ly l lz ma">100%|███████████████████████████████| 5/5 [00:01&lt;00:00, 5.17it/s]</span><span id="61bc" class="lw kr hh ls b fi mb ly l lz ma">Sequence: [1 1 1 1 0 1 1 1 1 1 1 1 0 0 0]</span><span id="6fe3" class="lw kr hh ls b fi mb ly l lz ma">Genome Value: 31736</span><span id="863b" class="lw kr hh ls b fi mb ly l lz ma">Profit: 5788</span><span id="9679" class="lw kr hh ls b fi mb ly l lz ma">Capacity Used: 4068</span></pre></div><div class="ab cl mc md go me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ha hb hc hd he"><p id="c9a8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="lq">这里</em>  <em class="lq">可以找到完整的python实现</em> <a class="ae jw" href="https://github.com/shashank3199/GeneticAlgorithm-ZeroOneKnapsack" rel="noopener ugc nofollow" target="_blank"> <em class="lq">。如果你觉得这篇文章很有帮助，请跟我上</em> </a><a class="ae jw" href="https://shashank-goyal-blogs.medium.com/" rel="noopener"> <em class="lq">中</em> </a> <em class="lq">和</em><a class="ae jw" href="https://github.com/shashank3199/" rel="noopener ugc nofollow" target="_blank"><em class="lq">GitHub</em></a><em class="lq">和star</em><a class="ae jw" href="https://github.com/shashank3199/GeneticAlgorithm-ZeroOneKnapsack" rel="noopener ugc nofollow" target="_blank"><em class="lq">项目库</em> </a> <em class="lq">。</em></p></div><div class="ab cl mc md go me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ha hb hc hd he"><p id="91e3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">请查看本系列文章的其他部分</p><ul class=""><li id="f638" class="kc kd hh ir b is it iw ix ja ke je kf ji kg jm kh ki kj kk bi translated"><strong class="ir hi"> <em class="lq">第一部分:</em> </strong> <a class="ae jw" href="https://shashank3199.medium.com/genetic-algorithms-to-solve-the-zero-one-knapsack-problem-d38856beaa35" rel="noopener">遗传算法求解零一背包问题</a>。</li><li id="41d2" class="kc kd hh ir b is kl iw km ja kn je ko ji kp jm kh ki kj kk bi translated"><strong class="ir hi"> <em class="lq">第二部分:</em> </strong> <a class="ae jw" href="https://shashank3199.medium.com/genetic-algorithms-to-solve-the-zero-one-knapsack-problem-implementation-26c1982f44b3" rel="noopener">遗传算法求解零一背包问题:实现</a>。</li><li id="fef5" class="kc kd hh ir b is kl iw km ja kn je ko ji kp jm kh ki kj kk bi translated"><strong class="ir hi"> <em class="lq">第三部分:</em> </strong> <a class="ae jw" href="https://shashank3199.medium.com/modified-genetic-algorithm-to-solve-the-zero-one-knapsack-problem-cc2f76d0050f" rel="noopener">改进的遗传算法求解零一背包问题</a>。</li></ul></div></div>    
</body>
</html>