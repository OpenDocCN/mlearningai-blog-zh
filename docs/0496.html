<html>
<head>
<title>Serverless Prediction at Scale: Custom Model Deployment on Google Cloud AI Platform</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">大规模无服务器预测:谷歌云人工智能平台上的定制模型部署</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/serverless-prediction-at-scale-custom-model-deployment-on-google-cloud-ai-platform-d2d0807a0b8f?source=collection_archive---------1-----------------------#2021-05-04">https://medium.com/mlearning-ai/serverless-prediction-at-scale-custom-model-deployment-on-google-cloud-ai-platform-d2d0807a0b8f?source=collection_archive---------1-----------------------#2021-05-04</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="4610" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">将真实世界的定制医疗保健模型部署到Google Cloud AI平台，将模型公开为安全的REST API，并通过负载测试验证模型的可扩展性</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/2f13e39a327c16bd4a6f0c8c11118933.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G-j4-PYAPw9i8aUBjiUoAw.png"/></div></div></figure><p id="9fac" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">模型部署是机器学习模型开发和操作(MLOps)生命周期的关键组成部分。在当今快速增长的云原生IT环境中，在将定制模型部署到生产环境时，公共云中的无服务器部署变得越来越流行。云中的无服务器部署提供了云计算的许多好处，例如简单性、成本效益、高可用性和可伸缩性。</p><p id="166d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这篇文章中，我将分享一个使用Google Cloud AI Platform(CAIP)[<a class="ae jo" href="https://cloud.google.com/ai-platform" rel="noopener ugc nofollow" target="_blank">1</a>]的真实定制模型部署体验。这个部署利用了CAIP的定制预测例程[ <a class="ae jo" href="https://cloud.google.com/ai-platform/prediction/docs/custom-prediction-routines" rel="noopener ugc nofollow" target="_blank"> 2 </a> ]的能力，该例程可以自动将模型的工件打包并部署到Kubernete集群。部署后，模型通过云函数和Apigee代理经由REST API公开为预测服务。公开的模型API经过负载测试，证明具有高度的可伸缩性。作为比较，我还计划在不久的将来分享另一个CAIP海关集装箱方法[ <a class="ae jo" href="https://cloud.google.com/architecture/ai-platform-prediction-custom-container-concepts" rel="noopener ugc nofollow" target="_blank"> 3 </a> ]的经验。</p><h1 id="0fe1" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">模型概述</h1><p id="231d" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">我在这个实验中使用的定制模型是一个原型ML模型，用于预测多种药物中的药物不良反应(ADR)风险。这是一个真实世界的ML模型，其复杂程度通常是医疗保健问题建模所期望的。就本文的目的而言，理解模型是如何构建的，它是如何运行的，或者模型预测的准确性并不重要。它只是作为一个现实的例子来说明如何自定义模型可以部署在CAIP无服务器的方式，并提供大规模的在线预测。</p><p id="14c5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对于对模型本身感兴趣的读者来说，这个ADR风险模型是基于Valeanu等人<a class="ae jo" href="https://www.nature.com/articles/s41598-020-66611-8#auth-Andrei-Valeanu" rel="noopener ugc nofollow" target="_blank">4</a>在最近的自然科学报告中发表的方法开发的。模型开发完成后，此ADR风险模型的工件由以下3个定制模型文件和1个特征转换文件组成:</p><ul class=""><li id="6c58" class="ks kt hh ig b ih ii il im ip ku it kv ix kw jb kx ky kz la bi translated">frequency_model.pkl:以Python pickle格式序列化的统计ADR频率模型</li><li id="df78" class="ks kt hh ig b ih lb il lc ip ld it le ix lf jb kx ky kz la bi translated">住院_model.h5:用TensorFlow构建的神经网络模型，保存为h5格式。该模型用于ADR住院风险的预测。</li><li id="40db" class="ks kt hh ig b ih lb il lc ip ld it le ix lf jb kx ky kz la bi translated">死亡率_模型. h5:预测ADR死亡率风险的类似神经网络模型</li><li id="5c4c" class="ks kt hh ig b ih lb il lc ip ld it le ix lf jb kx ky kz la bi translated">transformer.pkl:用于对住院和死亡率模型的输入数据进行预处理和编码的特征转换文件</li></ul><p id="6ca4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">目标是将这些模型构件部署到CAIP，将它们与实现白皮书[ <a class="ae jo" href="https://www.nature.com/articles/s41598-020-66611-8#auth-Andrei-Valeanu" rel="noopener ugc nofollow" target="_blank"> 4 </a> ]中概述的特定业务逻辑的定制服务代码结合在一起，然后通过公共REST API将模型安全地公开为预测服务。模型API的输入数据包括:</p><ul class=""><li id="e95b" class="ks kt hh ig b ih ii il im ip ku it kv ix kw jb kx ky kz la bi translated">患者的年龄和性别</li><li id="3b0b" class="ks kt hh ig b ih lb il lc ip ld it le ix lf jb kx ky kz la bi translated">患者医疗状况列表</li><li id="cf4a" class="ks kt hh ig b ih lb il lc ip ld it le ix lf jb kx ky kz la bi translated">患者正在服用的药物清单</li></ul><p id="c6c4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">示例:</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="lg lh l"/></div></figure><p id="238a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">模型API的输出是3个不同层级的ADR风险评分:</p><ul class=""><li id="7b7c" class="ks kt hh ig b ih ii il im ip ku it kv ix kw jb kx ky kz la bi translated">患者的住院、死亡率和总风险评分</li><li id="e8cd" class="ks kt hh ig b ih lb il lc ip ld it le ix lf jb kx ky kz la bi translated">每个MedDRA系统器官分类(SOC)级别的风险评分排名</li><li id="0a58" class="ks kt hh ig b ih lb il lc ip ld it le ix lf jb kx ky kz la bi translated">每个独立ADR级别的风险评分排名</li></ul><p id="8e89" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">示例:</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="lg lh l"/></div></figure><h1 id="43aa" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">自定义例程预测器</h1><p id="2121" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">谷歌CAIP提供了两种选择来在其平台上部署定制模型。一个是自定义预测例程，另一个是自定义容器。自定义预测例程是一种更简单的方法，只需最少的工作就可以在预测期间执行自定义服务代码。另一方面，自定义容器通过创建自己的docker容器，为模型部署提供了最大的灵活性。</p><p id="9439" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">自定义预测例程部署的第一步是创建自定义预测器类。这个类是自定义服务代码所在的地方。在预测器类中有两种方法要实现:</p><ul class=""><li id="d032" class="ks kt hh ig b ih ii il im ip ku it kv ix kw jb kx ky kz la bi translated"><em class="li"> from_path(cls，model_dir) </em>:加载模型工件的类方法</li><li id="adff" class="ks kt hh ig b ih lb il lc ip ld it le ix lf jb kx ky kz la bi translated"><em class="li"> predict(self，instances，**kwargs) </em>:由每个预测请求调用的实例方法。请求对象的有效负载在“实例”参数中传递给方法。</li></ul><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="lg lh l"/></div></figure><p id="41dc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果没有完全理解上面<em class="li"> ADR_Predictor() </em>类的<em class="li"> predict() </em>方法中的实现细节，也不用担心。这段代码是非常具体的ADR模型服务。它使用从一个单独的定制代码模块导入的几个助手函数。然而，重要的是要理解模型工件是从CAIP上运行的容器中的本地目录加载的。这些模型工件是从创建模型版本资源时指定的Google Cloud Storage (GCS)位置复制的，如下一节所述。</p><p id="84da" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我还建议在尝试部署到CAIP之前，在本地测试您的预测器类。在本地环境中调试和测试您的定制服务代码要比在CAIP容易得多。为这个预测器类创建一个本地测试器非常简单。</p><h1 id="f16b" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">源分发包</h1><p id="2c7f" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">在本地创建并测试了自定义预测器类之后，下一步是创建用于部署的源分发包。Google CAIP提供了一个简单的安装工具来创建这个分发包。使用这个工具，我只需要指定包名、版本和所有需要的定制脚本(包括预测器和助手脚本文件)。</p><p id="3a39" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">运行以下命令来执行安装脚本:</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="lg lh l"/></div></figure><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="lg lh l"/></div></figure><p id="1d32" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">它创建了一个源代码分发子目录和一个gzipped tarball包。在这次执行之后，我的本地目录文件结构如下所示:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es lj"><img src="../Images/7ef9f818b53d5a2ab0f91241ad1b5696.png" data-original-src="https://miro.medium.com/v2/resize:fit:652/format:webp/1*xCWOP42LfhtTri59NVoPlQ.png"/></div></figure><h1 id="60ac" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">CAIP模型部署</h1><p id="5679" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">在开始将您的模型部署到CAIP之前，请确保您已经在本地机器上安装了Google的gcloud SDK，并使用您的用户帐户、GCP项目和身份验证配置了SDK。</p><p id="15fb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在CAIP上的部署从创建Google Cloud Storage (GCS) bucket和上传模型工件和源代码分发包文件夹开始。对于我的ADR模型，我运行:</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="lg lh l"/></div></figure><p id="b509" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="li"> &lt; BUCKET_NAME &gt; </em>是我的GCP项目中的GCS bucket名称，用于托管模型工件和分发包。在确认这些文件夹已经成功上传到GCS bucket之后，我运行以下命令在CAIP上创建模型和版本资源:</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="lg lh l"/></div></figure><p id="c0be" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在GCP控制台上，我导航到CAIP的模型面板，并验证模型和版本资源已经成功创建:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es lk"><img src="../Images/c1406940c8789272a647c53078d93507.png" data-original-src="https://miro.medium.com/v2/resize:fit:1396/format:webp/1*hTgVeqrHg_J6D11zA6-zMQ.png"/></div></figure><p id="c6c5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在GCP控制台上的模型版本的“Test &amp; Use”选项卡中，我使用样本输入数据运行了一个快速测试，并验证了模型产生了预期的输出结果。注意，输入数据需要用“instances”元素包装，CAIP要求该元素作为请求体的根元素。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es ll"><img src="../Images/eaf99968d0c909e0ba4721319b278dd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1272/format:webp/1*xG5j6lxRw3hYAzMy_AwWGA.png"/></div></figure><p id="20e6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我还使用下面的gcloud命令，通过创建相同输入数据的测试示例文件，从本地机器远程运行了一个测试。它产生的输出与从GCP控制台测试的输出相同:</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="lg lh l"/></div></figure><h1 id="6b47" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">模型服务的云功能</h1><p id="f6ab" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">在CAIP部署后，ADR风险模型可以通过带有HTTP端点[ <a class="ae jo" href="https://cloud.google.com/functions" rel="noopener ugc nofollow" target="_blank"> 5 </a> ]的云功能作为预测服务公开。我在“cloud_function”子目录下的“main.py”文件中创建了一个名为“adr_http”的云函数，它调用模型的预测服务，然后使用http端点部署云函数:</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="lg lh l"/></div></figure><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="lg lh l"/></div></figure><p id="137a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了保证“adr_http”云函数的调用安全，我在GCP项目上创建了一个服务帐户，为该服务帐户生成了一个密钥文件，然后将一个“云函数调用者”角色的服务帐户授予“adr_http”云函数。Apigee代理将使用此服务帐户(在下一节中)来调用“adr_http”云函数:</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="lg lh l"/></div></figure><p id="5612" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">以上命令中的<em class="li"> &lt;地区&gt; </em>和<em class="li"> &lt;项目_ID &gt; </em>需要替换为实际的GCP地区和项目ID。在这之后，我可以用下面的gcloud和curl命令测试云函数的HTTP端点:</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="lg lh l"/></div></figure><p id="b6e7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">注意，在上面的curl命令中，HTTP授权是由gcloud auth激活的服务帐户的身份令牌提供的。模型输入数据需要由HTTP请求的JSON主体中的“instances”元素的数组包装。</p><h1 id="1185" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">模型API的Apigee代理</h1><p id="af48" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">虽然GCP云函数本身可以作为公共HTTP端点公开，但最佳实践是保持云函数端点私有，并用Apigee代理包装它，以便将其作为公共REST API[ <a class="ae jo" href="https://docs.apigee.com/" rel="noopener ugc nofollow" target="_blank"> 6 </a> ]公开。Apigee为公共API开发提供了许多内置的特性和策略，比如身份验证、日志记录、跟踪、spike arrest等。</p><p id="b5bc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对于这个ADR风险模型，我创建了一个Apigee代理，将其公开为一个公共REST API。Apigee代理和云功能之间的集成是通过Google云功能扩展连接器实现的。首先，我需要使用上一步中生成的密钥文件中的服务帐户凭证创建一个Apigee扩展。然后，我创建了一个名为“adr_model”的Apigee代理，并在该代理的默认预流步骤中添加了以下3个策略:</p><ul class=""><li id="0696" class="ks kt hh ig b ih ii il im ip ku it kv ix kw jb kx ky kz la bi translated">OA-VerifyToken:用于API调用的OAuth2.0令牌验证策略</li><li id="c3a5" class="ks kt hh ig b ih lb il lc ip ld it le ix lf jb kx ky kz la bi translated">ADR-Ext-CF:使用Google cloud函数扩展的ConnectorCallout策略</li><li id="b854" class="ks kt hh ig b ih lb il lc ip ld it le ix lf jb kx ky kz la bi translated">AM-AssignResponse:从云函数响应中检索消息的分配消息策略</li></ul><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es lm"><img src="../Images/74c69fa5121c3a76f35154ab03f85887.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/format:webp/1*o5dU-tPOhK7a8zGwTlF2-A.png"/></div></figure><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="lg lh l"/></div></figure><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="lg lh l"/></div></figure><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="lg lh l"/></div></figure><p id="e834" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">有了这个Apigee代理，我现在可以使用从我的Apigee客户端凭证生成的访问令牌安全地访问ADR风险模型API。</p><h1 id="0344" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">模型API的负载测试</h1><p id="a039" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">为了验证部署的ADR风险模型的API性能和可伸缩性，我在SoapUI[ <a class="ae jo" href="https://www.soapui.org/" rel="noopener ugc nofollow" target="_blank"> 7 </a> ]上配置了2个负载测试用例。一个是模拟单个用户(线程)进行API调用，另一个是模拟100个并发用户。两个测试用例都被配置为运行10分钟，每个请求之间有500毫秒的延迟。每个负载测试按顺序尝试3次。结果显示在下面的截图中。对于单个用户，API的平均响应时间约为2.5秒，事务量非常低，为0.34个请求/秒。对于100个并发用户，API的平均响应时间约为4.2秒，事务量约为22个请求/秒。结果显示，当事务量增加65倍时，API响应时间仅降低了1.7秒，这清楚地表明了部署的模型API的高可伸缩性。</p><p id="dd0b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">负载测试1:单用户</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es ln"><img src="../Images/bc18894bb210bedd5fbc23f5ae357e8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T5soD71so0DpjUDsIDpD-w.png"/></div></div></figure><p id="f82e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">负载测试2: 100个并发用户</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es lo"><img src="../Images/a816dc891ce5f179c884042e7e094528.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CpIrsDTU3JFnMkTThDrbVw.png"/></div></div></figure><p id="67e2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下图显示了云函数的执行时间以及由100个并发用户的测试用例产生的活动云函数实例的数量。为了处理所有100个用户的并发请求，GCP激活了大约70个云功能实例。大多数用户请求(95%)在不到4.2秒的时间内被执行，但是也应该注意到一些请求在每次测试开始时需要更长的时间来响应。这种初始时间延迟主要是由于:</p><ul class=""><li id="15d7" class="ks kt hh ig b ih ii il im ip ku it kv ix kw jb kx ky kz la bi translated">新生成的云函数实例处理请求量所需的预热时间</li><li id="6c89" class="ks kt hh ig b ih lb il lc ip ld it le ix lf jb kx ky kz la bi translated">CAIP Kubernete集群后面的模型容器的自动缩放</li></ul><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es lp"><img src="../Images/a8e2947acabf9ed133c1618419e2e4a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/1*8herPMPLthZsazAv6ZlPXg.png"/></div></figure><h1 id="c9e3" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">结论</h1><p id="dc0a" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">在这篇文章中，我分享了在谷歌云人工智能平台(CAIP)上部署真实世界医疗保健ML模型的经验。该模型被公开为一个安全的REST API，并验证了它对于服务在线预测具有高度的可伸缩性。总的来说，我觉得谷歌CAIP的自定义预测例程为在GCP上无服务器部署自定义ML模型提供了一个非常简单方便的方法。</p><p id="6db6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我从这次试验中学到的一个教训是，GCP项目的VPC服务控制可能会对CAIP定制预测例程的可用性产生重大影响。为了完成ADR风险模型的部署，我不得不切换到VPC服务控制较少的另一个GCP项目。如果您遇到CAIP自定义预测例程的区域端点可用性的类似问题，请检查您的GCP项目的VPC服务控制。</p><h1 id="a6b4" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">承认</h1><p id="ea72" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">我感谢谷歌客户工程师布伦丹·杜汉和内森·霍德森在这次实验中的支持。</p><h1 id="e32a" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">参考</h1><p id="e3bd" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">[1]谷歌，【https://cloud.google.com/ai-platform T2】</p><p id="eb08" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">[2]谷歌，<a class="ae jo" href="https://cloud.google.com/ai-platform/prediction/docs/custom-prediction-routines" rel="noopener ugc nofollow" target="_blank">https://cloud . Google . com/ai-platform/prediction/docs/custom-prediction-routines</a></p><p id="f834" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">[3]谷歌，<a class="ae jo" href="https://cloud.google.com/architecture/ai-platform-prediction-custom-container-concepts" rel="noopener ugc nofollow" target="_blank">https://cloud . Google . com/architecture/ai-platform-prediction-custom-container-concepts</a></p><p id="4b41" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">[4] Valeanu，Andrei等人，“<a class="ae jo" href="https://www.nature.com/articles/s41598-020-66611-8#auth-Andrei-Valeanu" rel="noopener ugc nofollow" target="_blank">多药疗法中针对患者的药物不良反应预测评分和分级策略的开发</a>”，《自然科学报告》第10卷，文章编号:9552 (2020)</p><p id="cf2b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">[5]谷歌，<a class="ae jo" href="https://cloud.google.com/functions" rel="noopener ugc nofollow" target="_blank">https://cloud.google.com/functions</a></p><p id="2e49" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">【6】阿比奇，<a class="ae jo" href="https://docs.apigee.com/" rel="noopener ugc nofollow" target="_blank">https://docs.apigee.com/</a></p><p id="9cde" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">[7]索普伊，<a class="ae jo" href="https://www.soapui.org/" rel="noopener ugc nofollow" target="_blank">https://www.soapui.org/</a></p></div></div>    
</body>
</html>