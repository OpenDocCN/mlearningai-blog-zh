<html>
<head>
<title>Linked List</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">链表</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/linked-list-570dee38406f?source=collection_archive---------10-----------------------#2022-02-11">https://medium.com/mlearning-ai/linked-list-570dee38406f?source=collection_archive---------10-----------------------#2022-02-11</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="d1b0" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated"><strong class="ak">链表</strong></h2></div><p id="6b6f" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iy hi">’“链表是一系列数据结构，通过节点间的链接连接在一起。”</strong></p><p id="454c" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">链表是相互关联的链接序列，每个链接包含另一个链接的链接地址。</p><p id="959e" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iy hi">链表</strong>是继<strong class="iy hi">数组</strong>之后被广泛使用的数据结构。</p><p id="c8bc" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iy hi">链接</strong>——链表的每个链接都可以存储一个数据。</p><p id="1fe1" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iy hi">下一个</strong>——链表的每个链接都包含一个指向下一个链接的链接地址。</p><p id="a81d" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iy hi">链表</strong>——链表包含第一个链接到下一个链接的连接链接。</p><h1 id="3785" class="js jt hh bd ju jv jw jx jy jz ka kb kc in kd io ke iq kf ir kg it kh iu ki kj bi translated">链表表示法</h1><figure class="kl km kn ko fd kp er es paragraph-image"><div class="er es kk"><img src="../Images/5b971dddffeca79e2a8d39a50180ed2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:844/format:webp/0*3RleWqqLudDBWbYC.png"/></div></figure><h2 id="eb7c" class="ks jt hh bd ju kt ku kv jy kw kx ky kc jf kz la ke jj lb lc kg jn ld le ki lf bi translated">链表的类型</h2><p id="0bf1" class="pw-post-body-paragraph iw ix hh iy b iz lg ii jb jc lh il je jf li jh ji jj lj jl jm jn lk jp jq jr ha bi translated"><strong class="iy hi">单链表</strong>—导航仅向前。</p><p id="3190" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iy hi">双向链表</strong>—向前和向后导航。</p><p id="18f7" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iy hi">循环链表</strong>—链接第一个元素作为下一个元素，第一个元素链接到最后一个元素作为上一个元素。</p><p id="8382" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iy hi">基本操作</strong></p><ul class=""><li id="dd48" class="ll lm hh iy b iz ja jc jd jf ln jj lo jn lp jr lq lr ls lt bi translated"><strong class="iy hi">插入</strong>——我们可以在链表的前端、末端或任何地方添加一个节点。</li><li id="d01c" class="ll lm hh iy b iz lu jc lv jf lw jj lx jn ly jr lq lr ls lt bi translated"><strong class="iy hi">删除</strong>——您可以从链表的前端、末端或任何地方删除一个节点。</li><li id="546b" class="ll lm hh iy b iz lu jc lv jf lw jj lx jn ly jr lq lr ls lt bi translated"><strong class="iy hi">显示</strong>—显示完整的链表。</li><li id="cd0f" class="ll lm hh iy b iz lu jc lv jf lw jj lx jn ly jr lq lr ls lt bi translated"><strong class="iy hi">搜索</strong>——从链表的前端、末端或任意位置搜索特定节点。</li></ul><h1 id="25fc" class="js jt hh bd ju jv jw jx jy jz ka kb kc in kd io ke iq kf ir kg it kh iu ki kj bi translated"><strong class="ak">单链表</strong></h1><figure class="kl km kn ko fd kp er es paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="er es lz"><img src="../Images/1523c167442498e2b373dd2b6409cfcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*QFQVMNgDl_x6JHs4.png"/></div></div></figure><p id="d612" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iy hi">单链表</strong>是一种<em class="me">单向的链表，</em>只能单向遍历。即头部到最后一个节点(尾部)。</p><p id="52a5" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iy hi">声明链表:</strong></p><pre class="kl km kn ko fd mf mg mh mi aw mj bi"><span id="b5fd" class="ks jt hh mg b fi mk ml l mm mn">struct node{<br/>    int data;<br/>    struct node *next;<br/> };</span></pre><p id="720f" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iy hi">创建节点:</strong></p><pre class="kl km kn ko fd mf mg mh mi aw mj bi"><span id="c9cb" class="ks jt hh mg b fi mk ml l mm mn">struct node{<br/>    int data;<br/>    struct node *next;<br/> };<br/>node createNode(){<br/>    temp = (node)malloc(sizeof(struct node)); <br/>    temp-&gt;next = NULL;<br/>    return temp;<br/>}</span></pre><p id="fea0" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iy hi"> malloc() </strong>用于在C中分配单个内存块，它在头文件<strong class="iy hi"> Stdlib.h </strong>中可用。</p><p id="a82c" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iy hi"> sizeof() </strong>用于确定c语言中一个元素的字节大小，用于在向<strong class="iy hi"> malloc </strong>发送参数时确定每个节点的大小。</p><p id="7477" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iy hi">遍历条件到链表:</strong></p><pre class="kl km kn ko fd mf mg mh mi aw mj bi"><span id="c034" class="ks jt hh mg b fi mk ml l mm mn">node p;<br/>p = head;<br/>while(p != NULL){<br/>    p = p-&gt;next;<br/>}</span></pre><p id="bcff" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iy hi">在列表中插入一个节点:- </strong></p><ul class=""><li id="cd80" class="ll lm hh iy b iz ja jc jd jf ln jj lo jn lp jr lq lr ls lt bi translated">我们可以在链表中添加一个节点</li></ul><pre class="kl km kn ko fd mf mg mh mi aw mj bi"><span id="da13" class="ks jt hh mg b fi mk ml l mm mn">node addNode(node head, int value){</span><span id="5b04" class="ks jt hh mg b fi mo ml l mm mn">node temp,p;</span><span id="1e0c" class="ks jt hh mg b fi mo ml l mm mn">temp = createNode();</span><span id="310d" class="ks jt hh mg b fi mo ml l mm mn">data = value and next pointing to NULL.</span><span id="29fb" class="ks jt hh mg b fi mo ml l mm mn">temp-&gt;data = value;</span><span id="b9a7" class="ks jt hh mg b fi mo ml l mm mn">if(head == NULL){</span><span id="f90d" class="ks jt hh mg b fi mo ml l mm mn">head = temp;</span><span id="297a" class="ks jt hh mg b fi mo ml l mm mn">}</span><span id="b174" class="ks jt hh mg b fi mo ml l mm mn">else{</span><span id="fa3e" class="ks jt hh mg b fi mo ml l mm mn">p  = head;</span><span id="6233" class="ks jt hh mg b fi mo ml l mm mn">while(p-&gt;next != NULL){</span><span id="a50e" class="ks jt hh mg b fi mo ml l mm mn">p = p-&gt;next;</span><span id="9e10" class="ks jt hh mg b fi mo ml l mm mn">}</span><span id="be5c" class="ks jt hh mg b fi mo ml l mm mn">p-&gt;next = temp;</span><span id="336f" class="ks jt hh mg b fi mo ml l mm mn">}</span><span id="d66f" class="ks jt hh mg b fi mo ml l mm mn">return head;</span><span id="2930" class="ks jt hh mg b fi mo ml l mm mn">}</span></pre><p id="6613" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iy hi">显示链表:- </strong></p><ul class=""><li id="32c9" class="ll lm hh iy b iz ja jc jd jf ln jj lo jn lp jr lq lr ls lt bi translated">我们可以显示链表</li></ul><pre class="kl km kn ko fd mf mg mh mi aw mj bi"><span id="c246" class="ks jt hh mg b fi mk ml l mm mn">void display() {</span><span id="efd8" class="ks jt hh mg b fi mo ml l mm mn">struct node *current = head;</span><span id="a28e" class="ks jt hh mg b fi mo ml l mm mn">if(head == NULL) {</span><span id="2be3" class="ks jt hh mg b fi mo ml l mm mn">printf(“List is empty\n”);</span><span id="e520" class="ks jt hh mg b fi mo ml l mm mn">return;</span><span id="88e7" class="ks jt hh mg b fi mo ml l mm mn">}</span><span id="b5f0" class="ks jt hh mg b fi mo ml l mm mn">printf(“Adding nodes to the end of the list: \n”);</span><span id="0e7d" class="ks jt hh mg b fi mo ml l mm mn">while(current != NULL) {</span><span id="5ce6" class="ks jt hh mg b fi mo ml l mm mn">printf(“%d “, current-&gt;data);</span><span id="4da1" class="ks jt hh mg b fi mo ml l mm mn">current = current-&gt;next;</span><span id="9900" class="ks jt hh mg b fi mo ml l mm mn">}</span><span id="2cff" class="ks jt hh mg b fi mo ml l mm mn">printf(“\n”);</span><span id="ab7d" class="ks jt hh mg b fi mo ml l mm mn">}</span></pre><p id="0a29" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iy hi">删除链表:- </strong></p><ul class=""><li id="8814" class="ll lm hh iy b iz ja jc jd jf ln jj lo jn lp jr lq lr ls lt bi translated">我们可以删除链表中的节点</li></ul><pre class="kl km kn ko fd mf mg mh mi aw mj bi"><span id="81e9" class="ks jt hh mg b fi mk ml l mm mn">void deleteNode(struct Node* head, int key)</span><span id="ab50" class="ks jt hh mg b fi mo ml l mm mn">{</span><span id="d9fb" class="ks jt hh mg b fi mo ml l mm mn">struct Node *temp ,*head, *prev;</span><span id="5430" class="ks jt hh mg b fi mo ml l mm mn">if (temp != NULL &amp;&amp; temp-&gt;data == key) {</span><span id="db38" class="ks jt hh mg b fi mo ml l mm mn">struct Node*head = temp-&gt;next;</span><span id="d5f9" class="ks jt hh mg b fi mo ml l mm mn">free(temp);</span><span id="5aaa" class="ks jt hh mg b fi mo ml l mm mn">return;</span><span id="5587" class="ks jt hh mg b fi mo ml l mm mn">}</span><span id="ff27" class="ks jt hh mg b fi mo ml l mm mn">while (temp != NULL &amp;&amp; temp-&gt;data != key) {</span><span id="7bdf" class="ks jt hh mg b fi mo ml l mm mn">prev = temp;</span><span id="9916" class="ks jt hh mg b fi mo ml l mm mn">temp = temp-&gt;next;</span><span id="b821" class="ks jt hh mg b fi mo ml l mm mn">}</span><span id="96ea" class="ks jt hh mg b fi mo ml l mm mn">if (temp == NULL)</span><span id="4322" class="ks jt hh mg b fi mo ml l mm mn">return;</span><span id="7f4d" class="ks jt hh mg b fi mo ml l mm mn">prev-&gt;next = temp-&gt;next;</span><span id="e980" class="ks jt hh mg b fi mo ml l mm mn">free(temp);</span><span id="8cab" class="ks jt hh mg b fi mo ml l mm mn">}</span></pre><h1 id="de85" class="js jt hh bd ju jv jw jx jy jz ka kb kc in kd io ke iq kf ir kg it kh iu ki kj bi translated"><strong class="ak">双向链表</strong></h1><p id="2c76" class="pw-post-body-paragraph iw ix hh iy b iz lg ii jb jc lh il je jf li jh ji jj lj jl jm jn lk jp jq jr ha bi translated">双向链表是一种链表，其中每个节点除了存储其数据之外，还有两个链接。第一个链接指向列表中的上一个节点，第二个链接指向列表中的下一个节点。</p><figure class="kl km kn ko fd kp er es paragraph-image"><div class="er es mp"><img src="../Images/fd6a39b495fe1834d08f8b236e82660c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1294/format:webp/0*USE1BAQy9m_eNp1a.png"/></div></figure><p id="754c" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iy hi">前一个</strong>存储前一个节点的地址</p><p id="f898" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iy hi"> Data </strong>是负责存储我们要在列表中处理的数据的字段</p><p id="ac27" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iy hi"> Next </strong>存储下一个节点的地址</p><p id="d688" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iy hi">优点</strong>:-很容易向后和向前访问遍历列表。</p><p id="7a83" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iy hi">双向链表的实现</strong></p><pre class="kl km kn ko fd mf mg mh mi aw mj bi"><span id="2e02" class="ks jt hh mg b fi mk ml l mm mn">struct node<br/>{<br/>	int data;     	<br/>	node *prev;  	<br/>	node *next; 	<br/>};</span></pre><p id="fe59" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iy hi">对双向链表的操作</strong></p><p id="e12e" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iy hi">在双向链表的开头插入数据</strong></p><figure class="kl km kn ko fd kp er es paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="er es et"><img src="../Images/722cb3e80999e7a1e4e431e85afc78e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*GryeCb3KY2-64t6j.png"/></div></div></figure><pre class="kl km kn ko fd mf mg mh mi aw mj bi"><span id="483c" class="ks jt hh mg b fi mk ml l mm mn">void Doubly_Linked_List_add_front(int d)<br/>{<br/><br/>	node *temp;<br/>	temp = new node();<br/>	temp-&gt;data = d;<br/>	temp-&gt;prev = NULL;<br/>	temp-&gt;next = front<br/>	if(front == NULL)<br/>		end = temp;<br/>		<br/>	else<br/>		front-&gt;prev = temp;<br/>		<br/>	front = temp;<br/>}</span></pre><p id="24c9" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iy hi">在双向链表中的节点前插入数据</strong></p><figure class="kl km kn ko fd kp er es paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="er es mq"><img src="../Images/fd4eb8f41cc6a2b2756f48c43720b3e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*F9X2SdGjJo0CeiqE.png"/></div></div></figure><pre class="kl km kn ko fd mf mg mh mi aw mj bi"><span id="bd1b" class="ks jt hh mg b fi mk ml l mm mn">void Doubly_Linked_List_add_before(node *n, int d)<br/>{<br/>	node *temp;<br/>	temp = new node();<br/>	temp-&gt;data = d;<br/>	temp-&gt;next = n;<br/>	temp-&gt;prev = n-&gt;prev;<br/>	n-&gt;prev = temp;<br/><br/><br/>	if(n-&gt;prev == NULL)<br/>		front = temp;<br/>}</span></pre><p id="3d8b" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iy hi">在双向链表中的一个节点后插入数据</strong></p><pre class="kl km kn ko fd mf mg mh mi aw mj bi"><span id="b5f5" class="ks jt hh mg b fi mk ml l mm mn">void Doubly_Linked_List_add_after(node *n, int d)<br/>{<br/>	node *temp;<br/>	temp = new node();<br/>	temp-&gt;data = d;<br/>	temp-&gt;prev = n;<br/>	temp-&gt;next = n-&gt;next;<br/>	n-&gt;next = temp;<br/><br/>	if(n-&gt;next == NULL)<br/>		end = temp;<br/>}</span></pre><p id="4980" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iy hi">在双向链表的末尾插入数据</strong></p><figure class="kl km kn ko fd kp er es paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="er es mq"><img src="../Images/d2ad981e6def979c0e79e6da7161532c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*otkhSw7p8Yj5AoCj.png"/></div></div></figure><pre class="kl km kn ko fd mf mg mh mi aw mj bi"><span id="b3b2" class="ks jt hh mg b fi mk ml l mm mn">void Doubly_Linked_List :: add_end(int d)<br/>{<br/>	<br/>	node *temp;<br/>	temp = new node();<br/>	temp-&gt;data = d;<br/>	temp-&gt;prev = end;<br/>	temp-&gt;next = NULL;<br/>	if(end == NULL)<br/>		front = temp;<br/>	else<br/>		end-&gt;next = temp;	<br/>	end = temp;<br/>}</span></pre><p id="415e" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iy hi">删除双向链表中的一个节点</strong></p><figure class="kl km kn ko fd kp er es paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="er es mr"><img src="../Images/1802495b62115b9a1c96cdf38f3c66b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6jpI2-TMwR7y8FVY.png"/></div></div></figure><pre class="kl km kn ko fd mf mg mh mi aw mj bi"><span id="4e65" class="ks jt hh mg b fi mk ml l mm mn">void Doubly_Linked_List_delete_node(node *n)<br/>{	<br/>	if(n-&gt;prev == NULL)<br/>	{<br/>		front = n-&gt;next; <br/>		front-&gt;prev = NULL;<br/>	}<br/><br/>	else if(n-&gt;next == NULL)<br/>	{<br/>		end = n-&gt;prev; <br/>		end-&gt;next = NULL;<br/>	}<br/>	else<br/>	{<br/>		n-&gt;prev-&gt;next = n-&gt;next;<br/>		n-&gt;next-&gt;prev = n-&gt;prev;<br/>	}<br/>	<br/>	delete(n);			<br/>}</span></pre><p id="2f84" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iy hi">双向链表中的向前遍历</strong></p><pre class="kl km kn ko fd mf mg mh mi aw mj bi"><span id="55c5" class="ks jt hh mg b fi mk ml l mm mn">void Doubly_Linked_List_forward_traverse()<br/>{<br/>	node *p;<br/>	p = front;<br/>	while(p != NULL)<br/>	{<br/>		p-&gt;data;<br/>		p = p-&gt;next;<br/>	}<br/>}</span></pre><p id="4089" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iy hi">双向链表中的向后遍历</strong></p><pre class="kl km kn ko fd mf mg mh mi aw mj bi"><span id="fd91" class="ks jt hh mg b fi mk ml l mm mn">void Doubly_Linked_List_backward_traverse()<br/>{<br/>	node *p;<br/>	p = end;<br/>	while(p != NULL)<br/>	{<br/>		p-&gt;data;<br/>		p = p-&gt;prev;<br/>	}<br/>}</span></pre><h1 id="e6f8" class="js jt hh bd ju jv jw jx jy jz ka kb kc in kd io ke iq kf ir kg it kh iu ki kj bi translated"><strong class="ak">循环链表</strong></h1><p id="27a0" class="pw-post-body-paragraph iw ix hh iy b iz lg ii jb jc lh il je jf li jh ji jj lj jl jm jn lk jp jq jr ha bi translated">循环链表是<strong class="iy hi">最后一个节点指向第一个节点的链表。换句话说，这个链表的变体在末尾没有空元素</strong></p><figure class="kl km kn ko fd kp er es paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="er es ms"><img src="../Images/ebb63bef5558cbeb2d7edbcb689730e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*w4wY3_TujH_L1NWH.png"/></div></div></figure><p id="a2e3" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iy hi">循环链表操作</strong></p><p id="4dbb" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iy hi">在循环链表的开头插入</strong></p><pre class="kl km kn ko fd mf mg mh mi aw mj bi"><span id="0400" class="ks jt hh mg b fi mk ml l mm mn">void insertAtBeginning(int value)<br/>{<br/>    struct Node *newNode;<br/>    newNode = (struct Node*)malloc(sizeof(struct Node));<br/>    newNode -&gt; data = value;<br/>    if(head == NULL)<br/>    {<br/>       head = newNode;<br/>       newNode -&gt; next = head;<br/>    }<br/>    else<br/>    {<br/>       struct Node *temp = head;<br/>       while(temp -&gt; next != head)<br/>          temp = temp -&gt; next;<br/>       newNode -&gt; next = head;<br/>       head = newNode;<br/>       temp -&gt; next = head;<br/>    }<br/>    printf("\nInsertion success!!!");<br/>}</span></pre><p id="64a0" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iy hi">在双向链表的末尾插入</strong></p><pre class="kl km kn ko fd mf mg mh mi aw mj bi"><span id="2f51" class="ks jt hh mg b fi mk ml l mm mn">void insertAtEnd(int value)<br/>{<br/>   struct Node *newNode;<br/>   newNode = (struct Node*)malloc(sizeof(struct Node));<br/>   newNode -&gt; data = value;<br/>   if(head == NULL)<br/>   {<br/>      head = newNode;<br/>      newNode -&gt; next = head;<br/>   }<br/>   else<br/>   {<br/>      struct Node *temp = head;<br/>      while(temp -&gt; next != head)<br/>         temp = temp -&gt; next;<br/>      temp -&gt; next = newNode;<br/>      newNode -&gt; next = head;<br/>   }<br/>   printf("\nInsertion success!!!");   <br/>}</span></pre><p id="9044" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iy hi">在循环链表中的节点后插入</strong></p><pre class="kl km kn ko fd mf mg mh mi aw mj bi"><span id="23d5" class="ks jt hh mg b fi mk ml l mm mn">void insertAfter(int value, int location)<br/>{<br/>   struct Node *newNode;<br/>   newNode = (struct Node*)malloc(sizeof(struct Node));<br/>   newNode -&gt; data = value;<br/>   if(head == NULL)<br/>   {      <br/>      head = newNode;<br/>      newNode -&gt; next = head;<br/>   }<br/>   else<br/>   {<br/>      struct Node *temp = head;<br/>      while(temp -&gt; data != location)<br/>      {<br/>         if(temp -&gt; next == head)<br/>         {<br/>            printf("Given node is not found in the list!!!");<br/>            goto EndFunction;<br/>         }<br/>         else<br/>         {<br/>            temp = temp -&gt; next;<br/>         }<br/>      }<br/>      newNode -&gt; next = temp -&gt; next;<br/>      temp -&gt; next = newNode;<br/>      printf("\nInsertion success!!!");<br/>   }<br/>   EndFunction:<br/>}</span></pre><p id="667e" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iy hi">显示循环链表</strong></p><pre class="kl km kn ko fd mf mg mh mi aw mj bi"><span id="40d0" class="ks jt hh mg b fi mk ml l mm mn">void display()<br/>{<br/>   if(head == NULL)<br/>      printf("\nList is Empty!!!");<br/>   else<br/>   {<br/>      struct Node *temp = head;<br/>      printf("\nList elements are: \n");<br/>      while(temp -&gt; next != head)<br/>      {<br/>         printf("%d ---&gt; ",temp -&gt; data);<br/>      }<br/>      printf("%d ---&gt; %d", temp -&gt; data, head -&gt; data);<br/>   }<br/>}</span></pre><p id="dfa5" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iy hi">删除循环链表中的开头</strong></p><pre class="kl km kn ko fd mf mg mh mi aw mj bi"><span id="d39b" class="ks jt hh mg b fi mk ml l mm mn">void deleteBeginning()<br/>{<br/>   if(head == NULL)<br/>      printf("List is Empty!!! Deletion not possible!!!");<br/>   else<br/>   {<br/>      struct Node *temp = head;<br/>      if(temp -&gt; next == head)<br/>      {<br/>         head = NULL;<br/>         free(temp);<br/>      }<br/>      else{<br/>         head = head -&gt; next;<br/>         free(temp);<br/>      }<br/>      printf("\nDeletion success!!!");<br/>   }<br/>}</span></pre><p id="f72c" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iy hi">在循环链表的末尾删除</strong></p><pre class="kl km kn ko fd mf mg mh mi aw mj bi"><span id="be9d" class="ks jt hh mg b fi mk ml l mm mn">void deleteEnd()<br/>{<br/>   if(head == NULL)<br/>      printf("List is Empty!!! Deletion not possible!!!");<br/>   else<br/>   {<br/>      struct Node *temp1 = head, temp2;<br/>      if(temp1 -&gt; next == head)<br/>      {<br/>         head = NULL;<br/>         free(temp1);<br/>      }<br/>      else{<br/>         while(temp1 -&gt; next != head){<br/>            temp2 = temp1;<br/>            temp1 = temp1 -&gt; next;<br/>         }<br/>         temp2 -&gt; next = head;<br/>         free(temp1);<br/>      }<br/>      printf("\nDeletion success!!!");<br/>   }<br/>}</span></pre><p id="82ef" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iy hi">删除循环链表中选中的位置</strong></p><pre class="kl km kn ko fd mf mg mh mi aw mj bi"><span id="c146" class="ks jt hh mg b fi mk ml l mm mn">void deleteSpecific(int delValue)<br/>{<br/>   if(head == NULL)<br/>      printf("List is Empty!!! Deletion not possible!!!");<br/>   else<br/>   {<br/>      struct Node *temp1 = head, temp2;<br/>      while(temp1 -&gt; data != delValue)<br/>      {<br/>         if(temp1 -&gt; next == head)<br/>         {<br/>            printf("\nGiven node is not found in the list!!!");<br/>            goto FuctionEnd;<br/>         }<br/>         else<br/>         {<br/>            temp2 = temp1;<br/>            temp1 = temp1 -&gt; next;<br/>         }<br/>      }<br/>      if(temp1 -&gt; next == head){<br/>         head = NULL;<br/>         free(temp1);<br/>      }<br/>      else{<br/>         if(temp1 == head)<br/>         {<br/>            temp2 = head;<br/>            while(temp2 -&gt; next != head)<br/>               temp2 = temp2 -&gt; next;<br/>            head = head -&gt; next;<br/>            temp2 -&gt; next = head;<br/>            free(temp1);<br/>         }<br/>         else<br/>         {<br/>            if(temp1 -&gt; next == head)<br/>            {<br/>               temp2 -&gt; next = head;<br/>            }<br/>            else<br/>            {<br/>               temp2 -&gt; next = temp1 -&gt; next;<br/>            }   <br/>            free(temp1);<br/>         }<br/>      }<br/>      printf("\nDeletion success!!!");<br/>   }<br/>   }</span></pre><p id="4fa7" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iy hi">链表的应用</strong></p><ol class=""><li id="8feb" class="ll lm hh iy b iz ja jc jd jf ln jj lo jn lp jr mt lr ls lt bi translated"><strong class="iy hi"> <em class="me">图像查看器</em> </strong> —上一张和下一张图像链接在一起，因此可以通过下一张和上一张按钮访问。</li><li id="fd8f" class="ll lm hh iy b iz lu jc lv jf lw jj lx jn ly jr mt lr ls lt bi translated"><strong class="iy hi"/></li><li id="622c" class="ll lm hh iy b iz lu jc lv jf lw jj lx jn ly jr mt lr ls lt bi translated"><strong class="iy hi"> <em class="me">音乐播放器</em> </strong> —音乐播放器中的歌曲链接到上一首和下一首歌曲。您可以从列表的开头或结尾播放歌曲。</li></ol><p id="4e91" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">感谢你阅读我的博客，我希望你学到了新的东西，并喜欢它。关注更多此类信息丰富的博客，并给予👏还有评论，它给了我写更多博客的鼓励祝你有美好的一天！！！</p><div class="mu mv ez fb mw mx"><a rel="noopener follow" target="_blank" href="/mlearning-ai/mlearning-ai-submission-suggestions-b51e2b130bfb"><div class="my ab dw"><div class="mz ab na cl cj nb"><h2 class="bd hi fi z dy nc ea eb nd ed ef hg bi translated">Mlearning.ai提交建议</h2><div class="ne l"><h3 class="bd b fi z dy nc ea eb nd ed ef dx translated">如何成为Mlearning.ai上的作家</h3></div><div class="nf l"><p class="bd b fp z dy nc ea eb nd ed ef dx translated">medium.com</p></div></div><div class="ng l"><div class="nh l ni nj nk ng nl kq mx"/></div></div></a></div><p id="dc8f" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">🔵<a class="ae nm" rel="noopener" href="/mlearning-ai/mlearning-ai-submission-suggestions-b51e2b130bfb"> <strong class="iy hi">成为作家</strong> </a></p></div></div>    
</body>
</html>