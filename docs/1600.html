<html>
<head>
<title>Classic human-in-the-loop tracking with n4sid and Machine learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">n4sid和机器学习的经典人在回路跟踪</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/classic-human-in-the-loop-tracking-with-n4sid-and-machine-learning-7a7c2654f16b?source=collection_archive---------2-----------------------#2022-01-10">https://medium.com/mlearning-ai/classic-human-in-the-loop-tracking-with-n4sid-and-machine-learning-7a7c2654f16b?source=collection_archive---------2-----------------------#2022-01-10</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="c65f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我很少看关于系统识别和机器学习的文章。当我学习系统辨识时，它有点像控制理论中不太令人兴奋的表亲，不像最优控制理论那样令人兴奋，而是一种实用的数值工具。</p><p id="7eda" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">经典的人在回路跟踪问题，如如何模拟操作员的行为，可以通过使用一种称为n4sid的“黑盒”建模算法来模拟，该算法根据操作员看到的信息和他们做的信息来预测操作员的行为。人看到的信号被认为是输入，人执行的信号被认为是输出。n4sid将输入投影到输出，这称为传递函数矩阵，以便识别和估计重要的ode系数，从而创建表示人类如何使用视觉信息来产生输出的模型。</p><p id="7226" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">想想机器学习和n4sid，ML回归模型可以用来预测同样的人类操作员行为，其中的特征是人所见和所做的巧妙混合。</p><p id="e60a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这篇文章中，我将从数值和状态空间控制理论的角度概述n4sid模型是如何工作的。这个公式可能不会像MATLAB的n4sid函数那样给出精确的结果，因为我估计ode的方式，但是步骤是正确的；在github<a class="ae jc" href="https://github.com/j622amilah/n4sid_prediction" rel="noopener ugc nofollow" target="_blank">https://github.com/j622amilah/n4sid_prediction</a>随意看看我的n4sid构造。n4sid有许多不同的公式，最流行的公式是从矩阵分析和状态空间控制理论的角度(伦纳特·荣的用户系统识别理论)。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/9476033f541528ca66ad3dd414c274d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vhpyQX-o3pzGG79hgkobVg.png"/></div></div></figure><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="jp jq l"/></div></figure><h1 id="588e" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">创建输入和输出信号</h1><p id="6830" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">让我们说，一个人类操作员看到一个球像输入信号一样在计算机屏幕上反弹，他们试图复制相同的球反弹轨迹，并创建输出信号。然后，我们希望建立一个模型，描述人类如何根据原始球的反弹来复制反弹的球，以便我们可以测试人类是否可以复制其他球的反弹轨迹，而不必在现实生活中再次测试操作员。</p><p id="9d2a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在下图中，球弹跳中的绿线和蓝线是复制弹跳球的操作员。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="jp jq l"/></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ku"><img src="../Images/438d0f05dba85d9171d6aef70f0e208b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-NCilnZvO3ASmay-OpWI-Q.png"/></div></div></figure><h1 id="9daf" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">步骤1:归一化系数预测的输入和输出信号</h1><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="jp jq l"/></div></figure><h1 id="c4f0" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">步骤2:估计投影系数</h1><p id="79cc" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">在这一步中，我们将输入点(u(s))映射到输出点(y(s))。</p><p id="f7ac" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">y(s) = g(s)u(s) <br/>其中g(s)= h1*s^-1+h2*s^-2+h3*s^-3+…+hn*s^-n</p><p id="4172" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">投影不是将先前的输入点乘以一个标量来获得未来的输出点。投影是通过一些标量来扩张/拉伸每个输入点，并将它们相加得到每个输出点。</p><p id="a0b0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们使用马尔可夫参数来计算汉克尔矩阵参数，它是传递函数矩阵(g(s))的系数；以上表示为h1，h2，…，hN，合称为H。h是汉克尔矩阵的第一行，它们是马尔可夫参数，汉克尔矩阵是求解h1，h2，…，hN投影系数的另一种方法。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="jp jq l"/></div></figure><h1 id="8555" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">步骤3:将幂级数(投影系数)转换成传递函数</h1><p id="2fcb" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">将系数转化为状态空间/传递函数形式，我们假设传递函数阶为二阶，我们使用已经证明的标准可控形式数值方法将幂级数转化为传递函数。有其他方法可以做到这一点，但使用规范的可控形式是直接的。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="jp jq l"/></div></figure><p id="0d59" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">求解完<br/>出来:[(T00，</p><p id="8ae6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">T01，</p><p id="f683" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">-(T01 * T03—T02 * * 2)/(T00 * T02—T01 * * 2)，</p><p id="6a59" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">(T00 * T03—T01 * T02)/(T00 * T02—T01 * * 2)</p><p id="1aa4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi">)]</p><p id="5b43" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这些是根据状态空间<br/> b1 = T00的二阶传递函数的系数</p><p id="a017" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">b2 = T01</p><p id="a54d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">a3 =-(T01 * T03—T02 * * 2)/(T00 * T02—T01 * * 2)</p><p id="d0cf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">a4 =(T00 * T03—T01 * T02)/(T00 * T02—T01 * * 2)</p><p id="51f9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们将在下面看到它们！下面不是真正的工作代码，而是理解算法如何工作的重要代码片段。</p><h1 id="9d9d" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">步骤4:调整几个参数以找到最佳拟合传递函数预测模型</h1><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="jp jq l"/></div></figure><h1 id="13d3" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">成功:让我们看看是否合适</h1><p id="13e9" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">将所有四个步骤放入一个函数中，参见github，我们可以测试所有可能的调谐参数组合，并找到可以使用输入信号预测输出的最佳模型。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="jp jq l"/></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kv"><img src="../Images/93d87d1f8f2ce5ed6cd46ada539e5f49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*omVFA_3O9FevfeZ5xcJXuA.png"/></div></div></figure><p id="c4f1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这里我们可以看到，该函数找到了一个模型，该模型可以预测R平方等于0.75的输出，其中R平方=1是完美预测。因此，模型拟合并不完美，但在预测人类操作可以做什么方面也不太差。</p><p id="e5b5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我认为n4sid可以用来寻找机器学习特征之间的因果关系。如果拟合度很差，意味着不太可能找到连接输入和输出的常微分方程。因此，输入和输出很可能由不同的过程产生，或者输入不会导致输出的发生。这就是非因果关系的定义。</p><p id="1b4d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">经过这次讨论，希望大家和我一样享受n4sid</p><div class="kw kx ez fb ky kz"><a rel="noopener follow" target="_blank" href="/mlearning-ai/mlearning-ai-submission-suggestions-b51e2b130bfb"><div class="la ab dw"><div class="lb ab lc cl cj ld"><h2 class="bd hi fi z dy le ea eb lf ed ef hg bi translated">Mlearning.ai提交建议</h2><div class="lg l"><h3 class="bd b fi z dy le ea eb lf ed ef dx translated">如何成为Mlearning.ai上的作家</h3></div><div class="lh l"><p class="bd b fp z dy le ea eb lf ed ef dx translated">medium.com</p></div></div><div class="li l"><div class="lj l lk ll lm li ln jn kz"/></div></div></a></div></div></div>    
</body>
</html>