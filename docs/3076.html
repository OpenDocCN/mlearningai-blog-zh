<html>
<head>
<title>Linear Regression: Closed-Form solution, the Dart way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">线性回归:封闭形式的解决方案，飞镖方式</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/ordinary-least-squares-closed-form-solution-the-dart-way-d7c0ee0e0d02?source=collection_archive---------0-----------------------#2022-07-17">https://medium.com/mlearning-ai/ordinary-least-squares-closed-form-solution-the-dart-way-d7c0ee0e0d02?source=collection_archive---------0-----------------------#2022-07-17</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="c37e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jc">本文是Dart编程语言机器学习系列文章的一部分:</em></p><ul class=""><li id="d52f" class="jd je hh ig b ih ii il im ip jf it jg ix jh jb ji jj jk jl bi translated"><a class="ae jm" rel="noopener" href="/mlearning-ai/machine-learning-in-dart-programming-language-fbfffd7deb18?source=friends_link&amp;sk=12ba21f2c7a01f1aa18954ba2a82fae9"><em class="jc">Dart编程语言中的机器学习</em> </a></li><li id="7384" class="jd je hh ig b ih jn il jo ip jp it jq ix jr jb ji jj jk jl bi translated"><a class="ae jm" rel="noopener" href="/mlearning-ai/a-gentle-introduction-to-linear-regression-the-dart-way-9750214e6fa2?source=friends_link&amp;sk=e199d8f5b0bb71c97525be2ee7f5819b"> <em class="jc">一元线性回归温柔入门:镖道</em> </a></li><li id="2820" class="jd je hh ig b ih jn il jo ip jp it jq ix jr jb ji jj jk jl bi translated"><a class="ae jm" rel="noopener" href="/mlearning-ai/linear-regression-ordinary-least-squares-in-a-nutshell-c2e0d7ed260f?source=friends_link&amp;sk=5c8bc0228d29bc67ebe524a91d687619"> <em class="jc">线性回归:简单地说就是普通最小二乘法</em> </a></li></ul><p id="cc1c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">大家好，</p><p id="b3f4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在我之前的<a class="ae jm" rel="noopener" href="/mlearning-ai/linear-regression-ordinary-least-squares-in-a-nutshell-c2e0d7ed260f?source=friends_link&amp;sk=5c8bc0228d29bc67ebe524a91d687619">文章</a>中，我解释了普通最小二乘问题。我提到有几种方法可以解决它，其中之一是封闭形式的解决方案。</p><p id="89cb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">今天我们将:</p><ul class=""><li id="aa9a" class="jd je hh ig b ih ii il im ip jf it jg ix jh jb ji jj jk jl bi translated">弄清楚什么是封闭形式</li><li id="9b72" class="jd je hh ig b ih jn il jo ip jp it jq ix jr jb ji jj jk jl bi translated">推导线性回归封闭解的公式</li><li id="a86f" class="jd je hh ig b ih jn il jo ip jp it jq ix jr jb ji jj jk jl bi translated">接触一个使用Dart编程语言的线性回归的实例</li></ul><p id="9cc2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们开始吧！</p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><p id="a874" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">什么是封闭解？</p><p id="ce79" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们看一个简单的例子:</p><figure class="ka kb kc kd fd ke er es paragraph-image"><div class="er es jz"><img src="../Images/82d073a4d8c3183bd876ad49e8f543e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:278/format:webp/1*CyZp1jTFcxOeFE2T26GMsQ.png"/></div></figure><p id="7e5c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我想每个人都能找到<code class="du kh ki kj kk b">x</code>，它是3。如果我们用<code class="du kh ki kj kk b">a</code>代替<code class="du kh ki kj kk b">2</code>，用<code class="du kh ki kj kk b">b</code>代替<code class="du kh ki kj kk b">6</code>，我们可以推导出<code class="du kh ki kj kk b">x</code>的公式:</p><figure class="ka kb kc kd fd ke er es paragraph-image"><div class="er es kl"><img src="../Images/301c6bad7bf2bac133d25860192434d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:204/format:webp/1*ceDzcPWTa8QHOMqrA467Zw.png"/></div></figure><p id="b8a6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在让我们看一个更复杂的例子:</p><figure class="ka kb kc kd fd ke er es paragraph-image"><div class="er es km"><img src="../Images/a00a94682a5e9553a5f7aa5e17c552c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:438/format:webp/1*LR7v2IIXLPCJok_BTtZptw.png"/></div></figure><p id="1e6b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">你可能注意到了，这是一个二次方程。因此，如果我们将<code class="du kh ki kj kk b">2</code>替换为<code class="du kh ki kj kk b">a</code>，将<code class="du kh ki kj kk b">7</code>替换为<code class="du kh ki kj kk b">b</code>，将<code class="du kh ki kj kk b">3</code>替换为<code class="du kh ki kj kk b">c</code>，我们可以使用众所周知的公式找到<code class="du kh ki kj kk b">x</code>的所有可能值:</p><figure class="ka kb kc kd fd ke er es paragraph-image"><div class="er es kn"><img src="../Images/299729b92ee9f5f4f4cbd6dd1ffe161b.png" data-original-src="https://miro.medium.com/v2/resize:fit:540/format:webp/1*hFqXAeNam0bRQejeUHbedw.png"/></div></figure><p id="dc9b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">同样，很容易找到答案:3和0.5。</p><p id="3df2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这两个例子有什么共同之处？是的，它们都可以用一个公式来表示，这意味着对有限数量的简单数学运算得出唯一可能的解。</p><p id="bc9a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在让我们看另一个例子:</p><figure class="ka kb kc kd fd ke er es paragraph-image"><div class="er es ko"><img src="../Images/a78d186bcd381e6e7c2aeced83a0fa1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:244/format:webp/1*6rXW7AedHngs2lxysq8yxw.png"/></div></figure><p id="2738" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">换句话说，我们必须区分正方形的功能。</p><p id="f905" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">回想一下什么是微分。这是一个过程，我们改变一点参数，观察函数的行为，了解函数对变化的敏感程度。我们可以用一个公式来表达这样一个过程:</p><figure class="ka kb kc kd fd ke er es paragraph-image"><div class="er es kp"><img src="../Images/6a271a763dea7407c42384395a0196f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*tc6mIvEzUmk8ofSFPkibRw.png"/></div></figure><p id="ad7d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如您所见，不可能找到<code class="du kh ki kj kk b">y</code>的精确值。我们可以改变函数的参数无数次，但仍然没有最终的解决方案。</p><p id="f7bb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对于一个我们可以通过有限次数的简单数学运算得到的问题，我们有唯一可能的解决方案的情况称为<strong class="ig hi">封闭形式的解决方案</strong>。前两个方程是这种解决方案的很好的例子；它们可以简单地完成，并汇聚成一个可能的答案。显然，最后一个没有封闭的形式。</p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><p id="33c9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在我们知道封闭形式是什么了。线性回归问题有这样的解吗？是的，确实如此。要推断公式，我们要记住普通最小二乘问题——推荐你看关于普通最小二乘的文章:</p><div class="kq kr ez fb ks kt"><a rel="noopener follow" target="_blank" href="/mlearning-ai/linear-regression-ordinary-least-squares-in-a-nutshell-c2e0d7ed260f"><div class="ku ab dw"><div class="kv ab kw cl cj kx"><h2 class="bd hi fi z dy ky ea eb kz ed ef hg bi translated">线性回归:简单的普通最小二乘法</h2><div class="la l"><h3 class="bd b fi z dy ky ea eb kz ed ef dx translated">大家好！</h3></div><div class="lb l"><p class="bd b fp z dy ky ea eb kz ed ef dx translated">medium.com</p></div></div><div class="lc l"><div class="ld l le lf lg lc lh kf kt"/></div></div></a></div></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><p id="d7df" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，我们有一个误差函数来最小化:</p><figure class="ka kb kc kd fd ke er es paragraph-image"><div class="er es li"><img src="../Images/667d792ecf38b616b0973abc07c9e1f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:314/format:webp/1*38CG7qSFlZfzf_zukLe_dQ.png"/></div></figure><p id="c854" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在哪里</p><figure class="ka kb kc kd fd ke er es paragraph-image"><div class="er es lj"><img src="../Images/6c85610a87645e1660e21eb8f9e55b9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:422/format:webp/1*kDyIJ8mo0eGULaQqHmsIqw.png"/></div></figure><p id="050b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">w_0_0和w_1_0是未知项；我们必须找到他们。如你所知，我们问题的解决方案是尽可能减少误差。解析地说，它是误差函数的最小点。由于函数是可微的，我们可以得到函数导数的表达式，并使其等于零。</p><p id="1560" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为什么要让它等于零？</p><p id="42ab" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如你所知，导数的值是某一点切线的斜率:</p><figure class="ka kb kc kd fd ke er es paragraph-image"><div class="er es lk"><img src="../Images/656a9aa51449054b15eee09cf91874f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/format:webp/1*gdyoKg3lhyY0oR-_Td-KeQ.png"/></div></figure><p id="e7df" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在上图中，我们看到在点<code class="du kh ki kj kk b">A</code>和点<code class="du kh ki kj kk b">B</code>的两条切线。很明显，这些线有一些斜率，这意味着这些点的绝对导数值大于0。</p><p id="9e09" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果导数值等于零，说明该点的切线没有斜率；平行于<code class="du kh ki kj kk b">X</code>轴；</p><figure class="ka kb kc kd fd ke er es paragraph-image"><div class="er es lk"><img src="../Images/ac1e692d69614c2ad6cf7b5771c8aef9.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/format:webp/1*iDjQdudljSD2zHvxrKKl7A.png"/></div></figure><p id="5430" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这意味着该点是函数的最小值。</p><p id="b039" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当然，具有这种切线的点也可能是最大值:</p><figure class="ka kb kc kd fd ke er es paragraph-image"><div class="er es lk"><img src="../Images/0114894c443b8caf4abb88c36c81a65f.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/format:webp/1*uDEav4SLbd_TR-2ALm53kg.png"/></div></figure><p id="d067" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">但是由于我们问题的性质，我们的误差函数只有一个全局最小值:</p><figure class="ka kb kc kd fd ke er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es ll"><img src="../Images/241a500533c03e12cf255ed65e424613.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EVXRtsTnQHncCMTtP_OW2A.png"/></div></div><figcaption class="lq lr et er es ls lt bd b be z dx">The parabolic plane has only one extremum, and it’s a minimum.</figcaption></figure><p id="1bcf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">好的，但是函数由两个未知变量w_0_1和w_1_0组成。怎样才能找到这样一个函数的导数呢？</p><p id="8dcd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们可以简单地找到关于每个未知项的偏导数的表达式，并使表达式等于零:</p><figure class="ka kb kc kd fd ke er es paragraph-image"><div class="er es lu"><img src="../Images/43c8685960bdb139d929c2f81a2ada8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:948/format:webp/1*SMRMgx74LASddwvI8221hA.png"/></div></figure><p id="7ec3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在上面的例子中，我们只为具有单个特征的单个<code class="du kh ki kj kk b">y</code>项——<code class="du kh ki kj kk b">x</code>项导出了表达式。</p><p id="9f94" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">想象我们有很多特征。这意味着可以有很多<code class="du kh ki kj kk b">x</code>术语。此外，可能不只有一个<code class="du kh ki kj kk b">y</code>——通常，可能有许多值。让我们从矩阵的角度来看问题:有一个包含<code class="du kh ki kj kk b">x</code>值的特征矩阵，一个包含<code class="du kh ki kj kk b">w</code>值的权重矩阵，一个包含<code class="du kh ki kj kk b">y</code>值的结果矩阵。</p><p id="7aaa" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">据此，让我们为偏导数创建一个更一般的表达式:</p><figure class="ka kb kc kd fd ke er es paragraph-image"><div class="er es lv"><img src="../Images/a3d98a8c29789bb56a2f8f9bb8f4f861.png" data-original-src="https://miro.medium.com/v2/resize:fit:882/format:webp/1*2dyoEwpdoAfszccV5fRMLA.png"/></div></figure><p id="70a3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">其中:</p><ul class=""><li id="8591" class="jd je hh ig b ih ii il im ip jf it jg ix jh jb ji jj jk jl bi translated"><code class="du kh ki kj kk b">j</code>是特征的指数(或特征权重的指数)，表示特征矩阵中的一列</li><li id="c16c" class="jd je hh ig b ih jn il jo ip jp it jq ix jr jb ji jj jk jl bi translated"><code class="du kh ki kj kk b">i</code>是观察的索引，表示特征矩阵中的行索引</li><li id="71d8" class="jd je hh ig b ih jn il jo ip jp it jq ix jr jb ji jj jk jl bi translated"><code class="du kh ki kj kk b">y_i</code>是第I次观察的结果(针对第I行)</li><li id="c15e" class="jd je hh ig b ih jn il jo ip jp it jq ix jr jb ji jj jk jl bi translated"><code class="du kh ki kj kk b">x_i_j</code>是特定的特征值(特征矩阵中第j列第I行的值)</li><li id="9f2a" class="jd je hh ig b ih jn il jo ip jp it jq ix jr jb ji jj jk jl bi translated"><code class="du kh ki kj kk b">N</code>是若干特性</li></ul><p id="2c46" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">很好，现在我们知道了如何基于单个观测值来寻找特征权重的导数，但是我们可能有很多观测值。根据<a class="ae jm" rel="noopener" href="/mlearning-ai/linear-regression-ordinary-least-squares-in-a-nutshell-c2e0d7ed260f?source=friends_link&amp;sk=5c8bc0228d29bc67ebe524a91d687619">普通最小二乘问题</a>，如果我们有大量的观测值，我们必须对每个观测值的所有误差值求和:</p><figure class="ka kb kc kd fd ke er es paragraph-image"><div class="er es lw"><img src="../Images/33f7d404d4d84d837966c715760210f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:418/format:webp/1*DnwhEnDiCNilRGEphs_-HA.png"/></div></figure><p id="be48" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">其中<code class="du kh ki kj kk b">M</code>是观察值的数量。</p><p id="da69" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们考虑偏导数表达式求和的事实:</p><figure class="ka kb kc kd fd ke er es paragraph-image"><div class="er es lx"><img src="../Images/830065b64c9416c5d418599f7c979ae6.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/format:webp/1*rXJzUlgwt6YJgdSMIX_AeA.png"/></div></figure><p id="317c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们应该根据以下模式将该公式迭代地应用于我们的数据改变项<code class="du kh ki kj kk b">j</code>: j = 0…N-1，因为我们有N个特征和N个权重。</p><p id="db7d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了使事情变得简单一点，我们可以将结果、<code class="du kh ki kj kk b">y</code>值表示为M×1维度的矩阵<code class="du kh ki kj kk b">Y</code>，将特征、<code class="du kh ki kj kk b">x</code>值表示为M×N维度的矩阵<code class="du kh ki kj kk b">X</code>，将权重、<code class="du kh ki kj kk b">w</code>值表示为N×1维度的矩阵<code class="du kh ki kj kk b">W</code>。让我们用矩阵符号重写上面的等式:</p><figure class="ka kb kc kd fd ke er es paragraph-image"><div class="er es ly"><img src="../Images/fbbc13a2678bd2029cfb5150d3430c55.png" data-original-src="https://miro.medium.com/v2/resize:fit:566/format:webp/1*500Wb7w5J2flLXT17svdhg.png"/></div></figure><p id="073d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们检查等式中矩阵的维数:</p><ul class=""><li id="0211" class="jd je hh ig b ih ii il im ip jf it jg ix jh jb ji jj jk jl bi translated"><code class="du kh ki kj kk b">X</code>和<code class="du kh ki kj kk b">W</code>的乘积给出了M×1维的列矩阵，因为我们将M×N维的<code class="du kh ki kj kk b">X</code>矩阵乘以N×1维的<code class="du kh ki kj kk b">W</code>矩阵。有一个简单的经验法则:输出矩阵的维数是<code class="du kh ki kj kk b">number of rows of the first matrix</code> x <code class="du kh ki kj kk b">number of columns of the second matrix</code>，这就是为什么我们得到M×1维数矩阵的结果。</li><li id="4e16" class="jd je hh ig b ih jn il jo ip jp it jq ix jr jb ji jj jk jl bi translated"><code class="du kh ki kj kk b">Y</code>和<code class="du kh ki kj kk b">XW</code>相减是有效的，因为两项都是具有相同行数和列数的矩阵。</li><li id="6f6d" class="jd je hh ig b ih jn il jo ip jp it jq ix jr jb ji jj jk jl bi translated">我们必须转置<code class="du kh ki kj kk b">X</code>矩阵以符合维度，因为<code class="du kh ki kj kk b">Y-XW</code>是M×1维度的矩阵，但是<code class="du kh ki kj kk b">X</code>矩阵是M×N大小:我们不能将M×N维度的矩阵乘以M×1维度的矩阵。转置后，<code class="du kh ki kj kk b">X</code>矩阵有N x M维，很完美，现在可以求积了。结果，我们得到了N×1矩阵。</li></ul><p id="6739" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">很好，我们方程的维数符合。我们的目标是<code class="du kh ki kj kk b">W</code>矩阵。让我们从方程式中表达出来。</p><p id="1537" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">首先，让我们去掉<code class="du kh ki kj kk b">-2</code>，因为我们可以用这个值除等式的两个部分:</p><figure class="ka kb kc kd fd ke er es paragraph-image"><div class="er es lz"><img src="../Images/4a3c12e005ca570a31c479df2f38abd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:492/format:webp/1*wOSCglfSF2rzE6lfZ7lQBg.png"/></div></figure><p id="d2b8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后，让我们去掉括号。为此，我们应将<code class="du kh ki kj kk b">X</code>(转置)乘以<code class="du kh ki kj kk b">Y</code>，并从中减去<code class="du kh ki kj kk b">X</code>(转置)、<code class="du kh ki kj kk b">X</code>和<code class="du kh ki kj kk b">W</code>的乘积:</p><figure class="ka kb kc kd fd ke er es paragraph-image"><div class="er es ma"><img src="../Images/d09987262f1439e116a21f1420238038.png" data-original-src="https://miro.medium.com/v2/resize:fit:536/format:webp/1*HDOvDL3Ze1tjBzmmTUXm0Q.png"/></div></figure><p id="3295" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在让我们将等式的第一项移到右边:</p><figure class="ka kb kc kd fd ke er es paragraph-image"><div class="er es mb"><img src="../Images/83e9ce2b38021da7bac35cb04f5a1749.png" data-original-src="https://miro.medium.com/v2/resize:fit:430/format:webp/1*9cAKRhy9m_1IQ9kSWZK2uQ.png"/></div></figure><p id="0544" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最后一步，现在我们可以将等式的两部分相乘:</p><figure class="ka kb kc kd fd ke er es paragraph-image"><div class="er es mc"><img src="../Images/ab9e54795788e8881a8502cb48f7e17d.png" data-original-src="https://miro.medium.com/v2/resize:fit:238/format:webp/1*XSDHqoHvbXtNYZynvf2O1g.png"/></div></figure><p id="301f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在矩阵世界中，将一个矩阵乘以它的逆矩阵(源矩阵的负1次方)意味着将一个数乘以该数的倒数，就像<code class="du kh ki kj kk b">5 * 1/5</code>。在数字世界中，后一个例子导致了<code class="du kh ki kj kk b">1</code>。在矩阵世界中，与逆矩阵相乘是类似的；它产生了一个单位矩阵，这与数字的<code class="du kh ki kj kk b">1</code>几乎相同。因此，在我们将等式的两部分乘以逆矩阵后，我们得到:</p><figure class="ka kb kc kd fd ke er es paragraph-image"><div class="er es md"><img src="../Images/8c90ef3bda35f42004216f93ef754811.png" data-original-src="https://miro.medium.com/v2/resize:fit:530/format:webp/1*uGNTGQtYACl-xfwRXB_-ZQ.png"/></div></figure><p id="776d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们得到了线性回归任务的闭式解的公式。</p><p id="94e7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们来编码吧！</p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><p id="f269" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用<code class="du kh ki kj kk b"><a class="ae jm" href="https://github.com/gyrdym/ml_linalg" rel="noopener ugc nofollow" target="_blank">ml_linalg</a></code>库，可以很容易地根据上面的公式创建一个查找<code class="du kh ki kj kk b">W</code>矩阵的程序。</p><p id="4321" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最好拿出一些易于验证的综合数据。说着，让下面的记录:</p><pre class="ka kb kc kd fd me kk mf mg aw mh bi"><span id="ce39" class="mi mj hh kk b fi mk ml l mm mn">x1 | x2<br/>-------<br/>2  |  3<br/>4  |  6<br/>6  | 12<br/>8  | 24</span></pre><p id="c4ec" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">将我们的特征矩阵<code class="du kh ki kj kk b">X</code>和下列值:</p><pre class="ka kb kc kd fd me kk mf mg aw mh bi"><span id="5191" class="mi mj hh kk b fi mk ml l mm mn">y<br/>--<br/>13<br/>26<br/>48<br/>88</span></pre><p id="c70b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">将是我们的成果矩阵<code class="du kh ki kj kk b">Y</code></p><p id="b162" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">用手很容易找到特征的重量——这是<code class="du kh ki kj kk b">2</code>和<code class="du kh ki kj kk b">3</code>:</p><pre class="ka kb kc kd fd me kk mf mg aw mh bi"><span id="3c0a" class="mi mj hh kk b fi mk ml l mm mn">2*2 + 3*3 = 13<br/>4*2 + 6*3 = 26<br/>6*2 + 12*3 = 48<br/>8*2 + 24*3 = 88</span></pre><p id="0934" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们将公式应用于数据，并检查它是否工作正常:</p><figure class="ka kb kc kd fd ke"><div class="bz dy l di"><div class="mo mp l"/></div></figure><p id="905b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最后一条指令打印如下:</p><pre class="ka kb kc kd fd me kk mf mg aw mh bi"><span id="0656" class="mi mj hh kk b fi mk ml l mm mn">Matrix 2 x 1:<br/>(2.0000219345092773)<br/>(2.9999969005584717)</span></pre><p id="a9b2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这些值看起来是有效的。这正是我们所期望的(尽管有一些舍入误差)。</p><p id="831e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">似乎我们只在一行代码中执行了线性回归(上面代码片段中的第16行)！</p><p id="b774" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">是什么阻止我们每次都使用这个简单而优雅的解决方案？</p><p id="ac22" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们试着分析一下算法的复杂性。它有一个矩阵求逆步骤，具有三次复杂度O(n)。想象一下，如果你的特征矩阵是100，000乘以1，000，000。因此，仅求矩阵逆的迭代总数大约是(100，000*1，000，000)！即使是支持<a class="ae jm" href="https://github.com/gyrdym/ml_linalg" rel="noopener ugc nofollow" target="_blank"> ml_linalg </a>库的SIMD建筑也不会帮助我们；迭代太多。这就是为什么我们不能每次都使用线性回归的封闭形式解。</p><p id="4783" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">有一种不同的技术可以克服大数据的障碍，叫做梯度下降，但这在今天已经太难了。让我们把它留给<a class="ae jm" rel="noopener" href="/@ilgyrd/gradient-descent-the-dart-way-2d6c39416a8a?source=friends_link&amp;sk=992b52c85a51ecea1c1e9e4afe2a8c1e">下一篇文章</a>。</p><p id="00a7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">差不多就是这样。现在您知道线性回归的封闭形式解是什么了！</p><p id="03be" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">干杯:)</p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><p id="a01c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">您也可能喜欢以下内容:</p><div class="kq kr ez fb ks kt"><a rel="noopener follow" target="_blank" href="/@ilgyrd/google-engine-from-scratch-pagerank-algorithm-in-dart-flutter-b985c0c18567"><div class="ku ab dw"><div class="kv ab kw cl cj kx"><h2 class="bd hi fi z dy ky ea eb kz ed ef hg bi translated">谷歌引擎从头开始:Dart/颤振中的PageRank算法</h2><div class="la l"><h3 class="bd b fi z dy ky ea eb kz ed ef dx translated">大家好，</h3></div><div class="lb l"><p class="bd b fp z dy ky ea eb kz ed ef dx translated">medium.com</p></div></div><div class="lc l"><div class="mq l le lf lg lc lh kf kt"/></div></div></a></div><div class="kq kr ez fb ks kt"><a rel="noopener follow" target="_blank" href="/mlearning-ai/machine-learning-in-dart-programming-language-fbfffd7deb18"><div class="ku ab dw"><div class="kv ab kw cl cj kx"><h2 class="bd hi fi z dy ky ea eb kz ed ef hg bi translated">Dart编程语言中的机器学习</h2><div class="la l"><h3 class="bd b fi z dy ky ea eb kz ed ef dx translated">大家好！</h3></div><div class="lb l"><p class="bd b fp z dy ky ea eb kz ed ef dx translated">medium.com</p></div></div><div class="lc l"><div class="mr l le lf lg lc lh kf kt"/></div></div></a></div><div class="kq kr ez fb ks kt"><a rel="noopener follow" target="_blank" href="/mlearning-ai/mlearning-ai-submission-suggestions-b51e2b130bfb"><div class="ku ab dw"><div class="kv ab kw cl cj kx"><h2 class="bd hi fi z dy ky ea eb kz ed ef hg bi translated">Mlearning.ai提交建议</h2><div class="la l"><h3 class="bd b fi z dy ky ea eb kz ed ef dx translated">如何成为移动人工智能的作者</h3></div><div class="lb l"><p class="bd b fp z dy ky ea eb kz ed ef dx translated">medium.com</p></div></div><div class="lc l"><div class="ms l le lf lg lc lh kf kt"/></div></div></a></div></div></div>    
</body>
</html>