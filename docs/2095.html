<html>
<head>
<title>A Stochastic Model For Demand Forecating In Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中需求预测的随机模型</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/a-stochastic-model-for-demand-forecating-in-python-a1b568b80b94?source=collection_archive---------0-----------------------#2022-03-07">https://medium.com/mlearning-ai/a-stochastic-model-for-demand-forecating-in-python-a1b568b80b94?source=collection_archive---------0-----------------------#2022-03-07</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="6bce" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">利用时间序列SARIMA模型和蒙特卡罗模拟</h2></div><p id="658f" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iy hi">什么是需求预测？</strong></p><p id="7c57" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">简而言之——预测产品/服务的未来需求。</p><p id="7e9c" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">需求预测是供应链中非常重要的领域，因为整个供应链的其他计划都依赖于它。例如，生产计划(时间安排、个人计划)、库存(仓库)、财务(预算计划、工厂/设备投资)、营销(促销、新生产计划)、原材料计划等。需求预测是供应链所有战略和计划决策的基础，因为它们减少了不确定性。</p><p id="f01c" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">需求预测方法:</p><ol class=""><li id="ee57" class="js jt hh iy b iz ja jc jd jf ju jj jv jn jw jr jx jy jz ka bi translated">定性-</li></ol><ul class=""><li id="2e3f" class="js jt hh iy b iz ja jc jd jf ju jj jv jn jw jr kb jy jz ka bi translated">在这种方法中，预测主要依靠人和判断。</li><li id="5817" class="js jt hh iy b iz kc jc kd jf ke jj kf jn kg jr kb jy jz ka bi translated">当几乎没有可用的历史数据或当专家有可能影响预测的市场情报时，最适合。</li></ul><p id="dd00" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">2.时间序列-</p><ul class=""><li id="0b14" class="js jt hh iy b iz ja jc jd jf ju jj jv jn jw jr kb jy jz ka bi translated">使用历史需求进行预测</li><li id="9fef" class="js jt hh iy b iz kc jc kd jf ke jj kf jn kg jr kb jy jz ka bi translated">假设过去的需求历史是未来需求的良好指标</li></ul><p id="08ae" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">3.因果-</p><ul class=""><li id="785e" class="js jt hh iy b iz ja jc jd jf ju jj jv jn jw jr kb jy jz ka bi translated">该方法假设需求预测与环境中的某些因素(利率、油价等)高度相关</li><li id="0ab0" class="js jt hh iy b iz kc jc kd jf ke jj kf jn kg jr kb jy jz ka bi translated">因果需求预测方法发现需求和这些环境因素之间的这种相关性，并利用对环境因素的估计来预测未来的需求。</li></ul><p id="dd81" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iy hi">为什么我们要应用</strong> <a class="ae kh" rel="noopener" href="/@juee_thete/understanding-monte-carlo-simulation-and-its-implementation-with-python-3ecacb958cd4"> <strong class="iy hi">蒙特卡洛模拟</strong> </a> <strong class="iy hi">？</strong></p><p id="85ac" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">以上所有的预测方法都会给我们未来需求的点估计(确定性模型)。如果我们想要找到不同的可能结果以及它们发生的可能性，我们可以通过使用MCS来实现。它可以帮助我们评估达到目标的可能性。我们可以更好地计划我们的安全库存。我们可以得到一个最低和最高水平的范围，这将有助于供应链规划决策，因为我们知道我们的需求可能波动的范围，从而减少不确定性。</p><p id="b6d6" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">示例:</p><p id="5116" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们将使用流行的航空乘客数据集。你可以从- <a class="ae kh" href="https://www.kaggle.com/rakannimer/air-passengers" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>下载数据集。这是一家航空公司每月乘客的数据。</p><ol class=""><li id="723c" class="js jt hh iy b iz ja jc jd jf ju jj jv jn jw jr jx jy jz ka bi translated"><strong class="iy hi">导入必要的库:</strong></li></ol><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="e2ec" class="kr ks hh kn b fi kt ku l kv kw">import pandas as pd<br/>import numpy as np<br/>import matplotlib.pyplot as plt<br/>import matplotlib as mlp</span></pre><p id="2035" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iy hi"> 2。加载数据集:</strong></p><p id="58aa" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们将在示例中使用的数据集是时间序列格式的。时间序列是按时间顺序 排列的一系列<strong class="iy hi"> <em class="kx">数据点。简而言之，及时收集数据，例如每天记录温度，每月或每年记录销售额。时间序列数据集不同于其他数据集，因为我们给数据点的权重不相似。</em></strong></p><p id="69d9" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">时间序列预测包括采用适合历史数据的模型，并使用它们来预测未来的观测值。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="5228" class="kr ks hh kn b fi kt ku l kv kw">#Loading data<br/>data = pd.read_csv('Datasets/AirPassengers.csv', index_col='Month', parse_dates=['Month'])<br/>data = data.rename(columns ={'#Passengers':'no_passengers'})<br/>data</span></pre><ul class=""><li id="c39a" class="js jt hh iy b iz ja jc jd jf ju jj jv jn jw jr kb jy jz ka bi translated">每当处理时间序列数据时，请确保您的索引是日期时间索引。默认情况下，从CSV文件加载数据时，<em class="kx">月/日</em>列表示为<em class="kx">对象</em>。<em class="kx">月</em>列作为<em class="kx">对象</em>数据类型被读取。使用默认的<code class="du ky kz la kn b">read_csv().</code>来正确读取<em class="kx">日期</em>列，我们可以使用参数<code class="du ky kz la kn b">parse_dates</code>来指定日期列的列表。为此，我们使用了参数parse_dates =['Month']。我们也可以用熊猫<code class="du ky kz la kn b">to_datetime().</code>把它转换成datetime64</li><li id="9358" class="js jt hh iy b iz kc jc kd jf ke jj kf jn kg jr kb jy jz ka bi translated"><code class="du ky kz la kn b">index_col='Month'</code>用于强制熊猫使用<br/>列作为索引。</li><li id="4bda" class="js jt hh iy b iz kc jc kd jf ke jj kf jn kg jr kb jy jz ka bi translated">我们已经将该列的名称从#passengers更改为' no_passengers ',以便于选择该列。</li></ul><p id="39c1" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们的数据看起来是这样的:</p><figure class="ki kj kk kl fd lc er es paragraph-image"><div class="er es lb"><img src="../Images/8311affdf30918d0675c823c87a1cb3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:370/format:webp/1*wkZ1XYjNh6fj4psLWgNOVQ.png"/></div><figcaption class="lf lg et er es lh li bd b be z dx">Air Pasenger dataset</figcaption></figure><p id="cfe5" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们可以看到我们的索引列是“<em class="kx">月</em>”，格式为<em class="kx">日期时间</em>。我们有144个观察值(144个月的数据)，no_passergers列表示每个月的passerger数。</p><p id="c217" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们绘制我们的数据:</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="db32" class="kr ks hh kn b fi kt ku l kv kw">plt.plot(data)<br/>plt.show()</span></pre><figure class="ki kj kk kl fd lc er es paragraph-image"><div class="er es lj"><img src="../Images/9cd07958188109dd286281849340c512.png" data-original-src="https://miro.medium.com/v2/resize:fit:848/format:webp/1*ogFYNiD-01dVK8917zAyaQ.png"/></div><figcaption class="lf lg et er es lh li bd b be z dx">Airpassenger data -plot</figcaption></figure><p id="b198" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">从上面我们可以看到，有一个积极的趋势，也是每年重复的季节性模式。</p><p id="8de7" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iy hi"> 3。数据部</strong></p><p id="fd1e" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">通常我们将训练集和测试集中的数据分为<em class="kx">训练</em>模型和<em class="kx">训练</em>数据以及<em class="kx">测试</em>我们的模型在<em class="kx">测试</em>数据。这里我们要应用蒙特卡罗模拟，所以我们需要一些数据来推导随机数的分布。</p><p id="56e3" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们把数据分成三部分</p><ol class=""><li id="8dd7" class="js jt hh iy b iz ja jc jd jf ju jj jv jn jw jr jx jy jz ka bi translated">训练数据</li><li id="6a72" class="js jt hh iy b iz kc jc kd jf ke jj kf jn kg jr jx jy jz ka bi translated">MCS分布拟合数据</li><li id="e05b" class="js jt hh iy b iz kc jc kd jf ke jj kf jn kg jr jx jy jz ka bi translated">测试数据</li></ol><p id="4707" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们采用过去70个月的数据进行数据拟合:</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="1e22" class="kr ks hh kn b fi kt ku l kv kw">data_for_dist_fitting = data[-70:]</span></pre><p id="5588" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们将从原始数据中移除过去70个月的数据，以获得训练数据集</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="2218" class="kr ks hh kn b fi kt ku l kv kw">data_train = data[~data.isin(data_for_dist_fitting).all(1)]</span></pre><p id="220d" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">对于测试数据，我们将采用最近20个月的数据</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="95a5" class="kr ks hh kn b fi kt ku l kv kw">test_data = data_for_dist_fitting[-20:]</span></pre><p id="a0a5" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">从数据分布拟合中删除测试数据。因此，在训练集之后和测试集之前，我们将有50周的数据。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="740c" class="kr ks hh kn b fi kt ku l kv kw">data_for_dist_fitting=data_for_dist_fitting[~data_for_dist_fitting.isin(test_data).all(1)]</span></pre><p id="2d45" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">绘图数据分区:</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="adc8" class="kr ks hh kn b fi kt ku l kv kw">train = plt.plot(data_train,color='blue', label = 'Train data')</span><span id="dec8" class="kr ks hh kn b fi lk ku l kv kw">data_f_mc = plt.plot(data_for_dist_fitting, color ='red', label ='Data for distribution fitting')</span><span id="9c5d" class="kr ks hh kn b fi lk ku l kv kw">test = plt.plot(test_data, color ='black', label = 'Test data')</span><span id="bf28" class="kr ks hh kn b fi lk ku l kv kw">plt.legend(loc='best') <br/>plt.title('Data division')<br/>plt.show(block=False)</span></pre><figure class="ki kj kk kl fd lc er es paragraph-image"><div class="er es ll"><img src="../Images/62a98b8ee26b9ac117f94ec3828aadcd.png" data-original-src="https://miro.medium.com/v2/resize:fit:892/format:webp/1*owuIulBM61I1frPGrsHQug.png"/></div><figcaption class="lf lg et er es lh li bd b be z dx">Data Division</figcaption></figure><p id="fd0b" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">从上面的图中，我们可以清楚地看到数据划分。</p><p id="82c1" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iy hi"> 4。我们将如何在本例中应用MCS</strong></p><blockquote class="lm ln lo"><p id="93f2" class="iw ix kx iy b iz ja ii jb jc jd il je lp jg jh ji lq jk jl jm lr jo jp jq jr ha bi translated">运行蒙特卡洛模拟有两个组成部分:</p><p id="b82a" class="iw ix kx iy b iz ja ii jb jc jd il je lp jg jh ji lq jk jl jm lr jo jp jq jr ha bi translated">1)要评估的方程</p><p id="d9f7" class="iw ix kx iy b iz ja ii jb jc jd il je lp jg jh ji lq jk jl jm lr jo jp jq jr ha bi translated">2)输入的随机变量</p></blockquote><p id="a13a" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">任何预测方法总有一个随机因素不能用历史需求模式来解释。任何观察到的需求都可以分为两部分:</p><p id="41cd" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">观察到的需求=系统成分+随机成分(误差)</p><p id="1b9c" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们将首先尝试找出要评估的方程，为此我们将使用AR/ MA/ ARIMA/ SARIMA等时间序列统计预测方法。使用哪个模型取决于我们时间序列的平稳性。</p><p id="a0fe" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iy hi"> 5。检查平稳性和时间序列分解</strong>:</p><p id="2321" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">一个平稳的时间序列是<em class="kx">,它的性质不依赖于序列被观察的时间。</em></p><p id="d4b3" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">时间序列数据由水平、趋势、季节性和随机噪声组成。</p><ol class=""><li id="659a" class="js jt hh iy b iz ja jc jd jf ju jj jv jn jw jr jx jy jz ka bi translated"><strong class="iy hi"> Level- </strong>如果是直线，则为系列的值。</li><li id="1381" class="js jt hh iy b iz kc jc kd jf ke jj kf jn kg jr jx jy jz ka bi translated"><strong class="iy hi">趋势- </strong>系列随时间变化的可选且通常是线性的增加或减少行为。</li><li id="816c" class="js jt hh iy b iz kc jc kd jf ke jj kf jn kg jr jx jy jz ka bi translated"><strong class="iy hi">季节性</strong>。随着时间的推移，可选的重复模式或行为周期。季节性总是有一个固定和已知的频率。</li><li id="6db8" class="js jt hh iy b iz kc jc kd jf ke jj kf jn kg jr jx jy jz ka bi translated"><strong class="iy hi">循环<em class="kx"> : </em> </strong>当数据显示非固定频率的上升和下降时，出现<em class="kx">循环</em>。如果波动不是固定频率的，那么它们就是周期性的</li><li id="72a5" class="js jt hh iy b iz kc jc kd jf ke jj kf jn kg jr jx jy jz ka bi translated"><strong class="iy hi">噪音</strong>。模型无法解释的观测值的可选可变性。</li></ol><p id="5eb6" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果一个时间序列没有趋势性、季节性和周期性，我们可以说我们的时间序列是平稳的。我们的大多数时间序列预测方法都假设我们的数据是平稳的(不随时间变化)。</p><p id="2170" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们可以通过绘制滚动平均值和滚动标准差来检查时间序列的平稳性，也可以通过dickey fuller检验来检查，如下所示:</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="b137" class="kr ks hh kn b fi kt ku l kv kw">from statsmodels.tsa.stattools import adfuller<br/>def test_stationarity(timeseries):<br/>    #Determining rolling statistics<br/>    rolmean = timeseries.rolling(window=12).mean()<br/>    rolstd = timeseries.rolling(window=12).std()<br/>    <br/>    #plot rolling statistics:<br/>    orig = plt.plot(timeseries,color='blue', label = 'Original')<br/>    mean = plt.plot(rolmean, color ='red', label ='Rolling Mean')<br/>    std = plt.plot(rolstd, color ='black', label = 'Rolling Std')<br/>    plt.legend(loc='best')<br/>    plt.title('Rolling Mean and Standard Deviation')<br/>    plt.show(block=False) <br/>    <br/>    #Perform Dickey Fuller test:<br/>    print('Results of Dickey Fuller Test:')<br/>    dftest = adfuller(timeseries, autolag= 'AIC')<br/>    dfoutput = pd.Series(dftest[0:4], index=['Test Statistic','p-value','#Lags Used','Number of Observations Used'])<br/>    <br/>    for key,value in dftest[4].items():<br/>        dfoutput['Critical Value (%s)'%key] = value<br/>    print (dfoutput)</span></pre><p id="5fb8" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">调用函数检查稳定性:</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="9c19" class="kr ks hh kn b fi kt ku l kv kw">test_stationarity(data_train)</span></pre><figure class="ki kj kk kl fd lc er es paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="er es ls"><img src="../Images/796b3c19577010328575706ef182c1be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ykjfJhCvGts1igVF_JCT0Q.png"/></div></div><figcaption class="lf lg et er es lh li bd b be z dx">Plot of rolling mean and standard deviation of time series</figcaption></figure><figure class="ki kj kk kl fd lc er es paragraph-image"><div class="er es lx"><img src="../Images/85254e53c0f2bb77e8a191769613e359.png" data-original-src="https://miro.medium.com/v2/resize:fit:758/format:webp/1*nu0OzivSdYumLqwA-jl79Q.png"/></div><figcaption class="lf lg et er es lh li bd b be z dx">Results of Dickey Fuller</figcaption></figure><p id="f5a7" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">从上述滚动平均值和标准偏差图中，我们可以说我们的时间序列不是平稳的。我们有增加的滚动平均值，这表明我们有积极的趋势，波动的滚动标准差表明我们的时间序列有季节性。同样根据迪基富勒测试的结果，p值为0.951..这是非常高的。如果它低于0.05，那么我们可以说我们的时间序列是平稳的</p><p id="b0da" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们可以通过使用<code class="du ky kz la kn b">statsmodels</code> <code class="du ky kz la kn b">seasonal_decompose</code>来可视化我们的数据。它将时间序列分解成几个部分——趋势、季节性和随机噪声，并绘制如下:</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="ea23" class="kr ks hh kn b fi kt ku l kv kw">from statsmodels.tsa.seasonal import seasonal_decompose<br/>decomposition = seasonal_decompose(data_train)</span><span id="84d9" class="kr ks hh kn b fi lk ku l kv kw">trend = decomposition.trend<br/>seasonal = decomposition.seasonal<br/>residual = decomposition.resid</span><span id="7a83" class="kr ks hh kn b fi lk ku l kv kw">plt.subplot(411)<br/>plt.plot(ts_log, label='Original')<br/>plt.legend(loc='best')<br/>plt.subplot(412)<br/>plt.plot(trend, label='Trend')<br/>plt.legend(loc='best')<br/>plt.subplot(413)<br/>plt.plot(seasonal,label='Seasonality')<br/>plt.legend(loc='best')<br/>plt.subplot(414)<br/>plt.plot(residual, label='Residuals')<br/>plt.legend(loc='best')<br/>plt.tight_layout()<br/></span></pre><figure class="ki kj kk kl fd lc er es paragraph-image"><div class="er es ly"><img src="../Images/511ca20b112f6703255812643e419d81.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/format:webp/1*gJ8wWTrPR1g_vb8p3lvJRg.png"/></div><figcaption class="lf lg et er es lh li bd b be z dx">Time Series Decomposition</figcaption></figure><p id="e24b" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">从上面的图中，我们可以分别看到时间序列的趋势、季节性和噪声成分。我们有一个为期一年的积极趋势和季节性。由于我们的时间序列有季节性，我们将使用SARIMA模型。</p><p id="053e" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">6。萨里玛模型:</p><p id="6a1c" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">萨里玛代表<strong class="iy hi"> S </strong>季节<strong class="iy hi"> A </strong> uto <strong class="iy hi"> R </strong>过度<strong class="iy hi"> I </strong>整合<strong class="iy hi"> M </strong>移动<strong class="iy hi"> A </strong>平均值。它是ARIMA模型的扩展。SARIMA模型还考虑了时间序列的季节性成分。</p><p id="6bc1" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iy hi">自回归</strong>:类似于常规回归。在自回归中，它使用以前时间步长的观测值作为回归方程的输入，来预测下一个时间步长的值。</p><p id="2c9b" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iy hi">综合</strong>:这个步长差分是为了使时间序列更加平稳。</p><p id="265c" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iy hi">移动平均</strong>:计算移动平均是为了减少误差。</p><p id="1cb3" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">对于序列的趋势和季节元素，SARIMA模型被表示为<code class="du ky kz la kn b">SARIMA(p,d,q).(P,D,Q).m</code>超参数。</p><p id="a436" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="kx">趋势元素(模型的非季节性部分)</em></p><p id="2d59" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">有三个趋势元素:</p><ul class=""><li id="0b9f" class="js jt hh iy b iz ja jc jd jf ju jj jv jn jw jr kb jy jz ka bi translated"><strong class="iy hi"> p </strong>:趋势自回归顺序。它是模型中包含的滞后观测值的数量。</li><li id="2473" class="js jt hh iy b iz kc jc kd jf ke jj kf jn kg jr kb jy jz ka bi translated"><strong class="iy hi"> d </strong>:趋势差序。原始观测值有差异的次数。</li><li id="f303" class="js jt hh iy b iz kc jc kd jf ke jj kf jn kg jr kb jy jz ka bi translated"><strong class="iy hi"> q </strong>:趋势移动平均线下单。指定移动平均窗口的大小。</li></ul><p id="ae14" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="kx">季节要素</em></p><ul class=""><li id="fd9a" class="js jt hh iy b iz ja jc jd jf ju jj jv jn jw jr kb jy jz ka bi translated"><strong class="iy hi"> P </strong>:季节性自回归顺序。</li><li id="9f4c" class="js jt hh iy b iz kc jc kd jf ke jj kf jn kg jr kb jy jz ka bi translated"><strong class="iy hi"> D </strong>:季节差单。</li><li id="118b" class="js jt hh iy b iz kc jc kd jf ke jj kf jn kg jr kb jy jz ka bi translated"><strong class="iy hi"> Q </strong>:季节性移动平均订单。</li><li id="9aa6" class="js jt hh iy b iz kc jc kd jf ke jj kf jn kg jr kb jy jz ka bi translated"><strong class="iy hi"> m </strong>:单个季节周期的时间步数。</li></ul><p id="5eb3" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们找出超参数的所有组合:</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="ba6d" class="kr ks hh kn b fi kt ku l kv kw">import itertools<br/>p = d = q = range(0, 2)<br/>pdq = list(itertools.product(p, d, q))<br/>seasonal_pdq = [(x[0], x[1], x[2], 12) for x in list(itertools.product(p, d, q))]<br/>print('Examples of parameter for SARIMA...')<br/>print('SARIMAX: {} x {}'.format(pdq[1], seasonal_pdq[1]))<br/>print('SARIMAX: {} x {}'.format(pdq[1], seasonal_pdq[2]))<br/>print('SARIMAX: {} x {}'.format(pdq[2], seasonal_pdq[3]))<br/>print('SARIMAX: {} x {}'.format(pdq[2], seasonal_pdq[4]))</span></pre><figure class="ki kj kk kl fd lc er es paragraph-image"><div class="er es lz"><img src="../Images/181a944667caa89552f597ac46a07341.png" data-original-src="https://miro.medium.com/v2/resize:fit:582/format:webp/1*VlU_o812mwVRoN33iaAwYg.png"/></div><figcaption class="lf lg et er es lh li bd b be z dx">Examples of parameter for SARIMA</figcaption></figure><p id="844a" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了选择SARIMA模型的超材料，我们将使用“网格搜索”。这将为我们提供一组最佳参数，为我们的模型带来最佳性能。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="aaca" class="kr ks hh kn b fi kt ku l kv kw">import warnings<br/>warnings.filterwarnings('ignore')<br/>import statsmodels.api as sm<br/>for param in pdq:<br/>    for param_seasonal in seasonal_pdq:<br/>        try:<br/>            mod = sm.tsa.statespace.SARIMAX(data_train,order=param,seasonal_order=param_seasonal,enforce_stationarity=False,enforce_invertibility=False)<br/>            results = mod.fit()<br/>            print('SARIMA{}x{}12 - AIC:{}'.format(param,param_seasonal,results.aic))<br/>        except Exception as E: <br/>            print(E)<br/>            continue</span></pre><p id="1462" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">结果如下:</p><figure class="ki kj kk kl fd lc er es paragraph-image"><div class="er es ma"><img src="../Images/f3ddd8f431d0a9be2cd87c8447207706.png" data-original-src="https://miro.medium.com/v2/resize:fit:802/format:webp/1*V4DNDHFPBBVATFZ47ySg7g.png"/></div></figure><figure class="ki kj kk kl fd lc er es paragraph-image"><div class="er es mb"><img src="../Images/15de788c5b01095ecb34e2d7af1cbc62.png" data-original-src="https://miro.medium.com/v2/resize:fit:838/format:webp/1*uF2CqWjZZb3ZREY7U46EkQ.png"/></div></figure><p id="9b3c" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">从上面的结果，我们有最小的AIC为<code class="du ky kz la kn b">SARIMAX(1, 1, 1)x(1, 1, 1, 12).</code> AIC是赤池的信息标准。</p><p id="36f6" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在训练数据集上训练模型:</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="f6b6" class="kr ks hh kn b fi kt ku l kv kw">from statsmodels.tsa.statespace.sarimax import SARIMAX</span><span id="579b" class="kr ks hh kn b fi lk ku l kv kw">mod= SARIMAX(data_train,order=(1,1,1),seasonal_order=(1, 1, 1, 12),enforce_invertibility=False, enforce_stationarity=False)<br/>results = mod.fit(disp=0)<br/>print(results.summary())</span></pre><figure class="ki kj kk kl fd lc er es paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="er es mc"><img src="../Images/9550ccb8a5ec1d73d27b14995154d060.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QBkNuzH3lCn8EoGPuc-kGg.png"/></div></div><figcaption class="lf lg et er es lh li bd b be z dx">SARIMA Results</figcaption></figure><p id="79c0" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">绘制我们的结果:</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="372b" class="kr ks hh kn b fi kt ku l kv kw">pred_sarima = results.forecast(50)<br/>predicted =plt.plot(pred_sarima,label='Prediction by SARIMA', color='red')<br/>Actual = plt.plot(data_for_dist_fitting,label='Actual data')<br/>plt.legend(loc='best') <br/>plt.title('SARIMA MODEL')<br/>plt.show(block=False)</span></pre><figure class="ki kj kk kl fd lc er es paragraph-image"><div class="er es md"><img src="../Images/e71af7071f12fd5580da870eeadeabf8.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/1*kuwlbtQcQoP9i8uQG7Mm6g.png"/></div><figcaption class="lf lg et er es lh li bd b be z dx">Prediction by SARIMA Model</figcaption></figure><p id="5843" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们将绘制残差的线图，表明可能仍有一些趋势信息未被模型捕捉到。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="15b2" class="kr ks hh kn b fi kt ku l kv kw"># plot residual errors of the training data<br/>residual_error = pd.DataFrame(results.resid)<br/>residual_error.plot()<br/>plt.show()</span></pre><figure class="ki kj kk kl fd lc er es paragraph-image"><div class="er es me"><img src="../Images/9bae0b832f6526120092959f17d2a8ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:908/format:webp/1*QYxFX6avJuE8SsazgfhWvQ.png"/></div><figcaption class="lf lg et er es lh li bd b be z dx">SARIMA fit residual error line plot</figcaption></figure><p id="60f8" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在我们将得到残差值的密度图，表明误差是高斯的，但可能不以零为中心。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="aa62" class="kr ks hh kn b fi kt ku l kv kw">residual_error.plot(kind='kde')<br/>plt.show()<br/>print(residual_error.describe())</span></pre><figure class="ki kj kk kl fd lc er es paragraph-image"><div class="er es mf"><img src="../Images/4d24d0a46a9b0e816816008f38c6cc53.png" data-original-src="https://miro.medium.com/v2/resize:fit:880/format:webp/1*eyuq5hcxO-0PNWXL447oYw.png"/></div><figcaption class="lf lg et er es lh li bd b be z dx">SARIMA fit residual error density plot</figcaption></figure><p id="71c2" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">从残差的分布可以看出，由于均值不为零(均值=0.993986~1)，我们的模型存在偏差</p><p id="b826" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iy hi"> 7。滚动预测:</strong></p><p id="4929" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了减少这种误差并避免偏差，我们可以进行滚动预测，在滚动预测中，我们将在下一个时间段的预测中使用最新的预测值。这可以通过在接收到每个观察值后重新创建SARIMA模型来完成。我们将在一个名为history的列表中手动跟踪所有的观察结果，该列表以训练数据为种子，并且每次迭代都会向其追加新的观察结果。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="c837" class="kr ks hh kn b fi kt ku l kv kw">#to suppress warnings<br/>warnings.filterwarnings('ignore')</span><span id="85d1" class="kr ks hh kn b fi lk ku l kv kw">from sklearn.metrics import mean_squared_error</span><span id="cd32" class="kr ks hh kn b fi lk ku l kv kw">#creating new dataframe for rolling forescast<br/>history = np.log(data_train.astype(float))<br/>predictions = list()</span><span id="7d01" class="kr ks hh kn b fi lk ku l kv kw">for i in range(len(data_for_dist_fitting)): <br/>    model = SARIMAX(history,order=(1,1,1),seasonal_order=(1, 1, 1, 12),enforce_invertibility=False, enforce_stationarity=False)<br/>    model_fit = model.fit(disp = 0)<br/>    # generate forcecast for next period<br/>    output = model_fit.forecast()<br/>    #Save the prediction value in yhat<br/>    yhat = np.e ** output[0]<br/>    #Append yhat to the list of prediction<br/>    predictions.append(yhat)<br/>    # grabs the observation at the ith index<br/>    obs = data_for_dist_fitting[i : i + 1]<br/>    # appends the observation to the estimation data set<br/>    history = history.append(np.log(obs.astype(float)))<br/>    <br/># prints the MSE of the model for the rolling forecast period<br/>error = mean_squared_error(data_for_dist_fitting, predictions)<br/>print('Test MSE: %.3f' % error)</span><span id="db45" class="kr ks hh kn b fi lk ku l kv kw"># converts the predictions list to a pandas dataframe with the same index as the actual values<br/># for plotting purposes<br/>predictions = pd.DataFrame(predictions)<br/>predictions.index = data_for_dist_fitting.index</span><span id="2210" class="kr ks hh kn b fi lk ku l kv kw"># sets the plot size to 12x8<br/>mlp.rcParams['figure.figsize'] = (12,8)</span><span id="e47b" class="kr ks hh kn b fi lk ku l kv kw"># plots the predicted and actual stock prices <br/>plt.plot(data_for_dist_fitting,label='Actual values')<br/>plt.plot(predictions, color = 'red', label='predicted rolling forecast')<br/>plt.legend(loc='best')<br/>plt.xlabel('week')<br/>plt.ylabel('#passengers')<br/>plt.title('Predicted vs. Actual #of passengers')<br/>plt.show()</span></pre><figure class="ki kj kk kl fd lc er es paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="er es mg"><img src="../Images/dcee95fbc13f11667ee12698009c9671.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LKYPJxNQ9q4QGLvVEQoLzw.png"/></div></div><figcaption class="lf lg et er es lh li bd b be z dx">Rolling Forecast prediction vs Actual Demand</figcaption></figure><p id="d674" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们现在将绘制一个误差图:</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="709a" class="kr ks hh kn b fi kt ku l kv kw"># to suppress warnings<br/>warnings.filterwarnings('ignore')</span><span id="dc58" class="kr ks hh kn b fi lk ku l kv kw"># sets the plot size to 12x8<br/>mlp.rcParams['figure.figsize'] = (12,8)</span><span id="5975" class="kr ks hh kn b fi lk ku l kv kw"># plots the rolling forecast error <br/>rf_errors = data_for_dist_fitting.no_passengers - predictions[0]<br/>rf_errors.plot(kind = 'kde')</span><span id="535f" class="kr ks hh kn b fi lk ku l kv kw"># produces a summary of rolling forecast error <br/>rf_errors.astype(float).describe()</span></pre><figure class="ki kj kk kl fd lc er es paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="er es mh"><img src="../Images/fbbecbe22155d7096e09dcd93560bc7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uynZxGhRUiDkSgUI5Hy3tA.png"/></div></div><figcaption class="lf lg et er es lh li bd b be z dx">Rolling forecast (SARIMA) fit residual error density plot</figcaption></figure><figure class="ki kj kk kl fd lc er es paragraph-image"><div class="er es mi"><img src="../Images/2f978269466846033ca4d1688a78c885.png" data-original-src="https://miro.medium.com/v2/resize:fit:330/format:webp/1*iGm4zMM0hq879Q52a7bDyQ.png"/></div><figcaption class="lf lg et er es lh li bd b be z dx">Rolling forecast (SARIMA) fit residual error description</figcaption></figure><p id="1248" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iy hi"> 8。选择用于预测的分布:</strong></p><p id="16fe" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">对于MCS的第二部分-生成随机数，我们将使用这个密度图。它大致呈钟形，似乎以0°为中心。查看分布函数，我们可以说正态分布或拉普拉斯分布可能适合。我们也可以用钳工来检查。<strong class="iy hi"> fitter </strong>包提供了一个简单的类来识别一个数据样本是从哪个分布中生成的。它使用来自Scipy的80个分布，并允许您绘制结果以检查什么是最可能的分布和最佳参数。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="d88b" class="kr ks hh kn b fi kt ku l kv kw"># to suppress warnings<br/>import warnings<br/>warnings.filterwarnings('ignore')</span><span id="a4d1" class="kr ks hh kn b fi lk ku l kv kw"># imports the fitter function and produces estimated fits for our rsarima_errors<br/>from fitter import Fitter,get_common_distributions,get_distributions</span><span id="c8fd" class="kr ks hh kn b fi lk ku l kv kw">f = Fitter(rf_errors, distributions=['binomial','norm','laplace','uniform'])<br/>f.fit()<br/>f.summary()</span></pre><figure class="ki kj kk kl fd lc er es paragraph-image"><div class="er es mj"><img src="../Images/ca2e63788c9dd403eeb0fc631976f8e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:756/format:webp/1*QaMf_Reg5LOnUQgcIo7y3g.png"/></div><figcaption class="lf lg et er es lh li bd b be z dx">Summary of distribution fit</figcaption></figure><p id="b524" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">sum函数根据sumsquare_error值按升序排列最佳的五个分布。它还提供了直方图上不同分布的图示。</p><figure class="ki kj kk kl fd lc er es paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="er es mk"><img src="../Images/b634ac3d72aef2e9b53d7d3228a4ce8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l3B1_RuviXPy2aYBtbC46Q.png"/></div></div><figcaption class="lf lg et er es lh li bd b be z dx">Different distributions fitted over a histogram</figcaption></figure><p id="f120" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">从上面的函数可以看出，正态分布是最合适的。我已经尝试应用正态分布和拉普拉斯分布，拉普拉斯分布在这个例子中给出了更好的结果，所以我们将使用拉普拉斯分布。拉普拉斯分布类似于高斯/正态分布，但是在峰值处更尖锐，并且具有更宽的尾部。</p><p id="fa8b" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iy hi"> 9。创建一个函数用拉普拉斯分布进行蒙特卡罗模拟:</strong></p><p id="b244" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">所以在这里我们首先找出了滚动预测的残差密度图(预测的时间段为- <code class="du ky kz la kn b">data_for_dist_fitting</code>(这是数据划分的线图中红色的数据)。然后我们将定义一个拉普拉斯分布函数来得到随机数的估计范围。计算滚动预测误差的方差。我们将把它作为拉普拉斯分布中的一个标度——第二个参数<code class="du ky kz la kn b">np.random.laplace(loc,scale,size)</code>。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="27b4" class="kr ks hh kn b fi kt ku l kv kw">def lapace_mc_randv_distribution(mean, rf_errors, n_sim):</span><span id="cd9e" class="kr ks hh kn b fi lk ku l kv kw">   #gets the estimated beta or mean absolute distance from the mean<br/>    var = (sum(abs(rf_errors - np.mean(rf_errors))) <br/>                           / len(rf_errors))</span><span id="bab8" class="kr ks hh kn b fi lk ku l kv kw">    # uses the numpy function to generate an array of simulated values<br/>    est_range = np.random.laplace(mean,var,n_sim)<br/>    # converts the array to a list<br/>    est_range = list(est_range)<br/>    # returns the simulated values<br/>    return(est_range)</span></pre><p id="0f83" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iy hi"> 10。创建MC分配函数:</strong></p><p id="cdfa" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们为滚动预测蒙特卡罗模拟创建了一个函数，类似于滚动预测函数。我们可以使用我们选择的分布(拉普拉斯分布)生成经验推导的预测区间，平均值将是我们的预测需求，比例将根据残差计算，作为与平均值的平均绝对距离，以及由用户选择的模拟数量。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="b66e" class="kr ks hh kn b fi kt ku l kv kw">def rolling_forecast_MC(train, test, std_dev, n_sims):<br/>   <br/> # create a new dataframe that will be added to as the forecast rolls <br/>    history = np.log(data_train.astype(float))<br/>    <br/># create an empty list that will hold predictions<br/>    predictions = list()</span><span id="42aa" class="kr ks hh kn b fi lk ku l kv kw"># loops through the indexes of the set being forecasted<br/>    for i in range(len(test_data)): <br/>        model = SARIMAX(history,order=(1,1,1),seasonal_order=(1, 1, 1, 12),enforce_invertibility=False, enforce_stationarity=False)<br/>        model_fit = model.fit(disp = 0)</span><span id="6b6e" class="kr ks hh kn b fi lk ku l kv kw">        # generate forcecast for next period<br/>        output = model_fit.forecast().values</span><span id="4b58" class="kr ks hh kn b fi lk ku l kv kw">        #Save the prediction value in yhat       <br/>        yhat = np.e ** output[0]<br/> <br/>       # performs monte carlo simulation using the predicted price as the mean, user-specified<br/>        # standard deviation, and number of simulations<br/>       randv_range = lapace_mc_randv_distribution(yhat,std_dev,n_sims)<br/>      <br/>        #Append yhat to the list of prediction<br/>        predictions.append([float(i) for i in randv_range])<br/>       <br/>        # grabs the observation at the ith index<br/>        obs = test_data[i : i + 1]<br/>      <br/>        # appends the observation to the estimation data set<br/>        history = history.append(np.log(obs.astype(float)))<br/>        <br/>        # converts the predictions list to a pandas dataframe with the same index as the actual <br/>    # values for plotting purposes<br/>    predictions = pd.DataFrame(predictions)<br/>    predictions.index = test_data.index<br/>        <br/>    # returns predictions<br/>    return(predictions)</span></pre><p id="5d18" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">好了，现在我们已经为蒙特卡洛模拟定义了函数，现在我们将把为调查预测残差而保留的数据附加回训练数据集，以避免第一次预测出现较大误差。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="ccb0" class="kr ks hh kn b fi kt ku l kv kw">data_train = data_train.append(data_for_dist_fitting)</span></pre><p id="7cfd" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">使用1000 MC模拟生成带有预测间隔的滚动预测:</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="1f06" class="kr ks hh kn b fi kt ku l kv kw">test_preds = rolling_forecast_MC(data_train, <br/>                               test_data, <br/>                               rf_errors,<br/>                              1000)</span></pre><p id="a0c7" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们画出我们的预测:</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="e4b1" class="kr ks hh kn b fi kt ku l kv kw">MC = plt.plot(test_preds)<br/>Actual=plt.plot(test_data,color='black',label='Actual Demand')<br/>plt.legend(loc='best')<br/>plt.show()</span></pre><figure class="ki kj kk kl fd lc er es paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="er es ml"><img src="../Images/49d1c29ad2fd50005f9ee577846a0509.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OXcoslCOc-P7wdf3TCMGNw.png"/></div></div><figcaption class="lf lg et er es lh li bd b be z dx">Monte carlo Simulations and Actual Demand line plot</figcaption></figure><p id="61a2" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在上图中，黑线代表实际需求，其他线代表通过蒙特卡洛模拟预测的不同需求。</p><p id="0516" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们计算模拟需求的平均值，模拟需求的分位数(5%)和分位数(95%)。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="0380" class="kr ks hh kn b fi kt ku l kv kw">print('Expected demand:',np.mean(test_preds.values))<br/>print('Quantile(5%):',np.percentile(test_preds,5))<br/>print('Quantile(95%):',np.percentile(test_preds,95))</span></pre><figure class="ki kj kk kl fd lc er es paragraph-image"><div class="er es lz"><img src="../Images/b8c60e4090b5e639fd896642206d1823.png" data-original-src="https://miro.medium.com/v2/resize:fit:582/format:webp/1*1EhrXaljLSOPVxLVGRYHZQ.png"/></div><figcaption class="lf lg et er es lh li bd b be z dx">Analysis of simulated demand forecast</figcaption></figure><p id="ee6c" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">从上面的结果中，我们可以看到有5%的概率需求会低于368，有5%的概率需求会高于623。我们的预期需求。</p><p id="0256" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们可以继续下一步，绘制需求的最小-最大范围，并计算模型的准确性。为此，我们需要每行(时间段)的列表格式的预测数据。</p><p id="e9d7" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">因此，我们将创建上述函数的副本，并通过使用预测<code class="du ky kz la kn b">predictions.values.tolist().</code>在每行列表中获得结果</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="2d84" class="kr ks hh kn b fi kt ku l kv kw">def rolling_forecast_MC_for_minmax_range(train, test, std_dev, n_sims):<br/>    # create a new dataframe that will be added to as the forecast rolls <br/>    history = np.log(data_train.astype(float))<br/>    # create an empty list that will hold predictions<br/>    predictions = list()</span><span id="acd7" class="kr ks hh kn b fi lk ku l kv kw"># loops through the indexes of the set being forecasted<br/>    for i in range(len(test_data)): <br/>        model = SARIMAX(history,order=(1,1,1),seasonal_order=(1, 1, 1, 12),enforce_invertibility=False, enforce_stationarity=False)<br/>        model_fit = model.fit(disp = 0)</span><span id="e89f" class="kr ks hh kn b fi lk ku l kv kw">        # generate forcecast for next period<br/>        output = model_fit.forecast().values<br/>        <br/>        #Save the prediction value in yhat       <br/>        yhat = np.e ** output[0]<br/>        <br/>       # performs monte carlo simulation using the predicted price as the mean, user-specified<br/>        # standard deviation, and number of simulations<br/>        randv_range = lapace_mc_randv_distribution(yhat,std_dev,n_sims)<br/>       <br/>        #Append yhat to the list of prediction<br/>        predictions.append([float(i) for i in randv_range])<br/>       <br/>       # grabs the observation at the ith index<br/>        obs = test_data[i : i + 1]<br/>        <br/>      # appends the observation to the estimation data set<br/>        history = history.append(np.log(obs.astype(float)))<br/>        <br/>    # converts the predictions list to a pandas dataframe with the same index as the actual <br/>    # values for plotting purposes</span><span id="3c12" class="kr ks hh kn b fi lk ku l kv kw">    predictions = pd.DataFrame(predictions)<br/>    # converts all the estimated yhats in each column to one list per row<br/>    predictions['predicted_range'] = predictions.values.tolist()<br/>   <br/>   # grabs only the column with all values in a list<br/>    predictions = pd.DataFrame(predictions['predicted_range'])<br/>    predictions.index = test_data.index<br/>        <br/>    # returns predictions<br/>    return(predictions)</span></pre><p id="e664" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">使用1000 MC模拟生成带有预测间隔的滚动预测:</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="fc04" class="kr ks hh kn b fi kt ku l kv kw"># produces a rolling forecast with prediction intervals using 1000 MC sims<br/>test_preds_minmax = rolling_forecast_MC_for_minmax_range(data_train, <br/>                               test_data, <br/>                               rf_errors,<br/>                              1000)</span></pre><p id="3cda" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们来看看我们的预测数据是怎样的:</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="9efc" class="kr ks hh kn b fi kt ku l kv kw">test_preds_minmax.head()</span></pre><figure class="ki kj kk kl fd lc er es paragraph-image"><div class="er es mm"><img src="../Images/9de35cfa4202ce0ee0200ca541a44385.png" data-original-src="https://miro.medium.com/v2/resize:fit:796/format:webp/1*Msn98mel0V-5Ah_9xVzVRg.png"/></div><figcaption class="lf lg et er es lh li bd b be z dx">Prediction data with MCS</figcaption></figure><p id="18c1" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">要检查模型的准确性:</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="32b2" class="kr ks hh kn b fi kt ku l kv kw"># creates an empty list<br/>prediction_interval = []<br/># loops through the rows in the testing data set<br/>for i in range(len(test_data)):<br/>    # appends true if the actual price is in the interval of predicted prices and false<br/>    # otherwise<br/>    prediction_interval.append(np.where(min(test_preds_minmax.predicted_range[i]) &lt;= <br/>                                           test_data.no_passengers[i]<br/>                                          &lt;= max(test_preds_minmax.predicted_range[i]), <br/>                                           True, False))<br/># prints the percentage of actual prices in the prediction intervals    <br/>print('Percentage of Demand in Predicted Demand Range: %f' % <br/>      (100 * sum(prediction_interval) / len(prediction_interval)))</span></pre><p id="9cff" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">结果:</p><figure class="ki kj kk kl fd lc er es paragraph-image"><div class="er es mf"><img src="../Images/5bc965cf39c760e9f837d7c24fcaf5b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:880/format:webp/1*V1StFkFQhG951uSTWR_tdg.png"/></div><figcaption class="lf lg et er es lh li bd b be z dx">Accuracy of the model</figcaption></figure><p id="6d00" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">上述结果告诉我们，我们的需求将100%低于模拟预测范围的最小和最大范围。我们也可以这样绘制:</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="4bfe" class="kr ks hh kn b fi kt ku l kv kw"># creates empty lists to append to with minimum and maximum values for each weeks prediction<br/>min_range = []<br/>max_range = []</span><span id="ec8a" class="kr ks hh kn b fi lk ku l kv kw"># loops through the rows in test_preds<br/>for i in range(len(test_preds_minmax)):<br/>    # appends to the list the min or max value as appropriate<br/>    min_range.append(min(test_preds_minmax.predicted_range[i]))<br/>    max_range.append(max(test_preds_minmax.predicted_range[i]))<br/>    <br/># converts the lists to data frames and makes their indexes match up with the dates they're<br/># predicting<br/>min_range = pd.DataFrame(min_range)<br/>min_range.index = test_data.index<br/>max_range = pd.DataFrame(max_range)<br/>max_range.index = test_data.index</span><span id="7a9a" class="kr ks hh kn b fi lk ku l kv kw"># plots the actual stock price with prediction intervals<br/>plt.plot(test_data, color ='red',label='Actual Data')<br/>plt.plot(min_range, color = 'm', label='Min range')<br/>plt.plot(max_range, color = 'b', label ='Max range')<br/>plt.legend(loc='best')<br/>plt.xlabel('Month')<br/>plt.ylabel('No of Passengers')<br/>plt.title('Actual Demand with Prediction Intervals')<br/>plt.show()</span></pre><figure class="ki kj kk kl fd lc er es paragraph-image"><div class="er es mn"><img src="../Images/91188d30c1dbb2e01295d1824acded7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/1*Q8SEjUqiKrJRXsIbsAUZPQ.png"/></div><figcaption class="lf lg et er es lh li bd b be z dx">Prediction interval vs Actual demand</figcaption></figure><p id="e996" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在本文中，我们应用蒙特卡罗模拟法来预测航空旅客的未来需求。通过这样做，获得了需求的概率预测，以及每个时间段(月)的最小和最大需求范围的估计。</p><p id="8193" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我希望你喜欢阅读这篇文章。</p><p id="8881" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">参考资料:</p><p id="b967" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">对于滚动预测-<a class="ae kh" href="https://machinelearningmastery.com/arima-for-time-series-forecasting-with-python/" rel="noopener ugc nofollow" target="_blank">https://machine learning mastery . com/ARIMA-for-time-series-forecasting-with-python/</a></p><p id="57f2" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">对于SARIMA模型-<a class="ae kh" href="https://machinelearningmastery.com/sarima-for-time-series-forecasting-in-python/" rel="noopener ugc nofollow" target="_blank">https://machine learning mastery . com/SARIMA-for-time-series-forecasting-in-python/</a></p><p id="89e5" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">用于网格搜索SARIMA模型超参数- <a class="ae kh" href="https://machinelearningmastery.com/how-to-grid-search-sarima-model-hyperparameters-for-time-series-forecasting-in-python/" rel="noopener ugc nofollow" target="_blank">如何网格搜索SARIMA超参数进行时间序列预测(machinelearningmastery.com)</a></p><div class="mo mp ez fb mq mr"><a rel="noopener follow" target="_blank" href="/mlearning-ai/mlearning-ai-submission-suggestions-b51e2b130bfb"><div class="ms ab dw"><div class="mt ab mu cl cj mv"><h2 class="bd hi fi z dy mw ea eb mx ed ef hg bi translated">Mlearning.ai提交建议</h2><div class="my l"><h3 class="bd b fi z dy mw ea eb mx ed ef dx translated">如何成为Mlearning.ai上的作家</h3></div><div class="mz l"><p class="bd b fp z dy mw ea eb mx ed ef dx translated">medium.com</p></div></div><div class="na l"><div class="nb l nc nd ne na nf ld mr"/></div></div></a></div></div></div>    
</body>
</html>