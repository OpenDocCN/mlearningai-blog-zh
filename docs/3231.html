<html>
<head>
<title>Group Similar Short Text and Assign ID Using DBSCAN in R</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在R中使用DBSCAN对相似的短文本进行分组并分配ID</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/group-similar-short-text-and-assign-id-using-dbscan-f0c6e9856b73?source=collection_archive---------2-----------------------#2022-08-07">https://medium.com/mlearning-ai/group-similar-short-text-and-assign-id-using-dbscan-f0c6e9856b73?source=collection_archive---------2-----------------------#2022-08-07</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/3a501b969a9599c2ef407267672161f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CI2TiRoxIAUA3J3G071iEw.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Picture by <a class="ae it" href="https://unsplash.com/@officestock" rel="noopener ugc nofollow" target="_blank">Sebastian Herrmann</a> from <a class="ae it" href="https://unsplash.com/photos/jzTQVxCyKYs" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="a9df" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">“我们有超过20年的交易数据”我听到他这样说。“它有数百万条交易记录”</p><p id="f4a4" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">“嗯，这是个好消息。”我兴高采烈。这是我开发数据科学项目的头几周，该项目旨在整合各种数据、客户的数字行为及其交易数据。</p><p id="bc18" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">“我们将对此进行调查，并在完成数据审核后向您报告最新情况”。</p><p id="cfc8" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">几天后，我们带着发现回来了。“我们已经检查了数据。然而，它似乎缺少了一个关于客户的基本列。它没有客户ID，只有客户姓名和他们购买的产品”。</p><p id="8c8d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">"你能检查一下他们是否有国籍证明吗？"他们问</p><p id="9695" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">“专栏中没有任何我们可以用来识别客户是否是同一个人的信息。“没有电子邮件、电话号码或身份证，”我们解释说，“如果我们无法识别一个客户是同一个人，我们就无法模拟他们的行为，如购买频率、他们下次购买的时间以及其他交易行为。”</p><p id="1a9b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">“我们知道，当人们填写姓名时，可能会出现一些拼写错误或不同的拼写。我认为我们现在可以开发的是测量姓名之间的相似性，并为具有一定相似度的每个姓名分配ID”。</p><p id="a01a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">“嗯。那我们开始吧”。</p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><h1 id="6970" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">测量和标准化文本相似性</h1><p id="6f1a" class="pw-post-body-paragraph iu iv hh iw b ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn lb jp jq jr ha bi translated">作为数据科学家，我们会遇到各种各样与数据相关的问题。在上面的例子中，我们得到了非常脏的数据，其中企业所有者拥有没有客户ID的遗留数据。问题是，名字可能会拼错。</p><p id="7a98" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">幸运的是，有算法可以测量两个文本之间的相似性。我们这里用的是Levenshtein距离。</p><p id="ef34" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Levenshtein距离度量将一个单词转换为另一个单词所需的最小单字符编辑次数。更多关于Levenshtein distance的信息可以通过这个<a class="ae it" href="https://www.cuelogic.com/blog/the-levenshtein-algorithm" rel="noopener ugc nofollow" target="_blank">链接</a>找到。</p><p id="9cdb" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在R中，我们可以使用包<em class="lc"> stringr </em>和函数<em class="lc"> adist。</em>参见下面的示例代码:</p><figure class="ld le lf lg fd ii"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="e67e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果我们想比较文本“韩国”和“德国”，我们可以看到上面的结果。我们可以得出两个结论。</p><p id="c5df" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">第一个</strong>。该算法区分大小写，如“韩国”和“韩国”之间的距离所示</p><p id="7fe7" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">第二个</strong>。结果取决于文本的数量。由于“韩国”和“德国”差别很大，所以距离是11。文本数量越多，距离越高。没有办法将结果标准化，例如在0-100之间，以方便用户做出决定(<strong class="iw hi">显然，我们更容易说相似度是80%，而不是相似度是2 </strong>)。</p><p id="c78a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们将在代码中添加两种处理来缓解这两种约束。首先，将文本改为小写，并删除不必要的字符。第二步，将距离转换为0-100之间的数字。我们使用这个公式来测量它:(1 —距离/最大可能距离)* 100</p><p id="394c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">请参见下面的示例:</p><figure class="ld le lf lg fd ii"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="d4d1" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们现在能够测量文本之间的距离和标准化的分数。事实是，当我们收到非常糟糕的数据，比如第一个故事中的问题，这些数据会以数百、数千甚至数十万行的形式出现。</p><p id="2b54" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们首先要做的是如何让解决方案规模化，随时可用。我们需要把数据转换成表格。缩放溶液的顺序如下:</p><ol class=""><li id="371f" class="lj lk hh iw b ix iy jb jc jf ll jj lm jn ln jr lo lp lq lr bi translated">使用<em class="lc"> expand.grid </em>将文本扩展到表格中</li><li id="e563" class="lj lk hh iw b ix ls jb lt jf lu jj lv jn lw jr lo lp lq lr bi translated">小写并删除不必要的字符</li><li id="4b90" class="lj lk hh iw b ix ls jb lt jf lu jj lv jn lw jr lo lp lq lr bi translated">测量距离并归一化分数</li></ol><p id="39b2" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">下面的代码就是这么做的！</p><figure class="ld le lf lg fd ii"><div class="bz dy l di"><div class="lh li l"/></div><figcaption class="ip iq et er es ir is bd b be z dx">R function to measure and normalise distance</figcaption></figure><p id="57b2" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">对上述功能使用相同输入的结果</p><figure class="ld le lf lg fd ii"><div class="bz dy l di"><div class="lh li l"/></div></figure><figure class="ld le lf lg fd ii er es paragraph-image"><div class="er es lx"><img src="../Images/b136973a2092832aeebf54d1c85d2e67.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/1*MsOtBr3qnLlCeQNicNy_iQ.png"/></div><figcaption class="ip iq et er es ir is bd b be z dx">Result from R</figcaption></figure><h1 id="4112" class="jz ka hh bd kb kc ly ke kf kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw bi translated">使用DBSCAN分配ID</h1><p id="420e" class="pw-post-body-paragraph iu iv hh iw b ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn lb jp jq jr ha bi translated">最后一步是为相似的文本分配ID。在上面的例子中，我们希望“韩国”和“韩国”有相同的ID，而“德国”将有自己的ID。为此，我们将使用名为DBSCAN的聚类算法。更多关于DBSCAN的信息可以在这里找到<a class="ae it" href="https://towardsdatascience.com/dbscan-clustering-explained-97556a2ad556" rel="noopener" target="_blank">。</a></p><p id="6dff" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">总体代码可以在下面的函数中找到。代码采用一些默认参数。例如，被认为是相似文本的最低分数。在这种情况下，最低分是80。其他默认参数是将用于DBSCAN算法的距离0.15。我们还有一个选项来考虑是否包括“空格”字符，以及如果我们想在文本相似性计算中忽略大小写(小写或大写)的选项。</p><p id="1812" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">好消息是，我们可以在调用函数时改变这些参数值。</p><figure class="ld le lf lg fd ii"><div class="bz dy l di"><div class="lh li l"/></div><figcaption class="ip iq et er es ir is bd b be z dx">R function to measure distance and assign D</figcaption></figure><p id="496f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们看看当我们使用相同的输入“韩国”、“韩国”和“德国”时的结果。</p><figure class="ld le lf lg fd ii"><div class="bz dy l di"><div class="lh li l"/></div></figure><figure class="ld le lf lg fd ii er es paragraph-image"><div class="er es md"><img src="../Images/3e9e155896cf1210fb73b8f6f7160b1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:736/format:webp/1*lxH5B_KlknUIaTqzEpg0YQ.png"/></div><figcaption class="ip iq et er es ir is bd b be z dx">Result from R Studio</figcaption></figure><p id="ee4b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">瞧。它工作了。</p><h1 id="97b2" class="jz ka hh bd kb kc ly ke kf kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw bi translated">结论</h1><p id="09ae" class="pw-post-body-paragraph iu iv hh iw b ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn lb jp jq jr ha bi translated">在这篇文章中，我向你展示了如何测量文本之间的距离，归一化分数，然后分配ID。如果我们有没有ID的脏文本数据，这些数据有许多行，并且我们想确定哪些文本属于同一个组，那么这个解决方案将非常方便。</p><p id="0260" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">幸运的是，我已经为此创建了一个包。请检查我的GitHub <a class="ae it" href="https://github.com/dessyamirudin/similaRText" rel="noopener ugc nofollow" target="_blank">包similaRText </a></p><h1 id="8d60" class="jz ka hh bd kb kc ly ke kf kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw bi translated">来源</h1><p id="f9ae" class="pw-post-body-paragraph iu iv hh iw b ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn lb jp jq jr ha bi translated"><a class="ae it" href="https://www.cuelogic.com/blog/the-levenshtein-algorithm" rel="noopener ugc nofollow" target="_blank">https://www.cuelogic.com/blog/the-levenshtein-algorithm</a></p><div class="me mf ez fb mg mh"><a href="https://towardsdatascience.com/dbscan-clustering-explained-97556a2ad556" rel="noopener follow" target="_blank"><div class="mi ab dw"><div class="mj ab mk cl cj ml"><h2 class="bd hi fi z dy mm ea eb mn ed ef hg bi translated">DBSCAN集群—解释</h2><div class="mo l"><h3 class="bd b fi z dy mm ea eb mn ed ef dx translated">详细的理论解释和scikit-learn实现</h3></div><div class="mp l"><p class="bd b fp z dy mm ea eb mn ed ef dx translated">towardsdatascience.com</p></div></div><div class="mq l"><div class="mr l ms mt mu mq mv in mh"/></div></div></a></div><div class="me mf ez fb mg mh"><a rel="noopener follow" target="_blank" href="/mlearning-ai/mlearning-ai-submission-suggestions-b51e2b130bfb"><div class="mi ab dw"><div class="mj ab mk cl cj ml"><h2 class="bd hi fi z dy mm ea eb mn ed ef hg bi translated">Mlearning.ai提交建议</h2><div class="mo l"><h3 class="bd b fi z dy mm ea eb mn ed ef dx translated">如何成为Mlearning.ai上的作家</h3></div><div class="mp l"><p class="bd b fp z dy mm ea eb mn ed ef dx translated">medium.com</p></div></div><div class="mq l"><div class="mw l ms mt mu mq mv in mh"/></div></div></a></div></div></div>    
</body>
</html>