<html>
<head>
<title>Understanding a Basic Recommendation System</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解基本的推荐系统</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/understanding-a-basic-recommendation-system-d6fd0d8cbb83?source=collection_archive---------1-----------------------#2021-04-30">https://medium.com/mlearning-ai/understanding-a-basic-recommendation-system-d6fd0d8cbb83?source=collection_archive---------1-----------------------#2021-04-30</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="0183" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">机器学习系列:第一部分</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/9efa529fb7523b0cb539b76c1f7a0396.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*675lMh6zhC34HEMU__4KEQ.jpeg"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx"><a class="ae jm" href="https://pixabay.com/" rel="noopener ugc nofollow" target="_blank">Source</a></figcaption></figure><p id="f32a" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">因此，我一直在从事一个基于推荐系统的项目，并决定将我对这些系统如何工作的理解写在博客上，希望能帮助一名即将到来的数据科学家。另外，请随时通过我的<a class="ae jm" href="https://www.linkedin.com/in/rithwikshetty/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>:)与我联系</p><h2 id="684f" class="kj kk hh bd kl km kn ko kp kq kr ks kt jw ku kv kw ka kx ky kz ke la lb lc ld bi translated"><strong class="ak">什么是推荐系统？</strong></h2><blockquote class="le lf lg"><p id="bbd3" class="jn jo lh jp b jq jr ii js jt ju il jv li jx jy jz lj kb kc kd lk kf kg kh ki ha bi translated">一个<strong class="jp hi">推荐系统</strong>，或者一个<strong class="jp hi">推荐系统</strong>(有时用一个同义词如平台或者<strong class="jp hi">引擎</strong>代替“<strong class="jp hi">系统</strong>”)，是信息过滤<strong class="jp hi">系统</strong>的一个子类，它试图预测用户对一个项目的“评分”或者“偏好”。</p></blockquote><p id="f0e3" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">让我为你简化一下。下面是一个在YouTube上播放的视频截图，你可以在右手边看到视频列表。向我们展示(推荐)这几组视频，是因为它们的内容与我们正在观看的视频相似，机器学习模型预测我们可能会对它们感兴趣。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/fe89c4d89e9deca397a0222fc0660dc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xrE6OfcSzfLCwdMyI6yDbw.png"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx">Main video (LEFT), Recommended Videos (RIGHT)</figcaption></figure><p id="bd9e" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">我们可以看到网飞和亚马逊也在使用类似的系统，在那里我们可以分别看到“因为你看过《盗梦空间》”和“看过这个项目的顾客也看过:”这样的分类。现在，让我们试着通过各种矩阵运算来深入了解这些系统。</p><h2 id="296e" class="kj kk hh bd kl km kn ko kp kq kr ks kt jw ku kv kw ka kx ky kz ke la lb lc ld bi translated">数据</h2><p id="2331" class="pw-post-body-paragraph jn jo hh jp b jq ll ii js jt lm il jv jw ln jy jz ka lo kc kd ke lp kg kh ki ha bi translated">假设我们有一个矩阵<strong class="jp hi"> A </strong>，其中每一行表示一个唯一的用户(<strong class="jp hi"> u_i) </strong>，每一列表示一部唯一的电影(<strong class="jp hi"> I_j) </strong>，矩阵元素(<strong class="jp hi"> A_ij </strong>)可以是二进制的(如果用户<strong class="jp hi"> u_i </strong>看过电影<strong class="jp hi"> I_j </strong>或者整数(由用户<strong class="jp hi">u _ I<strong class="jp hi">评级)<em class="lh">从下图</em>中你会有更好的理解。</strong></strong></p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lq"><img src="../Images/fdb702108434815ca7a44e723e899255.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bRC91eyHknTvI-k2KdsOnQ.jpeg"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx">Matrix A has <strong class="bd kl">n users </strong>and <strong class="bd kl">m movies</strong>, hence denoted as A_nxm</figcaption></figure><p id="fd82" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">我们可以说矩阵A是一个<strong class="jp hi">稀疏矩阵</strong>，意味着矩阵中的大部分值是0或Na(在整数的情况下)。<strong class="jp hi">为什么？因为在现实世界中，有数十亿用户和数百万部电影，单个用户几乎不可能观看每一部电影。所以假设矩阵中的大多数元素是0或Na是安全的。</strong></p><p id="c66d" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">从这个给定的矩阵A中，我们可以了解一个推荐系统是如何构建的。</p><h2 id="24d3" class="kj kk hh bd kl km kn ko kp kq kr ks kt jw ku kv kw ka kx ky kz ke la lb lc ld bi translated">简单的推荐系统</h2><blockquote class="le lf lg"><p id="f38d" class="jn jo lh jp b jq jr ii js jt ju il jv li jx jy jz lj kb kc kd lk kf kg kh ki ha bi translated">a) <strong class="jp hi">基于用户-用户的推荐系统:</strong></p></blockquote><ul class=""><li id="e6a6" class="lr ls hh jp b jq jr jt ju jw lt ka lu ke lv ki lw lx ly lz bi translated">考虑一个矩阵<strong class="jp hi"> A </strong>有<strong class="jp hi"> n行</strong>(用户)和<strong class="jp hi"> m列</strong>(项目)(如图所示)。</li><li id="4f44" class="lr ls hh jp b jq ma jt mb jw mc ka md ke me ki lw lx ly lz bi translated">我们可以分离所有的用户向量(<strong class="jp hi"> u_1，u_2…，u_n </strong>)来自矩阵A，<em class="lh">如图所示</em>。每个向量由用户<strong class="jp hi"> u_i </strong>对电影<strong class="jp hi"> I_1 </strong>到<strong class="jp hi"> I_m </strong>给出的评级组成</li></ul><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mf"><img src="../Images/4b796af442aa92a4dd2f4a7cd310e757.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ySorh4NvunUzb6hMtAplOA.jpeg"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx"><strong class="bd kl">U_i</strong> is a user vector (for all i ranging from 1 to n)</figcaption></figure><ul class=""><li id="07bd" class="lr ls hh jp b jq jr jt ju jw lt ka lu ke lv ki lw lx ly lz bi translated">现在，取<strong class="jp hi"> u_i </strong>和<strong class="jp hi"> u_j </strong>的所有组合，我们可以计算两个向量之间的相似度。也就是说，我们可以计算两个用户彼此有多相似。在我们的例子中，我们将计算两个向量之间的<a class="ae jm" href="https://en.wikipedia.org/wiki/Cosine_similarity" rel="noopener ugc nofollow" target="_blank"> <strong class="jp hi">余弦相似度</strong> </a>。从而创建一个<strong class="jp hi">相似度矩阵S </strong> ( <strong class="jp hi"> <em class="lh"> nxn </em> </strong>)。</li></ul><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mg"><img src="../Images/b8db67926c7e4a01b95009118e44bc0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FX6ENO4FyuO9gPlro3sZKA.jpeg"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx">Similarity Matrix S_nxn</figcaption></figure><p id="3f59" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">现在如果要给(比如说)用户<strong class="jp hi"> u_10 </strong>推荐什么东西，可以查一下<strong class="jp hi"> u_10 </strong>和谁最相似(最好是top 3相似)。然后我们检查哪些项目(电影)没有被<strong class="jp hi"> u_10 </strong>观看，但是被同类用户评价良好。那些项目可以推荐给我们的用户<strong class="jp hi"> u_10 </strong>。</p><p id="dba2" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">这种方法的问题是用户的喜好会随着时间而改变，所以我们可能会推荐用户不再感兴趣的东西。</p><blockquote class="le lf lg"><p id="cafb" class="jn jo lh jp b jq jr ii js jt ju il jv li jx jy jz lj kb kc kd lk kf kg kh ki ha bi translated">b) <strong class="jp hi">基于项目的推荐系统</strong></p></blockquote><p id="f3de" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">这种推荐系统在21世纪初被亚马逊广泛使用。</p><ul class=""><li id="ba0a" class="lr ls hh jp b jq jr jt ju jw lt ka lu ke lv ki lw lx ly lz bi translated">这里的概念非常类似于用户-用户类型的推荐系统。这里的主要区别是，我们不是从用户向量计算相似性矩阵<strong class="jp hi"> S </strong>，而是使用项目向量来计算它。</li><li id="76b4" class="lr ls hh jp b jq ma jt mb jw mc ka md ke me ki lw lx ly lz bi translated">每个向量<strong class="jp hi"> I_j </strong> (I_1，I_2 … I_m)由每个用户(u_1，u_2 … u_n)对<strong class="jp hi">项目j. </strong>给出的所有评分组成</li></ul><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mh"><img src="../Images/99ed4b54a3d77b27be8863b79a2dc46f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H0N3jYKA9Yhhxqs16Sz5bw.jpeg"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx">Similarity Matrix S_mxm</figcaption></figure><p id="4824" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">现在，如果用户喜欢电影(比如说)<strong class="jp hi"> I_10、I_21和I_30 </strong>，我们可以检查哪些电影与这些最相似，优先选择常见的电影。</p><p id="5ced" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">当<strong class="jp hi"> a) </strong>用户数量远大于项目数量，以及<strong class="jp hi"> b) </strong>当我们知道项目评级在一定时间后不会改变时，可以使用基于项目的推荐系统。</p><h2 id="f1b3" class="kj kk hh bd kl km kn ko kp kq kr ks kt jw ku kv kw ka kx ky kz ke la lb lc ld bi translated">基于机器学习的推荐系统</h2><p id="b25c" class="pw-post-body-paragraph jn jo hh jp b jq ll ii js jt lm il jv jw ln jy jz ka lo kc kd ke lp kg kh ki ha bi translated">现代推荐系统是使用机器学习技术构建的。推荐系统可以是:</p><h2 id="8efb" class="kj kk hh bd kl km kn ko kp kq kr ks kt jw ku kv kw ka kx ky kz ke la lb lc ld bi translated">1.分类/回归系统(基于内容的过滤):</h2><p id="d6f7" class="pw-post-body-paragraph jn jo hh jp b jq ll ii js jt lm il jv jw ln jy jz ka lo kc kd ke lp kg kh ki ha bi translated">从矩阵A中，如果我们有关于每个用户<strong class="jp hi"> u_i </strong>和电影<strong class="jp hi"> m_j </strong>的更多信息，我们可以继续创建一个新的传统数据集，其中<strong class="jp hi"> u_i </strong>的特征与<strong class="jp hi"> m_j、</strong>的特征连接作为属性，元素<strong class="jp hi"> A_ij </strong>作为<strong class="jp hi"> </strong>类标签。<em class="lh">(如图所示)</em></p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mi"><img src="../Images/1270e6abbdad230e121f83f3e25eb843.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d2IUAkKwD78WsivbP4YW1w.jpeg"/></div></div></figure><p id="de81" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">我们的模型可以在A_ij可用的数据上训练。测试数据由所有的<strong class="jp hi"> Null A_ij </strong>值组成(建议)。</p><p id="c9cf" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">这里的主要任务是到达<strong class="jp hi"> u_i &amp; m_j. </strong>的<strong class="jp hi">特征表示</strong></p><h2 id="fd6f" class="kj kk hh bd kl km kn ko kp kq kr ks kt jw ku kv kw ka kx ky kz ke la lb lc ld bi translated">2.矩阵完成系统(协同过滤):</h2><ul class=""><li id="b2e6" class="lr ls hh jp b jq ll jt lm jw mj ka mk ke ml ki lw lx ly lz bi translated">这是一种更常用的方法，我们将在本系列的后面部分深入研究这种方法背后的数学原理。为了让你对这是如何工作的有一个基本的了解，让我们假设一个用户<strong class="jp hi"> u_1 </strong>已经观看并且喜欢电影<strong class="jp hi"> I_1、I_3和I_7 </strong>，并且用户<strong class="jp hi"> u_2 </strong>已经观看并且喜欢电影<strong class="jp hi"> I_3、I_6和I_7 </strong>。</li></ul><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mm"><img src="../Images/c0808902b6c59e1f9ec2f09d200ce974.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bln1Lz0nl9-M9OsF30_Eig.jpeg"/></div></div></figure><ul class=""><li id="90aa" class="lr ls hh jp b jq jr jt ju jw lt ka lu ke lv ki lw lx ly lz bi translated">现在考虑另一个用户<strong class="jp hi"> u_3 </strong>，他刚刚看完电影<strong class="jp hi"> I_3 </strong>。</li><li id="3fc1" class="lr ls hh jp b jq ma jt mb jw mc ka md ke me ki lw lx ly lz bi translated">根据现有数据，我们知道喜欢过电影<strong class="jp hi">i3</strong>的用户(<strong class="jp hi">u1和U2</strong>)也喜欢过电影<strong class="jp hi">i7。因此，向我们的用户<strong class="jp hi"> u_3 </strong>推荐电影<strong class="jp hi"> I_7 </strong>到<strong class="jp hi"> </strong>可能是安全的。</strong></li></ul><h2 id="240e" class="kj kk hh bd kl km kn ko kp kq kr ks kt jw ku kv kw ka kx ky kz ke la lb lc ld bi translated">结论</h2><p id="d808" class="pw-post-body-paragraph jn jo hh jp b jq ll ii js jt lm il jv jw ln jy jz ka lo kc kd ke lp kg kh ki ha bi translated">在本系列的下一部分中，我们将看到如何使用诸如非负矩阵分解之类的操作来解决这个矩阵补全问题。我们还将了解机器学习优化方程是如何求解的，以及如何向用户提供建议。</p></div></div>    
</body>
</html>