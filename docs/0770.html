<html>
<head>
<title>Image Classification on CIFAR-10 with 15 Lines OF Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用15行代码在CIFAR-10上进行图像分类</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/image-classification-on-cifar-10-with-15-lines-of-code-52341e7fb00c?source=collection_archive---------2-----------------------#2021-07-11">https://medium.com/mlearning-ai/image-classification-on-cifar-10-with-15-lines-of-code-52341e7fb00c?source=collection_archive---------2-----------------------#2021-07-11</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><blockquote class="ie if ig"><p id="791e" class="ih ii ij ik b il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf ha bi translated">在15行代码内训练CIFAR-10图像分类器的快速方法</p></blockquote><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es jg"><img src="../Images/17b58292053b5de5ae8bcfb1b0c6f1db.png" data-original-src="https://miro.medium.com/v2/resize:fit:998/format:webp/1*r8Ampw0tYHoy_Bj-nwMOaw.png"/></div><figcaption class="jo jp et er es jq jr bd b be z dx">CIFAR-10 Dataset</figcaption></figure><h1 id="608e" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">介绍</h1><p id="90f4" class="pw-post-body-paragraph ih ii hh ik b il kq in io ip kr ir is ks kt iv iw ku kv iz ja kw kx jd je jf ha bi translated">在这篇博客中，我们将使用迁移学习并在流行的深度学习框架TensorFlow的帮助下，在流行的CIFAR-10数据集上构建并训练一个图像分类器CNN。我们的主要目的是展示用几行代码就可以在大型数据集上获得良好的准确性。通过对各种超参数进行更精细的调整，我们可以获得更好的结果。</p><h1 id="f21b" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">导入库</h1><p id="de57" class="pw-post-body-paragraph ih ii hh ik b il kq in io ip kr ir is ks kt iv iw ku kv iz ja kw kx jd je jf ha bi translated">我们将只导入TensorFlow库，因为该库足以完成从数据收集到模型选择和实现的所有任务。</p><pre class="jh ji jj jk fd ky kz la lb aw lc bi"><span id="62a8" class="ld jt hh kz b fi le lf l lg lh">import tensorflow as tf </span></pre><h1 id="7910" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated"><strong class="ak">数据集</strong></h1><p id="e5b1" class="pw-post-body-paragraph ih ii hh ik b il kq in io ip kr ir is ks kt iv iw ku kv iz ja kw kx jd je jf ha bi translated">CIFAR-10数据集由10类60000幅32x32彩色图像组成，每类6000幅图像。有50000个训练图像和10000个测试图像。我们可以通过tensorflow库直接访问这个数据集。</p><pre class="jh ji jj jk fd ky kz la lb aw lc bi"><span id="2a36" class="ld jt hh kz b fi le lf l lg lh">dataset = tf.keras.datasets.cifar10<br/>(x_train,y_train), (x_test , y_test) = dataset.load_data()</span></pre><p id="5ba3" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is ks iu iv iw ku iy iz ja kw jc jd je jf ha bi translated">数据已经在训练和测试子集中分开。我们将使用测试数据作为我们的验证数据，并借助验证准确性对模型的性能进行评分。</p><h1 id="fa73" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">预处理</h1><p id="78f6" class="pw-post-body-paragraph ih ii hh ik b il kq in io ip kr ir is ks kt iv iw ku kv iz ja kw kx jd je jf ha bi translated">我们现在将在拟合模型中的数据之前预处理我们的数据，以减少过度拟合的问题。这个过程被称为<strong class="ik hi">数据扩充。</strong>为此，我们将使用<strong class="ik hi"> </strong> tensorflow库中的<strong class="ik hi"> ImageDataGenerator </strong>函数。</p><p id="dab9" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is ks iu iv iw ku iy iz ja kw jc jd je jf ha bi translated">首先，我们将开始规范我们的形象。</p><pre class="jh ji jj jk fd ky kz la lb aw lc bi"><span id="1616" class="ld jt hh kz b fi le lf l lg lh">x_train = x_train /255 ; x_test = x_test/255</span></pre><p id="1b61" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is ks iu iv iw ku iy iz ja kw jc jd je jf ha bi translated">然后我们将调用<strong class="ik hi"> ImageDataGenerator </strong>函数，设置图像水平翻转、缩放、宽度和高度移动的各种参数。</p><pre class="jh ji jj jk fd ky kz la lb aw lc bi"><span id="c0ee" class="ld jt hh kz b fi le lf l lg lh">data_generator = tf.keras.preprocessing.image.ImageDataGenerator(<br/>horizontal_flip=True,<br/>zoom_range=0.05,<br/>width_shift_range=0.05 ,<br/>height_shift_range=0.05)</span></pre><p id="b1a7" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is ks iu iv iw ku iy iz ja kw jc jd je jf ha bi translated">现在，我们将使用<strong class="ik hi">。流</strong>方法来创建训练数据集。对于这项任务，我们将使用32的批量。批量大小是指必须通过网络才能更新权重的图像数量。</p><pre class="jh ji jj jk fd ky kz la lb aw lc bi"><span id="962f" class="ld jt hh kz b fi le lf l lg lh">train_generator = data_generator.flow(x_train, y_train, batch_size=32)</span></pre><p id="376b" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is ks iu iv iw ku iy iz ja kw jc jd je jf ha bi translated">到目前为止，我们已经加载了必要的库和数据集，并预处理了数据以适应我们的模型。所有这些都是在5行代码内完成的。</p><h1 id="c567" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">CNN模型设计</h1><p id="dd8b" class="pw-post-body-paragraph ih ii hh ik b il kq in io ip kr ir is ks kt iv iw ku kv iz ja kw kx jd je jf ha bi translated">我们将在迁移学习的帮助下建立模型。为此，我们将使用ResNet50V2型号。我们还将使用已经训练好的ImageNet权重作为模型的初始化权重。</p><p id="fc2d" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is ks iu iv iw ku iy iz ja kw jc jd je jf ha bi translated">我们将首先设计一个基础模型，其中我们将使用迁移学习来导入ResNet50V2，然后将这个基础模型添加到我们的顺序API中。ResNet50V2可以从<strong class="ik hi">tensor flow . applications</strong>导入。在参数中，我们将保持<strong class="ik hi"> include_top = False，</strong>因为我们将在下一部分创建我们自己的全连接层。我们将设置<strong class="ik hi"> weights="imagenet" </strong>并在<strong class="ik hi"> input_shape </strong>参数中使用图像的形状。</p><pre class="jh ji jj jk fd ky kz la lb aw lc bi"><span id="3591" class="ld jt hh kz b fi le lf l lg lh">base_model = tf.keras.applications.ResNet50V2(<br/>include_top=False,<br/>weights="imagenet",<br/>input_shape=x_train.shape[1:])</span></pre><p id="0fea" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is ks iu iv iw ku iy iz ja kw jc jd je jf ha bi translated">接下来，我们将使用TensorFlow库为我们的模型创建一个顺序API。我们将首先添加我们的<strong class="ik hi">基础模型</strong>到我们的主模型，然后是一个<strong class="ik hi">展平</strong>层。展平层将基本模型的输出传递给下一个完全连接的层。通过将输出转换为一维阵列网络，我们将添加一个具有1024个单元的<strong class="ik hi">密集</strong>层，然后添加一个具有0.2丢失率的<strong class="ik hi">丢失</strong>层。丢弃层有助于减少训练数据的过拟合，从而有助于减少高方差。最后一个密集图层将有10个输出单位，激活设置为softmax，因为这是一个多类分类。</p><pre class="jh ji jj jk fd ky kz la lb aw lc bi"><span id="fc78" class="ld jt hh kz b fi le lf l lg lh">model= tf.keras.Sequential()<br/>model.add(base_model) <br/>model.add(tf.keras.layers.Flatten())<br/>model.add(tf.keras.layers.Dense(1024,activation=('relu'))) <br/>model.add(tf.keras.layers.Dropout(.2))<br/>model.add(tf.keras.layers.Dense(10,activation=('softmax')))</span></pre><h1 id="cc88" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">编译和拟合模型</h1><p id="8e70" class="pw-post-body-paragraph ih ii hh ik b il kq in io ip kr ir is ks kt iv iw ku kv iz ja kw kx jd je jf ha bi translated">由于我们的数据已经过预处理，我们的模型也准备好了，现在是编译模型的时候了。</p><pre class="jh ji jj jk fd ky kz la lb aw lc bi"><span id="353c" class="ld jt hh kz b fi le lf l lg lh">model.compile(<br/>optimizer=tf.keras.optimizers.Adam(learning_rate = 0.0005),<br/>loss = "sparse_categorical_crossentropy",<br/>metrics = ["accuracy"])</span></pre><p id="ddd8" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is ks iu iv iw ku iy iz ja kw jc jd je jf ha bi translated">我们将使用Adam优化器并设置<strong class="ik hi"> learning_rate = 0.0005 </strong>。我们将使用<strong class="ik hi">loss = " sparse _ category _ cross entropy "</strong>和准确性作为我们对结果进行评分的标准。</p><p id="e544" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is ks iu iv iw ku iy iz ja kw jc jd je jf ha bi translated">在成功编译我们的模型之后，我们现在将调用fit函数并将进度度量保存在历史中。接下来，我们使用<strong class="ik hi"> train_generator </strong>作为我们的训练数据，并设置验证数据= <strong class="ik hi"> (x_test，y_test) </strong>，因为我们正在对我们的模型进行验证准确性评分。我们将把历元的数量设置为<strong class="ik hi"> 15 </strong>并且详细度等于1。</p><pre class="jh ji jj jk fd ky kz la lb aw lc bi"><span id="c43a" class="ld jt hh kz b fi le lf l lg lh">history = model.fit(train_generator , <br/>                    validation_data=(x_test , y_test), <br/>                    steps_per_epoch = x_train.shape[0]/32,<br/>                    epochs=10 ,<br/>                    verbose = 1 )</span></pre><p id="fb32" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is ks iu iv iw ku iy iz ja kw jc jd je jf ha bi translated">在对模型进行15个时期的训练后，我们在训练集上得到大约83.3%的准确率<strong class="ik hi"/>，在测试集上得到大约77.85%的准确率<strong class="ik hi"/>。</p><p id="6b00" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is ks iu iv iw ku iy iz ja kw jc jd je jf ha bi translated">最后，我们将使用<strong class="ik hi"> model.save </strong>函数保存我们的模型。</p><pre class="jh ji jj jk fd ky kz la lb aw lc bi"><span id="4006" class="ld jt hh kz b fi le lf l lg lh">model.save("CIFAR-10.h5")</span></pre><h1 id="e41f" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">结论</h1><p id="2010" class="pw-post-body-paragraph ih ii hh ik b il kq in io ip kr ir is ks kt iv iw ku kv iz ja kw kx jd je jf ha bi translated">我们已经成功地训练了CIFAR-10数据集，并且仅用15行代码就达到了的准确率。</p><pre class="jh ji jj jk fd ky kz la lb aw lc bi"><span id="da90" class="ld jt hh kz b fi le lf l lg lh">import tensorflow as tf                                           #1</span><span id="3904" class="ld jt hh kz b fi li lf l lg lh">(x_train  , y_train) , (x_test , y_test)  = tf.keras.datasets.cifar10.load_data()                             #2</span><span id="259a" class="ld jt hh kz b fi li lf l lg lh">x_train = x_train /255 ; x_test = x_test/255                      #3</span><span id="3125" class="ld jt hh kz b fi li lf l lg lh">data_generator = tf.keras.preprocessing.image.ImageDataGenerator(<br/>horizontal_flip=True,<br/>zoom_range=0.05,                                                               width_shift_range=0.05 ,                                                                 height_shift_range=0.05)                                          #4</span><span id="b5cc" class="ld jt hh kz b fi li lf l lg lh">train_generator = data_generator.flow(x_train, y_train,32)        #5</span><span id="5791" class="ld jt hh kz b fi li lf l lg lh">base_model = tf.keras.applications.ResNet50V2(<br/>include_top=False,<br/>weights="imagenet",<br/>input_shape=x_train.shape[1:] ,<br/>classes = 10)                                                     #6</span><span id="6d1f" class="ld jt hh kz b fi li lf l lg lh">model= tf.keras.Sequential()                                      #7<br/>model.add(base_model)                                             #8<br/>model.add(tf.keras.layers.Flatten())                              #9<br/>model.add(tf.keras.layers.Dense(1024,activation=('relu')))       #10<br/>model.add(tf.keras.layers.Dropout(.2))                           #11 <br/>model.add(tf.keras.layers.Dense(10,activation=('softmax')))      #12</span><span id="cac3" class="ld jt hh kz b fi li lf l lg lh"><br/>model.compile(<br/>optimizer=tf.keras.optimizers.Adam(learning_rate = 0.0005),<br/>loss = "sparse_categorical_crossentropy",<br/>metrics = ["accuracy"])                                          #13</span><span id="7ffa" class="ld jt hh kz b fi li lf l lg lh">history = model.fit(train_generator , <br/>                    validation_data=(x_test , y_test), <br/>                    steps_per_epoch = x_train.shape[0]/32,<br/>                    epochs=10 ,<br/>                    verbose = 1 )                                #14</span><span id="ed32" class="ld jt hh kz b fi li lf l lg lh">model.save("CIFAR-10.h5")                                        #15</span></pre><p id="2dc7" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is ks iu iv iw ku iy iz ja kw jc jd je jf ha bi translated">我希望你喜欢它。</p><p id="5c56" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is ks iu iv iw ku iy iz ja kw jc jd je jf ha bi translated">这个博客的代码和训练模型可以在这里获得——<a class="ae lj" href="https://github.com/sanskar-hasija/CIFAR10-15LOC" rel="noopener ugc nofollow" target="_blank">https://github.com/sanskar-hasija/CIFAR10-15LOC</a></p><p id="1f2c" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is ks iu iv iw ku iy iz ja kw jc jd je jf ha bi translated">此外，如果你想要这个分类的完整版本，有更好的超参数设置选择，你可以检查这个——<a class="ae lj" href="https://github.com/sanskar-hasija/CIFAR_10_ResNet" rel="noopener ugc nofollow" target="_blank">https://github.com/sanskar-hasija/CIFAR_10_ResNet</a></p></div></div>    
</body>
</html>