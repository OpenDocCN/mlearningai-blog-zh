<html>
<head>
<title>A Practical Guide to Time Series Data Analysis Using Pandas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Pandas进行时间序列数据分析的实用指南</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/a-practical-guide-to-time-series-data-analysis-using-pandas-2720950031?source=collection_archive---------3-----------------------#2021-05-13">https://medium.com/mlearning-ai/a-practical-guide-to-time-series-data-analysis-using-pandas-2720950031?source=collection_archive---------3-----------------------#2021-05-13</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="b147" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">了解如何使用Pandas分析时间序列数据集。</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/29a234afd0ab417362a7ddc0a655d385.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uAz0PNI4YGSQYTgj"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx">Photo by <a class="ae jm" href="https://unsplash.com/@photographybyniels?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Niels Kehl</a> on <a class="ae jm" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="5bd9" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">数据分析师和数据科学家花大部分时间清理和预处理他们的数据。这一步包括获取正确的数据、理解数据、探索数据的模式，以及在构建任何模型之前清理或预处理数据。</p><p id="9409" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">在本文中，我将解释数据分析师如何使用Pandas分析数据，Pandas是一个广泛使用的Python数据分析库。</p><p id="b4bf" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">我将浏览一个由昆汀·考德隆【1】制作的数据集。这是一个时间序列数据集，描述了到某个日期为止意式浓缩咖啡机制作的咖啡总数<strong class="jp hi">。</strong></p><p id="ab34" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">你可以在这里找到数据集:<a class="ae jm" href="https://github.com/QCaudron/pydata_pandas" rel="noopener ugc nofollow" target="_blank">https://github.com/QCaudron/pydata_pandas</a></p><p id="db8d" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">在继续之前，请确保将以下库下载并导入到您的笔记本中:</p><ul class=""><li id="cc63" class="kj kk hh jp b jq jr jt ju jw kl ka km ke kn ki ko kp kq kr bi translated">熊猫</li><li id="f2f7" class="kj kk hh jp b jq ks jt kt jw ku ka kv ke kw ki ko kp kq kr bi translated">Matplotlib</li><li id="dbba" class="kj kk hh jp b jq ks jt kt jw ku ka kv ke kw ki ko kp kq kr bi translated">Numpy</li></ul><p id="edc9" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">此外，在继续之前，确保你知道熊猫的基本知识。如果你想了解熊猫，你可以使用<a class="ae jm" href="https://pandas.pydata.org/docs/" rel="noopener ugc nofollow" target="_blank">文档</a>或者看看科里·斯查费写的关于熊猫的<a class="ae jm" href="https://www.youtube.com/watch?v=ZyhVh-qRZPA&amp;list=PL-osiE80TeTsWmV9i9c58mdDCSskIFdDS" rel="noopener ugc nofollow" target="_blank">系列教程</a>。</p><h1 id="9f0d" class="kx ky hh bd kz la lb lc ld le lf lg lh in li io lj iq lk ir ll it lm iu ln lo bi translated">导入和理解数据</h1><p id="f26c" class="pw-post-body-paragraph jn jo hh jp b jq lp ii js jt lq il jv jw lr jy jz ka ls kc kd ke lt kg kh ki ha bi translated">一旦有了CSV格式的数据集，就可以使用pandas中的<code class="du lu lv lw lx b">.read_csv()</code>方法将文件读入数据框。这允许用户导入CSV文件并将其转换为数据框。Pandas提供了许多不同的方法来通过读取不同的文件类型创建数据帧，函数列表可以在<a class="ae jm" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="718d" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">导入数据后，您可以查看数据的外观，并对数据有所了解。您可以使用打印出列名列表的<code class="du lu lv lw lx b">df.columns</code>方法来查看列。</p><p id="8a03" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">此外，您可以使用<code class="du lu lv lw lx b">df.describe()</code>获得数据的描述性统计摘要。在这里，您可以看到行数、列的平均值、标准偏差、最小值、最大值和每列的百分比。这是一个非常方便的工具，因为不用为所有列重复生成这些值，只需调用一次函数就可以获得所有值。</p><h1 id="3a21" class="kx ky hh bd kz la lb lc ld le lf lg lh in li io lj iq lk ir ll it lm iu ln lo bi translated">清理数据</h1><p id="64fc" class="pw-post-body-paragraph jn jo hh jp b jq lp ii js jt lq il jv jw lr jy jz ka ls kc kd ke lt kg kh ki ha bi translated">我们在现实世界中得到的大多数数据集并不干净，包含一些缺失值或随机垃圾值。因此，分析师花大部分时间清理数据，并将其转换成有用和有意义的东西。</p><p id="8bf5" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">在本节中，我将解释以下任务:</p><ul class=""><li id="ac69" class="kj kk hh jp b jq jr jt ju jw kl ka km ke kn ki ko kp kq kr bi translated">列的数据类型不正确</li><li id="3a76" class="kj kk hh jp b jq ks jt kt jw ku ka kv ke kw ki ko kp kq kr bi translated">处理缺失值</li></ul><h2 id="2dd1" class="ly ky hh bd kz lz ma mb ld mc md me lh jw mf mg lj ka mh mi ll ke mj mk ln ml bi translated">不正确的数据类型</h2><p id="138d" class="pw-post-body-paragraph jn jo hh jp b jq lp ii js jt lq il jv jw lr jy jz ka ls kc kd ke lt kg kh ki ha bi translated">一旦理解了数据，就知道列应该是什么数据类型。您可以使用<code class="du lu lv lw lx b">dtypes</code>检查数据类型。这将为数据集中的每一列返回一个具有数据类型的series对象。具有<em class="mm">对象</em>数据类型的列是字符串，其他数据类型是众所周知的整型和浮点型。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es mn"><img src="../Images/681f8382fcd1bea67d547d7c1df8ac52.png" data-original-src="https://miro.medium.com/v2/resize:fit:932/format:webp/1*Q-JYU-s36VHMymfcVpPmOw.jpeg"/></div><figcaption class="ji jj et er es jk jl bd b be z dx">Source : Image by Author</figcaption></figure><p id="59b9" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">正如您在数据集中看到的，coffees列是一个对象数据类型，但这没有意义，因为coffees应该只是coffees的数量，并且应该是int或float。因此，我们将进一步研究这个列，看看它为什么显示object数据类型。</p><p id="3496" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">如果您打印前5行，您将在coffees列中看到“testing”的值。这是一个字符串，这就是为什么数据类型是object。因此，您可以删除该行，并使用<code class="du lu lv lw lx b">pd.to_numeric()</code>方法将该列转换为正确的数据类型。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es mo"><img src="../Images/699777c10c6884cdf4c98eab74e11edf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1218/format:webp/1*0QvhjxTPmhfs2vhH0RCiow.jpeg"/></div><figcaption class="ji jj et er es jk jl bd b be z dx">Source : Image by Author</figcaption></figure><p id="0e0f" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">另外，<em class="mm">时间戳</em>列应该是日期时间类型，而不是字符串，因为它允许我们对它应用日期时间函数。当导入CSV文件时，pandas将datetime列作为字符串读取，您需要使用<code class="du lu lv lw lx b">pd.to_datetime()</code>方法将其转换为datetime。</p><h2 id="e934" class="ly ky hh bd kz lz ma mb ld mc md me lh jw mf mg lj ka mh mi ll ke mj mk ln ml bi translated">处理缺失值</h2><p id="b593" class="pw-post-body-paragraph jn jo hh jp b jq lp ii js jt lq il jv jw lr jy jz ka ls kc kd ke lt kg kh ki ha bi translated">有许多不同的方法来处理数据集中的缺失值。您使用的方法将取决于您的问题陈述和您拥有的数据集。但是，使用的主要技术是估算一些值，如平均值或中值来代替缺失值，或者删除包含缺失值的行。您也可以删除缺少值的列。参考文档以了解如何处理丢失的值。</p><p id="cc2f" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">在这里，我可以使用<code class="du lu lv lw lx b">df[‘coffees’].isnull().sum()</code>检查coffees列中缺失值的数量。在检查和查找丢失的值时，您应该了解为什么会丢失值。这里，机器坏了几次，因此值丢失了。因此，我们可以使用<code class="du lu lv lw lx b">.dropna()</code>方法删除空值行。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es mp"><img src="../Images/1a85010fd2dafdff0128076051308fe5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/1*vf9fczzRhS_J6k53RYnTow.jpeg"/></div><figcaption class="ji jj et er es jk jl bd b be z dx">Source : Image by Author</figcaption></figure><h1 id="27ae" class="kx ky hh bd kz la lb lc ld le lf lg lh in li io lj iq lk ir ll it lm iu ln lo bi translated">可视化和分析数据</h1><p id="7f26" class="pw-post-body-paragraph jn jo hh jp b jq lp ii js jt lq il jv jw lr jy jz ka ls kc kd ke lt kg kh ki ha bi translated">对于可视化时间序列数据，总是建议使用折线图来了解一段时间内的趋势。因此，您可以使用这个时间序列数据集做同样的事情。Pandas有一种简便的方法可以使用<code class="du lu lv lw lx b">df.plot()</code>方法立即绘制图表。你可以在这里看文档<a class="ae jm" href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.plot.html" rel="noopener ugc nofollow" target="_blank">。</a></p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es mq"><img src="../Images/ba48f29087a964e9cf46ad833392e2b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*zIUCoyS6ryMXNUryWHgegg.jpeg"/></div><figcaption class="ji jj et er es jk jl bd b be z dx">Source : Image by Author</figcaption></figure><p id="6c74" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">我们可以看到，在线图中，数据最终是以非常不规则的间隔记录的，我们可以将其从数据集中删除。这将导致更加统一的时间序列图。</p><p id="751f" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">我们也可以先用<code class="du lu lv lw lx b">value_counts()</code>法，再用<code class="du lu lv lw lx b">plot()</code>法和夸尔<code class="du lu lv lw lx b">kind = ‘bar’</code>一起看每个人的贡献数。Value_counts()就像对列上的数据进行分组，然后对其应用<code class="du lu lv lw lx b">count()</code>方法。它只返回列中每个唯一值的计数。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es mq"><img src="../Images/150c7d1b2732b1ccd4a6e14864b23933.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*7X-9XyB5tELi6rZQzO1pmg.jpeg"/></div><figcaption class="ji jj et er es jk jl bd b be z dx">Source : Image by Author</figcaption></figure><p id="5ac7" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">另一个有用的图表是查看每天有多少贡献。为此，我们首先必须从时间戳列中获取工作日名称。由于数据类型现在是datetime，我们可以应用<code class="du lu lv lw lx b">.dt.day_name()</code>来获取日期名称。然后，我们可以根据新的工作日列对其进行分组，获得一个计数，然后绘制一个条形图。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es mq"><img src="../Images/6f5a9cfdb5527124196cb60aca7a36af.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*wmTHx35hKJT91vzYb_wxtQ.jpeg"/></div><figcaption class="ji jj et er es jk jl bd b be z dx">Source : Image by Author</figcaption></figure><h1 id="eef1" class="kx ky hh bd kz la lb lc ld le lf lg lh in li io lj iq lk ir ll it lm iu ln lo bi translated">分析时间序列</h1><p id="0485" class="pw-post-body-paragraph jn jo hh jp b jq lp ii js jt lq il jv jw lr jy jz ka ls kc kd ke lt kg kh ki ha bi translated">处理时序数据时最重要的提示之一是将datetime列设置为数据集的索引。这有助于我们快速分析事物，并允许我们使用时间戳作为索引来索引数据帧。学习基本时间序列的一个有用的资源是伊恩·奥兹瓦尔德<a class="ae jm" href="https://ianozsvald.com/" rel="noopener ugc nofollow" target="_blank"/>【3】的<a class="ae jm" href="https://www.youtube.com/watch?v=8upGdZMlkYM&amp;t=1997s" rel="noopener ugc nofollow" target="_blank"> pydata演讲</a>。</p><p id="37ab" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">现在，我们可以使用以下代码将时间戳列指定为数据帧的索引:</p><pre class="ix iy iz ja fd mr lx ms mt aw mu bi"><span id="f119" class="ly ky hh lx b fi mv mw l mx my">data.index = data[‘timestamp’]</span><span id="ce20" class="ly ky hh lx b fi mz mw l mx my"># Let’s drop the timestamp column, as we no longer need it</span><span id="8d30" class="ly ky hh lx b fi mz mw l mx my">data.drop(columns=’timestamp’, inplace=True)</span><span id="cce2" class="ly ky hh lx b fi mz mw l mx my">data.head()</span></pre><p id="e563" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">现在，我们可以观察到的一个重要现象是，时间戳不是一个固定的时间间隔，即数据不是在每天的特定时间记录的。相反，每天可能有多条记录。因此，为了使我们的分析更容易，我们可以转换数据集，这样我们每天只获得1个值，最好是在每天的午夜。然后，我们可以对可能为NaN的值进行插值，并进一步进行分析。</p><p id="4fde" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">我们现在将创建一个从开始到时间戳列结束的<code class="du lu lv lw lx b">date_range()</code>。这将返回每天午夜的日期范围。然后我们可以把它和这个原始索引结合起来。然后，我们可以将数据框<code class="du lu lv lw lx b">reindex()</code>到我们创建的这个新索引。</p><pre class="ix iy iz ja fd mr lx ms mt aw mu bi"><span id="bef1" class="ly ky hh lx b fi mv mw l mx my"># pd.date_range, with daily frequency, and normalisation</span><span id="2f5c" class="ly ky hh lx b fi mz mw l mx my">midnights = pd.date_range(data.index[0], data.index[-1], freq='D', normalize=True)</span><span id="ab7a" class="ly ky hh lx b fi mz mw l mx my">new_index = midnights.union(data.index)</span><span id="de6d" class="ly ky hh lx b fi mz mw l mx my"># .reindex() the dataframe to get an upsampled dataframe</span><span id="af48" class="ly ky hh lx b fi mz mw l mx my">upsampled_data = data.reindex(new_index)<br/>upsampled_data.head(10)</span></pre><p id="31a8" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated"><code class="du lu lv lw lx b">reindex()</code>的作用是匹配索引处的值。如果该索引有一行数据，它将返回数据，如果索引不匹配，它将返回NaNs。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es na"><img src="../Images/8c33c8dfb5b22e508da9f2a23529aae2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iG7dvXHRZaJnCw5KOXEi0Q.jpeg"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx">Source : Image by Author</figcaption></figure><p id="1644" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">我们现在可以通过内插最近的时间值来填充NaN值。例如，如果3月3日上午8:22有一个值，3月4日上午11:48有一个值，那么3月4日上午12:00的值(因为我们将日期标准化为午夜)将最接近后者的值。这就是插值的基本工作原理。阅读此<a class="ae jm" href="https://stackoverflow.com/questions/30530001/python-pandas-time-series-interpolation-and-regularization" rel="noopener ugc nofollow" target="_blank">讨论</a>以了解更多关于时序插值。</p><pre class="ix iy iz ja fd mr lx ms mt aw mu bi"><span id="289e" class="ly ky hh lx b fi mv mw l mx my"># .interpolate the upsampled_data using the time method</span><span id="6a76" class="ly ky hh lx b fi mz mw l mx my">upsampled_data = upsampled_data.interpolate(method=’time’)</span><span id="7f85" class="ly ky hh lx b fi mz mw l mx my">upsampled_data.head(10)</span></pre><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es nb"><img src="../Images/09b99e83722034108c4e41bd5e454516.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vn_sNb1SBb3TOWOhi_Be5g.jpeg"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx">Source : Image by Author</figcaption></figure><p id="62b6" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">现在，我们可以在每天午夜对数据进行重新采样。这确保了我们在读数之间有一个固定的间隔。</p><pre class="ix iy iz ja fd mr lx ms mt aw mu bi"><span id="5d6b" class="ly ky hh lx b fi mv mw l mx my"># .resample() the upsampled dataframe,</span><span id="67e0" class="ly ky hh lx b fi mz mw l mx my"># using .asfreq() to get only exactly daily values</span><span id="2deb" class="ly ky hh lx b fi mz mw l mx my">daily_data = upsampled_data.resample('D').asfreq()</span><span id="7cce" class="ly ky hh lx b fi mz mw l mx my"># Drop the contributor column, we no longer need it</span><span id="a598" class="ly ky hh lx b fi mz mw l mx my">daily_data = daily_data.drop(columns='contributor')</span><span id="3fee" class="ly ky hh lx b fi mz mw l mx my">daily_data.head()</span></pre><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es nc"><img src="../Images/87deb5803b4a940617aca6f9952c0cf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*feRTb25DT1UQNWsMXqw7lw.jpeg"/></div><figcaption class="ji jj et er es jk jl bd b be z dx">Source : Image by Author</figcaption></figure><p id="bbe9" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">因此，如您所见，我们现在每天都有一个索引，并且还对值进行了插值。这有助于我们从数据集中获得更有意义的见解。</p><h1 id="f30c" class="kx ky hh bd kz la lb lc ld le lf lg lh in li io lj iq lk ir ll it lm iu ln lo bi translated">进一步分析</h1><p id="22fb" class="pw-post-body-paragraph jn jo hh jp b jq lp ii js jt lq il jv jw lr jy jz ka ls kc kd ke lt kg kh ki ha bi translated">现在，我们可以看看每天生产多少咖啡。coffees栏是截至该日期的咖啡数量。但是为了得到每天制作的咖啡数量，我们可以从下一行中减去当前行。这可以使用<code class="du lu lv lw lx b">.diff()</code>方法来完成。此外，我们在这里使用<code class="du lu lv lw lx b">.shift()</code>,因为如果我们查看周一和周二之间的<code class="du lu lv lw lx b">.diff()</code>,这些咖啡被归因于周二。然而，我们想说的是“这么多咖啡是在周一的某个时候做的”，所以我们将整个系列上移一个。</p><pre class="ix iy iz ja fd mr lx ms mt aw mu bi"><span id="2d5e" class="ly ky hh lx b fi mv mw l mx my"># Use .diff() on the coffees column; follow up with .shift()</span><span id="86a0" class="ly ky hh lx b fi mz mw l mx my">coffees_made = daily_data['coffees'].diff().shift(-1)</span><span id="75c7" class="ly ky hh lx b fi mz mw l mx my"># Add this as a column to the dataframe</span><span id="581b" class="ly ky hh lx b fi mz mw l mx my">daily_data["coffees_made_today"] = coffees_made</span></pre><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es nd"><img src="../Images/1f7c2154bd6e805a53873cc37f5a0b4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zFHy5GX1Mfupo9i8uDbOvA.jpeg"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx">Source : Image by Author</figcaption></figure><p id="71f2" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">现在，我们可以按工作日分组，得到每天咖啡的平均产量。这有助于了解哪一天制作的咖啡最普通。由于这台机器在数学系，我预测咖啡在周末会最少，因为它通常对人们来说是关闭的，而大多数咖啡会在有人过来做演讲的研讨会上。</p><pre class="ix iy iz ja fd mr lx ms mt aw mu bi"><span id="413a" class="ly ky hh lx b fi mv mw l mx my"># .groupby weekdays, take the mean, and grab the coffees_made_today column</span><span id="f409" class="ly ky hh lx b fi mz mw l mx my">coffees_by_day = daily_data.groupby('weekdays')['coffees_made_today'].mean()</span><span id="1e72" class="ly ky hh lx b fi mz mw l mx my"># Plot a bar chart</span><span id="d8b4" class="ly ky hh lx b fi mz mw l mx my">coffees_by_day.plot(kind='bar')</span></pre><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es mq"><img src="../Images/6f4490931ef88e93969daa8a8cb61e0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*0KWVjt1_-ZvM0fhtvf6ubw.jpeg"/></div><figcaption class="ji jj et er es jk jl bd b be z dx">Source : Image by Author</figcaption></figure><p id="860c" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">正如你从图表中看到的，在一个普通的周末制作的咖啡数量最少，而在周三研讨会日制作的咖啡数量最多。</p><h1 id="e69d" class="kx ky hh bd kz la lb lc ld le lf lg lh in li io lj iq lk ir ll it lm iu ln lo bi translated">结论</h1><p id="69df" class="pw-post-body-paragraph jn jo hh jp b jq lp ii js jt lq il jv jw lr jy jz ka ls kc kd ke lt kg kh ki ha bi translated">这只是对数据分析师如何处理时间序列数据的简单介绍。还有更多内容，你应该看看昆汀·考德隆的这篇全面深入的教程<a class="ae jm" href="https://www.youtube.com/watch?v=F7sCL61Zqss&amp;t=371s" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="e933" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">你可以在我的Github上找到完整的代码:<a class="ae jm" href="https://github.com/hemantrattey/pydata_pandas" rel="noopener ugc nofollow" target="_blank">https://github.com/hemantrattey/pydata_pandas</a></p><p id="8761" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">请随时给我同样的反馈。</p><p id="63a7" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">感谢你的阅读，我希望它能激励你继续前进，做你自己的分析。</p><p id="84ae" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">过来打个招呼。在推特上对我说。</p><h1 id="a2c5" class="kx ky hh bd kz la lb lc ld le lf lg lh in li io lj iq lk ir ll it lm iu ln lo bi translated">参考</h1><p id="3bfe" class="pw-post-body-paragraph jn jo hh jp b jq lp ii js jt lq il jv jw lr jy jz ka ls kc kd ke lt kg kh ki ha bi translated">[1] Pydata : <a class="ae jm" href="https://www.youtube.com/watch?v=F7sCL61Zqss&amp;t=371s" rel="noopener ugc nofollow" target="_blank">熊猫数据分析简介</a></p><p id="98a9" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">[2] Q. Caudron : Github知识库，【https://github.com/QCaudron/pydata_pandas T2】</p><p id="f240" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">[3] Pydata : <a class="ae jm" href="https://www.youtube.com/watch?v=8upGdZMlkYM&amp;t=1997s" rel="noopener ugc nofollow" target="_blank">伊恩·奥兹瓦尔德:对熊猫时代系列和Seaborn的温柔介绍| PyData伦敦2019 </a></p></div></div>    
</body>
</html>