<html>
<head>
<title>Music Generation Using Deep Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用深度学习的音乐生成</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/music-generation-using-deep-learning-49692851c57c?source=collection_archive---------0-----------------------#2021-06-30">https://medium.com/mlearning-ai/music-generation-using-deep-learning-49692851c57c?source=collection_archive---------0-----------------------#2021-06-30</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/ad139a738a0129eeed0e80e198b3745d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dxD-L7wuETIZvb-LZkdwIg.jpeg"/></div></div></figure><h1 id="f40f" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">机器能产生音乐吗？</h1></div><div class="ab cl jn jo go jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ha hb hc hd he"><h1 id="c2db" class="ip iq hh bd ir is ju iu iv iw jv iy iz ja jw jc jd je jx jg jh ji jy jk jl jm bi translated">现实世界的问题</h1><ul class=""><li id="da6a" class="jz ka hh kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">音乐生成的目标是利用人工智能探索关于音乐创作领域的深度学习。</li><li id="9acc" class="jz ka hh kb b kc kr ke ks kg kt ki ku kk kv km kn ko kp kq bi translated">案例研究的重点是使用递归神经网络(RNN)自动生成音乐。</li><li id="b4e3" class="jz ka hh kb b kc kr ke ks kg kt ki ku kk kv km kn ko kp kq bi translated">我们不需要成为创作音乐的专家。即使像我这样的非专家也可以用RNN创作出低质量的创造性音乐。</li><li id="3f81" class="jz ka hh kb b kc kr ke ks kg kt ki ku kk kv km kn ko kp kq bi translated">迄今为止，创作音乐是人类独有的事情，但使用深度学习已经取得了一些重大进展。</li></ul><h1 id="2e48" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">目标</h1><ul class=""><li id="1f93" class="jz ka hh kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">建立一个将现有音乐数据作为输入的模型，学习模式并生成“新”音乐。</li></ul><figure class="kx ky kz la fd ii er es paragraph-image"><div class="er es kw"><img src="../Images/ce6e6500854dc0b357e12139071406f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1174/format:webp/1*VpTpLc-JYqVOA159c5PiVw.png"/></div></figure><ul class=""><li id="d529" class="jz ka hh kb b kc lb ke lc kg ld ki le kk lf km kn ko kp kq bi translated">模型生成的音乐不需要专业，只要悠扬好听就行。</li><li id="7672" class="jz ka hh kb b kc kr ke ks kg kt ki ku kk kv km kn ko kp kq bi translated">它不能简单地从训练数据中复制和粘贴。它必须从人类喜欢的现有音乐中学习模式。</li></ul><h1 id="1c7d" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">现在，什么是音乐？</h1><ul class=""><li id="e588" class="jz ka hh kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">基本上，音乐是音乐成分/事件的序列。</li><li id="bef5" class="jz ka hh kb b kc kr ke ks kg kt ki ku kk kv km kn ko kp kq bi translated">音乐事件/音符的输入序列</li><li id="6708" class="jz ka hh kb b kc kr ke ks kg kt ki ku kk kv km kn ko kp kq bi translated">输出-音乐事件/音符的新序列</li><li id="5c95" class="jz ka hh kb b kc kr ke ks kg kt ki ku kk kv km kn ko kp kq bi translated">在这个案例研究中，我把自己限制在单一乐器音乐上。你可以把它扩展到多种乐器的音乐。</li></ul><h1 id="7d4c" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">一些用RNNs生成音乐的例子</h1><figure class="kx ky kz la fd ii"><div class="bz dy l di"><div class="lg lh l"/></div></figure><figure class="kx ky kz la fd ii"><div class="bz dy l di"><div class="lg lh l"/></div></figure><div class="li lj ez fb lk ll"><a href="https://folkrnn.org/" rel="noopener  ugc nofollow" target="_blank"><div class="lm ab dw"><div class="ln ab lo cl cj lp"><h2 class="bd hi fi z dy lq ea eb lr ed ef hg bi translated">民间RNN -用递归神经网络生成民间曲调</h2><div class="ls l"><h3 class="bd b fi z dy lq ea eb lr ed ef dx translated">机器民谣是一个社区网站，致力于由机器创作或与机器共同创作的民谣音乐…</h3></div><div class="lt l"><p class="bd b fp z dy lq ea eb lr ed ef dx translated">folkrnn.org</p></div></div></div></a></div><h1 id="59d6" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">音乐的表现</h1><h2 id="f337" class="lu iq hh bd ir lv lw lx iv ly lz ma iz kg mb mc jd ki md me jh kk mf mg jl mh bi translated">1.活页乐谱</h2><figure class="kx ky kz la fd ii er es paragraph-image"><div class="er es mi"><img src="../Images/54c2bf94249c7bd282b1acf8ead536a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:560/format:webp/1*ok_fv-C79RaMbeOvFNSWNQ.png"/></div><figcaption class="mj mk et er es ml mm bd b be z dx">sheet music</figcaption></figure><p id="226a" class="pw-post-body-paragraph mn mo hh kb b kc lb mp mq ke lc mr ms kg mt mu mv ki mw mx my kk mz na nb km ha bi translated">基本上，活页乐谱用一种特定的符号表示音乐，音乐家使用这种演奏音乐。它既可用于单台仪器，也可用于多台仪器。活页乐谱是一种视觉文件。</p><h2 id="0b20" class="lu iq hh bd ir lv lw lx iv ly lz ma iz kg mb mc jd ki md me jh kk mf mg jl mh bi translated">2.ABC符号</h2><figure class="kx ky kz la fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nc"><img src="../Images/31c5657b52af11d5eda9529e703626bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OwXtbkVm6mKVy1qiPTDutw.jpeg"/></div></div><figcaption class="mj mk et er es ml mm bd b be z dx">This is an example of the use of ABC notation from Wikipedia</figcaption></figure><figure class="kx ky kz la fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nd"><img src="../Images/492c155d662f4d8586a40df62bdd4e93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1266/format:webp/1*u7NdFbLPRd1EaDCu9jqJlQ.png"/></div></div></figure><ul class=""><li id="b55b" class="jz ka hh kb b kc lb ke lc kg ld ki le kk lf km kn ko kp kq bi translated">第一部分是生成的实际音乐的ABC符号的元数据。</li><li id="3c56" class="jz ka hh kb b kc kr ke ks kg kt ki ku kk kv km kn ko kp kq bi translated">x:当一个文件中有多个曲调时<br/> T:标题<br/> M:拍号<br/> L:默认音符长度<br/> R:曲调类型<br/> K:键</li><li id="05cf" class="jz ka hh kb b kc kr ke ks kg kt ki ku kk kv km kn ko kp kq bi translated">第二部分跟随元数据并表示曲调。</li><li id="7e22" class="jz ka hh kb b kc kr ke ks kg kt ki ku kk kv km kn ko kp kq bi translated">如果你知道音乐的ABC符号，你可以写乐谱，反之亦然。</li><li id="af7d" class="jz ka hh kb b kc kr ke ks kg kt ki ku kk kv km kn ko kp kq bi translated">你也可以将abc符号转换成MIDI并下载。</li></ul><h2 id="428e" class="lu iq hh bd ir lv lw lx iv ly lz ma iz kg mb mc jd ki md me jh kk mf mg jl mh bi translated">3.MIDI表示</h2><figure class="kx ky kz la fd ii er es paragraph-image"><div class="er es ne"><img src="../Images/82b29edb8fa3f611232884bba1d64a64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1106/format:webp/1*w2iQgwCXK-BnKEcaBT35fg.png"/></div><figcaption class="mj mk et er es ml mm bd b be z dx">MIDI format</figcaption></figure><ul class=""><li id="a449" class="jz ka hh kb b kc lb ke lc kg ld ki le kk lf km kn ko kp kq bi translated">我们可以看到使用Music21读取的midi文件的摘录。</li><li id="5ccf" class="jz ka hh kb b kc kr ke ks kg kt ki ku kk kv km kn ko kp kq bi translated">数据分为两种对象类型:音符和和弦。</li><li id="5894" class="jz ka hh kb b kc kr ke ks kg kt ki ku kk kv km kn ko kp kq bi translated">音符对象包含关于音符的<strong class="kb hi">音高</strong>、<strong class="kb hi">八度音程</strong>和<strong class="kb hi">偏移</strong>的信息。</li><li id="3760" class="jz ka hh kb b kc kr ke ks kg kt ki ku kk kv km kn ko kp kq bi translated">和弦对象本质上是同时播放的一组音符的容器。</li><li id="53d5" class="jz ka hh kb b kc kr ke ks kg kt ki ku kk kv km kn ko kp kq bi translated">每行基本上都是事件——事件0、事件1、事件2……事件n，它为我们提供了有关时间戳的信息。</li></ul><blockquote class="nf ng nh"><p id="812a" class="mn mo ni kb b kc lb mp mq ke lc mr ms nj mt mu mv nk mw mx my nl mz na nb km ha bi translated">在本案例研究中，我们将更多地关注ABC符号，因为它是最简单的符号，并且只使用了一个数字字符。</p></blockquote><h2 id="73b2" class="lu iq hh bd ir lv lw lx iv ly lz ma iz kg mb mc jd ki md me jh kk mf mg jl mh bi translated">为什么MP3不被认为是音乐的代表？</h2><ul class=""><li id="ff63" class="jz ka hh kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">Mp3包含频率、振幅和时间戳。</li><li id="a6a7" class="jz ka hh kb b kc kr ke ks kg kt ki ku kk kv km kn ko kp kq bi translated">音乐家使用ABC记谱法或活页乐谱作为一种更有效的表达方式，因为他们不是通过思考频率来创作音乐的。</li><li id="8ab1" class="jz ka hh kb b kc kr ke ks kg kt ki ku kk kv km kn ko kp kq bi translated">因此，最好利用非凡音乐家设计的数千年音乐符号。</li><li id="a60b" class="jz ka hh kb b kc kr ke ks kg kt ki ku kk kv km kn ko kp kq bi translated">因此，我们不会使用mp3文件。我们将在符号的空间里创作我们的音乐。</li></ul><h1 id="bbda" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">夏尔-RNN模型(高级概述)</h1><p id="1609" class="pw-post-body-paragraph mn mo hh kb b kc kd mp mq ke kf mr ms kg nm mu mv ki nn mx my kk no na nb km ha bi translated">所以，我们现在有一些领域知识，我们不需要成为专家。我们现在就来了解一下夏尔·RNN。因为我们的音乐是一个字符序列，所以我们明显的选择是RNNs。</p><figure class="kx ky kz la fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es np"><img src="../Images/af0b624284869ade139f2a5e44b1833b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sh-VHyIQ65ZIYuZytZHuLw.png"/></div></div></figure><ul class=""><li id="c6e8" class="jz ka hh kb b kc lb ke lc kg ld ki le kk lf km kn ko kp kq bi translated">有一种特殊类型的RNN叫做“夏尔-RNN”。</li><li id="1434" class="jz ka hh kb b kc kr ke ks kg kt ki ku kk kv km kn ko kp kq bi translated">我们将使用多对多RNN。这里，我们将把序列中的字符一个接一个地输入RNN，它将输出序列中的下一个字符。</li></ul><figure class="kx ky kz la fd ii er es paragraph-image"><div class="er es nq"><img src="../Images/9cf225f94a96734abf029068c665171d.png" data-original-src="https://miro.medium.com/v2/resize:fit:710/format:webp/1*Xy_jBPFTP_TTJUNHNqAaEA.png"/></div></figure><ul class=""><li id="cb86" class="jz ka hh kb b kc lb ke lc kg ld ki le kk lf km kn ko kp kq bi translated">这将允许我们一次生成一个新的曲调。</li><li id="1a7a" class="jz ka hh kb b kc kr ke ks kg kt ki ku kk kv km kn ko kp kq bi translated">作为一个工作示例，假设我们只有四个可能字母“helo”的词汇表，并且想要在训练序列“hello”上训练一个RNN。</li></ul><figure class="kx ky kz la fd ii er es paragraph-image"><div class="er es nr"><img src="../Images/2b50a075fa7020d76b62dc13c7a6cd36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1158/format:webp/1*37JIe2RNmwiXM6d9wkFRZw.png"/></div></figure><ul class=""><li id="aa9a" class="jz ka hh kb b kc lb ke lc kg ld ki le kk lf km kn ko kp kq bi translated">这个训练序列实际上是4个独立训练例子的来源:<br/> 1。给定“h”的上下文,“e”的概率应该是可能的。<br/> 2。“l”在“他”的上下文中应该是可能的。<br/> 3。考虑到“hel”的上下文,“l”也应该是可能的。<br/> 4。最后，考虑到“地狱”的上下文,“o”应该是可能的。</li><li id="b165" class="jz ka hh kb b kc kr ke ks kg kt ki ku kk kv km kn ko kp kq bi translated">我们将使用一键编码将每个字符编码到一个向量中(即，除了词汇表中字符索引处的一个1之外，所有字符都是零)，并使用步进函数将它们一次一个地输入到RNN中。</li><li id="e5f2" class="jz ka hh kb b kc kr ke ks kg kt ki ku kk kv km kn ko kp kq bi translated">然后，我们将观察4维输出向量的序列(每个字符一维)，我们将其解释为当前分配给序列中下一个字符的RNN的置信度。</li><li id="2b0e" class="jz ka hh kb b kc kr ke ks kg kt ki ku kk kv km kn ko kp kq bi translated">我们希望输出层中的绿色数字较高，红色数字较低，从而得到目标字符。</li><li id="4b98" class="jz ka hh kb b kc kr ke ks kg kt ki ku kk kv km kn ko kp kq bi translated">请记住，在这种多对多模型中，操作系统输入的数量等于输出的数量。</li></ul><h1 id="dcbb" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">数据</h1><figure class="kx ky kz la fd ii er es paragraph-image"><div class="er es ns"><img src="../Images/29a181f4eec9756a5418f92dd20373cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:584/format:webp/1*PouCqoUHYFtFSPP_hssQFQ.png"/></div></figure><ul class=""><li id="f2c0" class="jz ka hh kb b kc lb ke lc kg ld ki le kk lf km kn ko kp kq bi translated">第一部分是获取数据本身。</li><li id="65a7" class="jz ka hh kb b kc kr ke ks kg kt ki ku kk kv km kn ko kp kq bi translated">第二部分是预处理数据并生成每个单独的批次，我们将使用这些批次及其构造，因为我们将在训练Char-RNN时应用Batch-SGD的变体。</li></ul><h2 id="c8a8" class="lu iq hh bd ir lv lw lx iv ly lz ma iz kg mb mc jd ki md me jh kk mf mg jl mh bi translated">数据获取:</h2><ul class=""><li id="0431" class="jz ka hh kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">参考:【http://abc.sourceforge.net/NMD】T4</li><li id="9030" class="jz ka hh kb b kc kr ke ks kg kt ki ku kk kv km kn ko kp kq bi translated">上面写着“诺丁汉音乐数据库的ABC版本”,它包含了1000多首以特殊文本格式存储的民间曲调。</li><li id="e616" class="jz ka hh kb b kc kr ke ks kg kt ki ku kk kv km kn ko kp kq bi translated">当然，像1000首曲子这种更大的数据，训练模型是要花很多时间的。所以我将使用包含大约340首曲子的夹具数据集。</li><li id="a686" class="jz ka hh kb b kc kr ke ks kg kt ki ku kk kv km kn ko kp kq bi translated">你得到一个包含多首曲子的txt文件。</li><li id="8fd3" class="jz ka hh kb b kc kr ke ks kg kt ki ku kk kv km kn ko kp kq bi translated">只需复制并粘贴到一个txt文件中作为input.txt。</li><li id="e280" class="jz ka hh kb b kc kr ke ks kg kt ki ku kk kv km kn ko kp kq bi translated">每首曲子都有元数据部分和音乐部分。</li></ul><h2 id="7650" class="lu iq hh bd ir lv lw lx iv ly lz ma iz kg mb mc jd ki md me jh kk mf mg jl mh bi translated">数据预处理:</h2><p id="5730" class="pw-post-body-paragraph mn mo hh kb b kc kd mp mq ke kf mr ms kg nm mu mv ki nn mx my kk no na nb km ha bi translated">我们希望将input.txt文件预处理成这样一种格式，即我们可以将其输入到RNN中，因为我们构建数据集的方式会严重影响模型，并且RNNs可能会比较棘手。</p><ul class=""><li id="d577" class="jz ka hh kb b kc lb ke lc kg ld ki le kk lf km kn ko kp kq bi translated">批处理大小= 16 <br/>序列长度= 64<br/>input . txt文件中字符的总长度= 129，665 <br/>唯一字符数= 86</li></ul><blockquote class="nf ng nh"><p id="fab6" class="mn mo ni kb b kc lb mp mq ke lc mr ms nj mt mu mv nk mw mx my nl mz na nb km ha bi translated">char_to_idx = { ch: i for (i，ch)in enumerate(sorted(list(set(text))))}</p></blockquote><ul class=""><li id="6a24" class="jz ka hh kb b kc lb ke lc kg ld ki le kk lf km kn ko kp kq bi translated">这里，在char_to_idx中，char-to-idx是将每个字符转换成一个索引或数值，其中ch(character)是键和索引或数值，类似于json文件:<br/>这是jusk like json文件:<br/> {"\n": 0，" ":1，"！":2，" \ ":3，" #": 4，" %": 5，"&amp; ": 6，" ' ":7，"(":8，")":9，"+": 10，"，":11，"-": 12，"。": 13, "/": 14, "0": 15, "1": 16, "2": 17, "3": 18, "4": 19, "5": 20, "6": 21, "7": 22, "8": 23, "9": 24, ":": 25, "=": 26, "?":27，" A": 28，" B": 29，" C": 30，" D": 31，" E": 32，" F": 33，" G": 34，" H": 35，" I": 36，" J": 37，" K": 38，" L": 39，" M": 40，" N": 41，" O": 42，" P": 43，" Q": 44，" R": 45，" S": 46，" T": 47，" U": 48，" V": 49，" W": 50，" X": 51，" y " " j": 67，" k": 68，" l": 69，" m": 70，" n": 71，" o": 72，" p": 73，" q": 74，" r": 75，" s": 76，" t": 77，" u": 78，" v": 79，" w": 80，" x": 81，" y": 82，" z": 83，" |": 84，" ~": 85}</li><li id="7371" class="jz ka hh kb b kc kr ke ks kg kt ki ku kk kv km kn ko kp kq bi translated">批处理是如何构造的？</li></ul><figure class="kx ky kz la fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nu"><img src="../Images/947ef25cf35713a0d8207f9a8b876255.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jQQu5g3Jd6PkhfWFXV-mUQ.jpeg"/></div></div></figure><p id="370c" class="pw-post-body-paragraph mn mo hh kb b kc lb mp mq ke lc mr ms kg mt mu mv ki mw mx my kk mz na nb km ha bi translated">→假设X中的索引“0”是字符索引82。<br/> →所以，我想让我的Y预测为80作为下一个字符索引号。<br/> →在“Y”中的张量是一个热编码，被认为是分类的一部分。<br/>→X的索引0处的字符索引82被送入RNN，这给我们一个热编码向量，80为“1”。如我们所知，我们已经给每个角色分配了索引。<br/> →实际上，批次将包含相应字符的索引。</p><ul class=""><li id="7924" class="jz ka hh kb b kc lb ke lc kg ld ki le kk lf km kn ko kp kq bi translated">我试图每次使用名为“read_batches”的函数生成新的批处理。<br/> →一个批次包含16行(BATCH_SIZE)和64列(SEQUENCE_LENGTH)，使得一个批次中总共有(16*64) 1024个字符，类似地，一个时期总共有126个批次。<br/> → <em class="ni">为什么我们不简单地在batch_1中使用前1024个字符，在batch_2中使用后1024个字符，以此类推，直到batch_126？</em> <br/>它是序列数据，所以如果我们组合两个序列，就意味着我们给出了错误的数据。所以我们必须给一批中的所有序列以不同的方式。<br/> →假设序列长度为64，批次大小为16，我们需要构建126个批次，在第一个批次中，我们输入前63个字符，在第二个批次中，我们从第64个字符开始继续输入，以此类推，以保持序列不变。</li></ul><figure class="kx ky kz la fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nv"><img src="../Images/d62b35ddbd9ce9685cfa5a730aff0e80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*16aa1gRXV0npVsU52uhyLA.png"/></div></div><figcaption class="mj mk et er es ml mm bd b be z dx"><em class="nw">The above code snippet is a function to create batches. Here, there are three nested loops. The first loop denotes the batch number. It runs every time when a new batch is created. The second loop denotes a row in a batch and the third loop denotes a column in a batch.</em></figcaption></figure><h1 id="2e0e" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">多对多RNN</h1><ul class=""><li id="396f" class="jz ka hh kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">在隐藏层中，我们可以有多个lstm用于生产目的，而不是单个lstm。实际上，我们可以进行如下图所示的设置。</li></ul><figure class="kx ky kz la fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nu"><img src="../Images/15097883946db28d69e648f0fa62c8a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7Fa4imaqnWtCsGyXy9rUuA.jpeg"/></div></div></figure><p id="3780" class="pw-post-body-paragraph mn mo hh kb b kc lb mp mq ke lc mr ms kg mt mu mv ki mw mx my kk mz na nb km ha bi translated">→假设，我们在隐藏层中有四个lstms。<br/> →我在时间“t”在输入层有一个输入“Ci”。<br/> →现在，所有四个lstms将一起为我生成一个输出，理想情况下应该是“Ci+1”字符。<br/> →第一个时间步的输出会转到下一个时间步，我的输入是“Ci+1”。<br/> →又来了，会有四个lstms一起给我输出“Ci+2”。<br/> →这个过程将继续下去。每个lstm单元将学习我们性格的不同方面。</p><ul class=""><li id="9e5a" class="jz ka hh kb b kc lb ke lc kg ld ki le kk lf km kn ko kp kq bi translated">为了能够构建这样的网络，我们需要了解返回序列和时间分布密集层。</li></ul><pre class="kx ky kz la fd nx ny nz oa aw ob bi"><span id="834b" class="lu iq hh ny b fi oc od l oe of">def build_model(batch_size, seq_len, vocab_size):<br/>    model = Sequential()<br/>    model.add(Embedding(vocab_size, 512, batch_input_shape (batch_size, seq_len)))</span><span id="b953" class="lu iq hh ny b fi og od l oe of">    for i in range(3):<br/>        model.add(LSTM(256, return_sequences=True, stateful=True))<br/>        # It creates 256 lstms layers in hiden layers<br/>        model.add(Dropout(0.2))</span><span id="2898" class="lu iq hh ny b fi og od l oe of">    model.add(TimeDistributed(Dense(vocab_size))) <br/>    model.add(Activation('softmax'))<br/>    return model</span></pre><ul class=""><li id="7dc1" class="jz ka hh kb b kc lb ke lc kg ld ki le kk lf km kn ko kp kq bi translated"><strong class="kb hi">返回序列:</strong></li></ul><figure class="kx ky kz la fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nu"><img src="../Images/2e9f7b0f9d8e093046a20f6be22dfd81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZKDNdJ5mnOGNu0cNBrr8BA.jpeg"/></div></div></figure><p id="6340" class="pw-post-body-paragraph mn mo hh kb b kc lb mp mq ke lc mr ms kg mt mu mv ki mw mx my kk mz na nb km ha bi translated">→对于每个时间步，我们给出一个输入，我们想要一个输出→这里你可以有<strong class="kb hi"> <em class="ni"> return-sequence = True。这就是我们想要的。</em> </strong> <em class="ni"> <br/> → </em>对于每一个时间步，我们不断给输入，到最后，只有消耗完整个序列，它才给我们输出→这里可以有<strong class="kb hi"> <em class="ni"> return_sequence = False。</em> </strong></p><ul class=""><li id="8877" class="jz ka hh kb b kc lb ke lc kg ld ki le kk lf km kn ko kp kq bi translated"><strong class="kb hi">时间分布密集层:<br/> → </strong>我们的数据集中有87个独特的字符，我们希望每个时间戳的输出将是序列中87个字符之一的下一个字符。<br/> →时间分布密集层包含87个“Softmax”激活，它在每个时间戳创建一个密集连接。<br/> →最后，它将在每个时间戳生成87维输出，相当于87个概率值。它帮助我们保持多对多的关系。</li></ul><figure class="kx ky kz la fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nu"><img src="../Images/9ee205bd45aafbf58d8d8b83c484188a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R8Ja0LAfFfsKTfMXUcLu6A.jpeg"/></div></div></figure><ul class=""><li id="ae80" class="jz ka hh kb b kc lb ke lc kg ld ki le kk lf km kn ko kp kq bi translated"><strong class="kb hi">有状态RNN: <br/> - </strong>这与批处理操作模式有关。<br/>——这里我们给出了“<strong class="kb hi"> stateful = True </strong>”。<br/> -如果<strong class="kb hi">为真</strong>，那么一批中索引为‘I’的每一批的最后状态将被用作下一批中索引为‘I’的样本的初始状态。<br/> -这是因为所有批次都包含连续的行，我们的模型将学习更多更长的序列。<br/> -默认值为stateful = False</li></ul><figure class="kx ky kz la fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nu"><img src="../Images/37fb5c909a58939d914508e6e4d50c83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C9h77CrWhmekJi_qK-FA3w.jpeg"/></div></div></figure><h1 id="d958" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">模型架构和培训</h1><figure class="kx ky kz la fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nu"><img src="../Images/41cce56c62bea2cb15e12ac2a86bacb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lTFO2BxJV473ZFFVQsY1mw.jpeg"/></div></div><figcaption class="mj mk et er es ml mm bd b be z dx">Model Architecture</figcaption></figure><pre class="kx ky kz la fd nx ny nz oa aw ob bi"><span id="f7fd" class="lu iq hh ny b fi oc od l oe of">def built_model(batch_size, seq_length, unique_chars):<br/> model = Sequential()<br/> <br/> model.add(Embedding(input_dim = unique_chars, output_dim = 512, batch_input_shape = (batch_size, seq_length))) <br/> <br/> model.add(LSTM(256, return_sequences = True, stateful = True))<br/> model.add(Dropout(0.2))<br/> <br/> model.add(LSTM(256, return_sequences = True, stateful = True))<br/> model.add(Dropout(0.2))<br/> <br/> model.add(LSTM(256, return_sequences = True, stateful = True))<br/> model.add(Dropout(0.2))<br/> <br/> model.add(TimeDistributed(Dense(unique_chars)))<br/> model.add(Activation(“softmax”))<br/> <br/> return model</span></pre><ul class=""><li id="8498" class="jz ka hh kb b kc lb ke lc kg ld ki le kk lf km kn ko kp kq bi translated">x是(批量大小，SEQ长度)= (16，64)的矩阵</li><li id="9879" class="jz ka hh kb b kc kr ke ks kg kt ki ku kk kv km kn ko kp kq bi translated">y是(批量大小，SEQ长度，语音大小)= (16，64，86)的3D张量。考虑vocab大小是因为一位热码编码。</li><li id="645a" class="jz ka hh kb b kc kr ke ks kg kt ki ku kk kv km kn ko kp kq bi translated">嵌入后，(巴克思大小，SEQ长度，嵌入尺寸)= (16，64，512)</li><li id="9bfd" class="jz ka hh kb b kc kr ke ks kg kt ki ku kk kv km kn ko kp kq bi translated">我们将“Y”编码为一个热编码，因为我们将在它上面应用softmax。</li><li id="f11a" class="jz ka hh kb b kc kr ke ks kg kt ki ku kk kv km kn ko kp kq bi translated">现在，我们想预测下一个字符，它应该是86个唯一字符中的一个。所以，这是一个多类分类问题。因此，我们的最后一层是86个激活的softmax层。</li><li id="6bf1" class="jz ka hh kb b kc kr ke ks kg kt ki ku kk kv km kn ko kp kq bi translated">因此，我将生成我的每一批并训练它们。对于每个训练时期，我将打印分类交叉熵损失和准确性。</li><li id="5deb" class="jz ka hh kb b kc kr ke ks kg kt ki ku kk kv km kn ko kp kq bi translated">下面是我的模型总结。所以，我总共有1，904，214个参数。</li></ul><figure class="kx ky kz la fd ii er es paragraph-image"><div class="er es oh"><img src="../Images/5e4ed847d073fc12af075f3ac464384f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1054/format:webp/1*vYWoAafJRbkXBYXwjhckbQ.png"/></div></figure><ul class=""><li id="1429" class="jz ka hh kb b kc lb ke lc kg ld ki le kk lf km kn ko kp kq bi translated">因为我们有如此多的参数，所以我们使用保持概率为0.2的退出。</li><li id="9734" class="jz ka hh kb b kc kr ke ks kg kt ki ku kk kv km kn ko kp kq bi translated">当我们在训练中达到100个纪元时，大约90%以上的时候，模型能够预测下一个字符是什么。所以，我们的模型做得很好。</li><li id="7504" class="jz ka hh kb b kc kr ke ks kg kt ki ku kk kv km kn ko kp kq bi translated">在10个时期结束时，我们存储模型的权重。我们将使用这些权重来重建模型和预测。</li></ul><h1 id="7a8e" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">音乐一代</h1><ul class=""><li id="bbb4" class="jz ka hh kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">现在我们已经有了训练好的模型，并且找到了我们的最佳权重。让我们看看我们将如何创造新的音乐。</li><li id="8ed2" class="jz ka hh kb b kc kr ke ks kg kt ki ku kk kv km kn ko kp kq bi translated">我们的模型可以预测。</li><li id="705c" class="jz ka hh kb b kc kr ke ks kg kt ki ku kk kv km kn ko kp kq bi translated">为了进行预测，我们将87个唯一字符中的任何一个作为我们模型的输入，它将通过softmax层生成87个概率值。从这些返回的87个概率值中，我们将概率性地选择下一个字符，最后，我们将再次将选择的字符反馈给模型，依此类推。</li><li id="8e04" class="jz ka hh kb b kc kr ke ks kg kt ki ku kk kv km kn ko kp kq bi translated">我们将继续连接输出字符，并生成所需长度的音乐。典型的数字在300-600之间。太小的数字几乎不会产生任何序列。</li><li id="e1e9" class="jz ka hh kb b kc kr ke ks kg kt ki ku kk kv km kn ko kp kq bi translated">当我们试图使用较小时期的权重来预测音乐时，我们会出错。</li></ul><figure class="kx ky kz la fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es oi"><img src="../Images/adc5b0703b053202ef92d73794883aa3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tA91hzw8ZaVo55sgCcVX2Q.png"/></div></div></figure><ul class=""><li id="35d6" class="jz ka hh kb b kc lb ke lc kg ld ki le kk lf km kn ko kp kq bi translated">打开以下链接，将您生成的音乐粘贴到给定的空间，以便播放。</li></ul><div class="li lj ez fb lk ll"><a href="https://www.abcjs.net/abcjs-editor.html" rel="noopener  ugc nofollow" target="_blank"><div class="lm ab dw"><div class="ln ab lo cl cj lp"><h2 class="bd hi fi z dy lq ea eb lr ed ef hg bi translated">abcjs编辑器</h2><div class="ls l"><h3 class="bd b fi z dy lq ea eb lr ed ef dx translated">abcjs是一个开源的javascript渲染引擎，用于解释abc格式的曲调。它将呈现活页乐谱…</h3></div><div class="lt l"><p class="bd b fp z dy lq ea eb lr ed ef dx translated">www.abcjs.net</p></div></div></div></a></div><figure class="kx ky kz la fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es oj"><img src="../Images/11a103cb7b247c4343e99882239bb39b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5KL53Yvv0JVfzsLpN5ZPng.png"/></div></div></figure><ul class=""><li id="c2e7" class="jz ka hh kb b kc lb ke lc kg ld ki le kk lf km kn ko kp kq bi translated">我用时代= 10的weights.10.h5模型和时代= 100的weights.100.h5模型生成音乐。</li></ul><figure class="kx ky kz la fd ii"><div class="bz dy l di"><div class="lg lh l"/></div></figure><p id="bb18" class="pw-post-body-paragraph mn mo hh kb b kc lb mp mq ke lc mr ms kg mt mu mv ki mw mx my kk mz na nb km ha bi translated">上面的音乐序列是我从模型中生成的一些例子。</p><h1 id="dbc5" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">生成Tabla音乐</h1><p id="2b7e" class="pw-post-body-paragraph mn mo hh kb b kc kd mp mq ke kf mr ms kg nm mu mv ki nn mx my kk no na nb km ha bi translated">您也可以使用夏尔-RNN模型来生成tabla音乐。为了更好地理解，请参考这些博客。</p><div class="li lj ez fb lk ll"><a href="https://www.trivedigaurav.com/blog/machines-learn-to-play-tabla/" rel="noopener  ugc nofollow" target="_blank"><div class="lm ab dw"><div class="ln ab lo cl cj lp"><h2 class="bd hi fi z dy lq ea eb lr ed ef hg bi translated">机器学习演奏塔布拉</h2><div class="ls l"><h3 class="bd b fi z dy lq ea eb lr ed ef dx translated">更新:这篇文章现在有第二部分。如果你关注新闻中的机器学习话题，我相信现在你已经…</h3></div><div class="lt l"><p class="bd b fp z dy lq ea eb lr ed ef dx translated">www.trivedigaurav.com</p></div></div><div class="ok l"><div class="ol l om on oo ok op in ll"/></div></div></a></div><div class="li lj ez fb lk ll"><a href="https://www.trivedigaurav.com/blog/machines-learn-to-play-tabla-part-2/" rel="noopener  ugc nofollow" target="_blank"><div class="lm ab dw"><div class="ln ab lo cl cj lp"><h2 class="bd hi fi z dy lq ea eb lr ed ef hg bi translated">机器学习玩塔布拉，第2部分</h2><div class="ls l"><h3 class="bd b fi z dy lq ea eb lr ed ef dx translated">这是我之前关于机器学习玩塔布拉的后续文章。你可能希望它先看看这个…</h3></div><div class="lt l"><p class="bd b fp z dy lq ea eb lr ed ef dx translated">www.trivedigaurav.com</p></div></div></div></a></div><h1 id="11c1" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">MIDI音乐一代</h1><p id="63f0" class="pw-post-body-paragraph mn mo hh kb b kc kd mp mq ke kf mr ms kg nm mu mv ki nn mx my kk no na nb km ha bi translated">这里，Music21库用于读取MIDI文件并将其转换为事件序列。你可以通过下面的博客更好地了解。</p><div class="li lj ez fb lk ll"><a href="https://towardsdatascience.com/how-to-generate-music-using-a-lstm-neural-network-in-keras-68786834d4c5" rel="noopener follow" target="_blank"><div class="lm ab dw"><div class="ln ab lo cl cj lp"><h2 class="bd hi fi z dy lq ea eb lr ed ef hg bi translated">如何在Keras中使用LSTM神经网络生成音乐</h2><div class="ls l"><h3 class="bd b fi z dy lq ea eb lr ed ef dx translated">使用LSTM神经网络创作音乐的介绍</h3></div><div class="lt l"><p class="bd b fp z dy lq ea eb lr ed ef dx translated">towardsdatascience.com</p></div></div><div class="ok l"><div class="oq l om on oo ok op in ll"/></div></div></a></div><div class="li lj ez fb lk ll"><a href="https://github.com/Skuldur/Classical-Piano-Composer" rel="noopener  ugc nofollow" target="_blank"><div class="lm ab dw"><div class="ln ab lo cl cj lp"><h2 class="bd hi fi z dy lq ea eb lr ed ef hg bi translated">斯库尔杜尔/古典钢琴作曲家</h2><div class="ls l"><h3 class="bd b fi z dy lq ea eb lr ed ef dx translated">这个项目允许你训练一个神经网络来生成midi音乐文件，利用单个乐器…</h3></div><div class="lt l"><p class="bd b fp z dy lq ea eb lr ed ef dx translated">github.com</p></div></div><div class="ok l"><div class="or l om on oo ok op in ll"/></div></div></a></div><h1 id="ef40" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">进一步的范围</h1><p id="7e2b" class="pw-post-body-paragraph mn mo hh kb b kc kd mp mq ke kf mr ms kg nm mu mv ki nn mx my kk no na nb km ha bi translated">嗯，我们得到了相当好的结果，但我们可以通过用多种乐器的更多曲调来训练它，从而改进我们的模型。</p><p id="ac3c" class="pw-post-body-paragraph mn mo hh kb b kc lb mp mq ke lc mr ms kg mt mu mv ki mw mx my kk mz na nb km ha bi translated">在这里，我只用350首曲子训练我的模型。因此，我们可以将我们的模型暴露给更多的乐器和各种音乐曲调，这将导致更悠扬的各种曲调。我们可以添加一个方法，通过过滤未知音符，用已知音符替换，来处理音乐中的未知音符。</p><p id="8b57" class="pw-post-body-paragraph mn mo hh kb b kc lb mp mq ke lc mr ms kg mt mu mv ki mw mx my kk mz na nb km ha bi translated">截至目前，我的模型是在单个乐器上训练的，所以生成的音乐只是一个乐器的。通过添加上述方法，并在增加类别数量的同时在大量数据上训练模型，我们可以生成更强健的质量和更悠扬的音乐。</p><h1 id="139f" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">此项目的代码链接</h1><p id="d0e3" class="pw-post-body-paragraph mn mo hh kb b kc kd mp mq ke kf mr ms kg nm mu mv ki nn mx my kk no na nb km ha bi translated"><a class="ae nt" href="https://github.com/Swetadas-1718/Music-Generation" rel="noopener ugc nofollow" target="_blank">https://github.com/Swetadas-1718/Music-Generation</a></p></div></div>    
</body>
</html>