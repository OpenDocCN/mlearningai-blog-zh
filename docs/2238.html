<html>
<head>
<title>Perfecting Parallel Python Programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">完善并行Python编程</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/perfecting-parallel-python-programming-d92c1a0c1d8f?source=collection_archive---------3-----------------------#2022-03-29">https://medium.com/mlearning-ai/perfecting-parallel-python-programming-d92c1a0c1d8f?source=collection_archive---------3-----------------------#2022-03-29</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="3335" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用Dask的任务，享受快速</p><p id="973c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在我的<a class="ae jc" href="https://jasondeden.medium.com/eat-my-dust-loops-33e5279a01de" rel="noopener">上一篇文章</a>中，我比较了用Python执行任务的四种不同方法，NumPy和矢量化Python在循环和列表理解方面明显优于前者。但是，如果有一种方法可以更快，特别是在非常大、非常复杂的问题上，会怎么样呢？</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ji jj l"/></div><figcaption class="jk jl et er es jm jn bd b be z dx">Faster than NumPy? That’s ludicrous!</figcaption></figure><p id="becb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果你回到我关于Python中的<a class="ae jc" href="https://jasondeden.medium.com/recursive-functions-in-python-a-visual-walk-through-28cf22cc10e2" rel="noopener">递归函数</a>的博客文章，你会想起Python的挑战之一是它的单线程特性。当您运行循环、递归函数或其他函数时，默认情况下，它一次执行一个代码命令，并等待该命令完成后再执行下一个命令。为了避免这类问题，我们使用像NumPy这样的包，它接受Python命令并在较低的级别执行它们。假设a) NumPy支持您正在尝试执行的操作，b)您正在处理的数据足够小，可以放入系统内存，这种方法非常有效。但是，当我们开始真正定制的操作或真正的大数据时，事情开始分崩离析，这在历史上迫使我们进入完全不同的平台，如Hadoop/Spark，以便对真正的大数据进行并行操作。但是今天，由于<a class="ae jc" href="https://dask.org/" rel="noopener ugc nofollow" target="_blank"> Dask </a>的存在，这在很多情况下不再需要。</p><p id="16ac" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我不打算花太多时间解释Dask是如何工作的。有一套很棒的教程带你完成设置和各种组件操作。在这里，我将假设您已经安装并配置了Dask，让我们看看是否能找出它胜过NumPy的用例。会是全部吗？而如果不是，在什么情况下更好(如果有的话)，会好到什么程度？</p><p id="a453" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果你想直接跳到答案，查看笔记本<a class="ae jc" href="https://github.com/jasondeden/GCP-Jupyter/blob/main/NumPy%20vs.%20Dask%20Array.ipynb" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="ef2c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">首先，我首先测试了一个简单的numpy.where()与dask.array.where()操作，测试对象是我的机器上numpy能够处理的最大数据集。(注意:Dask实际上可以处理的数据比你在内存中可以容纳的要多，但我是在比较苹果和苹果。)</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="er es jo"><img src="../Images/f0a9f1e82885422b92ea1befb7b31cbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*538zch7uQaoQ6qoMzkMRGg.png"/></div></div><figcaption class="jk jl et er es jm jn bd b be z dx">Let’s go!</figcaption></figure><p id="82c5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最初的几次测试对于并行化方法来说并不乐观。在大型数组和矩阵中用-1替换0的简单where()函数让NumPy打败了Dask，通常是2倍左右。</p><p id="5de4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">所以我决定加大赌注，做一个更复杂的问题——创建一个大的随机矩阵，将其所有值除以2，对结果求平方，然后对平方求和。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="er es jv"><img src="../Images/eae5ec26ac1fcc211564e45f18bbab34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6LcUBCjcRg7EvgGz1YjvXw.png"/></div></div><figcaption class="jk jl et er es jm jn bd b be z dx">So…. sloooooow…..</figcaption></figure><p id="4588" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">与之前的练习相比，这花费了相对较长的时间，加上所有增加的复杂性，我认为这将是Dask大放异彩的机会。我还打印了结果输出作为健全性测试——以确保Dask和NumPy确实在执行类似的复杂操作。</p><p id="0100" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">所以我用Dask创建了一个类似的函数，并试了一下。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="er es jw"><img src="../Images/58ebdf97676d272f29cbfc6f1d8b7de1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TuCXzC7-2O7br6ecz6fC1A.png"/></div></div><figcaption class="jk jl et er es jm jn bd b be z dx">ZOOM!</figcaption></figure><p id="0d67" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">伙计们，起初我不相信自己的眼睛，所以我运行了几次以确保万无一失(在这一点上，我添加了打印结果语句作为健全性检查……)果然，Dask在这个更复杂的问题上的方法将计算时间从4分钟减少到了6秒，在我的笔记本电脑上实现了97%的性能提升(一台装有新m1芯片的Mac，因此您的里程数可能会有所不同)。</p><p id="9366" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">还是那句话，你自己去看看吧。Dask需要一点时间来适应，并且不支持NumPy支持的所有东西，但是对于大型复杂的问题，基于这些结果，它已经很快成为我的首选。</p><div class="jx jy ez fb jz ka"><a rel="noopener follow" target="_blank" href="/mlearning-ai/mlearning-ai-submission-suggestions-b51e2b130bfb"><div class="kb ab dw"><div class="kc ab kd cl cj ke"><h2 class="bd hi fi z dy kf ea eb kg ed ef hg bi translated">Mlearning.ai提交建议</h2><div class="kh l"><h3 class="bd b fi z dy kf ea eb kg ed ef dx translated">如何成为Mlearning.ai上的作家</h3></div><div class="ki l"><p class="bd b fp z dy kf ea eb kg ed ef dx translated">medium.com</p></div></div><div class="kj l"><div class="kk l kl km kn kj ko jt ka"/></div></div></a></div></div></div>    
</body>
</html>