<html>
<head>
<title>Clustering</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使聚集</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/clustering-79338eeb3bb0?source=collection_archive---------2-----------------------#2021-06-11">https://medium.com/mlearning-ai/clustering-79338eeb3bb0?source=collection_archive---------2-----------------------#2021-06-11</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="2eba" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">聚类通常是在给定数据集中查找子组或聚类的技术。当我们对数据集的观察值进行聚类时，我们的目标是将数据划分到不同的组中，使得每个组中的观察值或多或少彼此相似，而不同组中的观察值彼此差异很大。聚类被认为是<strong class="ig hi">无监督学习</strong>的一部分，因为这里的目标是隔离，形成子群，而不是像监督学习那样预测。像<a class="ae jc" href="https://sen-aby.medium.com/pca-principal-component-analysis-e0cbc7a63f6b" rel="noopener"> PCA </a>这样的聚类试图用小摘要来简化数据；尽管值得一提的是，两者使用的方法是不同的。聚类的工作是找到同质的子群。为了识别子群，我们试图找到特征并使用它们来形成子群。在下文中，为了简单起见，我们将讨论聚类观察。</p><p id="7326" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">数据聚类在各种行业中非常有用，如银行业(客户细分、异常检测)，在医疗保健中用于对MRI数据进行分类，在零售业中用于根据过去的购买情况推荐产品；也可以用在新闻文章分组到站点的几个例子。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/f621727ec90294549745684c6fc5fde0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*M2EQyyvvRvdo3bHsjkYplg.png"/></div></figure><p id="4ec8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">聚类模型的一些例子是</p><ul class=""><li id="9c05" class="jl jm hh ig b ih ii il im ip jn it jo ix jp jb jq jr js jt bi translated">k均值</li><li id="7d97" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb jq jr js jt bi translated">分层聚类</li><li id="081c" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb jq jr js jt bi translated">基于密度的带噪声应用空间聚类(DBSCAN)聚类</li></ul><p id="9ca9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在<strong class="ig hi"> K-means </strong>聚类中，我们试图将观察值划分为预先指定数量的非重叠聚类，使得聚类内的变化尽可能小。</p><p id="e9c4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">K均值聚类是如何工作的！</p><ol class=""><li id="b685" class="jl jm hh ig b ih ii il im ip jn it jo ix jp jb jz jr js jt bi translated">选择群集的数量。</li><li id="6e6e" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb jz jr js jt bi translated">随机选择k个点，即质心。</li><li id="f82e" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb jz jr js jt bi translated">将每个数据点分配给形成k个聚类的最近质心。</li><li id="a2c1" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb jz jr js jt bi translated">计算并放置每个簇的新质心。</li><li id="6e08" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb jz jr js jt bi translated">将每个数据点重新分配给新的最近质心，直到聚类分配停止变化。</li><li id="ce07" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb jz jr js jt bi translated">这将给出最终的集群。</li></ol><p id="fc54" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因为我们发现的是局部最优而不是全局最优，所以获得的结果将取决于我们对每个观察值的初始(随机)聚类分配。因此，从不同的随机初始配置多次运行该算法是非常重要的。</p><p id="0253" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">我们如何选择合适的K数？</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ka"><img src="../Images/f9974a0133bf0d620ce68e18a5d300e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1394/format:webp/1*TH9rxggk7opvGMFzG3dNXQ.png"/></div></figure><p id="868a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最佳结果基于聚类平方和内的总数(WCSS)。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kb"><img src="../Images/e393004551d19f3037546b3ba829129a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1342/format:webp/1*cNCpAO1gWMs93PdiCikR-Q.png"/></div></figure><p id="fc92" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">模型质量随着聚类数量的变化而变化</p><p id="4f91" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">理想的图将有一个<strong class="ig hi">弯头</strong>，在此处，质量度量随着群集数量的增加而提高得更慢。如果我们观察该图，它表明随着模型复杂性(聚类数量)的增加，模型的质量不再显著提高。换句话说，肘形表示数据中固有的聚类数。</p><p id="007e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了执行K均值聚类，我们在R包中使用K均值函数。该函数的两个重要特征是n start(用于降低算法对初始聚类/聚类均值的随机选择的敏感性的参数。)和聚类标签(标签从一次运行到另一次运行是变化的。)</p><p id="9dc6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">虽然K-均值聚类有一些优点，如</p><ul class=""><li id="a634" class="jl jm hh ig b ih ii il im ip jn it jo ix jp jb jq jr js jt bi translated">易于实现和高速性能。</li><li id="ba0a" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb jq jr js jt bi translated">方法是可伸缩的，对于大型数据集非常有效。</li><li id="a212" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb jq jr js jt bi translated">总会收敛</li></ul><p id="52cb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">也有一些挑战！</p><ul class=""><li id="32bc" class="jl jm hh ig b ih ii il im ip jn it jo ix jp jb jq jr js jt bi translated">需要预先指定集群的数量。</li><li id="10f1" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb jq jr js jt bi translated">聚类对质心的初始分配很敏感。</li><li id="5f6b" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb jq jr js jt bi translated">算法对异常值过于敏感。因为具有极大值的对象可能会严重扭曲数据的分布。</li></ul><p id="933d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">层次聚类</strong></p><p id="3d13" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在<strong class="ig hi">层次聚类</strong>中，我们事先并不知道我们想要多少个聚类，事实上，我们最终得到了一个类似观察结果的树状可视化表示，称为树状图，它允许我们立即查看每个可能数量的聚类所获得的聚类。</p><ol class=""><li id="8290" class="jl jm hh ig b ih ii il im ip jn it jo ix jp jb jz jr js jt bi translated">使每个数据点成为形成N个聚类的单个点聚类</li><li id="1351" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb jz jr js jt bi translated">取两个最近的数据点并使它们成为一个聚类，这形成N-1个聚类</li><li id="7f06" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb jz jr js jt bi translated">取两个最近的聚类，使它们成为一个聚类，形成N-2个聚类</li><li id="d273" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb jz jr js jt bi translated">重复上述步骤，直到我们只有一个集群</li></ol><p id="fd36" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们可以用各种方法来测量距离</p><ul class=""><li id="21db" class="jl jm hh ig b ih ii il im ip jn it jo ix jp jb jq jr js jt bi translated">选项1:最近点</li><li id="9f99" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb jq jr js jt bi translated">选项2:最远的点</li><li id="dbcf" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb jq jr js jt bi translated">选项3:平均距离</li><li id="1d47" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb jq jr js jt bi translated">选项4:质心之间的距离</li></ul><p id="9866" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">所有这些距离当转换成高度时，我们形成了<strong class="ig hi">树状图。</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kc"><img src="../Images/7491d7eb1fd06e9bd45284a8a8b939ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1336/format:webp/1*mRW2WycyCFMPS07O_Tm0ow.png"/></div></figure><ul class=""><li id="26d4" class="jl jm hh ig b ih ii il im ip jn it jo ix jp jb jq jr js jt bi translated">同一集群中的单元由一条水平线连接。</li><li id="d5c7" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb jq jr js jt bi translated">底部的叶子代表单个单元。</li><li id="4e15" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb jq jr js jt bi translated">它们很有用，因为它们提供了集群的可视化表示。</li><li id="bf98" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb jq jr js jt bi translated">通过画一条垂直线给出不与任何水平线相交的最大垂直距离，可以确定最佳聚类数。</li></ul><p id="ea51" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">算法有两种类型</p><ul class=""><li id="3447" class="jl jm hh ig b ih ii il im ip jn it jo ix jp jb jq jr js jt bi translated">凝聚算法:这是一种自下而上的方法，我们从单个叶子开始，然后将簇合并在一起(Agnes)</li><li id="cd18" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb jq jr js jt bi translated">分裂:这是另一种方法，我们从顶部开始向下移动(DIANA)，从根开始递归分裂集群。</li></ul><p id="6e7e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第三种方法是查看密度而不是距离，即<strong class="ig hi"> DBScan </strong>聚类。一个簇被定义为密集连接的点的最大集合。该方法发现了具有一些噪声的空间距离中的任意形状的聚类。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kd"><img src="../Images/56438bd901c1a370ddb09c1bec18c383.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/format:webp/1*7BbnN6worr8KOqXHwWyMww.png"/></div></figure><ol class=""><li id="68e0" class="jl jm hh ig b ih ii il im ip jn it jo ix jp jb jz jr js jt bi translated">所以随机选择一个点<em class="ke"> p </em>。</li><li id="9af9" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb jz jr js jt bi translated">然后检索关于Eps(最大)从<em class="ke"> p </em>可到达的所有点。邻域半径)和min pts(Eps邻域内的最小点数)。</li><li id="c03a" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb jz jr js jt bi translated">如果邻域中的点数大于MinPts，则p是核心点。</li><li id="fed2" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb jz jr js jt bi translated">对于<em class="ke"> p </em>核心点，形成一个聚类。</li><li id="5fc3" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb jz jr js jt bi translated">如果p不是一个核心点，让它成为一个噪声，然后移动到下一个点。</li><li id="8fdc" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb jz jr js jt bi translated">继续，直到覆盖所有的点。</li></ol><p id="31f6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi">— — — — — — — — — — — — — @— — — — — — — — — — — — — — — — —</p></div></div>    
</body>
</html>