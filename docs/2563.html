<html>
<head>
<title>YOLOX Explanation — SimOTA For Dynamic Label Assignment</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">YOLOX解释— SimOTA用于动态标签分配</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/yolox-explanation-simota-for-dynamic-label-assignment-8fa5ae397f76?source=collection_archive---------0-----------------------#2022-05-19">https://medium.com/mlearning-ai/yolox-explanation-simota-for-dynamic-label-assignment-8fa5ae397f76?source=collection_archive---------0-----------------------#2022-05-19</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="8c10" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">本文是我全面解释YOLOX(你只看一次X)模型如何工作的系列文章的第三篇。如果您对该代码感兴趣，可以在下面找到它的链接:</p><div class="jc jd ez fb je jf"><a href="https://github.com/gmongaras/YOLOX_From_Scratch/tree/main" rel="noopener  ugc nofollow" target="_blank"><div class="jg ab dw"><div class="jh ab ji cl cj jj"><h2 class="bd hi fi z dy jk ea eb jl ed ef hg bi translated">GitHub-gmongaras/YOLOX _从头开始</h2><div class="jm l"><h3 class="bd b fi z dy jk ea eb jl ed ef dx translated">试图从头开始构建YOLOX算法</h3></div><div class="jn l"><p class="bd b fp z dy jk ea eb jl ed ef dx translated">github.com</p></div></div><div class="jo l"><div class="jp l jq jr js jo jt ju jf"/></div></div></a></div><p id="4cf1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">本系列有4个部分来全面介绍YOLOX算法:</p><ul class=""><li id="0a38" class="jv jw hh ig b ih ii il im ip jx it jy ix jz jb ka kb kc kd bi translated">什么是YOLO，它有什么特别之处？</li><li id="9c09" class="jv jw hh ig b ih kf il kg ip kh it ki ix kj jb ka kb kc kd bi translated">【YOLOX是怎么工作的？</li><li id="4ce7" class="jv jw hh ig b ih kf il kg ip kh it ki ix kj jb ka kb kc kd bi translated"><strong class="ig hi"> SimOTA进行动态标签分配</strong> ( <a class="ae ke" rel="noopener" href="/p/8fa5ae397f76"> self </a>)</li><li id="5459" class="jv jw hh ig b ih kf il kg ip kh it ki ix kj jb ka kb kc kd bi translated"><a class="ae ke" href="https://gmongaras.medium.com/yolox-explanation-mosaic-and-mixup-for-data-augmentation-3839465a3adf" rel="noopener">用于数据增强的镶嵌和混合</a></li></ul><h1 id="c76e" class="kk kl hh bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">目标检测中的标签分配</h1><p id="7825" class="pw-post-body-paragraph ie if hh ig b ih li ij ik il lj in io ip lk ir is it ll iv iw ix lm iz ja jb ha bi translated">标签分配是对象检测中的一项关键任务，因为它决定了在训练期间什么样的边界框与什么样的地面真实对象相匹配。正如在上一篇文章中提到的<a class="ae ke" rel="noopener" href="/p/3e5c89f2bf78">，标签分配将锚点分为正组和负组。</a></p><p id="13a2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">正分组锚点被认为是绑定对象的好预测，而负分组锚点被认为是不绑定对象的坏预测。</p><p id="44a2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">例如，请看下图:</p><figure class="lo lp lq lr fd ls er es paragraph-image"><div class="er es ln"><img src="../Images/684cffb29b3f0684d78d88b3ce889ae4.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/format:webp/1*JskQM4TlCrdGgleKM_uONw.png"/></div><figcaption class="lu lv et er es lw lx bd b be z dx">Bear Box</figcaption></figure><p id="11fe" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">请注意，有三个边界框，分别标记为A、B和C。如果一个人检查边界框并将其标记为正或负，他们可能会说B是正的，因为它完全限制了熊的头部，而A和C是负的，因为它没有限制熊的头部。如果熊的头是地面真实物体，他们也可能会说B会跟着地面真实物体走，而A和C不会跟着任何地面真实物体走，或者只是跟着背景走。</p><p id="9aa4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">有很多方法可以将边界框标记为正或负，我将介绍YOLOX如何使用SimOTA解决这个问题。</p><h1 id="7dfa" class="kk kl hh bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">为什么在训练中使用标签分配？</h1><p id="27b4" class="pw-post-body-paragraph ie if hh ig b ih li ij ik il lj in io ip lk ir is it ll iv iw ix lm iz ja jb ha bi translated">SimOTA需要地面真值对象来分配标签。所以，它只在训练时使用，而不在推理时使用。</p><p id="363e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">标签分配有助于模型在训练时更加稳定。我们可以使用标签分配来获得最佳预测，而不是优化所有预测(在YOLOX中，对于256个输入图像，预测的数量大约是1344个)。然后，我们可以优化最佳预测，使它们变得更好。</p><p id="0d01" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">请记住，该模型优化了回归和类别目标的阳性预测，但优化了阳性/阴性目标的客观性。通过这种方式，模型可以学习做出更好的预测，而不用担心其他的预测。剔除不好的预测会使最终模型做出更好的预测。</p><p id="1e82" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">训练更稳定的原因是模型必须处理更少的梯度更新。与处理回归和类损失的数千个梯度更新的模型相反，它只需要处理每个图像的几个梯度更新。由于模型更新处理较少的输出，优化空间更容易优化。</p><h1 id="0ebf" class="kk kl hh bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">SimOTA之前的标签分配</h1><p id="29c7" class="pw-post-body-paragraph ie if hh ig b ih li ij ik il lj in io ip lk ir is it ll iv iw ix lm iz ja jb ha bi translated">标签分配可以通过多种方式完成。分配标签的一种最常见的方式是通过找到地面真实边界框和所有其他边界框之间的最高IoU。具有最高IoU的预测被分配给该基础事实对象。</p><p id="9872" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">其他算法可能会使用其他类似的方法，但SimOTA的作者声称，“在没有上下文的情况下，为每个gt(地面真实)独立分配pos/neg样本可能是次优的，就像缺乏上下文可能会导致不正确的预测一样。”为了处理次优标签分配问题，作者建议使用图像中的全局上下文来分配标签，而不是旧的标签分配算法所使用的局部上下文。</p><h1 id="89ef" class="kk kl hh bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">飞越顶部攻击(Overflying-Top Attack)</h1><p id="baa4" class="pw-post-body-paragraph ie if hh ig b ih li ij ik il lj in io ip lk ir is it ll iv iw ix lm iz ja jb ha bi translated">OTA是提出的处理全局上下文标签分配的方法。OTA将标签分配问题视为一个<a class="ae ke" href="https://kantorovich.org/post/ot_intro/" rel="noopener ugc nofollow" target="_blank">最优传输(OT)问题</a>。</p><p id="bf8a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">OTA的作者(他们也是YOLOX的作者)将OT问题定义为一个在某个区域有<em class="ly"> m </em>个供给和<em class="ly"> n </em>个需求的问题。第<em class="ly"> i </em>供应商持有s <em class="ly"> ᵢ </em>单位货物，而第<em class="ly"> j </em>需求d <em class="ly"> ⱼ </em>单位货物。每单位货物从一个供方<em class="ly"> i </em>到需方<em class="ly"> j </em>的运输成本记为<em class="ly"> cᵢⱼ.</em>该问题的目标是找到一个运输计划𝝅*，根据该计划，供应商的所有货物都可以以最小的运输成本运输到需求方(第3页)</p><p id="b399" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">本质上，OT有供应商和需求者，目标是找到最佳的计划，以最低的成本将供应品运输给需求者。</p><p id="83c5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">OTA将标签分配公式化为OT问题，其中<em class="ly"> m </em>供应商是<em class="ly"> gt </em>目标，而<em class="ly"> n </em>需求者是图像上的预测或锚位置。请记住，每个预测都被分配给图像上的一个锚点，因此这两个可以作为同义词使用。<em class="ly"> gt </em>目标是向有需求的主播提供正面标签，目标是形成向主播提供正面标签的最佳方案。如你所见，目标实际上是使用OT问题找到将锚/预测标记为pos/neg的最佳方式。</p><p id="69d4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">除了gts，还有另一个供应商，后台。该供应商持有所有其他标签，并显示在算法的步骤4中。</p><p id="398c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在解释OTA算法之前，首先让我们定义一些符号:</p><ul class=""><li id="0014" class="jv jw hh ig b ih ii il im ip jx it jy ix jz jb ka kb kc kd bi translated"><em class="ly"> I </em> -输入图像</li><li id="8c25" class="jv jw hh ig b ih kf il kg ip kh it ki ix kj jb ka kb kc kd bi translated"><em class="ly"> A </em> -输入图像上的锚点集合</li><li id="7933" class="jv jw hh ig b ih kf il kg ip kh it ki ix kj jb ka kb kc kd bi translated"><em class="ly"> G </em> -图像中的地面真实包围盒<em class="ly"> I </em></li><li id="5c92" class="jv jw hh ig b ih kf il kg ip kh it ki ix kj jb ka kb kc kd bi translated"><em class="ly"> m </em> -地面真实目标的数量</li><li id="ebc5" class="jv jw hh ig b ih kf il kg ip kh it ki ix kj jb ka kb kc kd bi translated"><em class="ly"> n </em> -锚的数量</li><li id="31b3" class="jv jw hh ig b ih kf il kg ip kh it ki ix kj jb ka kb kc kd bi translated"><em class="ly"> k </em> -每台gt可提供的阳性标签数量</li><li id="d5c9" class="jv jw hh ig b ih kf il kg ip kh it ki ix kj jb ka kb kc kd bi translated">s <em class="ly"> ᵢ </em> -供应第<em class="ly">I</em>th gt(s<em class="ly">ᵢ</em>=<em class="ly">k</em></li><li id="b142" class="jv jw hh ig b ih kf il kg ip kh it ki ix kj jb ka kb kc kd bi translated">d<em class="ly">ⱼ</em>-<em class="ly">j</em>号锚的需求</li><li id="97c2" class="jv jw hh ig b ih kf il kg ip kh it ki ix kj jb ka kb kc kd bi translated"><em class="ly"> c </em> -从gt <em class="ly"> ᵢ </em>运输一个阳性标签到锚定a <em class="ly"> ⱼ </em>的费用</li><li id="514e" class="jv jw hh ig b ih kf il kg ip kh it ki ix kj jb ka kb kc kd bi translated">-背景类，通常表示为0</li><li id="ba50" class="jv jw hh ig b ih kf il kg ip kh it ki ix kj jb ka kb kc kd bi translated">α -回归平衡系数(通常大于或等于1，以加权大于1的回归损失)</li><li id="8036" class="jv jw hh ig b ih kf il kg ip kh it ki ix kj jb ka kb kc kd bi translated"><em class="ly"> T </em> -运行Sinkhorn-Knopp迭代的迭代次数</li></ul><p id="42c0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">获得最佳标签分配的算法如下。</p><ol class=""><li id="878c" class="jv jw hh ig b ih ii il im ip jx it jy ix jz jb lz kb kc kd bi translated">将<em class="ly"> m </em>和<em class="ly"> n </em>指定为地面真相数和锚数的计数</li><li id="4d84" class="jv jw hh ig b ih kf il kg ip kh it ki ix kj jb lz kb kc kd bi translated">通过在模型中发送图像<em class="ly"> I </em>来获得类别预测Pᶜˡˢ和回归预测Pᵇᵒˣ。</li><li id="616e" class="jv jw hh ig b ih kf il kg ip kh it ki ix kj jb lz kb kc kd bi translated">创建供应向量，<em class="ly"> s </em>，其值为<em class="ly"> m </em> + 1。使用<strong class="ig hi">动态<em class="ly"> k </em>估算</strong>获得每个gt的供应量，并将其存储在向量中。</li><li id="f11a" class="jv jw hh ig b ih kf il kg ip kh it ki ix kj jb lz kb kc kd bi translated"><em class="ly">s</em>[<em class="ly">m</em>+1]=<em class="ly">n</em>-sum(<em class="ly">s</em>)，供给向量中位置<em class="ly"> m </em> + 1处的背景供给等于<em class="ly"> n </em> - sum( <em class="ly"> s </em></li><li id="9645" class="jv jw hh ig b ih kf il kg ip kh it ki ix kj jb lz kb kc kd bi translated">将需求向量<em class="ly"> d、</em>初始化为大小为<em class="ly"> n </em>的向量，用1填充。</li><li id="a9b0" class="jv jw hh ig b ih kf il kg ip kh it ki ix kj jb lz kb kc kd bi translated">获得每个第<em class="ly"> j </em>个预测与其对应的第<em class="ly"> i </em>个真实标签之间的成对<em class="ly"> cls </em>损失。<em class="ly"> c </em> ᶜˡˢ = FocalLoss(Pᶜˡˢ，<em class="ly"> G </em> ᶜˡˢ)</li><li id="c229" class="jv jw hh ig b ih kf il kg ip kh it ki ix kj jb lz kb kc kd bi translated">获得每个第<em class="ly"> j </em>个预测与其对应的第<em class="ly"> i </em>个真实标签之间的成对<em class="ly"> reg </em>损失。<em class="ly"> c </em> ʳᵉᵍ = IoULoss(Pᵇᵒˣ，<em class="ly"> G </em> ᵇᵒˣ)</li><li id="a05b" class="jv jw hh ig b ih kf il kg ip kh it ki ix kj jb lz kb kc kd bi translated">在每个<em class="ly"> j </em> th锚和其对应的<em class="ly"> i </em> th gt之间获得成对的<strong class="ig hi">中心优先</strong>。<em class="ly">c</em>ᶜᵖ= center prior(a<em class="ly">ⱼ</em>，<em class="ly"> G </em> ᵇᵒˣ)</li><li id="4d00" class="jv jw hh ig b ih kf il kg ip kh it ki ix kj jb lz kb kc kd bi translated">获取背景类成本:<em class="ly"> c </em> ᵇᵍ = FocalLoss(Pᶜˡˢ，ψ)</li><li id="021b" class="jv jw hh ig b ih kf il kg ip kh it ki ix kj jb lz kb kc kd bi translated">得到前台成本:<em class="ly">c</em>ᶠᵍ=<em class="ly">c</em>ᶜˡˢ+<em class="ly">αc</em>ʳᵉᵍ+<em class="ly">c</em>ᶜᵖ</li><li id="2f13" class="jv jw hh ig b ih kf il kg ip kh it ki ix kj jb lz kb kc kd bi translated">通过连接<em class="ly"> c </em> ᵇᵍ到<em class="ly"> c </em> ᶠᵍ来计算最终成本矩阵<em class="ly"> c </em>以形成最终形状矩阵(<em class="ly"> m </em> +1，<em class="ly"> n </em>)</li><li id="ab44" class="jv jw hh ig b ih kf il kg ip kh it ki ix kj jb lz kb kc kd bi translated">将<em class="ly"> u </em>和<em class="ly"> v </em>初始化为一</li><li id="6cf4" class="jv jw hh ig b ih kf il kg ip kh it ki ix kj jb lz kb kc kd bi translated">通过运行Sinkhorn-Knopp Iter进行<em class="ly"> T </em>步骤来填充<em class="ly"> u </em>和<em class="ly"> v </em>。</li><li id="713b" class="jv jw hh ig b ih kf il kg ip kh it ki ix kj jb lz kb kc kd bi">^</li><li id="3beb" class="jv jw hh ig b ih kf il kg ip kh it ki ix kj jb lz kb kc kd bi translated">根据原始文件中的等式11计算最优分配计划𝝅*。</li><li id="0159" class="jv jw hh ig b ih kf il kg ip kh it ki ix kj jb lz kb kc kd bi translated">返回𝝅*</li></ol><p id="7087" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">论文给出了如下算法。</p><figure class="lo lp lq lr fd ls er es paragraph-image"><div class="er es ma"><img src="../Images/70d112128ceeea90c290f28cf49b27dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:990/format:webp/1*T040dIc7iJL7Uhq_UkvdPw.png"/></div><figcaption class="lu lv et er es lw lx bd b be z dx"><a class="ae ke" href="https://arxiv.org/abs/2103.14259" rel="noopener ugc nofollow" target="_blank">https://arxiv.org/abs/2103.14259</a></figcaption></figure><h1 id="33b1" class="kk kl hh bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">西蒙塔</h1><p id="b1a6" class="pw-post-body-paragraph ie if hh ig b ih li ij ik il lj in io ip lk ir is it ll iv iw ix lm iz ja jb ha bi translated">算法看起来要处理很多，但也没那么糟糕。SimOTA使算法更加简单和快速。</p><p id="1039" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">YOLOX的作者意识到，即使OTA提高了模型的性能，它也使模型慢了25%,这对于训练一个模型大约300次迭代来说是一个很大的时间。作者意识到，他们可以通过删除Sinkhorn Iter步骤，而不是近似最优分配计划，使OTA OT算法更快，同时保持良好的性能提升。</p><p id="6178" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">不使用Sinkhorn迭代，SimOTA选择成本最低的顶部<em class="ly"> kᵢ </em>(或s <em class="ly"> ᵢ </em>)预测作为第<em class="ly"> i </em>地面实况对象的正样本。使用SimOTA分配方法，在所有gt对象上的单次迭代近似分配，而不是使用优化算法来获得最佳分配。</p><p id="6ac0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">SimOTA算法如下所示:</p><ol class=""><li id="65cd" class="jv jw hh ig b ih ii il im ip jx it jy ix jz jb lz kb kc kd bi translated">将<em class="ly"> m </em>和<em class="ly"> n </em>指定为地面真相数和锚数的计数</li><li id="78f2" class="jv jw hh ig b ih kf il kg ip kh it ki ix kj jb lz kb kc kd bi translated">通过模型发送图像<em class="ly"> I </em>获得类别预测Pᶜˡˢ和回归预测Pᵇᵒˣ。</li><li id="7031" class="jv jw hh ig b ih kf il kg ip kh it ki ix kj jb lz kb kc kd bi translated">创建供应向量<em class="ly"> s </em>，其值为<em class="ly"> m </em> + 1。使用<strong class="ig hi">动态<em class="ly"> k </em>估算</strong>得到每个gt的供应量，并存储在向量中。</li><li id="c505" class="jv jw hh ig b ih kf il kg ip kh it ki ix kj jb lz kb kc kd bi translated"><em class="ly">s</em>[<em class="ly">m</em>+1]=<em class="ly">n</em>—sum(<em class="ly">s</em>)，供给向量中位置<em class="ly"> m </em> + 1处的背景供给等于<em class="ly"> n </em> — sum( <em class="ly"> s </em></li><li id="9a7f" class="jv jw hh ig b ih kf il kg ip kh it ki ix kj jb lz kb kc kd bi translated">将需求向量<em class="ly"> d、</em>初始化为大小为<em class="ly"> n </em>的向量，并用1填充。</li><li id="1472" class="jv jw hh ig b ih kf il kg ip kh it ki ix kj jb lz kb kc kd bi translated">获得每个<em class="ly"> j </em>个预测与其对应的<em class="ly"> i </em>个地面真实标签之间的成对<em class="ly"> cls </em>损失。<em class="ly"> c </em> ᶜˡˢ = FocalLoss(Pᶜˡˢ，<em class="ly"> G </em> ᶜˡˢ)</li><li id="f9e3" class="jv jw hh ig b ih kf il kg ip kh it ki ix kj jb lz kb kc kd bi translated">获得每个第<em class="ly"> j </em>个预测与其对应的第<em class="ly"> i </em>个真实标签之间的成对<em class="ly"> reg </em>损失。<em class="ly"> c </em> ʳᵉᵍ = IoULoss(Pᵇᵒˣ，<em class="ly"> G </em> ᵇᵒˣ)</li><li id="67ae" class="jv jw hh ig b ih kf il kg ip kh it ki ix kj jb lz kb kc kd bi translated">获得每个<em class="ly"> j </em>个锚与其对应的<em class="ly"> i </em>个锚之间的成对<strong class="ig hi">中心先验</strong>。<em class="ly"> c </em> ᶜᵖ =中心优先(A <em class="ly"> ⱼ </em>，<em class="ly"> G </em> ᵇᵒˣ)</li><li id="9907" class="jv jw hh ig b ih kf il kg ip kh it ki ix kj jb lz kb kc kd bi translated">获取背景类成本:<em class="ly"> c </em> ᵇᵍ = FocalLoss(Pᶜˡˢ</li><li id="03fa" class="jv jw hh ig b ih kf il kg ip kh it ki ix kj jb lz kb kc kd bi translated">得到前景成本:<em class="ly">c</em>ᶠᵍ=<em class="ly">c</em>ᶜˡˢ+<em class="ly">αc</em>ʳᵉᵍ+<em class="ly">c</em>ᶜᵖ</li><li id="7b4d" class="jv jw hh ig b ih kf il kg ip kh it ki ix kj jb lz kb kc kd bi translated">通过连接<em class="ly"> c </em> ᵇᵍ到<em class="ly"> c </em> ᶠᵍ来计算最终的成本矩阵<em class="ly"> c </em>以形成最终的形状矩阵(<em class="ly"> m </em> +1，<em class="ly"> n </em>)</li><li id="981f" class="jv jw hh ig b ih kf il kg ip kh it ki ix kj jb lz kb kc kd bi translated">迭代<em class="ly"> s </em>中的所有供应<em class="ly"> sᵢ </em>并获得成本最低的顶部<em class="ly"> sᵢ </em>最佳预测<em class="ly"> cᵢ </em>。结果数组应该有<em class="ly"> m </em>个值，其中结果数组中的每个<em class="ly"> mᵢ </em>索引最多有<em class="ly"> sᵢ </em>个预测。</li><li id="ea03" class="jv jw hh ig b ih kf il kg ip kh it ki ix kj jb lz kb kc kd bi translated">返回结果数组</li></ol><p id="a444" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">运行SimOTA后，输出将是一个大小为<em class="ly"> m </em>的数组，其中结果数组中的第<em class="ly"> i </em>个元素是一个对应于第<em class="ly"> i </em>个基本事实<em class="ly"> Gᵢ </em>的正标签锚/预测。不在结果数组中的其余预测被认为是没有gt赋值的负标签预测。</p><h1 id="0be1" class="kk kl hh bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">动态k估计</h1><p id="0e25" class="pw-post-body-paragraph ie if hh ig b ih li ij ik il lj in io ip lk ir is it ll iv iw ix lm iz ja jb ha bi translated"><em class="ly"> k </em>是每个gt对象的供应量，有两种计算方式。计算k的简单方法是让它在所有gt对象中保持不变。这种给每个gt分配供给的方式的问题是，不是所有的地面实况都应该有相同数量的锚被分配给它们。</p><p id="37c4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">计算<em class="ly"> k </em>的第二种建议方法是分别查看每个gt。OTA的作者建议使用动态<em class="ly"> k </em>估算，该估算接近每个燃气轮机的供应量。为了估算每个燃气轮机的电源，我们可以查看所有预测，并根据每个预测和燃气轮机之间的IoU值选择顶部的<em class="ly"> q </em>预测。然后，我们对顶部的<em class="ly"> q </em> IoU值求和，并将其用作该gt的<em class="ly"> k </em>值。</p><p id="a051" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用这种方法，我们通过观察每个预测限定gt的准确程度来估计每个gt的供应或阳性标签的数量。这样，当使用SimOTA算法时，预测更准确的gt更有可能被分配给该gt。OTA的作者陈述了这种算法背后的直觉，即“某个gt的合适的正锚的数量应该与很好地回归该gt的锚的数量正相关。”</p><p id="930b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">注意:虽然<em class="ly"> k </em>不再是我们必须改变的参数，但是<em class="ly"> q </em>现在是必须调整的参数。在我的代码中，我使用20作为<em class="ly"> q </em>值，这看起来很好。</p><p id="d353" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下面是我的动态<em class="ly"> k </em>估算代码:</p><pre class="lo lp lq lr fd mb mc md me aw mf bi"><span id="0772" class="mg kl hh mc b fi mh mi l mj mk"># The supplying vector<br/>s_i = np.ones(m+1, dtype=np.int16)</span><span id="65c4" class="mg kl hh mc b fi ml mi l mj mk"># The sum of all k values<br/>k_sum = 0</span><span id="9688" class="mg kl hh mc b fi ml mi l mj mk"># Iterate over all ground truth boxes (i = gt_i)<br/>for i in range(0, m):</span><span id="7960" class="mg kl hh mc b fi ml mi l mj mk">    # Get the ith truth value<br/>    gt = G_reg[i]</span><span id="8346" class="mg kl hh mc b fi ml mi l mj mk">    # Get the (x, y) coordinates of the intersections<br/>    xA = np.maximum(gt[0], P_reg[:, 0])<br/>    yA = np.maximum(gt[1], P_reg[:, 1])<br/>    xB = np.minimum(gt[0]+gt[2], P_reg[:, 0]+P_reg[:, 2])<br/>    yB = np.minimum(gt[1]+gt[3], P_reg[:, 1]+P_reg[:, 3])</span><span id="d747" class="mg kl hh mc b fi ml mi l mj mk">    # Get the area of the intersections<br/>    intersectionArea = np.maximum(0, xB - xA + 1) * np.maximum(0, yB - yA + 1)</span><span id="2a3b" class="mg kl hh mc b fi ml mi l mj mk">    # Compute the area of both rectangles<br/>    areaA = (gt[2]+1)*(gt[3]+1)<br/>    areaB = (P_reg[:, 2]+1)*(P_reg[:, 3]+1)</span><span id="b89c" class="mg kl hh mc b fi ml mi l mj mk">    # Get the union of the rectangles<br/>    union = areaA + areaB - intersectionArea</span><span id="3d07" class="mg kl hh mc b fi ml mi l mj mk">    # Compute the intersection over union for all anchors<br/>    IoU = intersectionArea/union</span><span id="6894" class="mg kl hh mc b fi ml mi l mj mk">    # Get the q top IoU values (the top q predictions)<br/>    # and sum them up to get the k for this gt<br/>    k = np.sort(IoU)[-q:].sum()</span><span id="6543" class="mg kl hh mc b fi ml mi l mj mk">    # Add the k value to the total k sum<br/>    k_sum += k</span><span id="c900" class="mg kl hh mc b fi ml mi l mj mk">    # Save the k value to the supplying vector<br/>    # as an iteger<br/>    s_i[i] = int(round(k))</span></pre><h1 id="ebf1" class="kk kl hh bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">中心先验</h1><p id="d2ca" class="pw-post-body-paragraph ie if hh ig b ih li ij ik il lj in io ip lk ir is it ll iv iw ix lm iz ja jb ha bi translated">SimOTA在分配标签时遇到的一个问题是，来自gt的正标签可以被分配给任何锚预测。有时，当分配正面标签时，gt没有很好的选项可供选择，但由于它必须分配<em class="ly"> k </em>正面标签，gt必须向自己分配负面正面标签。例如，请看下图:</p><figure class="lo lp lq lr fd ls er es paragraph-image"><div class="er es ln"><img src="../Images/0108990c467b17116783425f5aaf138d.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/format:webp/1*sY7TcS5tEjkFOcahwe5xfQ.png"/></div></figure><p id="0ddd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">请注意，图像上的所有边界框都没有很好地覆盖熊的脸。如果熊的脸是一个gt对象，假设它有一个值为2的supply或<em class="ly"> k </em>，那么它必须选择两个预测作为正标签。显然，没有两个预测是好的，gt对象将求助于使两个坏的预测为正。</p><p id="c8a6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在训练初期，坏预测问题非常突出。因此，gts没有一个很好的预测是一个大问题。</p><p id="ad8f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">解决方案是定义一个半径<em class="ly"> r </em>并选择距离每个gt中心最近的r个锚不被惩罚，同时通过向这些预测增加额外成本来惩罚该r半径之外的所有其他锚。如SimOTA算法的步骤8所示，计算中心先验成本并将其添加到所有预测的总成本中。</p><p id="fd65" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">选择r半径内具有更高机会被选为该gt的正锚的预测背后的直觉是更接近的锚预测更容易优化，而进一步的预测更难优化。</p><p id="39eb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了得到最接近r的预测，我们可以使用古老的距离公式来得到所有点和gt中心之间的距离。</p><p id="6eb0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">首先，我们可以找到gt的中心，<em class="ly"> G </em>，将x坐标增加一半宽度，y坐标增加一半高度，如下所示:</p><pre class="lo lp lq lr fd mb mc md me aw mf bi"><span id="e2e5" class="mg kl hh mc b fi mh mi l mj mk">center = (G[0]+G[2]//2, G[1]+G[3]//2)</span></pre><p id="10a2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后，我们可以使用所有锚点<em class="ly"> A </em>和gt <em class="ly"> G </em>之间的距离公式:</p><pre class="lo lp lq lr fd mb mc md me aw mf bi"><span id="7a77" class="mg kl hh mc b fi mh mi l mj mk">diff = A-center<br/>dist = np.sqrt(np.sum(diff**2, axis=-1))</span></pre><p id="bd2f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">注意:<em class="ly">中心</em>将是一对两个坐标。如果<em class="ly"> A </em>是(x，y)轴上的锚位置，那么我们可以从<em class="ly"> A </em>中减去<em class="ly">中心</em>来得到<em class="ly"> A </em>的差对数。因此，距离公式是计算沿这些二维坐标对的距离。<em class="ly"> dist </em>的结果应该等于<em class="ly"> A </em>中的锚数量。</p><p id="a9a0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下面是我写的一个函数，它可以在我的代码中找到，用来计算单个基础事实和所有锚之间的中心先验:</p><pre class="lo lp lq lr fd mb mc md me aw mf bi"><span id="31e9" class="mg kl hh mc b fi mh mi l mj mk"># Get the center prior between a gt and the anchor locations<br/># on the image<br/># Inputs:<br/>#   A - All anchors for a single image<br/>#   G_box - A ground truth box for this image<br/>#   r - radius used to select anchors in this function<br/>#   extraCost - The extra cost to add to those anchors not in<br/>#               the r**2 radius<br/># Output:<br/>#   Array with the same number of values as the number of anchors<br/>#   where each value is the center prior value of that anchor<br/>def centerPrior(A, G_box, r, extraCost):<br/>    ## Center Prior selects the r**2 closest anchors according to the<br/>    ## center distance between the anchors and gts. Those anchors<br/>    ## that are in the radius are not subject to any extra cost, but those<br/>    ## anchors outside the radius are assigned extra cost to avoid<br/>    ## having them be labelled as positive anchors for this gt.<br/>    <br/>    # Get the center location of the ground truth boudning box<br/>    center = (G_box[0]+(G_box[2]//2), G_box[1]+(G_box[3]//2))<br/>    <br/>    # Get the difference between the center locations in A and the<br/>    # center location of the gt bounding box<br/>    diff = A-center<br/>    <br/>    # Use the distance formula to get the distance from the<br/>    # gt center location for each anchor<br/>    dist = np.sqrt(np.sum(diff**2, axis=-1))<br/>    <br/>    # Get the indices of the distances which are greater<br/>    # than r**2 meaning the anchor is outside the radius<br/>    idx_neg = np.where(dist &gt; r**2)<br/>    <br/>    # Array of zeros corresponding to the center prior of each anchor<br/>    c_cp = np.zeros(A.shape[0])<br/>    <br/>    # Those values not in the r**2 radius are subject to a constant cost<br/>    c_cp[idx_neg] = extraCost<br/>    <br/>    return c_cp</span></pre><p id="dd10" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">记住每个FPN关卡有不同数量的锚。在256像素的输入图像上，在FPN级上将有64、256、1024个锚，分别具有32、16和8的步幅。如果半径相当大，熊的头是gt，那么蓝色圆圈中网格上的交叉点就是锚点，不需要额外的成本。</p><figure class="lo lp lq lr fd ls er es paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="er es mm"><img src="../Images/f93a40555e7a8f167a40bb51002281e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gdy8T3uFstbVAAg-sPh45Q.png"/></div></div></figure><p id="0d32" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">OTA的作者指出，挑选r个最接近的锚点可以稳定训练，尤其是在训练的早期阶段。此外，他们声称，由于模型训练中的这种额外稳定性，该模型会产生更好的性能。</p><p id="9a5d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">YOLOX实际上会删除r半径以外的标签。它没有给半径之外的预测额外的成本，而是移除了r半径之外的所有预测。有时这将导致该gt没有预测，但是移除半径之外的预测保持了中心先验，并有助于模型的稳定性，因此梯度不会由于一些坏的预测而爆炸。我实际上发现，完全删除半径以外的预测会影响性能，但这可能是因为我只对1000张图像进行了训练。</p><p id="0fb8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这就结束了西蒙塔。剩下要解释的就是YOLOX使用的数据扩充，这将在下一篇文章中解释。</p><h1 id="3de4" class="kk kl hh bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">参考</h1><p id="8048" class="pw-post-body-paragraph ie if hh ig b ih li ij ik il lj in io ip lk ir is it ll iv iw ix lm iz ja jb ha bi translated">太田:【https://arxiv.org/abs/2103.14259】T2</p><p id="b4f7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">约洛克斯:【https://arxiv.org/abs/2107.08430】T4</p><div class="jc jd ez fb je jf"><a rel="noopener follow" target="_blank" href="/mlearning-ai/mlearning-ai-submission-suggestions-b51e2b130bfb"><div class="jg ab dw"><div class="jh ab ji cl cj jj"><h2 class="bd hi fi z dy jk ea eb jl ed ef hg bi translated">Mlearning.ai提交建议</h2><div class="jm l"><h3 class="bd b fi z dy jk ea eb jl ed ef dx translated">如何成为Mlearning.ai上的作家</h3></div><div class="jn l"><p class="bd b fp z dy jk ea eb jl ed ef dx translated">medium.com</p></div></div><div class="jo l"><div class="mr l jq jr js jo jt ju jf"/></div></div></a></div></div></div>    
</body>
</html>