<html>
<head>
<title>Introduction to Support Vector Machine Algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">支持向量机算法简介</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/introduction-to-support-vector-machine-algorithm-3b412c4e25f4?source=collection_archive---------3-----------------------#2022-03-26">https://medium.com/mlearning-ai/introduction-to-support-vector-machine-algorithm-3b412c4e25f4?source=collection_archive---------3-----------------------#2022-03-26</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="760d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">解释经典机器学习算法中最健壮的分类器之一</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/ebdc3d7007608bbdf17519f2a63c1875.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-jweL3j5fx2mPSIfG_GzEA.jpeg"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Photo by <a class="ae js" href="https://unsplash.com/@kellysikkema?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Kelly Sikkema</a> on <a class="ae js" href="https://unsplash.com/s/photos/learning-algorithm?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure></div><div class="ab cl jt ju go jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="ha hb hc hd he"><p id="6453" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">SVM——支持向量机——是一种监督机器学习分类器，它基于利用一个将两个类分开的超平面来工作。</p><h2 id="ad9d" class="ka kb hh bd kc kd ke kf kg kh ki kj kk ip kl km kn it ko kp kq ix kr ks kt ku bi translated">超平面和边缘</h2><p id="c736" class="pw-post-body-paragraph ie if hh ig b ih kv ij ik il kw in io ip kx ir is it ky iv iw ix kz iz ja jb ha bi translated">超平面是一个比其周围空间的维数小一的子空间。例如，如果我们有2个特征(2-D)的数据集，那么超平面是一条线(1-D)，同时对于3个特征(3-D)，那么超平面是一个平面(2-D)，等等。</p><p id="cce6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">回忆直线方程(线性方程)</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es la"><img src="../Images/27db11ab1d5fd327a79422b532ceb98d.png" data-original-src="https://miro.medium.com/v2/resize:fit:178/format:webp/1*h3biKQ_EMl5jXg2vaCiykQ.png"/></div></figure><p id="309a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">其中m是常数，称为斜率，b是y轴的截距。这可以写成</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es lb"><img src="../Images/42060d6eeb9e276540f230167fe1791f.png" data-original-src="https://miro.medium.com/v2/resize:fit:326/format:webp/1*EZWwZF_HB8jlXgEtbIrD9g.png"/></div></figure><p id="eb03" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果我们定义二维向量<strong class="ig hi"> x </strong> =(x，y)和<strong class="ig hi"> w </strong> =(m，-1)</p><p id="8444" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们可以把<code class="du lc ld le lf b">mx-y+b=0 </code>写成</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es lg"><img src="../Images/40e34f60f960fb4876416b9d487f2e31.png" data-original-src="https://miro.medium.com/v2/resize:fit:286/format:webp/1*uzOWJSiQ-DEKJzd-W1XWjA.png"/></div></figure><p id="cdbe" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这样线性方程可以写成向量w和x的形式，上面的方程叫做超平面的<strong class="ig hi">方程。</strong></p><p id="47d1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们得到了超平面的方程，利用它我们也可以得到线性方程。给定向量<strong class="ig hi"> w=(w0，w1) </strong>和<strong class="ig hi"> x=(x，y) </strong></p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es lh"><img src="../Images/a2667f84d89ba99bbcec2be5d7fa3002.png" data-original-src="https://miro.medium.com/v2/resize:fit:708/format:webp/1*bhUMwK-8pYzMvZ8l6tmkvA.png"/></div></figure><p id="9a7c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在常数a是斜率，c是y轴的截距。注意，向量形式的b不是线性方程的斜率。</p><p id="9ab9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在我们将使用超平面的方程来对数据集中的一些特征进行分类。假设我们有这样的数据</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es li"><img src="../Images/68ef8f8157850b06f5986f42e17eea37.png" data-original-src="https://miro.medium.com/v2/resize:fit:730/format:webp/1*J8HcrudeAE3zxOOVcNJPdQ.png"/></div></figure><p id="3669" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后我们有了一个新的数据点‘X’，我们想分类X是红色类还是黄色类</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es li"><img src="../Images/e37905346182367cd5a4226af0f76e3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:730/format:webp/1*UWdTAqGExPjHf-Gtpzbw7A.png"/></div></figure><p id="9eb4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们可以使用超平面来执行二元分类。例如，对于向量<strong class="ig hi"> w=(-1，1) </strong>和b=0.65，我们得到超平面</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es lj"><img src="../Images/d9341b0fa7bc512e6d2e5c2e41b2d95d.png" data-original-src="https://miro.medium.com/v2/resize:fit:748/format:webp/1*vI0TBO7x5bInNVIy5vUkMQ.png"/></div></figure><p id="d64f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">从这个结果，我们可以推断点“X”是红色类。但是我们看到了一个问题:有不止一个可能的超平面可以在两个类之间完美分离！</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es lj"><img src="../Images/cb36b1363b3158356418104f6312217b.png" data-original-src="https://miro.medium.com/v2/resize:fit:748/format:webp/1*V4wcECXlqqGdua4n8sSCVw.png"/></div></figure><p id="7682" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">所以画超平面来分隔类是不够的。有许多可能的超平面可以画在图上，但我们需要最好的一个。为了确定最优超平面，我们需要理解边缘的概念。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es lk"><img src="../Images/470d83e99dfa049bdd1ad9e3a34409aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8edlhHZp-cK7TjUXrzwEKA.jpeg"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Figure 1: SVM graph — <a class="ae js" href="http://ireneli.eu/" rel="noopener ugc nofollow" target="_blank">Ireneli.eu</a></figcaption></figure><p id="2a02" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">请看图1。假设蓝线是分隔圆类和三角形类的最佳超平面。黑色虚线是通过最近的三角形点和最近的圆形点的一些超平面。那些超平面经过的最近的点被称为<strong class="ig hi">支持向量</strong>。这些超平面之间的距离称为<strong class="ig hi">余量。</strong></p><p id="0186" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在你可能想知道，我们知道向量<strong class="ig hi"> x </strong>与特征点相关联，但是向量<strong class="ig hi"> w的意义是什么？为了澄清这一点，我们需要确定一种计算利润的方法。</strong></p><p id="13af" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">首先，让我们以正式的方式定义SVM问题。你有数据集<em class="ll"> D </em>并且你想对它进行分类。数据集由与<em class="ll"> n </em>标签向量<strong class="ig hi">y</strong>相关联的<em class="ll"> n </em>特征向量<strong class="ig hi"> x </strong>组成。在二进制分类的情况下<strong class="ig hi"> y </strong>具有两个可能的值，-1和1，并且特征<strong class="ig hi"> x </strong>是<strong class="ig hi"> <em class="ll"> p </em> </strong>维向量。因此，数据集的定义可以写成</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es lm"><img src="../Images/13358711a38211eb7ab21aaa92b5d86c.png" data-original-src="https://miro.medium.com/v2/resize:fit:802/format:webp/1*yyZysOlLly8mV72kA4UM3Q.png"/></div></figure><p id="a96b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了简单说明，我们只限制为<strong class="ig hi"> <em class="ll"> p </em> </strong> =2维。</p><p id="aebc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第二步，选择超平面<strong class="ig hi"> H₀ </strong>分离数据集并满足超平面方程</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es lg"><img src="../Images/c8c7a39df93ca96095cfd1174d1b9d0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:286/format:webp/1*9WRgxUQv__0WXOVA201jVw.png"/></div></figure><p id="2e94" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们可以选择另一个超平面<strong class="ig hi"> H₁ </strong>和<strong class="ig hi"> H₂ </strong>，它们也分离数据并满足以下方程:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es ln"><img src="../Images/4c3f146061398e87c3e2156e839a637b.png" data-original-src="https://miro.medium.com/v2/resize:fit:262/format:webp/1*f_eoaSqYFns1bXDLwAerrA.png"/></div></figure><p id="7220" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">和</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es lo"><img src="../Images/f69a8644b853332fac35efdb218c4378.png" data-original-src="https://miro.medium.com/v2/resize:fit:300/format:webp/1*1B82lwCmPS6mT09RsCnaKg.png"/></div></figure><p id="718f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此<strong class="ig hi"> H₀ </strong>与<strong class="ig hi"> H₁ </strong>和<strong class="ig hi"> H₂ </strong>的距离相同。变量δ可以是任意的，所以为了简单起见，我们定义δ=1，因此</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es lp"><img src="../Images/028ca406efec29b79ba101ce38b4b080.png" data-original-src="https://miro.medium.com/v2/resize:fit:260/format:webp/1*nfQfzshdh6R751NEMhHCuQ.png"/></div></figure><p id="7c84" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">和</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es lq"><img src="../Images/f09840d25bd6f19c58628b3ac54767aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:298/format:webp/1*P277CaYSS2RvW1QwmoCBrw.png"/></div></figure><p id="dcf3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">由于边缘充当分隔符，我们希望确保它们在这些超平面之间没有点。</p><p id="daaf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在我们要选择满足以下约束的超平面。</p><p id="f124" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对于每个矢量<strong class="ig hi"> x </strong>，ᵢ都满意</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es lh"><img src="../Images/fdbd3455657139074483ab8c4b63884c.png" data-original-src="https://miro.medium.com/v2/resize:fit:708/format:webp/1*wvdTygWf9CsdhLu1rudYJQ.png"/></div></figure><p id="bf3e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">或者</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es lr"><img src="../Images/2eada5b0574adf02be67a08ebb51e3c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:746/format:webp/1*_p0nMMAL4jXdrE-QuOQLQg.png"/></div></figure><p id="15d7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们需要将这些约束组合成单一约束。对于产生yᵢ=-1类的<strong class="ig hi"> x </strong> ᵢ，如果我们用yᵢ计算约束x.w+b≥1，我们得到-1</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es ls"><img src="../Images/6bf85959d9f6d0ab16fc2527ef628797.png" data-original-src="https://miro.medium.com/v2/resize:fit:798/format:webp/1*sKFUsHzExwsmoi86KDFlrA.png"/></div></figure><p id="3238" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因为对于产生yᵢ=1的<strong class="ig hi"> x </strong> ᵢ，我们将得到相同的结果，因此约束变成</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es lt"><img src="../Images/b90640dc68c874f2fe0efae0272046b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*YJhLOIC_l2I0FwjzRg0QhA.png"/></div></figure><p id="5642" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在我们有了单一约束，保证超平面之间没有点。</p><p id="f52d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最后一步是确定这些超平面之间的距离</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es lu"><img src="../Images/ccc8ba8f807289e59d01783d234a7ce7.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/format:webp/1*21qKBABM7EJVuZQQ07-qkA.png"/></div></figure><p id="69af" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">假设我们有向量<strong class="ig hi"> x </strong> ₀，其点位于超平面<strong class="ig hi"> H₀ </strong>中，并且满足<strong class="ig hi"> w.x </strong> ₀ + b=0。裕度<strong class="ig hi"> <em class="ll"> m </em> </strong>定义为从<strong class="ig hi"> x </strong> ₀到位于超平面<strong class="ig hi"> H₁.中的向量的距离</strong>所以，如果我们可以确定任何一个矢量的点位于<strong class="ig hi"> H₁ </strong>并且方向垂直于<strong class="ig hi"> H₁ </strong>的话，那么边距<em class="ll"> m </em>这个标量值就有意义了。幸运的是，我们已经有了一个垂直于<strong class="ig hi"> H₁的向量，</strong>向量<strong class="ig hi"> w，(</strong>因为<strong class="ig hi"> H₁=w.x+b=1) </strong>，</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es lv"><img src="../Images/711a59780b5a9ecc0e5ffe2e39de3e8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:966/format:webp/1*tnjWirilOEjDiGptJhqiVw.png"/></div></figure><p id="8b2f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在我们的任务是利用矢量<strong class="ig hi"> w. </strong>的存在性找到<strong class="ig hi"> H₁ </strong>中的矢量m</p><p id="12d9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们将矢量<strong class="ig hi"> u </strong>定义为<strong class="ig hi"> w </strong>的单位矢量</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es lw"><img src="../Images/635f615612aca95f5ed3346e01a48068.png" data-original-src="https://miro.medium.com/v2/resize:fit:198/format:webp/1*czqsEiXtF3E2mc69aQJmvQ.png"/></div></div></figure><p id="53af" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">由于<strong class="ig hi"> u </strong>是单位矢量，所以|| <strong class="ig hi"> u|| = 1 </strong>并且与<strong class="ig hi"> w </strong>方向相同，那么它也垂直于<strong class="ig hi"> H₁.</strong>现在，我们寻找的向量也有方向<strong class="ig hi">u。</strong>让我们定义这个向量为<strong class="ig hi"> k </strong></p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es lx"><img src="../Images/57db16c88bfcedf4c2571cd8318ae85f.png" data-original-src="https://miro.medium.com/v2/resize:fit:670/format:webp/1*VrjdnoOGtCTOf8EzChprRg.png"/></div></figure><p id="f900" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此<strong class="ig hi"> k </strong>具有大小<em class="ll"> m </em>和方向<strong class="ig hi"> u </strong>，记为</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es ly"><img src="../Images/79f5374ba999c3f30c123589c8a9162e.png" data-original-src="https://miro.medium.com/v2/resize:fit:378/format:webp/1*0ZNuxj52c41J1BzqxVHyOw.png"/></div></figure><p id="4c71" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这也可以解释为从<strong class="ig hi"> x </strong> ₀指向<strong class="ig hi"> H₁.的矢量</strong>我们现在剩下的任务是确定利润率<em class="ll"> m. </em></p><p id="ea81" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">回想一下，对于<strong class="ig hi">中的任意向量，H₁ </strong>满足<strong class="ig hi"> w.x + b =1，</strong>对于<strong class="ig hi">中的向量<strong class="ig hi">x</strong>₁</strong></p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es lz"><img src="../Images/15862b499c8555325953a4c8717e7656.png" data-original-src="https://miro.medium.com/v2/resize:fit:306/format:webp/1*UkE6EcotcF7HiL0oMEhZzw.png"/></div></div></figure><p id="5cbf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">由于我们在<strong class="ig hi"> H₁ </strong>中将<strong class="ig hi"> k </strong>构造为从<strong class="ig hi"> x </strong> ₀指向<strong class="ig hi"> x </strong> ₁的向量，我们可以应用向量加法<strong class="ig hi"> x </strong> ₁= <strong class="ig hi"> x </strong> ₀+k，因此</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es ma"><img src="../Images/6d1f2cd435f34d728b07e939c491cfc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:450/format:webp/1*ESqnZ4K4yQu0Dm5Q5A7cow.png"/></div></figure><p id="5e34" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es mb"><img src="../Images/727e1e3bcc3f51f9e7dbb960beb03707.png" data-original-src="https://miro.medium.com/v2/resize:fit:510/format:webp/1*9XiViyyZNp7LGXYEQqeYBA.png"/></div></figure><p id="45a0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">由于<strong class="ig hi"> x </strong> ₀在<strong class="ig hi"> H₀，</strong>那么<strong class="ig hi"> H₀ = w </strong>。<strong class="ig hi"> x </strong> ₀ + 1 = -1</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es mc"><img src="../Images/520f9eef829015b62e633027adab638c.png" data-original-src="https://miro.medium.com/v2/resize:fit:348/format:webp/1*thIbtrZn_XqS9bAOUIgbrg.png"/></div></figure><p id="e9aa" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">就这样，我们找到了一种计算余量<em class="ll">m</em>的方法，从这个结果我们知道，余量只取决于矢量<strong class="ig hi"> w </strong>的大小。</p><p id="30a9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">根据我们的目标，找到最佳超平面等于最大化余量，这等于最小化向量的大小<strong class="ig hi"> w. </strong>连同约束，让我们将我们的问题重写为</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es md"><img src="../Images/2e88e36f12281ba06eccc49352a24bec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/format:webp/1*u0PY3DD1K688rzlo_ZXWpQ.png"/></div></figure><p id="4237" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在我们的问题变成了优化问题，这意味着我们需要找到某些参数来给出<strong class="ig hi"> w </strong>的最小值。由于优化问题经常涉及导数，因此通常将我们的问题改写为</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es me"><img src="../Images/008904d3ac929e83fccebc3b2c4994bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1064/format:webp/1*U0cE1wrjEQU146tnd1JkbQ.png"/></div></figure><h2 id="2ebc" class="ka kb hh bd kc kd ke kf kg kh ki kj kk ip kl km kn it ko kp kq ix kr ks kt ku bi translated">拉格朗日乘数</h2><p id="7174" class="pw-post-body-paragraph ie if hh ig b ih kv ij ik il kw in io ip kx ir is it ky iv iw ix kz iz ja jb ha bi translated">数学家约瑟夫·路易斯·拉格朗日发明的拉格朗日乘子是一种寻找受约束函数的局部最大值和最小值的技术。假设我们有一个优化问题</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es mf"><img src="../Images/2b69181b08904734f6abd85a36692895.png" data-original-src="https://miro.medium.com/v2/resize:fit:766/format:webp/1*D9BVa9b0rPHzX87rmanKXg.png"/></div></div></figure><p id="abd9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当<em class="ll"> f </em>的斜率与<em class="ll"> g </em>的斜率同向时，f 的最小值出现</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es mg"><img src="../Images/06570f0ed4197124d14af29340a1d3c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:368/format:webp/1*RJ5gKL5Qb84H5qZQTGlatw.png"/></div></figure><p id="ed18" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，为了找到约束条件<em class="ll"> g下<em class="ll"> f </em>的最小值，我们需要求解</em></p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es mh"><img src="../Images/b8890e77dcc2bb385f0a7148a6299a09.png" data-original-src="https://miro.medium.com/v2/resize:fit:456/format:webp/1*q6XX7Y8euDZuENW_QIykbg.png"/></div></figure><p id="9ef7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">常数λ，称为<strong class="ig hi">拉格朗日乘数。</strong></p><p id="a71f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">拉格朗日乘数法概括为三个步骤</p><ol class=""><li id="e7fc" class="mi mj hh ig b ih ii il im ip mk it ml ix mm jb mn mo mp mq bi translated">定义拉格朗日函数<em class="ll"> L </em></li></ol><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es mr"><img src="../Images/f9781b8d670264e26565a141bc67be3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/format:webp/1*7VEsf3bBHZ1CvueUNyqkNQ.png"/></div></figure><p id="25c6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">2.求拉格朗日函数的梯度</p><p id="2c11" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">3.求解</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es ms"><img src="../Images/b8bd9f4e6a2a58795899063379832abd.png" data-original-src="https://miro.medium.com/v2/resize:fit:282/format:webp/1*8oDhPlK1rJ26oNYuDt2KOA.png"/></div></figure><p id="9a41" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，对于支持向量机优化问题，我们已经定义了</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es mt"><img src="../Images/b2977f6fc0a28b322d480fe22f046b02.png" data-original-src="https://miro.medium.com/v2/resize:fit:324/format:webp/1*qb-6c81M7Cq8Mo3zmCXj-Q.png"/></div></figure><p id="d70a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">和<em class="ll"> n </em>约束</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es mu"><img src="../Images/2042f87bdae7f1d71187e824cbe61c1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/format:webp/1*beOdX_CUXa5eu758z8qsUQ.png"/></div></figure><p id="7abd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，SVM优化的拉格朗日函数为</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es lh"><img src="../Images/ae6d28328314187fb8096c996d54702d.png" data-original-src="https://miro.medium.com/v2/resize:fit:708/format:webp/1*pbpFiKLvq8t9tmdCJ1QCNw.png"/></div></figure><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es mv"><img src="../Images/5607a53e6b697fda8c73a56aadab85af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1020/format:webp/1*skjlVVNKWZPjnFLhos_zFQ.png"/></div></figure><p id="eca0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们现在剩下的任务是找到<strong class="ig hi"> w </strong>，b和λ的值，它们反过来给我们提供了最佳超平面。</p><h2 id="d495" class="ka kb hh bd kc kd ke kf kg kh ki kj kk ip kl km kn it ko kp kq ix kr ks kt ku bi translated">沃尔夫对偶问题</h2><p id="6bec" class="pw-post-body-paragraph ie if hh ig b ih kv ij ik il kw in io ip kx ir is it ky iv iw ix kz iz ja jb ha bi translated">让我们继续解决SVM优化的步骤。计算拉格朗日函数的梯度</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es mw"><img src="../Images/8259b783f7f1cdb3e22e644a2664d7d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:718/format:webp/1*ez5fpO27EhGYWJvD71FNEA.png"/></div></figure><p id="c580" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们有</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es mx"><img src="../Images/754f14eb4bfcda08d52dc2f76e8cf4cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:322/format:webp/1*KDA-_4EUn_sWOnFZ39720w.png"/></div></figure><p id="7d8c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">从上面的结果，我们只能找到最佳值的<strong class="ig hi"> w </strong>，这是依赖于λ，所以我们需要找到λ的最佳值。而寻找b的最优值需要<strong class="ig hi"> w </strong>和λ。</p><p id="49f6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们的工作结果对解决最优化问题仍然没有帮助，我们仍然需要找到所有的最优值。我们公式化的优化被称为<strong class="ig hi">原始问题。</strong>如果其没有给我们结果，我们应该转移到<strong class="ig hi">沃尔夫</strong>T10】对偶问题，从而保证了结果。请记住，如果我们转移到对偶问题，我们改变公式从最小化到最大化的功能。现在我们优化问题被写成</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es my"><img src="../Images/67ebee0a5411e46902e6372e70d96049.png" data-original-src="https://miro.medium.com/v2/resize:fit:810/format:webp/1*v88C3neE4Ttz5WjUXXXGlQ.png"/></div></figure><p id="2b99" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">用<strong class="ig hi"> w </strong>是从脑瓜子问题中发现的。现在让我们重写对偶形式的拉格朗日函数</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es mz"><img src="../Images/8863931176641dad04536e89685f11d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Goy5Y6zGF9G0xtWoZQGu4A.png"/></div></div></figure><p id="1443" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">通过将大量代数应用于上述方程，我们得到</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es na"><img src="../Images/f3f3bc5126158b1e6dd7db46d658e72c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/format:webp/1*vW17vtGNN4eyl6E_QNVdKA.png"/></div></figure><p id="1559" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">从最初的问题，我们得到</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es nb"><img src="../Images/4bc72d777b842458c0cc38da81fdb895.png" data-original-src="https://miro.medium.com/v2/resize:fit:568/format:webp/1*tjR25w-0gDajtYfPUsbu-w.png"/></div></figure><p id="6761" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后我们可以写作</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es nc"><img src="../Images/694e7107adadcae2915fc062b851e32d.png" data-original-src="https://miro.medium.com/v2/resize:fit:836/format:webp/1*1K2_o1EP7iFUiXVODfpU7A.png"/></div></figure><p id="2a75" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在我们的优化问题是以仅依赖于λ的对偶拉格朗日函数的形式</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es nd"><img src="../Images/8e585912b8cb0167c9441e7e07e3c123.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZxrTEAZCg7W6NnPtKmppyA.png"/></div></div></figure><p id="5e2d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">由此，我们可以使用任何可用的数值库来求解λ。</p><p id="2a38" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一旦最优λ被求解，我们将回到原始问题来寻找最优的<strong class="ig hi"> w </strong>和b</p><p id="f4d7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">正如我们已经发现的<strong class="ig hi"> w </strong></p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es mx"><img src="../Images/754f14eb4bfcda08d52dc2f76e8cf4cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:322/format:webp/1*KDA-_4EUn_sWOnFZ39720w.png"/></div></figure><p id="65b8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用<strong class="ig hi"> w </strong>和λ，我们计算b如下:</p><p id="06e7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">超平面方程</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es ne"><img src="../Images/2416949467da1bcf113c846be285067c.png" data-original-src="https://miro.medium.com/v2/resize:fit:480/format:webp/1*yfUDCH4S24JzTwjWYT5O1Q.png"/></div></figure><p id="dcd5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们得到的替代物</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es nf"><img src="../Images/dbd568a616250aa11290e76e51c7eb65.png" data-original-src="https://miro.medium.com/v2/resize:fit:376/format:webp/1*t-5bH03RD5YpzQFruJCjIQ.png"/></div></figure><p id="5974" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对于稳定的数值解，我们使用支持向量的平均数</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es ng"><img src="../Images/9250c3ce89223025c4d0107118d40b9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:536/format:webp/1*PcofEmEA4KdFEA8jNbucuQ.png"/></div></figure><p id="045a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">其中S是支持向量的数量。</p><p id="98c9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">至于现在有了w 和b<strong class="ig hi">的值，从而构建了最优超平面。现在预测特征向量xi的类别由下式给出</strong></p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es mb"><img src="../Images/aded06a3aa1ec21cbf2875e1ec80a09b.png" data-original-src="https://miro.medium.com/v2/resize:fit:510/format:webp/1*_3TOYEnoLveHM4t3f-UmgQ.png"/></div></figure><p id="5815" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用对偶公式，仅使用支持向量来计算</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es nh"><img src="../Images/0964e04fac4edbf709228af5a6b482d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*LLHMYIQFko3xhbnKxslVtA.png"/></div></figure><h2 id="d62e" class="ka kb hh bd kc kd ke kf kg kh ki kj kk ip kl km kn it ko kp kq ix kr ks kt ku bi translated">软利润</h2><p id="d0c7" class="pw-post-body-paragraph ie if hh ig b ih kv ij ik il kw in io ip kx ir is it ky iv iw ix kz iz ja jb ha bi translated">到目前为止，我们已经讨论了关于<strong class="ig hi">硬边界</strong> SVM，它假设数据集是线性可分的，在现实世界中，数据经常有噪声。为了克服这一点，我们需要修改SVM算法，所以它会犯一些错误，因为让我们通过添加一个变量来修改我们的约束</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es ni"><img src="../Images/47d77668d9365d1ca0747f60661a65fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:458/format:webp/1*Ueyi372FHPRopcmI9PS4hA.png"/></div></figure><p id="bb00" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最优化问题现在的形式是</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es nj"><img src="../Images/9fbbf52c6b3d962e30db18d00e6f703a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1278/format:webp/1*Y0DHn24wq7gaI9H-GF1MnQ.png"/></div></figure><p id="ed1c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">其中C是起控制ζ的重要性作用的参数，注意，当C -&gt; 0时，优化问题又回到硬边界。软裕度的Wolfe对偶问题与硬裕度具有相同的形式，唯一不同的是我们将λ的值限制在0≤λ≤C的范围内。</p><h2 id="eb74" class="ka kb hh bd kc kd ke kf kg kh ki kj kk ip kl km kn it ko kp kq ix kr ks kt ku bi translated">内核技巧</h2><p id="c1e8" class="pw-post-body-paragraph ie if hh ig b ih kv ij ik il kw in io ip kx ir is it ky iv iw ix kz iz ja jb ha bi translated">在现实世界中，有时数据是不可分的，我们希望使用支持向量机对其进行分类。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es nk"><img src="../Images/4bcbd1c49ecd207efcc3ffce9bde879f.png" data-original-src="https://miro.medium.com/v2/resize:fit:770/format:webp/1*_U2bFGojuBG_nSwDu-TlFw.png"/></div></figure><p id="8b23" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">从上图中我们可以看到，我们有一个不可分离的二维要素数据集，如果我们向数据集添加额外的维度，那么它将是可分离的，如下图所示</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es nl"><img src="../Images/5466289cd11ee22f41295bcb2c8ddcc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dwgwLm4BNQrwm1iSOFybyw.jpeg"/></div></div></figure><p id="6cdc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，数据是可分离的，这意味着我们可以绘制一个分离数据的超平面，在这种情况下是三维空间中的二维平面。</p><p id="1bfb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">回忆一下SVM的沃尔夫对偶拉格朗日函数</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es nc"><img src="../Images/694e7107adadcae2915fc062b851e32d.png" data-original-src="https://miro.medium.com/v2/resize:fit:836/format:webp/1*1K2_o1EP7iFUiXVODfpU7A.png"/></div></figure><p id="8858" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们注意到函数中x的点积，我们希望在三维空间中执行点积，因为在二维空间中数据集是不可分的。这种在另一个空间执行点积的技术被称为<strong class="ig hi">内核技巧，</strong>的定义为</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es nm"><img src="../Images/b0f50ab2e01e5db524b1c611738c533d.png" data-original-src="https://miro.medium.com/v2/resize:fit:424/format:webp/1*o9vNIPbsHPEES64J521uMw.png"/></div></figure><p id="09aa" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，我们可以把沃尔夫对偶拉格朗日函数写成</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es nn"><img src="../Images/9c62c0fd36227992db2847891e855cb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:958/format:webp/1*W6W7Xa8ez_X3M6taO4qeUg.png"/></div></figure><p id="8bd9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">也为假设函数预测类</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es my"><img src="../Images/849585094d818725f0bc977317cbe26d.png" data-original-src="https://miro.medium.com/v2/resize:fit:810/format:webp/1*0A0EkaicUMoVvXi2jcKgtg.png"/></div></figure><p id="d8d9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">内核有很多种。诸如</p><h2 id="5a8e" class="ka kb hh bd kc kd ke kf kg kh ki kj kk ip kl km kn it ko kp kq ix kr ks kt ku bi translated">线性核</h2><p id="3db8" class="pw-post-body-paragraph ie if hh ig b ih kv ij ik il kw in io ip kx ir is it ky iv iw ix kz iz ja jb ha bi translated">这是最基本的内核，写成</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es no"><img src="../Images/21ca7605147c4b3511b02d39bc3eebdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:226/format:webp/1*er3LzZP59Og8Iw5FCSIC2w.png"/></div></figure><h2 id="87e5" class="ka kb hh bd kc kd ke kf kg kh ki kj kk ip kl km kn it ko kp kq ix kr ks kt ku bi translated">多项式核。</h2><p id="92ec" class="pw-post-body-paragraph ie if hh ig b ih kv ij ik il kw in io ip kx ir is it ky iv iw ix kz iz ja jb ha bi translated">当数据的分布近似符合<em class="ll"> d </em>次多项式时使用。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es np"><img src="../Images/2bba0cb47485d42a5c9ad3e54cb0d739.png" data-original-src="https://miro.medium.com/v2/resize:fit:364/format:webp/1*2hSKzHeWGNVZOFjeAHdmcA.png"/></div></figure><h2 id="a115" class="ka kb hh bd kc kd ke kf kg kh ki kj kk ip kl km kn it ko kp kq ix kr ks kt ku bi translated">径向基函数(RBF)核</h2><p id="cc7f" class="pw-post-body-paragraph ie if hh ig b ih kv ij ik il kw in io ip kx ir is it ky iv iw ix kz iz ja jb ha bi translated">这是SVM最受欢迎的果仁之一。当没有关于数据的先验知识时使用它。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es nq"><img src="../Images/5cbc6ebd8682b051fd4727cba0c0516a.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/format:webp/1*UByFy4Y46moropr8p6hQTA.png"/></div></figure><h2 id="e3d9" class="ka kb hh bd kc kd ke kf kg kh ki kj kk ip kl km kn it ko kp kq ix kr ks kt ku bi translated">履行</h2><p id="1b6f" class="pw-post-body-paragraph ie if hh ig b ih kv ij ik il kw in io ip kx ir is it ky iv iw ix kz iz ja jb ha bi translated">我们将使用以下内容:</p><ul class=""><li id="6f3b" class="mi mj hh ig b ih ii il im ip mk it ml ix mm jb nr mo mp mq bi translated"><a class="ae js" href="https://scikit-learn.org/stable/index.html" rel="noopener ugc nofollow" target="_blank"> Scikit-learn m </a>模块，用于将数据拆分为<a class="ae js" href="https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.train_test_split.html?highlight=train_test_split#sklearn.model_selection.train_test_split" rel="noopener ugc nofollow" target="_blank">训练测试</a>样本，构建SVM模型，以及<a class="ae js" href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.classification_report.html?highlight=classification_report#sklearn.metrics.classification_report" rel="noopener ugc nofollow" target="_blank">模型评估</a></li><li id="4c1b" class="mi mj hh ig b ih ns il nt ip nu it nv ix nw jb nr mo mp mq bi translated">乳腺癌数据集，由Scikit-learn提供</li><li id="8b41" class="mi mj hh ig b ih ns il nt ip nu it nv ix nw jb nr mo mp mq bi translated"><a class="ae js" href="https://numpy.org/" rel="noopener ugc nofollow" target="_blank"> Numpy </a>用于数据操作</li></ul><p id="c739" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们导入所有的库</p><pre class="jd je jf jg fd nx lf ny nz aw oa bi"><span id="4bda" class="ka kb hh lf b fi ob oc l od oe">from sklearn.model_selection import train_test_split</span><span id="5192" class="ka kb hh lf b fi of oc l od oe">from sklearn import datasets</span><span id="1e1c" class="ka kb hh lf b fi of oc l od oe">from sklearn.svm import SVC</span><span id="9249" class="ka kb hh lf b fi of oc l od oe">from sklearn.metrics import accuracy_score</span></pre><p id="2eb1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">加载数据集</p><pre class="jd je jf jg fd nx lf ny nz aw oa bi"><span id="3d70" class="ka kb hh lf b fi ob oc l od oe">X,y = datasets.load_breast_cancer(return_X_y=True)</span></pre><p id="4699" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">拆分为训练和测试数据集</p><pre class="jd je jf jg fd nx lf ny nz aw oa bi"><span id="3457" class="ka kb hh lf b fi ob oc l od oe">X_train, X_test, y_train, y_test = train_test_split(<br/>        X, y, test_size=0.2, random_state=1234<br/>    )</span></pre><p id="8ec3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">创建SVM模式</p><pre class="jd je jf jg fd nx lf ny nz aw oa bi"><span id="63ba" class="ka kb hh lf b fi ob oc l od oe">clf = SVC(kernel = 'linear', random_state = 1234)</span></pre><p id="7880" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">拟合和预测输出</p><pre class="jd je jf jg fd nx lf ny nz aw oa bi"><span id="75e4" class="ka kb hh lf b fi ob oc l od oe">clf.fit(X_train,y_train)<br/>predictions=clf.predict(X_test)</span></pre><p id="9a95" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们看看模型的准确性</p><pre class="jd je jf jg fd nx lf ny nz aw oa bi"><span id="1117" class="ka kb hh lf b fi ob oc l od oe">from sklearn.model_selection import cross_val_score</span><span id="79ca" class="ka kb hh lf b fi of oc l od oe">accuracies = cross_val_score(estimator = clf, X = X_train, y = y_train, cv = 10)</span><span id="3524" class="ka kb hh lf b fi of oc l od oe">print("Accuracy: {:.2f} %".format(accuracies.mean()*100))</span></pre><p id="b294" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">得分96.94%。</p><p id="28b7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们看看当使用混淆矩阵预测测试数据集时，模型有多好</p><pre class="jd je jf jg fd nx lf ny nz aw oa bi"><span id="4385" class="ka kb hh lf b fi ob oc l od oe">from sklearn.metrics import confusion_matrix confusion_matrix(y_test,predictions)</span></pre><p id="a65a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">混淆矩阵是</p><pre class="jd je jf jg fd nx lf ny nz aw oa bi"><span id="56b3" class="ka kb hh lf b fi ob oc l od oe">array([[39,  6],  <br/>      [ 0, 69]])</span></pre><p id="064b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这表明39个预测为真正的恶性，69个预测为真正的良性。但是该模型未能预测6个恶性肿瘤为良性肿瘤</p><h1 id="7606" class="og kb hh bd kc oh oi oj kg ok ol om kk on oo op kn oq or os kq ot ou ov kt ow bi translated">结论</h1><p id="cfb7" class="pw-post-body-paragraph ie if hh ig b ih kv ij ik il kw in io ip kx ir is it ky iv iw ix kz iz ja jb ha bi translated">在本文中，我们了解到:</p><ol class=""><li id="e306" class="mi mj hh ig b ih ii il im ip mk it ml ix mm jb mn mo mp mq bi translated">SVM算法中超平面和边缘的概念</li><li id="f776" class="mi mj hh ig b ih ns il nt ip nu it nv ix nw jb mn mo mp mq bi translated">使用SVM使用的拉格朗日定理的约束优化</li><li id="368e" class="mi mj hh ig b ih ns il nt ip nu it nv ix nw jb mn mo mp mq bi translated">实现SVM算法。</li></ol><div class="ox oy ez fb oz pa"><a rel="noopener follow" target="_blank" href="/mlearning-ai/mlearning-ai-submission-suggestions-b51e2b130bfb"><div class="pb ab dw"><div class="pc ab pd cl cj pe"><h2 class="bd hi fi z dy pf ea eb pg ed ef hg bi translated">Mlearning.ai提交建议</h2><div class="ph l"><h3 class="bd b fi z dy pf ea eb pg ed ef dx translated">如何成为Mlearning.ai上的作家</h3></div><div class="pi l"><p class="bd b fp z dy pf ea eb pg ed ef dx translated">medium.com</p></div></div><div class="pj l"><div class="pk l pl pm pn pj po jm pa"/></div></div></a></div></div></div>    
</body>
</html>