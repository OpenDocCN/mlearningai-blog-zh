<html>
<head>
<title>IRIS Segmentation Mediapipe Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">虹膜分割媒体管道Python</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/iris-segmentation-mediapipe-python-a4deb711aae3?source=collection_archive---------1-----------------------#2022-01-23">https://medium.com/mlearning-ai/iris-segmentation-mediapipe-python-a4deb711aae3?source=collection_archive---------1-----------------------#2022-01-23</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex ie if ig ih"><div class="bz dy l di"><div class="ii ij l"/></div><figcaption class="ik il et er es im in bd b be z dx">Demo Video</figcaption></figure><blockquote class="io ip iq"><p id="026e" class="ir is it iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp ha bi translated">让我们看看虹膜分割，嗯，这不是一个分割，老实说，你只能从Mediapipe获得虹膜的四个标志，但我们也可以将这些标志转化为分割。</p></blockquote><h2 id="26dc" class="jq jr hh bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">代码库:</h2><p id="a3ba" class="pw-post-body-paragraph ir is hh iu b iv ko ix iy iz kp jb jc kb kq jf jg kf kr jj jk kj ks jn jo jp ha bi translated">你会在<a class="ae kt" href="https://github.com/Asadullah-Dal17/iris-Segmentation-mediapipe-python" rel="noopener ugc nofollow" target="_blank"> Github库</a>上找到所有的源代码，这里我会解释一些代码片段。</p><h2 id="4249" class="jq jr hh bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">要求:</h2><p id="c663" class="pw-post-body-paragraph ir is hh iu b iv ko ix iy iz kp jb jc kb kq jf jg kf kr jj jk kj ks jn jo jp ha bi translated">你需要python，安装在你的机器上，另一个要求是OpenCV和NumPy，但是它们和Mediapipe打包在一起，当你通过PIP(python包管理器)安装时，这是一个要求，所以不需要手动安装。</p><h2 id="34d1" class="jq jr hh bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">装置</h2><p id="a657" class="pw-post-body-paragraph ir is hh iu b iv ko ix iy iz kp jb jc kb kq jf jg kf kr jj jk kj ks jn jo jp ha bi translated">如果您已经安装了Mediapipe及其低于(0.8.9.1)的版本，请升级到最新版本</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="5324" class="jq jr hh kz b fi ld le l lf lg">pip install --upgrade mediapipe </span></pre><h2 id="5ecc" class="jq jr hh bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">面部标志</h2><p id="f064" class="pw-post-body-paragraph ir is hh iu b iv ko ix iy iz kp jb jc kb kq jf jg kf kr jj jk kj ks jn jo jp ha bi translated">Mediapipe提供了478个面部标志，你可以找到更多关于<strong class="iu hi">面部网格</strong>的细节，这里我们只关注虹膜标志，因为我们要在NumPy数组中存储所有标志，所以你可以访问它们，绕过索引列表。以下是使用<a class="ae kt" href="https://github.com/google/mediapipe/blob/master/mediapipe/modules/face_geometry/data/canonical_face_model_uv_visualization.png" rel="noopener ugc nofollow" target="_blank">面部网格点的地图</a>提取的虹膜标志列表</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="7754" class="jq jr hh kz b fi ld le l lf lg">LEFT_IRIS = [474,475, 476, 477]<br/>RIGHT_IRIS = [469, 470, 471, 472]</span></pre><p id="46f4" class="pw-post-body-paragraph ir is hh iu b iv iw ix iy iz ja jb jc kb je jf jg kf ji jj jk kj jm jn jo jp ha bi translated"><strong class="iu hi">对于眼睛(指数)</strong></p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="85e7" class="jq jr hh kz b fi ld le l lf lg"># Left eye indices list<br/>LEFT_EYE =[ 362, 382, 381, 380, 374, 373, 390, 249, 263, 466, 388, 387, 386, 385,384, 398 ]</span><span id="d8dd" class="jq jr hh kz b fi lh le l lf lg"># Right eye indices list<br/>RIGHT_EYE=[ 33, 7, 163, 144, 145, 153, 154, 155, 133, 173, 157, 158, 159, 160, 161 , 246 ]</span></pre><figure class="ku kv kw kx fd ih er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es li"><img src="../Images/f9b9c7921e97b5486ddee216cf10e2ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tbnoVzLabNYU_6gGRBadaA.jpeg"/></div></div><figcaption class="ik il et er es im in bd b be z dx">Eyes Landmarks</figcaption></figure><h1 id="ef61" class="lp jr hh bd js lq lr ls jw lt lu lv ka lw lx ly ke lz ma mb ki mc md me km mf bi translated">编码部分</h1><p id="0af7" class="pw-post-body-paragraph ir is hh iu b iv ko ix iy iz kp jb jc kb kq jf jg kf kr jj jk kj ks jn jo jp ha bi translated">模块导入</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="ca48" class="jq jr hh kz b fi ld le l lf lg">import mediapipe as mp<br/>import cv2 as cv <br/>import numpy as np</span><span id="3f94" class="jq jr hh kz b fi lh le l lf lg">mp_face_mesh = mp.solution.face_mesh</span></pre><h2 id="2dd6" class="jq jr hh bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">模式配置</h2><p id="3343" class="pw-post-body-paragraph ir is hh iu b iv ko ix iy iz kp jb jc kb kq jf jg kf kr jj jk kj ks jn jo jp ha bi translated"><strong class="iu hi"> <em class="it">最大面数</em> </strong>:检测到的面数</p><p id="fe9c" class="pw-post-body-paragraph ir is hh iu b iv iw ix iy iz ja jb jc kb je jf jg kf ji jj jk kj jm jn jo jp ha bi translated"><strong class="iu hi"/></p><p id="6c37" class="pw-post-body-paragraph ir is hh iu b iv iw ix iy iz ja jb jc kb je jf jg kf ji jj jk kj jm jn jo jp ha bi translated"><strong class="iu hi"><em class="it">min _ detection _ confidence</em></strong>:(0.0，1)人脸检测模型的最小检测置信度。</p><p id="e2a9" class="pw-post-body-paragraph ir is hh iu b iv iw ix iy iz ja jb jc kb je jf jg kf ji jj jk kj jm jn jo jp ha bi translated"><strong class="iu hi"><em class="it">min _ tracking _ confidence</em></strong>:(0.0，1)地标追踪的最小置信度，用于地标追踪器模型。</p><p id="45c4" class="pw-post-body-paragraph ir is hh iu b iv iw ix iy iz ja jb jc kb je jf jg kf ji jj jk kj jm jn jo jp ha bi translated">加载人脸网格模型。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="df44" class="jq jr hh kz b fi ld le l lf lg">with mp_face_mesh.FaceMesh(<br/>    max_num_faces=1,<br/>    refine_landmarks=True,<br/>    min_detection_confidence=0.6,<br/>    min_tracking_confidence=0.6<br/>) as face_mesh:</span></pre><p id="00f4" class="pw-post-body-paragraph ir is hh iu b iv iw ix iy iz ja jb jc kb je jf jg kf ji jj jk kj jm jn jo jp ha bi translated">因为我们要实时运行，所以我将图像称为帧，这将是有意义的，在这里，首先需要使用OpenCV中的函数将相机帧翻转为镜像图像，因为Mediapipe需要RGB颜色格式，但OpenCV使用BGR尼特来改变颜色，在这里，<em class="it"> cvtColor </em>函数。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="db21" class="jq jr hh kz b fi ld le l lf lg">frame = cv.flip(frame, 1)<br/>rgb_frame = cv.cvtColor(frame, cv.COLOR_BGR2RGB)</span></pre><p id="13ac" class="pw-post-body-paragraph ir is hh iu b iv iw ix iy iz ja jb jc kb je jf jg kf ji jj jk kj jm jn jo jp ha bi translated">当RGB帧由<em class="it">人脸网格模型</em>处理时，它将返回478个标志，每个检测到的人脸，每个标志都有x、y和z值，每个都有一个值在<strong class="iu hi"> 0到1 </strong>之间，换句话说就是归一化值，然后我们需要乘以相应的缩放比例来获得帧中的像素坐标，</p><p id="1b06" class="pw-post-body-paragraph ir is hh iu b iv iw ix iy iz ja jb jc kb je jf jg kf ji jj jk kj jm jn jo jp ha bi translated">对于<strong class="iu hi"><em class="it">【X】</em></strong>，缩放比例是宽度，<em class="it">【Y】</em>是图像的高度，对于<strong class="iu hi"><em class="it"/></strong>与X，宽度相同</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="95a9" class="jq jr hh kz b fi ld le l lf lg">results = face_mesh.process(rgb_frame)</span><span id="5b3c" class="jq jr hh kz b fi lh le l lf lg">#getting width and height or frame<br/>img_h, img_w = frame.shape[:2]</span></pre><p id="63a8" class="pw-post-body-paragraph ir is hh iu b iv iw ix iy iz ja jb jc kb je jf jg kf ji jj jk kj jm jn jo jp ha bi translated"><strong class="iu hi">遍历地标</strong></p><p id="cd6c" class="pw-post-body-paragraph ir is hh iu b iv iw ix iy iz ja jb jc kb je jf jg kf ji jj jk kj jm jn jo jp ha bi translated">当我们处理RGB帧时，我们将获得每个检测到的人脸及其界标，因此我们从结果变量中访问界标，我们必须存储它们，就像<strong class="iu hi"><em class="it">results . multi _ face _ landmarks</em></strong>这里我们有所有的人脸界标，您可以循环通过它们，因为我已经检测到一个人脸，所以我将在这里提供索引<strong class="iu hi"><em class="it">results . multi _ face _ landmarks[0]，</em> </strong>，其格式如下</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="c4e7" class="jq jr hh kz b fi ld le l lf lg">landmark {<br/>  x: 0.6233813166618347<br/>  y: 0.7154796719551086<br/>  z: -0.0638529509305954<br/>}</span></pre><p id="b5f5" class="pw-post-body-paragraph ir is hh iu b iv iw ix iy iz ja jb jc kb je jf jg kf ji jj jk kj jm jn jo jp ha bi translated">现在你将得到要面对的地标，只需调用<em class="it">results . multi _ face _ landmarks[0]</em><strong class="iu hi"><em class="it">。地标</em> </strong>它要对<strong class="iu hi"><em class="it">【x，y，z】</em></strong>的值进行归一化如果打印出<strong class="iu hi"> <em class="it">类型</em> </strong>你会得到</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="0805" class="jq jr hh kz b fi ld le l lf lg">&lt;class 'google.protobuf.pyext._message.RepeatedCompositeContainer'&gt;</span></pre><p id="c9c8" class="pw-post-body-paragraph ir is hh iu b iv iw ix iy iz ja jb jc kb je jf jg kf ji jj jk kj jm jn jo jp ha bi translated">当你循环通过<strong class="iu hi"><em class="it">results . multi _ face _ landmarks[0]时。地标</em> </strong>每个地标你都会得到x，y，z。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="801f" class="jq jr hh kz b fi ld le l lf lg">[print(p.x, p.y, p.z )for p in results.multi_face_landmarks[0].landmark]</span></pre><p id="0e3a" class="pw-post-body-paragraph ir is hh iu b iv iw ix iy iz ja jb jc kb je jf jg kf ji jj jk kj jm jn jo jp ha bi translated">但是你仍然有规格化的值，所以你需要用适当的缩放比例乘以每个值，你将得到像素坐标，<strong class="iu hi"><em class="it">【x * img _ w，y*img_h，z * img _ w】</em></strong>，但是这里，我们只需要x和y，我将使用NumPy的乘法函数来实现，不要忘记，将它们转换成整数，因为OpenCV接受像素坐标作为int。这是一个简单的一行程序，它为我们完成了工作，end end我已经将所有的界标存储在了NumPy数组中(<strong class="iu hi"> <em class="it"> mesh_points </em> </strong>)，所以绕过索引列表可以更容易地访问</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="90df" class="jq jr hh kz b fi ld le l lf lg">mesh_points=np.array([np.multiply([p.x, p.y], [img_w, img_h]).astype(int) for p in results.multi_face_landmarks[0].landmark])</span></pre><figure class="ku kv kw kx fd ih er es paragraph-image"><div class="er es mg"><img src="../Images/2d89114a2336b231a1a4004c7e032d7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:428/format:webp/1*CZrFKCxn_GTHvJZXNz2-4g.png"/></div><figcaption class="ik il et er es im in bd b be z dx">graph</figcaption></figure><p id="4067" class="pw-post-body-paragraph ir is hh iu b iv iw ix iy iz ja jb jc kb je jf jg kf ji jj jk kj jm jn jo jp ha bi translated">现在我们可以使用OpenCV函数绘制<strong class="iu hi">虹膜</strong>地标，折线，我们已经有了虹膜的索引列表，使用它们来获得虹膜坐标，</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="eced" class="jq jr hh kz b fi ld le l lf lg">cv.polylines(frame, [mesh_points[LEFT_IRIS]], True, (0,255,0), 1, cv.LINE_AA)</span><span id="5287" class="jq jr hh kz b fi lh le l lf lg">cv.polylines(frame, [mesh_points[RIGHT_IRIS]], True, (0,255,0), 1, cv.LINE_AA)</span></pre><p id="492b" class="pw-post-body-paragraph ir is hh iu b iv iw ix iy iz ja jb jc kb je jf jg kf ji jj jk kj jm jn jo jp ha bi translated">它看起来就像这样。</p><figure class="ku kv kw kx fd ih er es paragraph-image"><div class="er es mh"><img src="../Images/f3deeeb7f9bff40b8871b4c46afc25bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/format:webp/1*VkHXIn9U_NrnBtmQfUF0hA.png"/></div><figcaption class="ik il et er es im in bd b be z dx">Irises Landmarks</figcaption></figure><p id="0e55" class="pw-post-body-paragraph ir is hh iu b iv iw ix iy iz ja jb jc kb je jf jg kf ji jj jk kj jm jn jo jp ha bi translated">但是我们可以把这些正方形变成圆形，因为它们的函数OpenCV提供了基于给定点的封闭圆。命名为<strong class="iu hi"><em class="it">mineclosingcircle</em></strong>其中返回的，圆心(x，y)和半径的圆，⚠返回值都是浮点型的，我们必须把它们转换成int。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="d74f" class="jq jr hh kz b fi ld le l lf lg">(l_cx, l_cy), l_radius = cv.minEnclosingCircle(mesh_points[LEFT_IRIS])</span><span id="31a9" class="jq jr hh kz b fi lh le l lf lg">(r_cx, r_cy), r_radius = cv.minEnclosingCircle(mesh_points[RIGHT_IRIS])</span><span id="fea9" class="jq jr hh kz b fi lh le l lf lg"># turn center points into np array <br/>center_left = np.array([l_cx, l_cy], dtype=np.int32)<br/>center_right = np.array([r_cx, r_cy], dtype=np.int32)</span></pre><p id="183e" class="pw-post-body-paragraph ir is hh iu b iv iw ix iy iz ja jb jc kb je jf jg kf ji jj jk kj jm jn jo jp ha bi translated">最后根据<strong class="iu hi"><em class="it">mineclosingcircle</em></strong>函数的返回值绘制圆，通过<strong class="iu hi"> <em class="it"> circle </em> </strong>函数根据圆心(x，y)和半径绘制圆图像</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="6b69" class="jq jr hh kz b fi ld le l lf lg">cv.circle(frame, center_left, int(l_radius), (255,0,255), 2, cv.LINE_AA)<br/>cv.circle(frame, center_right, int(r_radius), (255,0,255), 2, cv.LINE_AA)</span></pre><figure class="ku kv kw kx fd ih er es paragraph-image"><div class="er es mi"><img src="../Images/fa9b310ea2973fae86c30f4df4002d03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1284/format:webp/1*qK0v535jSA6ExCCLG2xkXQ.png"/></div><figcaption class="ik il et er es im in bd b be z dx">Circles draw on Iris</figcaption></figure><p id="600d" class="pw-post-body-paragraph ir is hh iu b iv iw ix iy iz ja jb jc kb je jf jg kf ji jj jk kj jm jn jo jp ha bi translated">最后得到分割蒙版，这很简单，你只需使用NumPy的zeroes函数创建一个空蒙版(图像),具有与框架相同的尺寸，你可以在蒙版上画一个白色的圆圈，你就有了分割蒙版。</p><p id="4d38" class="pw-post-body-paragraph ir is hh iu b iv iw ix iy iz ja jb jc kb je jf jg kf ji jj jk kj jm jn jo jp ha bi translated">使用图像尺寸宽度和框架高度创建遮罩。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="9b9c" class="jq jr hh kz b fi ld le l lf lg">mask = np.zeros((img_h, img_w), dtype=np.uint8)</span></pre><p id="ddc7" class="pw-post-body-paragraph ir is hh iu b iv iw ix iy iz ja jb jc kb je jf jg kf ji jj jk kj jm jn jo jp ha bi translated">在面具上画白色圆圈</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="fc57" class="jq jr hh kz b fi ld le l lf lg">cv.circle(mask, center_left, int(l_radius), (255,255,255), -1, cv.LINE_AA)</span><span id="0fc6" class="jq jr hh kz b fi lh le l lf lg">cv.circle(mask, center_right, int(r_radius), (255,255,255), -1, cv.LINE_AA)<br/></span></pre><figure class="ku kv kw kx fd ih er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es mj"><img src="../Images/c03541d9d416b8281786a2b9e9bd2316.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iHK2p7UnPFKvWu5w759KDQ.png"/></div></div><figcaption class="ik il et er es im in bd b be z dx">results with segmented mask</figcaption></figure><p id="b4d7" class="pw-post-body-paragraph ir is hh iu b iv iw ix iy iz ja jb jc kb je jf jg kf ji jj jk kj jm jn jo jp ha bi translated">因为你有一个虹膜遮罩，你可以用任何颜色的虹膜图像替换它们，以创建不同的Instagram过滤器，或眼控光标(指针)🖱.</p><p id="a899" class="pw-post-body-paragraph ir is hh iu b iv iw ix iy iz ja jb jc kb je jf jg kf ji jj jk kj jm jn jo jp ha bi translated">我在youtube上有一个完整的视频教程，如果你愿意，你也可以去看看，参考链接</p><p id="978d" class="pw-post-body-paragraph ir is hh iu b iv iw ix iy iz ja jb jc kb je jf jg kf ji jj jk kj jm jn jo jp ha bi translated">由于我是一个写作新手，很明显你会发现错误，如果你发现了，请让我知道，我将很乐意修复它们，非常感谢。</p><p id="9009" class="pw-post-body-paragraph ir is hh iu b iv iw ix iy iz ja jb jc kb je jf jg kf ji jj jk kj jm jn jo jp ha bi translated">下面是视频教程:</p><figure class="ku kv kw kx fd ih"><div class="bz dy l di"><div class="ii ij l"/></div></figure><h1 id="682f" class="lp jr hh bd js lq lr ls jw lt lu lv ka lw lx ly ke lz ma mb ki mc md me km mf bi translated">参考</h1><div class="mk ml ez fb mm mn"><a href="https://github.com/Asadullah-Dal17/iris-Segmentation-mediapipe-python" rel="noopener  ugc nofollow" target="_blank"><div class="mo ab dw"><div class="mp ab mq cl cj mr"><h2 class="bd hi fi z dy ms ea eb mt ed ef hg bi translated">GitHub-Asadullah-dal 17/iris-Segmentation-media pipe-python</h2><div class="mu l"><h3 class="bd b fi z dy ms ea eb mt ed ef dx translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="mv l"><p class="bd b fp z dy ms ea eb mt ed ef dx translated">github.com</p></div></div><div class="mw l"><div class="mx l my mz na mw nb ln mn"/></div></div></a></div><div class="mk ml ez fb mm mn"><a href="https://google.github.io/mediapipe/solutions/face_mesh.html" rel="noopener  ugc nofollow" target="_blank"><div class="mo ab dw"><div class="mp ab mq cl cj mr"><h2 class="bd hi fi z dy ms ea eb mt ed ef hg bi translated">面网格</h2><div class="mu l"><h3 class="bd b fi z dy ms ea eb mt ed ef dx translated">MediaPipe面部网格是一个面部几何解决方案，可以实时估计468个3D面部标志，即使在移动…</h3></div><div class="mv l"><p class="bd b fp z dy ms ea eb mt ed ef dx translated">google.github.io</p></div></div><div class="mw l"><div class="nc l my mz na mw nb ln mn"/></div></div></a></div><div class="mk ml ez fb mm mn"><a rel="noopener follow" target="_blank" href="/mlearning-ai/mlearning-ai-submission-suggestions-b51e2b130bfb"><div class="mo ab dw"><div class="mp ab mq cl cj mr"><h2 class="bd hi fi z dy ms ea eb mt ed ef hg bi translated">Mlearning.ai提交建议</h2><div class="mu l"><h3 class="bd b fi z dy ms ea eb mt ed ef dx translated">如何成为Mlearning.ai上的作家</h3></div><div class="mv l"><p class="bd b fp z dy ms ea eb mt ed ef dx translated">medium.com</p></div></div><div class="mw l"><div class="nd l my mz na mw nb ln mn"/></div></div></a></div></div></div>    
</body>
</html>