<html>
<head>
<title>The Star Schema: A Hands-On Approach to Modeling</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">星型模式:建模的实践方法</h1>
<blockquote>原文：<a href="https://medium.com/mlearning-ai/the-star-schema-a-hands-on-approach-to-modeling-fcf9e87edc08?source=collection_archive---------3-----------------------#2021-06-05">https://medium.com/mlearning-ai/the-star-schema-a-hands-on-approach-to-modeling-fcf9e87edc08?source=collection_archive---------3-----------------------#2021-06-05</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/7f30e1d67c80e13040636701ad4f48f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K3XC7rq6J-VfFvimLWy5lQ.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Photo by <a class="ae it" href="https://unsplash.com/@timmossholder?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Tim Mossholder</a> on <a class="ae it" href="https://unsplash.com/s/photos/inspiration?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="0fd6" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">介绍</h2><p id="ea5c" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km ha bi translated">数据建模是一门艺术。它是分析和工程之间的最终交叉点，在这一点上，您同时考虑性能、可扩展性和可伸缩性，以及可能的业务查询的覆盖范围。</p><p id="49b1" class="pw-post-body-paragraph js jt hh ju b jv kn jx jy jz ko kb kc jf kp ke kf jj kq kh ki jn kr kk kl km ha bi translated">我不会为您的公司选择“正确”的数据模型，但是，我会说有许多数据模型可供选择，每种模型都有自己的优缺点，但最终这种选择取决于3个因素:</p><ol class=""><li id="55be" class="ks kt hh ju b jv kn jz ko jf ku jj kv jn kw km kx ky kz la bi translated">源数据(您是否有共享一个键的不同平面文件？或者您的数据是否来自规范化的生产数据库表？)</li><li id="d5f0" class="ks kt hh ju b jv lb jz lc jf ld jj le jn lf km kx ky kz la bi translated">您的分析/数据工程师的技能组合——星型模式涉及的工作比广泛的非规范化表要详细得多。</li><li id="ea53" class="ks kt hh ju b jv lb jz lc jf ld jj le jn lf km kx ky kz la bi translated">商业用户。如果他们不采用数据模型，什么都不重要。如果您的数据模型导致长时间运行的查询、不一致的数据，或者对于日常使用来说过于复杂/难以承受，就会发生这种情况。</li></ol><h2 id="e2a3" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">搭建舞台</h2><p id="ed9f" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km ha bi translated">先说几点。</p><ol class=""><li id="f8e7" class="ks kt hh ju b jv kn jz ko jf ku jj kv jn kw km kx ky kz la bi translated">我们是一家虚构的股票市场交易公司的数据团队成员，该公司需要对其订单数据进行深入分析。在分析了我们的源数据和业务需求之后，团队决定将订单数据建模为星型模式是最佳选择。</li><li id="1f3e" class="ks kt hh ju b jv lb jz lc jf ld jj le jn lf km kx ky kz la bi translated">我们从后端团队接收数据导出。这种转移的方式并不重要，因为我们将在项目被装载到我们的仓库时开始我们的项目。原始数据将被规范化，由三个表组成——用户、订单和符号。</li><li id="fd96" class="ks kt hh ju b jv lb jz lc jf ld jj le jn lf km kx ky kz la bi translated">Google的BigQuery是我们的数据仓库(您可以使用任何列数据仓库或RDBMS来跟进)。</li></ol><p id="328c" class="pw-post-body-paragraph js jt hh ju b jv kn jx jy jz ko kb kc jf kp ke kf jj kq kh ki jn kr kk kl km ha bi translated"><strong class="ju hi">源数据</strong></p><p id="fa81" class="pw-post-body-paragraph js jt hh ju b jv kn jx jy jz ko kb kc jf kp ke kf jj kq kh ki jn kr kk kl km ha bi translated">我在这里保持事情简单，但是对于任何不熟悉交易世界的人，让我们详细地看一下每张表。</p><p id="572b" class="pw-post-body-paragraph js jt hh ju b jv kn jx jy jz ko kb kc jf kp ke kf jj kq kh ki jn kr kk kl km ha bi translated">Users —这只是一个为每个用户存储一条记录的表。用户是唯一的，包含一些额外的信息，如城市、州等。</p><p id="c2e4" class="pw-post-body-paragraph js jt hh ju b jv kn jx jy jz ko kb kc jf kp ke kf jj kq kh ki jn kr kk kl km ha bi translated">订单—当用户想要进行交易时，他们首先必须下订单。这增加了模型的复杂性，因为订单的状态会随着时间的推移而变化。比如你可能今天下单买100股特斯拉，明天取消。</p><p id="747d" class="pw-post-body-paragraph js jt hh ju b jv kn jx jy jz ko kb kc jf kp ke kf jj kq kh ki jn kr kk kl km ha bi translated">符号—该表存储了我们虚构的贸易公司中所有可交易的符号。在现实世界中，这个表的条目将包括像Apple、Tesla等公司。我也包括了一些额外的信息，只是为了有更多的数据。</p><h2 id="d8f4" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">*所有数据都是随机生成的，并非基于任何真实情况。用户数据是使用Python Faker库创建的，所以虽然看起来这是真实的人的数据，但实际上不是。我将在文章末尾包含用于创建这些表的脚本。</h2><p id="7b53" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km ha bi translated">为了帮助可视化表之间的关系，让我们来看一个ER图:</p><figure class="lh li lj lk fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lg"><img src="../Images/d47ddff9082601b63cefb525363e3424.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TqPrmipqo5STVUsxQYgvNQ.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">ER Diagram for Backend Tables</figcaption></figure><p id="daad" class="pw-post-body-paragraph js jt hh ju b jv kn jx jy jz ko kb kc jf kp ke kf jj kq kh ki jn kr kk kl km ha bi translated">记住，这不是我们的分析模型。为操作使用而优化的数据建模与用于分析的数据建模非常不同。将前者转化为后者，是数据和分析工程师存在的原因之一。</p><h2 id="b060" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">将原始数据加载到BQ</h2><p id="f276" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km ha bi translated">您可以自由地使用任何数据库系统，但是请记住，像BigQuery、Redshift和Snowflake这样的云数据仓库不是免费的。如果你想免费跟进，请建立一个开源的RDBMS，如PostgreSQL或MySQL。不同引擎的方言略有不同，但任何语法问题都可以通过快速的谷歌搜索得到解决。</p><p id="9bc0" class="pw-post-body-paragraph js jt hh ju b jv kn jx jy jz ko kb kc jf kp ke kf jj kq kh ki jn kr kk kl km ha bi translated">第一步是确保从我的存储库中获取代表我们的表的三个CSV文件(您可以将repo克隆到您的本地机器并从那里获取文件)。在数据库中创建相应的表。在我的例子中，我创建了一个raw_hands_on_star_schema数据集(BQ版本的模式),其中包含我的四个表。</p><figure class="lh li lj lk fd ii er es paragraph-image"><div class="er es ll"><img src="../Images/dfd0d294d13fb22815483cc66b2c6aab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1136/format:webp/1*bUEWDBVWbRm86nGNAxJJyQ.png"/></div><figcaption class="ip iq et er es ir is bd b be z dx">Raw Tables in BigQuery</figcaption></figure><p id="9a35" class="pw-post-body-paragraph js jt hh ju b jv kn jx jy jz ko kb kc jf kp ke kf jj kq kh ki jn kr kk kl km ha bi translated">BigQuery使得通过其UI加载数据变得非常容易，但是，如果您使用PostgreSQL之类的东西，您可能需要执行一些CREATE TABLE和COPY命令。以用户表为例，DDL应该如下所示:</p><pre class="lh li lj lk fd lm ln lo lp aw lq bi"><span id="af63" class="iu iv hh ln b fi lr ls l lt lu">CREATE TABLE <strong class="ln hi">users</strong> (<br/>    user_id INTEGER,<br/>    first_name <strong class="ln hi">VARCHAR</strong>(155),<br/>    last_name <strong class="ln hi">VARCHAR</strong>(155),<br/>    email <strong class="ln hi">VARCHAR</strong>(155),<br/>    city <strong class="ln hi">VARCHAR</strong>(155),<br/>    state <strong class="ln hi">VARCHAR</strong>(155),<br/>    date_joined DATE<br/>);</span></pre><p id="5b63" class="pw-post-body-paragraph js jt hh ju b jv kn jx jy jz ko kb kc jf kp ke kf jj kq kh ki jn kr kk kl km ha bi translated">虽然复制命令看起来像这样:</p><pre class="lh li lj lk fd lm ln lo lp aw lq bi"><span id="6ebf" class="iu iv hh ln b fi lr ls l lt lu">COPY users<br/>FROM 'path/to/local/file/users.csv'<br/>DELIMITER ','<br/>CSV HEADER;</span></pre><p id="b6a7" class="pw-post-body-paragraph js jt hh ju b jv kn jx jy jz ko kb kc jf kp ke kf jj kq kh ki jn kr kk kl km ha bi translated">将“path/to/local/file/users.csv”更改为您下载实际文件的目录。这两个命令都可以在PostgreSQL中使用，但是如果您使用的是另一个关系数据库，可能需要稍微调整一下。</p><p id="ddde" class="pw-post-body-paragraph js jt hh ju b jv kn jx jy jz ko kb kc jf kp ke kf jj kq kh ki jn kr kk kl km ha bi translated">其余表的DDL包含在我的Github存储库中的ddl.sql文件中。</p><h2 id="388f" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">维度设计流程</h2><p id="7e06" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km ha bi translated">在这个阶段，我们需要做出四个决定。</p><ol class=""><li id="2138" class="ks kt hh ju b jv kn jz ko jf ku jj kv jn kw km kx ky kz la bi translated">选择业务流程。</li><li id="582a" class="ks kt hh ju b jv lb jz lc jf ld jj le jn lf km kx ky kz la bi translated">申报粮食。</li><li id="b71e" class="ks kt hh ju b jv lb jz lc jf ld jj le jn lf km kx ky kz la bi translated">确定维度。</li><li id="3bec" class="ks kt hh ju b jv lb jz lc jf ld jj le jn lf km kx ky kz la bi translated">辨别事实。</li></ol><p id="e3cb" class="pw-post-body-paragraph js jt hh ju b jv kn jx jy jz ko kb kc jf kp ke kf jj kq kh ki jn kr kk kl km ha bi translated">这实际上是教科书式的Kimball(实际上，转到数据仓库工具包的第38页)。</p><p id="cfeb" class="pw-post-body-paragraph js jt hh ju b jv kn jx jy jz ko kb kc jf kp ke kf jj kq kh ki jn kr kk kl km ha bi translated">我们项目中的业务流程是用户下的订单。快速浏览一下原始订单表，我们看到两个数字列——价格和数量——从中我们可以生成业务的关键指标。这些将是我们最终事实表中的事实/衡量标准。</p><p id="06d2" class="pw-post-body-paragraph js jt hh ju b jv kn jx jy jz ko kb kc jf kp ke kf jj kq kh ki jn kr kk kl km ha bi translated">既然我们已经清楚地定义了我们的业务流程，我们就可以着手解决这个问题了。Kimball鼓励瞄准<em class="lv">原子粒度——</em>给定业务流程捕获数据的最低级别——在我们的情况下，这将在订单级别定义我们的记录。这意味着我们不会试图通过先发制人地猜测他们的问题来限制我们的业务用户，相反，我们会给他们最大量的数据，并允许他们自己探索。</p><p id="1955" class="pw-post-body-paragraph js jt hh ju b jv kn jx jy jz ko kb kc jf kp ke kf jj kq kh ki jn kr kk kl km ha bi translated">除了粒度，BI用户采用我们的模型的最重要的贡献者是维度表。请求通常至少有两部分，首先是度量(多少，多少，等等。)，其次是过滤器/描述符(谁，什么，什么时候等等。).我们提供的维度越多，我们的用户通过分割数据能够发现的就越多。</p><p id="83db" class="pw-post-body-paragraph js jt hh ju b jv kn jx jy jz ko kb kc jf kp ke kf jj kq kh ki jn kr kk kl km ha bi translated">最后，我们转到事实表。事实表有几种不同的类型，但是，选择哪一种并不取决于我们。仔细看看我们的业务流程及其粒度，很明显我们的表是事务性的。每个订单都是在特定时间点只发生一次的事件。</p><p id="92c7" class="pw-post-body-paragraph js jt hh ju b jv kn jx jy jz ko kb kc jf kp ke kf jj kq kh ki jn kr kk kl km ha bi translated">📝其他类型的事实表包括定期快照和无事实表。定期快照是指每一行汇总一段时间内的测量值，累积定期快照是指每一行代表某个业务流程的一个实例(如订单或索赔的生命周期)，无事实表是指没有测量值的表。</p><h2 id="0600" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">形成星形模式</h2><p id="000a" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km ha bi translated">开始设计星型模式最简单的方法是将原始表反规格化为一条记录。这将为我们的订单交易提供一个广阔的视野，并帮助我们构建我们的维度。</p><p id="ea06" class="pw-post-body-paragraph js jt hh ju b jv kn jx jy jz ko kb kc jf kp ke kf jj kq kh ki jn kr kk kl km ha bi translated">下面的查询将做到这一点。</p><pre class="lh li lj lk fd lm ln lo lp aw lq bi"><span id="a7b3" class="iu iv hh ln b fi lr ls l lt lu">WITH users AS(<br/>  SELECT *<br/>  FROM `gcpuser-project.raw_hands_on_star_schema.users`<br/>),</span><span id="a6eb" class="iu iv hh ln b fi lw ls l lt lu">symbols AS(<br/>  SELECT *<br/>  FROM `gcpuser-project.raw_hands_on_star_schema.symbols`<br/>),</span><span id="ef86" class="iu iv hh ln b fi lw ls l lt lu">orders AS (<br/>  SELECT *<br/>  FROM `gcpuser-project.raw_hands_on_star_schema.orders`<br/>),</span><span id="7dcd" class="iu iv hh ln b fi lw ls l lt lu">joined AS (<br/>  SELECT<br/>    u.user_id,<br/>    u.last_name,<br/>    u.email,<br/>    u.city,<br/>    u.state,<br/>    u.date_joined,<br/>    o.order_id,<br/>    o.price,<br/>    o.quantity,<br/>    o.order_date,<br/>    o.buy_or_sell,<br/>    o.order_status,<br/>    s.symbol_id,<br/>    s.symbol,<br/>    s.date_added,<br/>    s.listed_at<br/>  FROM orders AS o</span><span id="b411" class="iu iv hh ln b fi lw ls l lt lu">  LEFT JOIN symbols AS s <br/>  ON o.symbol_id = s.symbol_id</span><span id="1562" class="iu iv hh ln b fi lw ls l lt lu">  LEFT JOIN users AS u <br/>  ON o.user_id = u.user_id<br/>)</span><span id="22e7" class="iu iv hh ln b fi lw ls l lt lu">SELECT *<br/>FROM joined <br/>LIMIT 1</span></pre><p id="41ed" class="pw-post-body-paragraph js jt hh ju b jv kn jx jy jz ko kb kc jf kp ke kf jj kq kh ki jn kr kk kl km ha bi translated">太好了！我们现在对订单交易有了一个完整的了解。</p><figure class="lh li lj lk fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lx"><img src="../Images/0c9bd1888a3f07d04258df0a1268c37e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0eDS30eebvxN-o3lUuYY2Q.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Denormalized Query Result</figcaption></figure><p id="bee7" class="pw-post-body-paragraph js jt hh ju b jv kn jx jy jz ko kb kc jf kp ke kf jj kq kh ki jn kr kk kl km ha bi translated">该记录由我们的两个业务事实——价格和数量——以及将用于构建维度表的外键和各种描述符组成。</p><p id="9e4f" class="pw-post-body-paragraph js jt hh ju b jv kn jx jy jz ko kb kc jf kp ke kf jj kq kh ki jn kr kk kl km ha bi translated">幸运的是，将原始用户表转换成用户维度表似乎不需要任何更改。符号表也是如此，因此剩下的唯一真正的数据建模就是创建日期和订单维度表。</p><p id="be7f" class="pw-post-body-paragraph js jt hh ju b jv kn jx jy jz ko kb kc jf kp ke kf jj kq kh ki jn kr kk kl km ha bi translated"><strong class="ju hi">日期</strong></p><p id="ac91" class="pw-post-body-paragraph js jt hh ju b jv kn jx jy jz ko kb kc jf kp ke kf jj kq kh ki jn kr kk kl km ha bi translated">对于日期维度表，有很多方法可以生成一系列过去和未来的日期。这实际上取决于您的数据库使用的方言，但应该看起来非常类似于我下面的内容(同样，我使用的是BigQuery)。</p><pre class="lh li lj lk fd lm ln lo lp aw lq bi"><span id="3667" class="iu iv hh ln b fi lr ls l lt lu">-- dim_dates</span><span id="1ba0" class="iu iv hh ln b fi lw ls l lt lu">CREATE TABLE `gcpuser-project.marts_hands_on_star_schema.dim_dates` AS(<br/>  SELECT<br/>    date AS date_id,<br/>    date,<br/>    EXTRACT(MONTH FROM date) AS month,<br/>    EXTRACT(YEAR FROM date) AS year<br/>  FROM UNNEST(<br/>    GENERATE_DATE_ARRAY('2014-01-01', CURRENT_DATE('America/New_York'), INTERVAL 1 DAY)<br/>  ) AS date</span></pre><p id="f873" class="pw-post-body-paragraph js jt hh ju b jv kn jx jy jz ko kb kc jf kp ke kf jj kq kh ki jn kr kk kl km ha bi translated">上面的查询生成一个不同日期的表，从任意日期“2014-01-01”开始到当前日期，间隔一天。因为日期是不同的，所以我选择在date_id字段中也使用它们。</p><p id="4cc9" class="pw-post-body-paragraph js jt hh ju b jv kn jx jy jz ko kb kc jf kp ke kf jj kq kh ki jn kr kk kl km ha bi translated">此外，该表需要每天重新创建，以包含最近的当前日期。BigQuery允许我们调度查询，而其他引擎也有类似的功能来帮助自动化作业。或者，我们可以生成很久以后的日期，而不必担心每天更新表。</p><p id="1d5e" class="pw-post-body-paragraph js jt hh ju b jv kn jx jy jz ko kb kc jf kp ke kf jj kq kh ki jn kr kk kl km ha bi translated"><strong class="ju hi">垃圾订单</strong></p><p id="ecda" class="pw-post-body-paragraph js jt hh ju b jv kn jx jy jz ko kb kc jf kp ke kf jj kq kh ki jn kr kk kl km ha bi translated">我们将在原始订单表的基础上构建我们的事实表，但要在删除一些描述性列之后。buy_or_sell和order_status列可用于创建所谓的垃圾维度表，其中的行只是列属性的所有可能组合。还将计算不同组合的散列，并将其用作代理键。</p><pre class="lh li lj lk fd lm ln lo lp aw lq bi"><span id="3489" class="iu iv hh ln b fi lr ls l lt lu">-- jnk_orders</span><span id="ef9d" class="iu iv hh ln b fi lw ls l lt lu">CREATE TABLE `gcpuser-project.marts_hands_on_star_schema.jnk_orders` AS (</span><span id="b37a" class="iu iv hh ln b fi lw ls l lt lu">WITH values AS (<br/>  SELECT DISTINCT buy_or_sell, order_status<br/>  FROM `gcpuser-project.raw_hands_on_star_schema.orders`<br/>),</span><span id="b7df" class="iu iv hh ln b fi lw ls l lt lu">apply_surrogate_key AS (<br/>  SELECT<br/>    SHA256(CONCAT(buy_or_sell, order_status)) AS jnk_orders_id,<br/>    buy_or_sell,<br/>    order_status<br/>  FROM values<br/>)</span><span id="3d49" class="iu iv hh ln b fi lw ls l lt lu">SELECT *<br/>FROM apply_surrogate_key<br/>)</span></pre><p id="ee1b" class="pw-post-body-paragraph js jt hh ju b jv kn jx jy jz ko kb kc jf kp ke kf jj kq kh ki jn kr kk kl km ha bi translated">让我们进一步讨论这个问题。假设我们的orders维度表包含事实表中每个order_id的buy_or_sell和order_status值。</p><p id="8b11" class="pw-post-body-paragraph js jt hh ju b jv kn jx jy jz ko kb kc jf kp ke kf jj kq kh ki jn kr kk kl km ha bi translated">我们遇到的第一个问题是冗余。考虑这两列之间可能组合的基数(只有4种不同的组合)，这将在我们的维度表中引入相当多的重复数据。</p><p id="fca7" class="pw-post-body-paragraph js jt hh ju b jv kn jx jy jz ko kb kc jf kp ke kf jj kq kh ki jn kr kk kl km ha bi translated">更大的问题是性能。我们的orders维度表将以与orders事实表相同的速度增长。我们需要尽力避免这样的设计，而是选择相对于事实表增长缓慢的维度表。</p><p id="0f90" class="pw-post-body-paragraph js jt hh ju b jv kn jx jy jz ko kb kc jf kp ke kf jj kq kh ki jn kr kk kl km ha bi translated">这就是垃圾维度表有所帮助的地方。我们用每列所有可能的值填充该表，基于行值的组合创建一个新的代理键，并将这个新键添加到事实表中以供参考。结果是一个不会增长的表，除非底层业务流程发生变化(例如，我们添加了一个新的order_status，比如‘modified’)。</p><p id="eb37" class="pw-post-body-paragraph js jt hh ju b jv kn jx jy jz ko kb kc jf kp ke kf jj kq kh ki jn kr kk kl km ha bi translated"><strong class="ju hi">用户&amp;符号</strong></p><p id="ef62" class="pw-post-body-paragraph js jt hh ju b jv kn jx jy jz ko kb kc jf kp ke kf jj kq kh ki jn kr kk kl km ha bi translated">用户和符号维度表可以创建为原始表的一对一副本。这两个表的模式都不需要更改。</p><p id="d150" class="pw-post-body-paragraph js jt hh ju b jv kn jx jy jz ko kb kc jf kp ke kf jj kq kh ki jn kr kk kl km ha bi translated"><strong class="ju hi">订单事实表</strong></p><p id="b6f2" class="pw-post-body-paragraph js jt hh ju b jv kn jx jy jz ko kb kc jf kp ke kf jj kq kh ki jn kr kk kl km ha bi translated">剩下的工作就是从原始订单表构建一个事实表。这个阶段唯一的主要变化是重新计算jnk_orders_id散列，这将允许我们连接到jnk_orders维度表。我们将此作为事实表的DDL的一部分。</p><pre class="lh li lj lk fd lm ln lo lp aw lq bi"><span id="574e" class="iu iv hh ln b fi lr ls l lt lu">-- fct_orders</span><span id="acd6" class="iu iv hh ln b fi lw ls l lt lu">CREATE TABLE `gcpuser-project.marts_hands_on_star_schema.fct_orders` AS (</span><span id="e83b" class="iu iv hh ln b fi lw ls l lt lu">SELECT<br/>  order_id,<br/>  order_date as order_date_id,<br/>  user_id,<br/>  SHA256(CONCAT(buy_or_sell, order_status)) as jnk_order_id,<br/>  symbol_id,<br/>  price,<br/>  quantity<br/>FROM `gcpuser-project.raw_hands_on_star_schema.orders`<br/>)</span></pre><p id="c212" class="pw-post-body-paragraph js jt hh ju b jv kn jx jy jz ko kb kc jf kp ke kf jj kq kh ki jn kr kk kl km ha bi translated">现在一切都建模完毕，让我们看看我们的星型模式的ERD。</p><figure class="lh li lj lk fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ly"><img src="../Images/c55afc51046d9703acd78bb16ae75ea4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zcm1URoCkGBXY_3PYlgdMQ.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">ERD Star Schema</figcaption></figure><p id="6948" class="pw-post-body-paragraph js jt hh ju b jv kn jx jy jz ko kb kc jf kp ke kf jj kq kh ki jn kr kk kl km ha bi translated">以及BigQuery内部的表结构。</p><figure class="lh li lj lk fd ii er es paragraph-image"><div class="er es lz"><img src="../Images/1cba49cb95d6dc669edf5a28c9dd631d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*v2XI-Rdlapj1yfT14ZLbcg.png"/></div><figcaption class="ip iq et er es ir is bd b be z dx">Table Structure in BQ</figcaption></figure><p id="b3c8" class="pw-post-body-paragraph js jt hh ju b jv kn jx jy jz ko kb kc jf kp ke kf jj kq kh ki jn kr kk kl km ha bi translated">需要注意的几件事是日期字段的维度表之间的关系。在金博尔模式中，这是一种可接受的设计，称为外伸支架尺寸。</p><h2 id="5f0c" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">分析</h2><p id="5f73" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km ha bi translated">我们现在有了一个模型，可以输入到大多数BI工具中，并提供给最终用户。</p><p id="566a" class="pw-post-body-paragraph js jt hh ju b jv kn jx jy jz ko kb kc jf kp ke kf jj kq kh ki jn kr kk kl km ha bi translated">让我们用我们的模型来回答几个假设的问题。</p><ol class=""><li id="69df" class="ks kt hh ju b jv kn jz ko jf ku jj kv jn kw km kx ky kz la bi translated"><strong class="ju hi">平均而言，哪些城市的股票交易价格最高？</strong></li></ol><pre class="lh li lj lk fd lm ln lo lp aw lq bi"><span id="b3ba" class="iu iv hh ln b fi lr ls l lt lu">SELECT<br/>  city,<br/>  ROUND(AVG(price),2) AS avg_price<br/>FROM `gcpuser-project.marts_hands_on_star_schema.fct_orders` AS f</span><span id="17ac" class="iu iv hh ln b fi lw ls l lt lu">LEFT JOIN `gcpuser-project.marts_hands_on_star_schema.dim_users` as u<br/>ON f.user_id = u.user_id</span><span id="8d57" class="iu iv hh ln b fi lw ls l lt lu">GROUP BY city<br/>ORDER BY avg_price DESC<br/>LIMIT 5</span></pre><figure class="lh li lj lk fd ii er es paragraph-image"><div class="er es ma"><img src="../Images/ce1662a1eac953e2fa13bfdd1bdb42e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:972/format:webp/1*YYszpybenaoP3nLBwH-IfA.png"/></div><figcaption class="ip iq et er es ir is bd b be z dx">Results</figcaption></figure><p id="bec9" class="pw-post-body-paragraph js jt hh ju b jv kn jx jy jz ko kb kc jf kp ke kf jj kq kh ki jn kr kk kl km ha bi translated">2.<strong class="ju hi">每天执行的订单比例是多少(相对于取消的)？</strong></p><pre class="lh li lj lk fd lm ln lo lp aw lq bi"><span id="9c3a" class="iu iv hh ln b fi lr ls l lt lu">SELECT<br/>  date,<br/>  SUM(CASE WHEN order_status = 'executed' THEN 1 ELSE 0 END) /<br/>    COUNT(*) AS proportion_executed<br/>FROM `gcpuser-project.marts_hands_on_star_schema.fct_orders` as f</span><span id="e0d4" class="iu iv hh ln b fi lw ls l lt lu">LEFT JOIN `gcpuser-project.marts_hands_on_star_schema.dim_dates` as d<br/>ON f.order_date_id = d.date_id</span><span id="9f46" class="iu iv hh ln b fi lw ls l lt lu">LEFT JOIN `gcpuser-project.marts_hands_on_star_schema.jnk_orders` as o<br/>ON f.jnk_order_id = o.jnk_order_id</span><span id="9f6f" class="iu iv hh ln b fi lw ls l lt lu">GROUP BY date<br/>ORDER BY date DESC</span></pre><figure class="lh li lj lk fd ii er es paragraph-image"><div class="er es mb"><img src="../Images/dcc6b458bcb9e11920a40f6fd5fada09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1048/format:webp/1*gpTsogcqLITGMzVVOpusJA.png"/></div><figcaption class="ip iq et er es ir is bd b be z dx">Results</figcaption></figure><h2 id="3ce9" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">包裹</h2><p id="79b2" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km ha bi translated">我希望本文提供了一个实践数据建模的好机会。我认为，让其他人可以访问数据是整个数据领域最大的增值。</p><p id="2fba" class="pw-post-body-paragraph js jt hh ju b jv kn jx jy jz ko kb kc jf kp ke kf jj kq kh ki jn kr kk kl km ha bi translated">和往常一样，请查看文章后面的<a class="ae it" href="https://github.com/jduran9987/medium-star-schema-hands-on.git" rel="noopener ugc nofollow" target="_blank"> github repo </a>。</p><p id="fbba" class="pw-post-body-paragraph js jt hh ju b jv kn jx jy jz ko kb kc jf kp ke kf jj kq kh ki jn kr kk kl km ha bi translated">👋干杯。</p></div></div>    
</body>
</html>